_N_E =
(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([["pages/portfolio"],{

/***/ "./components/common/Headline.js":
/*!***************************************!*\
  !*** ./components/common/Headline.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);

var _jsxFileName = "G:\\MDMax\\go brasov\\site_nextjs\\gobv-site\\components\\common\\Headline.js";


function Headline(props) {
  var label = props.label,
      title = props.title,
      subtitle = props.subtitle,
      divider_1 = props.divider_1,
      divider_2 = props.divider_2,
      position = props.position,
      className = props.className;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("header", {
    className: "el-headline ".concat(position || "side", " ").concat(className),
    children: [label && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "el-headline-label",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
        children: label
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 9,
        columnNumber: 21
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 8,
      columnNumber: 17
    }, this), title && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h3", {
      className: "el-headline-title",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
        children: title
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 14,
        columnNumber: 21
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 13,
      columnNumber: 17
    }, this), divider_1 && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: "divider divider-1-reverse divider-1-1"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 19,
        columnNumber: 21
      }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: "divider divider-1-reverse divider-1-2"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 20,
        columnNumber: 21
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 18,
      columnNumber: 17
    }, this), divider_2 && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: "divider divider-1-reverse divider-1-2 divider-single"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 25,
        columnNumber: 21
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 24,
      columnNumber: 17
    }, this), subtitle && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
      children: subtitle
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 28,
      columnNumber: 26
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 6,
    columnNumber: 9
  }, this);
}

_c = Headline;
/* harmony default export */ __webpack_exports__["default"] = (Headline);

var _c;

$RefreshReg$(_c, "Headline");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/common/portofoliu/card.js":
/*!**********************************************!*\
  !*** ./components/common/portofoliu/card.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react_grid_system__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-grid-system */ "./node_modules/react-grid-system/build/index.js");
/* harmony import */ var react_grid_system__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_grid_system__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react_tabs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-tabs */ "./node_modules/react-tabs/esm/index.js");
/* harmony import */ var _tables_parteneri_table__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tables/parteneri_table */ "./components/common/tables/parteneri_table.js");

var _jsxFileName = "G:\\MDMax\\go brasov\\site_nextjs\\gobv-site\\components\\common\\portofoliu\\card.js";






function Cards() {
  var _this = this;

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_tabs__WEBPACK_IMPORTED_MODULE_4__["Tabs"], {
    className: "el-tabs el-tabs-1 ".concat(_tables_parteneri_table__WEBPACK_IMPORTED_MODULE_5__["default"]["class"]),
    selectedTabClassName: "active",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_tabs__WEBPACK_IMPORTED_MODULE_4__["TabList"], {
      className: "el-tabs-links ".concat(_tables_parteneri_table__WEBPACK_IMPORTED_MODULE_5__["default"]["class"]),
      children: _tables_parteneri_table__WEBPACK_IMPORTED_MODULE_5__["default"].map(function (category, categoryIndex) {
        return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_tabs__WEBPACK_IMPORTED_MODULE_4__["Tab"], {
          children: category.name
        }, categoryIndex, false, {
          fileName: _jsxFileName,
          lineNumber: 17,
          columnNumber: 17
        }, _this);
      })
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 15,
      columnNumber: 9
    }, this), _tables_parteneri_table__WEBPACK_IMPORTED_MODULE_5__["default"].map(function (category, categoryIndex) {
      return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_tabs__WEBPACK_IMPORTED_MODULE_4__["TabPanel"], {
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_grid_system__WEBPACK_IMPORTED_MODULE_3__["Row"], {
          className: "row-center mb--30",
          children: category.items.map(function (item, index) {
            return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_grid_system__WEBPACK_IMPORTED_MODULE_3__["Col"], {
              xs: 6,
              sm: 6,
              md: 6,
              lg: 3,
              xl: 3,
              children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
                className: "portfolio-item",
                children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {
                  href: "/parteneri_details".concat(item.link),
                  children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
                    className: "portfolio-card",
                    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
                      className: "image overlay-image",
                      style: {
                        backgroundImage: "url(".concat(item.image, ")")
                      }
                    }, void 0, false, {
                      fileName: _jsxFileName,
                      lineNumber: 28,
                      columnNumber: 41
                    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
                      className: "content",
                      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
                        children: item.title
                      }, void 0, false, {
                        fileName: _jsxFileName,
                        lineNumber: 30,
                        columnNumber: 45
                      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h3", {
                        children: item.subtitle
                      }, void 0, false, {
                        fileName: _jsxFileName,
                        lineNumber: 31,
                        columnNumber: 45
                      }, _this)]
                    }, void 0, true, {
                      fileName: _jsxFileName,
                      lineNumber: 29,
                      columnNumber: 41
                    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
                      className: category["class"],
                      children: item.title
                    }, void 0, false, {
                      fileName: _jsxFileName,
                      lineNumber: 33,
                      columnNumber: 41
                    }, _this)]
                  }, void 0, true, {
                    fileName: _jsxFileName,
                    lineNumber: 27,
                    columnNumber: 37
                  }, _this)
                }, void 0, false, {
                  fileName: _jsxFileName,
                  lineNumber: 26,
                  columnNumber: 33
                }, _this)
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 25,
                columnNumber: 29
              }, _this)
            }, index, false, {
              fileName: _jsxFileName,
              lineNumber: 24,
              columnNumber: 25
            }, _this);
          })
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 22,
          columnNumber: 17
        }, _this)
      }, categoryIndex, false, {
        fileName: _jsxFileName,
        lineNumber: 21,
        columnNumber: 13
      }, _this);
    })]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 14,
    columnNumber: 9
  }, this);
}

_c = Cards;
/* harmony default export */ __webpack_exports__["default"] = (Cards);

var _c;

$RefreshReg$(_c, "Cards");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/common/tables/parteneri_table.js":
/*!*****************************************************!*\
  !*** ./components/common/tables/parteneri_table.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {var parteneri_table = [{
  name: "Culese din toate",
  "class": "Culese_din_toate",
  items: [{
    title: "Hotel Stop",
    link: "/hotel2",
    subtitle: "Brașov",
    image: "/images/parteneri/hotel2.jpg",
    thumbnail: "/images/parteneri/hotel2.jpg"
  }, {
    title: "Le Pompon Rouge",
    subtitle: "Restaurant Franțuzesc",
    link: "/restaurant1",
    image: "/images/parteneri/restaurant5.jpg",
    thumbnail: "/images/parteneri/restaurant5.jpg"
  }, {
    title: "English Club",
    subtitle: "Bar englezesc",
    link: "/",
    image: "/images/parteneri/bar1.jpg",
    thumbnail: "/images/parteneri/bar1.jpg"
  }, {
    title: "Iron Will",
    subtitle: "fitness",
    link: "/",
    image: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxMTEhUTExMVFRUXFxUYFxcYFxcVFxcXFRYWFxgVFRcYHSggGh0lHRcXITEhJSkrLi4uGB8zODMtNygtLisBCgoKDQ0NFQ8PFSsZFRkrKystLS0rKy0rLSsrKysrKy0rKzctKzc3LS0rKzc3KystLS0tKysrKysrLS0rKysrK//AABEIALcBEwMBIgACEQEDEQH/xAAcAAACAgMBAQAAAAAAAAAAAAAEBQMGAAIHAQj/xABJEAACAQIDAwgFCAgFBAIDAAABAhEAAwQSIQUxQQYTIlFhcYGxBzKRocEUI0JSYnKy0SQzY3OCkqLwFUOzwuElU8PSRPE0g5P/xAAXAQEBAQEAAAAAAAAAAAAAAAAAAQID/8QAGREBAQEAAwAAAAAAAAAAAAAAABEBITFB/9oADAMBAAIRAxEAPwDmbmoWNNsRsS4D6y+8fChTsm59n2n8q6ICzV5noo7Mu/VB/iHxrT/Dbv1D7V/OgBvHWvFqTG2GQgMMvfWiUHorYVgFbRUHgavc1eRXlB7NZNYKyKDCa9U14RWCglVqKtYiP7/5oKtlagYNiePZ5n360HduE8ez+zXhbw8fM1G9B4z1oWr0itYoPC1b27kGa0IrAKCybK2nk1Bj2an2RG7t9pona21mcSdZ07BxMnWO4VWVuxBHxNSvdn+/GggxD0RgjoKDuUbgx0RVC0tvrA1eNvPfXgoJUapVeoEqZaCUXK2V6jFbgUBuGvVY9m4iCNfGqtZMf3rR1rER/wDe7t0qC5/4h2j+Y/AVlVhMYY/OT8ayin20rOppYyU+xyzSu5boAwlT2rNbpbou0lA45Lcj2xnOFbxtZMggTrOfXQ9la8quRT4S2He9zgO4QesDWe+rh6LP/kD9z/5fyon0opOGHYf9yVLyOLXNnakDWCfoqfhUZ2YOz/8Amv5V1T0V2lN7EhlB6NsiQDxbr76t73LQfXDiASPUTXhSj51u7KH2fZHlSrH4fIyiBrPXwjt7a+neUOzLPydmFpFaU1CqCJdZEjsJFfNm2Vm6g7D7SdfIVc0DWsMCO3T4z8KlXBA9dGthyqz2jyP5VvYtFjoKI8wWwOcBgXGiJKwYmd+nZWYjk8V4XB3qPzFdZ9CYgYr/APR/5qk9KduXtn7w/oFSq4x/hf3/AOQf+1Rvs6OJ8VI8pruHJ/kFhr+GtXWNwM6KxgiJO+NKl2h6NMMqMwuXdATErw8KUcAuIAYn3N+VYuHZvVE93/NMtt4cDEG2B6uYeAYgeVFbKw5kwOIH4oqoR/JH+qamGzLkA5RH3k8pmrScFcGaUgAxJIM9UCav2N5OYddk2r62gLpw9pi2s5jbknfG+lVxU7OufUY9wJ8q1OBf6jj+Ej4V1HYHIF8Zba6jWlAdlhgZ6MdQ7a0296N7uHtNddrRVQScuadATxA6qVHL+YI3j2g1mU8P77qJt25Z43BmA7pNNbGDmJXSBqApO7qJHnVFeuWj2+NF4VOiP74mmG39mXMOLedVXnMxA6JaFy6kDd6wilWdlAgwIn3kfCgBa3qa1K1fbXo62hcPRwRynUM160oIO5vWnUa0bs/0UYp8QLF17VolOcJVmuwubLqIUTPbUo5vaWpwtdbtehjMrNbxeoZ1h7cSUYrvVtASJ3GJ40uveiDHqdBh3HWLzA+xrQ86XBzlVqW2lWTFckHs3ebuvlYHpAANGu4NMHvio8JydvknJL5QCStgXPaJPvFAhCRW4ova2BvWiBcIWdwNnmye7oVtsbYWLxRIsIbhWJhlSM05dXKjXKfZQQhf7mvabPyU2ghytZuAjhnXjrwaONZTgWDENQVw0RdahWqK9QVMLqrvIHeYqFK02gug7z5VR0n0V3VLYjKQdLO7vu019I6zhj3H8SVVfQ0CMRiweNvDn2G6vwq48vlnDN3N5T8Kz6K16L9MReHXatn8P510quaejbTF3R+wX3c1+ddLpoB22s2X/h9zLXzDtpIv2/4vxCvqHag+abw8xXzTyisxft97/iFXAZtDoWs0GCyg+/UzXuAw73FZ0C5EHSLPbXerERLamEbdOo7aYYvHWreGuhwXz28gyFSyPzltleCeBXdVxXHWMZsn5abNkXVV1uEIiNnQMMuYCQCcp8RVDr0abCv4VsQL6BM4slYZWnKbs+qT1ioPSZbk2+/zVvyqwcl8VhbkthlVQ1u2WCrl4tEjd9bdSf0kJ+pP2x5PWfQ95Ff/AIOH+58TTPaA+af7reRpXyJP6DY+6fc7U2xg+bf7reRqD5n25b/6gw+0/wDqPTFLWQggT01nhAyvrQnKAf8AUW+/c/1Gq0YbAI9pyf1ga3zWpAzEXC0jj0VO/vrYSYnG3CzHmnyhFaTIGlkPB006u+r5sfbwxuw3It5DZBslc2aebtCGmBvBGlOvklpsNtBbTBg63EnOHEDDrlOnefGue+iu6Ts7aVvgCH/mtOp/AKg6P6Lx+i3P39zySmHLxZwV77j/AIGoH0Zj9Gu/v3/BbpnyzWcHe/dv+Bqno+c9iWcxuD7beZp0iumoUNGWBmAJ0GokdfbQPJe3L3fvt+I10Xauy7SYW1fGHW6RYZnWWUsEVurw9laHOeXW0TeNglWUqtwEMI4oNCND6vCq/f8AVT7h/G9N+VuLFxcORZt2tLp+bZ2DBjbIBVycpXXUHWdwik+Jbop+7/3vVHefSNyivYXAWHwt4I8orQLbkA2idQ4Mbhw41JyK5S22w5xmJug3OZsq5jpE2ree42VBpLOToI3VQNvbCvpgcReuEKouoFt5FBbPDc6bm86ECJO8nSarCbVa3hLK23IL8/zuZnNsADIqi2DlzEINTO9eqswd+5E7btX0vFSYD85mIIBW7JDCdYlWHgab7O27h78c1eR82aBME5QrMMp10DqT3ivmWzyixJVbCMgXm1SObScqtnEvGf1idzDfVt5FYe9iMXat28ViLQ5vMxtuPmySyEKrSu63bGomI7KQWzb2yr1/F3blq2zoHKlhEAqYZZ6watHJXAm1cVWQI3yW3nGk5hcuSTG8676m5G4Z7Vi9buO1xlxGIBdozP0yQzRpJBB0ppbX9JJ/ZD/UaoOcemXAZ72FI+q494I+NJeTe2P8Nw+MxBVGcCwqI303ZrgEGQQBJJjWBVv9JdqcRhD9m9/sqqbewamyQ+vzls5dNYFzWI13xv8ApVc6FHx3pF2jcdnOICzwW1ayiBEDMpMd5NZQOM2EwdoAjs3doHZWVoW+eiO4VGTW106UPzlQThwASdANT4UFtDaFtguV0Op3Ok7u1qMtNWm1D0V7/hQXb0Q3FOIvFQQDaUa6zkfrBI+numfaKu/LRJw5/i/03qh+iG6TirgJJ+ZbeZ/zLddC5VLNg/xf6b1nexVeQ+EFvEi4W/WobQXqKhWnui2R3xXQqonJFw19FI9VWYd8R8TV7poH2h+rbu8q+ftvYWcZZXruMP61r6Bx4+bf7reVcT23ajHWT1XLx/lGb4Uwc/2qhuYx8okl34E/WO4Amr9yNwn6FisI7EMyLiIGYZQCFOZCQdRzZ1G6eoTzp7zC87KxUiekOAZgpP8AVXTdhYBLDJdQDNlKnU9NXXKQ5+kTO8zrWhYPQpiSUuoYhFSN0jM93MCQJPSBOsxOlP8A0gW8wsj7a++RVZ9Dt39Jxa6Tlts0fWZ7hI9/vq28tUkW/vL5mp6DuSNsJh1tCTzcgE/SDEtPtJH8M8aa4r1G+63kaVcknnDIx9Y5p8HYCmuI1Rvut5GsjgW19lo+OuO2Js2St26Aj84WbpkyoRTprHhTHFXeaChbyHpBpVb4JypcUhS1oAdG4xknhSzljZjaQ7Xufiqfb5KopBj157sh31sJvRYbgx117dk3RzF1XglMitDZiw+5EHfJ415yK222Fu4rDiy104iLQAYLDA3NTIOkZj2QafehWy3N465bZEchEzXJyiFYxodCS/b6u6geQFtf8VxKsATzGIdDvhujDL/A7juNQdO5HX8RbtFbeEBzMXJN9R0stsGOieGX30XylxeLbDXQ2FRVKPJF8MQMjSQMonThNHcjB8y88H/8dujuUazh7o+xc/02qD5+5NoRcu5AWOdpzALBk6AhjNWzG8vhYFqy9tHNtCrKpzGGkZXDQAY1gE6EdYpFyYtRevj9o34jVf5bYYLiDcUaEw5+3LQP5APYK0Ido38PcCZnurE7rSGZj9rpu99D3reGKrN296pA+ZU6Zm/a99Lbx0HjWXDoO74mqjo+3OVHyvCXLCqRzfSYxEm2uX6xgdE8KouBsG8qWoIALQVhiSW3ZSV4kcasPJ65m+WrBH6LeO8GWUk5hoI0gRrumdYAfIjCc4zSxVUL5oMFsyoFQneBMnTfqKipbdqzbAVrzjLKj9HUnefpC/rM9QptycxiYO9zlm65c5Vy3MNAP0wNMQu8f3NJ9s4FLTgqIAOaOHHh76n5VOXuJlyAhEzEkglgGjcOpvKguW1OUGPSLofILjXwqrZXJcuPaDENGKJlVEqdIJM5tw6ZsLFNdFq40Znw9tmjcCxJIHjXELmOuuLFi3aRig5xrnOLfQC6mXSVBRpRg0dcdtPdu8t79qyFsvbtEW0tErLXAASSyn1V6txqQW70mYtLVzDtcYKoW6ST2ZN3E9wrlm3+WXOApZSF+s2rGCCCANBqBxNIcXtbnnDXrly627NcdnIk8MxMDsom3hcrK3NyAQYO4jqqwANtO6TJY+wflWU9TE2o1w+v8P8A61lBBg9svezTbtIBHqKwJJneWY1s1wzQOy0CqRIkktoQdNBGh86JnWgY4Zq92q/RXv8AhVV2tj7qXYVyogQBu3an2zXlrbV//ue0KfhQdU9D939OI67Fz3PaNdT5Qkc1qQBJ3kD6DddcY9DOPe5tMZ2J+YujcFG9D6o46b6tnKj0VJiLjXWxLdK5cbpW1cjnXZ8uZj6omAKm9hjybxVlMQpN22OgwPTXt7as2I5T4JJzY3DL33rQ82rmGz/Q9h2cK+IuwZnKlpTpO6Vbqqw2fQ3gV/zcUf47Y/DbFTgWccqcFeW6lrF2HIRictxSIjfMwfCuYcosVZN8st205UYk9F1Y6pA3HrNXix6NNn2s7lHuypAW6/OICNcwB+l21zvltyZsWGvOlpVXLNuJAUl0BA4cdOw1cHPLQBW/9YhABxM3FY+5ab7A2zeR7a3HbmVPGDAAMaxmjsoTZ+FzYTFXIlhcw6qQJI1ctHETImgsM5t3FZwwymYiDu00PhWkdL9GW3sNhcXirl26xW6BlOS45JFxiAAqkgBSN9XHlBy2wtwDKuJfUHTD3RuJ+sBSb0VEf4jfK7nwtt+wkuFJ/p99dK2sNPAedY3tVH2Ny0RLdtVwO0rhBOqYQldWJ9YsBxpvc5Y3WVguytobj6yWk8dblN8HdVQo16JO6O3rPbRF7aIykQdZ3kDfQcT5QNib+ODDA3QwW6/NF0DESozSNNGdJG8z40m27tq8Ve1cwxtFcwJzhiDqpBAAq+coMS/y8NZaG+S4mSOlEvh4PtA9hqq8v7QFprk9NmKnt1kk9u6tBPyI5TYjB23WxzY555YsqOYQBQOlcQLvbeTPUOO+zLty1jM1tmTEtbIE83lZGtiQoC3ATkE+Bqt4LG80qnMM0zlKhxB6wf77t9ONjbeDbSwN7KECPh7bEkKCP1bP1IIbdJiN9EXfkh6WLeGW4mL5y6SwKG22GaAFggmbfUNIPHXhTnHemjAXEZBZxMkMP/jcVI/7/bTp+UWFE5nsHr+dw76x9lyaU7S5T7PjU4bxS634bBHvrKuebL5T2bd26+S6Q7lhHNSATOvzm+k/KDHG/cYoGCF88NkmcoXgTwHXUXK02TfDWnR0ZpJRCirLHo5TvgRrA30mRVnVRHdW0F37LQNDpQz3uHxH5149tQYgb+oTBA0mvSBG4UDbY22bqOxtWc+a3cRwouPK3JliFG8A92grTY+1XsC6UgglQQeM5joeB6I99NLWMw9np2rjI3NlWDg/rTbiVIExvG46kHtqt2tc4G7on2SPjQP9v4rPZR92ayp7ujBHuNC4Nrr21YsSYgyM0hQFUmQdwUa1oBnwyKD6ouIT1E3HcD2MKg2ndJt4cZektu2uvHpPEHq0jwioq57Sxb2sHh1APO3bSFokkAjooskkDUmO2kljZ93mr3OJLuFyagkQSTJ4cPZVxxQU4pgd9q2ir2aQfL30vu3emw0gGI4xlnNPVOlBWti3LadB1VX3ElAW9p/KmuFx/RglNNBO8xp8PfSflWAGRl0YyPZB/Oodur0MM2/5tZ7d9BZPlq/s/d+dZVJydcT2GvKoNRoOhpnh7ZNV7ntasWzcWMtES4vAC4hQ9Wh4g8DVWa1lTKdGkkjtBygT/N7auICvxI8YpNtXYnFKKsHoXbJtO2WIEpdG/X1C2o4erX0BjMUCugJgg6Cd3dXyzsnalzDsWtsVZJKsrMpGZYIkQePnRd/lljH33nPfcut5vWdwd/8AlbA/qr47eauD35YrLu2QPWkfeu20/G4r5wvbYvNqWE9wP4pqP/Erv1z4BR5CkH0Je2/aP07Pjfst+Bmql8v9oh8K+V7TDMghGdonMdcyKOHAmuWNjrp33H/mb86YW75+RPJJLXgNTPqWweP36QN+SeJW3gr0suc3swUyJVEURMRJ1pthcTbvKwdcvRAKsBAITKwtzOkkae88OfbOALaxENqe410HC9DCm8dUt2y6TqJGo7yLggdiRubWgLkfy0XAsji2bnzT2mBuFSg5yVOiGdFHAb6f7Q9LocQMOvi90+RSuTZpJgkgZQJAEdkDTST56TWTSI6Bc9J9z6Nm2O/nW/HfI91A3/SPiT6qWV7rNifa1sn31TKwCTABJMAAakk7gBxNILK/LvGkki5lLbyoVCY3TzYWoNq7XvX8IGvXGc88wBZmbQIh+kTxJqDF7Kt2rUu7tdguURRlVAQuZmP0cxy5o1PqhhDmLaGmFsCCJ5xoIg6sQD3QBQCJYKrnyp0YJJbVg0AAA9Xdx46VpeYnK0ELmEHWPonQn86kv3wI5tV6hmAe5P3W0HYQvjUN1LjhrjFmy5QSxJjMGIXX7p07Ko8e4x3sT3kmoiK2Y1oaDa4eh4/lWttt1bBJVuyD7Jmo7W7xoCr/AK3gK3TRWeAcoEA7izGBPXxMccsVpfEwRwEHs149VTOsWBpq9w+y2oA991vZQHcnNmW7l9FuktJEiYJ6LGCd/Abo31BhcGGxL21KoPnNTOUBDPkvlReE5QGyoFoSwIJMLGaANWIk9wpZhLx58Mw1OeRqohlaR18dO2KCXB57bkMOixyt9llIExv0LQe+m2zSDft22UHOLdndMMMSLgYQwjQwTrx0M0LiQIIMnOE6XVoCJ7TGvd1zJHJO/nxmFBEkMCdD/l22ae/o1Ax5T7Va3jHdesgjgRO73UTZx9u4ARftKSNVYvKnqaEI9k0j2k4uYpydQS3uNehQN26ipdpYQsSS9p+rIXIA4zmUdlL3w9wwGuSAIAM6AUcnHurUmiAfkTfWFZR015QVrPRdrERQ4tzRVnAE1QZhcaRxp3hcUGEGkgwBomxbK1BJtTBgKxG+PCNZ+Hvqvirkq50IPUaqeLs5HIoqKsFeTWTRHs0yxWmDtfae63vCf7KWTTHaxixh1/Zk/wA7u3+4UAuyxLqIzSDpJE9E8RV5vKTsu7qVCm2Mg1kC7aViDv0CMI4zNULAk5xlEnWABJJg6AcautvaTjZ11SjIyhMzRpPOWwoYcDr5fWoqnYhAF0VxrvYQPDShZplaS7iGFpdSTxMKIBJJJ3ACaa3sPhsMhUHnrpEZ4gKT/wBteHfRFd5h/qN/Kfyo7ZV1sPeW6whlzFQSoYEqQGKHpaTOo4CgLqazrUUADQVQftjbVy9fuMHKK+RQo9ULbXKgA+yN3USSKN5W4oO1shVVcgKquiqv0VA6gAKQW7cmNcxIjSQZPEzp76tGI2A2IjmriM6qqm1MXAFUaqDo/gZ7KCqmSJ3dUDjTbFsBhbYAjnbrP4W7aIB/M1ygr+AZGCuCuvrHRdDrw0PYRPZRG2IU27Y3W7SDxebp/wBQeygCNamsrygnwn0h9k+X/Nb3MM2VYB+cZgum+NIHsPtrbAXkVWm2WYkQ0tCgakZV3z1k6RpWyYq5NsAki1nZRwWYLNQAXozEDQCQPD41MSebEkkDd3tw9xofPDSYOpPtozH4pnVVOUZAq6AD1QRr1ntNBmBvoH+cMLE5hqRxjSi9qOpvQuihQBwJ6OkxuOooHAmWUAdKRHGDO8jqqXPme4d8k9umaR5CgbYjGF7FpQPokbtcwMyT1EMR/Dw1ptyJwon5ROtsX4GnCyAD173I8DSmwrNhy0CEuQ2muV9Ynhx75jqozkgGNy6foiy2nVLIfNRUAH+ee40VQVtpvnuajCaDdOPdWhr1Dv7q1JoNqysFZQAbPwHE00WBXi6CK1ZqCXPXoqDNUqUBGHuwaQbbMvNOTQOOwmfcy9uZlQDxcifCaKRTT7AbMX5HdxJCuwYKqtmyqNQXOUiTOgmR47ld/BhQfnrTEfRXnWJ7m5vJ/VTzFbQZNnIjlc9wrkQAAiyiwrvHFjqOJ3miK2x4j2dRpht1SObT6tq0PZbWaWWruXeAw4gzB8RqD2im20ofELJIVmQSNSFMDTwqhdYgNqYGuvSHwq2bJfCph+Za4lzMVJRXyjotnUOSQSQZ0HWYNLNo4fDgxbzz9/MB3mNT2CgDhQePtANAZtMXRcNxFdVnRQrBAIiANxHspbYdiSWGnEma8bBidI74iO0mdKit4TMWhgSoncddQNJ76Ai7eRjvCiN+rT2wKHhPrnwUkx1w0D30wt7JVFDX2ZZ9W2I5xu8R0R30Dea2pboEQG0mSDBy5i3bEgcJ3Gg9t4hEIKhmMMNSF3qRIUBt0zv4V7cxrF+cAytvBE6dREmrGcGlvDC2qq95wc28k3AnOtu3JZRlXKvr3G1nKAUF8MU6Xr22ZG7CCf8AkeFBJex9/FMlu7de5mZVEmd5CzAG+OO/Stb2HuYi/cNpGeXaIGgE9ETuHRjfW2xnhi+g5tHbxC5V/qYGgbbQpE6HeNP7NBZsD6O9oXBmFpEHW123/sLH21HtHkFjbIlxZj9/bX33CopJZ2jcQEW3ZJ+qxXyqTZu279nObdxlZ4zPPTMbukdffU5EuH2VjFJFtLwkam0WZWAB0L2SVPHSePbUNzZlznCCjW4UmSrLEAzE79NIp5heVWNCHNfzLpLsUusCZgQZaT1btKSbU2jcY9K8zsfWGUJHUDlgT1gSB11QJg8MWuKrCJMmRHRUFm9wNRvBJJkSTrvH976N2cdLrnXLaYeNxlTyZqDsoJnPlPj50BWzVCtm3wGafuqSPeBUWFJAJG+Ru0O7TX21Nh7YAusGzdCN0asyj86gcEIsDfPid/kwoHGzXZrV1RuJTNJJEFbqyfEr4gU65HiLOLY/UtDwJbT+mqzsvUOrEiUJEH6ano929te2rLsB/wBDxLdbovfCk+bVBX8Mfnj3NRxNL8H+sPcaPoNlO/urQmtl491aGgkBrKjrKCfPUDvXhaobhoImxBJ0ozB3TS+1bM02s2gBVEzNQeNOlTM9B4x9KgUPxo3aWK59kO5sltI3AlFCCO+BQeQngalw1g511A6S8Z4jqqifBYdbd1eeAiCYOoO+JjeJG7jRG2mDgXF3Hu0g9lMcTydvXbiswNu2UDBmHCTuBIPbO7dJEioMZhLS22t23L5TJbeNQNAY7PfQCqwyhusTWjseo9wEsfyHaaEtYkKIMyNxiY7hUT4gnfJ7yTQT32YjLAUb4ke/WTW2y2yXVYNGsaTx0nXqMHwoNrh7u6vDmPWaAy9dYMxYktOpJ1Pt19lLw2uu4kE9sHjTDHJmYH6wB8SNR7ZqF8C4U9CQYObisTOnbPuoC7e1zacXEUMwV8hYk827vmF1QCAWXes6AwYMChNmtOZT9IT4ihymoLSFmM0adsGtsErG6BbBYzoANYmJPVQEoctq71sUXwEsfJa0TBseFT2Sy3hlKqSYl1R1E8SrgrVotXMVGgwV371hF99uKCs2tlMd815svBZ3dT9GPiPhVs+U4jjgcO/7u46e4uBSjZ9u5Yu3bj4a8Q5JyqJyjMSOkA0xMbqipMRsY21lVAVLb3SQeMLBI7FY++qg5O88dfbTTaWPctcHSUEMMpmYLEgGQODdQpXcaY7gPZpVQXcsMqosEc4QwkRK7l798+NQ4jeQNwphd2iWvWWMEW1UKOAyKAoj+FfZSo75PEmgkzwIUnpASPtAkAeR8adsyC6QUORTlgakBdBGm+lGzkm9bA+uvsDAn3A1dMTgrT6sgJ6/jQe/I7PNF1MAo2u4iQeFQ7Kf/p9w/WvN7kSoygtjKkZZ9U7uvWp+bCYAAcbjnyFRVdwR+cPcaYUBgAMx640+NHUR6p8q1r0fCtaBtgsNhygLuQ2sjMo4mNDrurKk2djcMttRctZmEycoM6njPVWUCDNUTNUa3K1ZqonS5UpxVA561L0Bpv16RIoFWpvs5kBBuTlG+AD7jvoFWUTunv8A+KsOy8MmGy4i8VDDpJbhSdRoWDDfrPYYOsRXt/EWQ5+S2WZzuJU5U+6GJjvJqfBbOvAl3SzdY7+dTnB4SdPCopftXlA18ksWgmcoJlu123n+4il2EuXC4kQpBEDcJ3e+KvGHQqIOAw7DqU+S3QQPCiBdwv8Am7OvW+23mb8LFR/LQcy+TlnyjfrECd3dRQ2aRv079POpcUwtYlXE5VuA6jpZM2sgxrl4aV1DBW8M3q30Pfx/lzCqOZ2tlHqou1squmrsrDE68zPX0VPt0NErySw76jMO1bhb3NIqUcg21hzbyMOHwM0fiUdl6IhGAMgAmDrvNXTl7ySFvBtcRi3NlTBUTDEKdVgaSDu4Ut5CbNfE4QMuQm2zW2BYhtIZdMseqy8eFKKYmz7qiFdgNdNQNewVtaOJt+qV8NKv2P2WyHVYP3k8g0+6leIw4A1gnq118aCkYi4yXFuEQwOYjhv1Hcdas+ExNu4NbQB7DFJNs2b1w6WlEdT5jHeY8qK2aXFtQQQRpHduPsiqh6lgfRZ199RvfuAxnB76Wvij1mhHumd9RWvKHZly43ODKTABAMZgNx14/kKr17CXF3oR/fXVibEt10LdvMSCeBBjSD2GqhXirYS4y69Hoz1MI8yCPGh1bgd2vhPGjbtsksSZzEkz1mozYFBvsy8Fuh+ABie7KN3GKcttKeNJINeCaBzjQcqsSdRJH3icg9ilvEUTZvE4ODwd48daUPezKJO4DTuVV/2++nFwH5IjH6RY+AMDyqBVgD0j1xR1AYP1vA0dQeitCa9mtCaB/sy5fFpclkMusEkCekZ49dZUOA57m1y3Qq8BlmJJ4xXtB1La3IPZqRKKpPUW8gfhVO5Y8ksLbtlrCPPA7l9+vuroXKCJXXjSzb1rNZbjp8KiuAsa1mp8UkOw6ifOoaqJLI1pthLYYhTuNK7O+m+B9dO8edBdsNse6qAqFcRuMg+dGYa5bH6xWtnuzD2irjsDBLzS8dBRuJ2bbI9UVKquYO3Zf1bit4ijxs0dnhSjaOyLWY9AT17vKgMioYm4nc7RQVD0q7M5vEK4GlxAf4l6J92X21ZOR+yMHi8FZuPh7ZfLkdgMjFrZykkpBkwD40u5d2Ocw4fnC/Ntx3gP0Tr35apmw9s462rYfCMwDMXIVQWBgKTmI6I0FUdTxPIvCqsrfv4cDiL3R8edB86qW1cVZsH5ragun6vMc4fG4jACl+H5H4zFHNicQFn67m8w/hnL76tuyvRvgU1uG5eP2myr/KkH2k0FexXKNmstbF8uXBVgcyCDoRlZj50XsHJaslEuZc5lwr5ZO7WDNXW9yUwDLHyWyNIlVyH+ZYPvpNjPR3hD6hvW/u3Aw/rBPvoEd5oByu4/jYj+okVX8Rt0ajnZ70n3iKi2nsLmsauFv3StskZbmnqtOQkEwNRlPaDTzGf4ZZAVLK3GHZmnvLb/AH0FZXa91zltoGaCYgzAEzE9WtabIwj4i6bb3mt6FtQSDBEgCQBvqbbuMZryYhU5kgACSBOXSYPYY3bop3s6xkgs2ZjqSPLuqhgeTtqFC3LggAb1O4RrpUF7k0QOjdHcUj3g/CmlmKzEXiBUFVxmzbifVbuJ+IFK7hYb1Pn5VY8Zi6TX708KIWPc7KjLUY7GtsNh1Y61QBmryj8RhEDQK0+SDgagCq1bS0weGH7OfaSaQHBHhFWDbCZcLhgd4tLQV/Cev4GjSaDwqnNPCDRZoMBrWa9FaUB2GS3lGZiDrIDRx6orKjsMmUShJ11jtrKBttHlfirhnoiD21OvLe6UKuvDeDNZWVYKfi2zMzdZmhSaysoJsPvpvZEEHtFZWVB3XkzcmyvcKOxWJgVlZWVVnHXCWoDE282+srKoAx+CD23t/WUjxjQ+2udcmMRzWMt9Tk227n0H9WX2VlZVHUfkQPD3xWNhGUEi4QB41lZUCLF8sltNlDF4+zA9+tQvyvvXujahOs9Xn7hWVlUVblMrswLubj7p3RuIAnXieqgflTgdGF7QAD7d9ZWVUaAtcIDmRM09svurKygdYFpFEXrJIrysqKU4rCUBdw9ZWUAj26iyVlZRGZa3yVlZQbKKb8ov1Fj90vlWVlAmwh+bPf8AlXhrKyg8Fa1lZQHJfaB0TuG5yogDTQGsrKyg/9k=",
    thumbnail: "data:image/jpeg;base64,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"
  }, {
    title: "Socar Brașov",
    subtitle: "Benzinarie",
    link: "/",
    image: "https://storage0.dms.mpinteractiv.ro/media/1/1481/21330/16945839/1/poza-2.jpg",
    thumbnail: "https://storage0.dms.mpinteractiv.ro/media/1/1481/21330/16945839/1/poza-2.jpg"
  }, {
    title: "Filarmonica Brașov",
    subtitle: "Filarmonica",
    link: "/",
    image: "data:image/jpeg;base64,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",
    thumbnail: "data:image/jpeg;base64,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"
  }, {
    title: "Hotel Alinalex",
    link: "/hotel3",
    subtitle: "Brașov",
    image: "/images/parteneri/hotel3.jpg",
    thumbnail: "/images/parteneri/hotel3.jpg"
  }]
}, {
  name: "Hoteluri",
  "class": "hoteluri",
  items: [{
    title: "Piatra Mare",
    link: "/hotel1",
    subtitle: "Poiana Brașov",
    image: "/images/parteneri/hotel1.jpg",
    thumbnail: "/images/parteneri/hotel1.jpg"
  }, {
    title: "Hotel Stop",
    link: "/hotel2",
    subtitle: "Brașov",
    image: "/images/parteneri/hotel2.jpg",
    thumbnail: "/images/parteneri/hotel2.jpg"
  }, {
    title: "Hotel Alinalex",
    link: "/hotel3",
    subtitle: "Brașov",
    image: "/images/parteneri/hotel3.jpg",
    thumbnail: "/images/parteneri/hotel3.jpg"
  }, {
    title: "Hotel Esprit",
    link: "/hotel4",
    subtitle: "Brașov",
    image: "/images/parteneri/hotel4.jpg",
    thumbnail: "/images/parteneri/hotel4.jpg"
  }, {
    title: "Hotel Kolping",
    link: "/hotel5",
    subtitle: "Brașov",
    image: "/images/parteneri/hotel5.jpg",
    thumbnail: "/images/parteneri/hotel5.jpg"
  }]
}, {
  name: "Restaurante",
  "class": "restaurante",
  items: [{
    title: "Ceasul Rău",
    subtitle: "Restaurant Traditional",
    link: "/restaurant1",
    image: "/images/parteneri/restaurant1.jpg",
    thumbnail: "/images/parteneri/restaurant1.jpg"
  }, {
    title: "Pilvax",
    subtitle: "Restaurant Maghiar",
    link: "/restaurant1",
    image: "/images/parteneri/restaurant2.jpg",
    thumbnail: "/images/parteneri/restaurant2.jpg"
  }, {
    title: "Gaura Dulce",
    subtitle: "Restaurant ",
    link: "/restaurant1",
    image: "/images/parteneri/restaurant3.jpg",
    thumbnail: "/images/parteneri/restaurant3.jpg"
  }, {
    title: "Dei Fratti",
    subtitle: "Restaurant Italian",
    link: "/restaurant1",
    image: "/images/parteneri/restaurant4.jpg",
    thumbnail: "/images/parteneri/restaurant4.jpg"
  }, {
    title: "Le Pompon Rouge",
    subtitle: "Restaurant Franțuzesc",
    link: "/restaurant1",
    image: "/images/parteneri/restaurant5.jpg",
    thumbnail: "/images/parteneri/restaurant5.jpg"
  }, {
    title: "Prima Școală Românească",
    subtitle: "Muzeu",
    link: "/",
    image: "data:image/jpeg;base64,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",
    thumbnail: "data:image/jpeg;base64,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"
  }]
}, {
  name: "Baruri",
  "class": "baruri",
  items: [{
    title: "English Club",
    subtitle: "Bar englezesc",
    link: "/",
    image: "/images/parteneri/bar1.jpg",
    thumbnail: "/images/parteneri/bar1.jpg"
  }, {
    title: "Sculărie",
    subtitle: "Bar",
    link: "/",
    image: "/images/parteneri/bar2.jpg",
    thumbnail: "/images/parteneri/bar2.jpg"
  }, {
    title: "Deane's",
    subtitle: "Irish Bar",
    link: "/",
    image: "/images/parteneri/bar3.jpg",
    thumbnail: "/images/parteneri/bar3.jpg"
  }, {
    title: "Jamaica",
    subtitle: "Rasta Bar",
    link: "/",
    image: "/images/parteneri/bar4.jpg",
    thumbnail: "/images/parteneri/bar4.jpg"
  }, {
    title: "Cafe13",
    subtitle: "Cafenea",
    link: "/",
    image: "/images/parteneri/bar5.jpg",
    thumbnail: "/images/parteneri/bar5.jpg"
  }]
}, {
  name: "Cluburi",
  "class": "cluburi",
  items: [{
    title: "Four Rooms",
    subtitle: "Club",
    link: "/",
    image: "/images/parteneri/club1.jpg",
    thumbnail: "/images/parteneri/club1.jpg"
  }, {
    title: "MOVe",
    subtitle: "Club",
    link: "/",
    image: "/images/parteneri/club2.jpg",
    thumbnail: "/images/parteneri/club2.jpg"
  }, {
    title: "Arta",
    subtitle: "Sport Club",
    link: "/",
    image: "/images/parteneri/club3.jpg",
    thumbnail: "/images/parteneri/club3.jpg"
  }, {
    title: "Zao Planet",
    subtitle: "Children Club",
    link: "/",
    image: "/images/parteneri/club4.jpg",
    thumbnail: "/images/parteneri/club4.jpg"
  }, {
    title: "Malibu Brașov",
    subtitle: "Gentlemen Club",
    link: "/",
    image: "/images/parteneri/club5.jpg",
    thumbnail: "/images/parteneri/club5.jpg"
  }]
}, {
  name: "Fitness",
  "class": "fitness",
  items: [{
    title: "18gim",
    subtitle: "Fitness Club",
    link: "/",
    image: "/images/parteneri/fitness1.jpg",
    thumbnail: "/images/parteneri/fitness1.jpg"
  }, {
    title: "Gym puls Brasov",
    subtitle: "Fitness",
    link: "/",
    image: "https://upfit.world/data_files/clubs-gallery/752/gym-puls-brasov_752.jpg?cache=1532338519",
    thumbnail: "https://upfit.world/data_files/clubs-gallery/752/gym-puls-brasov_752.jpg?cache=1532338519"
  }, {
    title: "URSU",
    subtitle: "Gentlemen fitness",
    link: "/",
    image: "https://upfit.world/data_files/clubs-gallery/672/sala-fitness-brasov_672.jpg?cache=1531748162",
    thumbnail: "https://upfit.world/data_files/clubs-gallery/672/sala-fitness-brasov_672.jpg?cache=1531748162"
  }, {
    title: "Iron Will",
    subtitle: "fitness",
    link: "/",
    image: "data:image/jpeg;base64,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",
    thumbnail: "data:image/jpeg;base64,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"
  }, {
    title: "Belaqva",
    subtitle: "Gentlemen fitness",
    link: "/",
    image: "https://www.belaqva.com/data_files/gallery/group-fitness/9/group-fitness-image-clase-realryder-belaqva.jpg?cache=1564648290",
    thumbnail: "https://www.belaqva.com/data_files/gallery/group-fitness/9/group-fitness-image-clase-realryder-belaqva.jpg?cache=1564648290"
  }]
},, {
  name: "Circuite turistice",
  "class": "circuite",
  items: [{
    title: "Tur Privat Brașov",
    subtitle: "Transfer București Brașov",
    link: "/",
    image: "https://www.rentcarwithdriver.ro/wp-content/gallery/brasovvvv/Circuit-Turistic-Brasov.jpg",
    thumbnail: "https://www.rentcarwithdriver.ro/wp-content/gallery/brasovvvv/Circuit-Turistic-Brasov.jpg"
  }]
}, {
  name: "Benzinari",
  "class": "benzinari",
  items: [{
    title: "Socar Brașov",
    subtitle: "Benzinarie",
    link: "/",
    image: "https://storage0.dms.mpinteractiv.ro/media/1/1481/21330/16945839/1/poza-2.jpg",
    thumbnail: "https://storage0.dms.mpinteractiv.ro/media/1/1481/21330/16945839/1/poza-2.jpg"
  }]
}, {
  name: "Cultură și divertisment",
  "class": "cultura",
  items: [{
    title: "Muzeul Civilizatiei Urbane",
    subtitle: "Muzeu",
    link: "/",
    image: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxMSEhUSExMWFhUWFxoYGBcVFxcbGxgYGBoYGBkdFxgYHSggGBolGx0XIjEhJSktLi4uGB8zODMtNygtLisBCgoKDg0OGhAQGi0lICUtLS0tLS8tLS0tLS0tLS0tLS0rKy0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLf/AABEIAKIBOAMBIgACEQEDEQH/xAAcAAABBQEBAQAAAAAAAAAAAAAAAQIDBAUGBwj/xABFEAABAgMFBQUGAwYEBQUAAAABAhEAAyEEBRIxQSJRYXGBBhORocEyQrHR4fAjUnIHFGKCovEzkrLCFRZT0uIkNENEk//EABkBAQEBAQEBAAAAAAAAAAAAAAABAgMEBf/EACYRAQEAAgICAgICAgMAAAAAAAABAhESIQMxQVETYSLBcYEEFDL/2gAMAwEAAhEDEQA/AO+QmJkphEJidCY9DkRKYlSmFSmJEpiBAmHBMPCYcExA0CHgQoEOAgEAh4EKBDgIikAhwEKBCtAI0LCwRFELBCxAkLBBAEEEERRBBBAEEEEAQQQQBBBBAEEEEAQQQQBBBBAEEEEAQQQQBBBBAcXYe0FnmezMHUGNeTNSoOFAjgRHgKZ6klwpQO99zfSLUm8pwyWoBmz4ND8sa/G97QQ7OHiVKY8Wuq/1JUO8GJNXYl66u+bt4R0UrtNLU34s1H6iSBUM2F6e15RecThXpYEKBHms/tZNDplrC6BlEqBqATqxY0q0dHdXaFaUAzsJDO4zZnUdcTO3GJfLjPazxZV1IEPAiKx2lE1IWhTpP3UaGLAEbc9EAhwEKBCxAkLBBBRBCwRAQQQRFEEEEAQQQQBBBBAEEEEAQQQQBBBBAEEEEAQQQQBBDJa3KsqFqaUBrxrD4AggggCCCCAIIZNnJQHUoJDgOogByWArqTSEgPmQu2m94JQiKzkoeWoVQcPFswfD4RbUoaNXKkcPT0e0spD1i3LleP3qIr2bnXPpFpCsKsuOpHQb4zbWpFuVKLfdNOkadiVQA6U+/GM5EytCGfN/usadmWzOPrHLKuuMbtzX2qQ4CXq56tuzoB4x3V03rLnpBSa6g/dY8vQNBxeJ7BbFIIwkhQNI34/JcWPJ45k9Zgjm7q7SYtmZ/mHqI6KXMCg6SCOEenHOZenlywuPs6CCCNMCCCAwUiVPl9tCxjWHtFZFLWhNqQpWM0UpIGQog0Ck8axsJIIcVG8QLLPZYIIjTOBWpFXSEk0LMrEzHI+ycsqb4CSCCCAIIIIAggggCGyy4fifIkRUvq8U2aRMnqyQklt5ySOpYdY8Ksl8WiWtUxE+ahZUVKwqoSqpdJ2TUnMRLdNY47fQUEeRWD9pVslUnS5c9O8fhq8Q6T/lEdTdn7TLFMYTCuQo/wDUS6f86XA6tCWJcbHYzVs1HcgeMPjje2vaQCRLFlnJKpinC5akqwpQxfUZ4Qx4xy9g/ahaJKsFqkpmge/L2FNvY7KujQ5Tel4XW3rUEc5cnbexWlgmb3az7k7YPIE7J6ExsXteKLPJXPmFkISVc9wHMsOsVnTmuxd899arwl1pPxpfcwkluXdp/wA0dhHhPZXtYiyWoTll0LBTNZyQlZxFQAzYh+hEe5yZoWlK0l0qAUDvBDg+ESXbWckvR8EEEVkQQRVvW3CRJmTlAkS0lRAZyBUs9IDi/wBqluCrChDf40zL+FOI/wDb4wRwvbbtZLny7EARsSWUkKCmViwKcjgh+sEcsu67Y605edMLonNmyCRr+UncdDzidahu88vlG1bLsSuU4AGNISSMsQZlAaEFhwcRiWMlQ2sxskF2xCmnjyjnuWbbks6PQqu6Lsi0AFjlviFNlxBwemY+cTd0zOHoDTPcac98S2VuSrsmYnMFs8szzi9KDauMxuDRlBW0CcsmIYxp2RQbZLGueu+OeUbxWBM49WoYFTd7ffGFM0GhTxfTdThE0lCMzSutRkzcneMy6Wy1NZrWQY17Heq0F0qIBqQDl0jAnTK4gzMwbKofLm5ixZ7QCz6Cjesb/cZ/VdpI7Un3kPypHQWC2Jmoxp5NuMebKm6u9PrDLZ2umWR0y0/iKAIEz2CDkuhr5VeOmHly325ZeKX09Bv6/pFjl95PXhHupFVLO5CcyfIatHkPaLtnaLwV3YBlWc5yknaUN81Q9p/yDZrXFQxhWufMtE3vZ8wzJqywfg9EpFAkVoKfGJMGGme8xvPP6a8Xik7q5LkgkDC5JAAAq5oAAA/IRqhNosi8KVzJSmBYKIzFKZH6GND9mJld5MCh+OEkoUSTsahIPskUPEHhGv2ok/8ApVqmHvFImgS1lsQSsJUQSGcZjoDmI5cLre3X8058dKlg7bWpDBeCaP4gyvFLfAxWvK/pkxRmyJkyzT83SQuWsaCahQYjQFiRpujB74AfZ+sdDclwKmIM2ee4QThQFjbKjRJUMkJJIzqXakMc8/hfJ4/FO70bd/7Up8khFtswVR+8kKAccEKJBP8AMOUdnc/bew2lgielCj7k38NT7tqiuhMeY37d+FfdTxhYsSNHyUN4yPEccsC9btVZliXOAqHSQXCk5OI64+S6ebPxSXp9HjfBHhvZJc8KAlWhckVIDqwLYOwBOBSixpnnHYXD2tnyp0yRaUGbtkKXKSMQUNkuEgBYZPOmuUdJm5fjvw9Chq1hIJJYAOScgBmTEQtaVSzNQoKThJBBpR6HdWh3Rh3pf8qXInKUtishMpJLlSpkqWU4U5s6q7qmNMSOT/arfmKYmxpUyUMuYxzUXwp6CvUbo87nTSCeB9a+Tnwhbba5i5kxaqrUpRWSzlT1oBlSGXohQnLGj7nzTXXc/gYxe67TqaXVChBzG+KUySNx9fAw68Jy5c1aUtm+uoHqYmnTGmqSRUS8VNRgCulIybZc1LVTRQqG4co05axPQCfaEVipCklQ0IHi7RCF90pKhkoepHpCxZVpIDMoV4+8MvERKuatUvuFLUZThQQVEpBDgMHpQnKGWg5EMFDR93DUQ2UsHJhvD5Qho6z2JAUmnvD4/U5x7L2DtQ7icqZOKsEzaVMmFWFAQhnKjsiivA6vHjq7UlG0osx6nkNYy7wvZc0qqUpUACkEsQDiGP8ANWsWXtnKR6lf37XkS5hRZpImpFO8WopBP8KQHKeNHjnLX+163K9hEhH8qlH+pUefKMRKVGts6jqbb+0W8pmdqUn9CUp8wHjm7de0+cXmzpkz9a1HyJiqoxEqAjmKhYYqCA9blKBlmUkg4KHIAqKMQqKJBxM+8PpHNKxInBwxme1uKmDU4hzDbDaJpxykrTi1wpKgtKUYSSQ29NWbaehETXvZLQtIXjlrYhmGFmYioBGfrHlwmpq16cru7kWZ6i52Wb11EWAsMS5xb3Zhn8I53v5yk4jhJO4s3A5Vf73WLDOmuBgOROIKTRqZO5r8It8fSzydtaSnawjacO7kUrnE5kkAUamvhFVSUlQUlRSaBQIauuXrGp3iQkOAWau4cN0YyrchBMDMXFOFPukXO+Y5a1PzGREUZE7Fio43BPu8xF2yWRc0ESk4iSCGYNXU5DXWJx2ctROUg0AFaPTTRvCucQTWlkVDH4xZwJlFMvvRMmqWE0AUgKoGUVJONnGyGjMtlrRhnItUrCvEgoQhQxY2W7mrJAIz3jOkdJhYxc5WquxqmSljEEDBLmS5tQGIUVBZyNAA38T6RUt97d5JlWaUhMyZ3aAteEHCyUghAIpzo2lcqKUzpyES5q8ElKUgI1VhycM5L16jc8dFdt3FKWQnAnfms/I+Yjdsxc+6z7o7OhGLvphBmABQSXeuy9C7F2o1TGovsjKNUTG/Vp5iNiw2RKatXeS56mNooB4Nm4+cc+VtXueq4b/lScg45UxlDJSSxHIgD4w28JV4KlmVNKloJBqAS4yOIAnzjuE2UGoA5/VMOMgjU9SD5GNbJlXktosa/ZUk5bnPlHYXB2hR+7GzWlYChspUQqqW2cTB3FKtu1eOoXIJG0Af1J+VIpTrnlLoZQ/lLeVIS69GWfLqxxPa6emZapqkqxJVhwkOzYEinV4wr7tpVJlhZJSgiVMADkyidkgbwMScvy749BtHZaScsSeYcf0xkW/slskYgQ1Q4y/SW+MWe2ss5ZJ9C+bukyrEuWkBSEMoLC9vEFITtHCQCx40DMNKN1XZ3dnnLxlM0BQQvDiQUgEqTMIxBQUlwQzMMjFW7uzk2YBZ0TEpwpXhmFJCsKFoSEqKDkX0LEA0oY3JPZm3okqld9KWDicOoBWIMAXQ6WcjZUKNHXjfpw3PW1Ds/bLa1onIVRSVrWkgFE0rrsAEbZDkMAcgc2ivddnFsVLmqKSuUhIJVsgBBYEpSHfCM3D4TQxsWKTb5EkS1WYKCThGFbnDhqQoKUVajCUjSsZ1yWv91k4ZyFoCiyhMlqAUyABjDlSKgVNNo1Oksq+0yLmlBiVpdTsAEVZxQrBKmGo36PEdpsssomlClqSxY4inJO5JAzeCenvCJ6Egy9kBSWKUnEKCrpzGYEX71nJUJpSX2DofyAaxyu1jNXIlmY2I1yBUzsA4CTprlCTrmQpasCgfwy7pamAg8cmz6NDL9UF2xChoJfkDvr4xsWydKVMDjYwMvENmgByqGyp11eNI4qd2dUJU0IBbZU4Ys2LQs3LhGXed0zEy5YaoCnemanHLXwjrroRis8x1ElJVhrn7VKmtPIRLeKj3UqYosjacEANiL14N65vG5ajh7dKUJymBLGhFfXPl5Q1VpCU7QOM6DT9Qaj7h5RJe15oWcMtIYe+RU5+yDUCMlIf7+3ih0yYpZ1JDZDfyhkxKkqwqBBZ2IY1fSHS5zImIAP4mEEgsQEHEGNc4ktClTCFFJolKKAlwkMHOpgdaVHgs8nHjdWEITiJIJYChoM4tS7unKylqPSJpdzWkZIUl6OSBTjDZGdaJQCZa0qxJXiYsR7JALg8YrLRXdG3MuK0KbEU0/NMdoeOzSvemIT0J9Icp9rxt9RzxS0EdIOzyRnNP8o+cEOcXhl9OiuyzIRO2VJoUyiAUuVYHYVapAcakAVaNm0pxIJ7pKlu20zvQ4Ts0UAQGB30jnb07JlIK5SiUu+A0IFDRT1IIzZ2G+HWXtOUBpoXiDqTMDPkzTEqYKJKmfOsccdWblaz3L3G5YLulMDMky0k5uHzc1AFSz61+OT2jtYTMEqWEjuwp8Iw+3hIDUILDwUIjt3acpS+0F54l4HCsKU7CA6QRSuoBDRkrmLmJ7wyykBtouVOakk6g5uXPLKOkn2xv6NTeBDg5cQDxi0i1O2TcPlpGYunEGL9hsCpqkIlJK1nRGbauSGDb8ovCEyrqkrEuQlaTtK2yVUSmWEFRJ2q6Ek6RUV2mmzpCUpIly6/4aO7xDKoqwPrWL1/KEuUJcwpSo07twS7V4MmgB4BuNOw3SZgcl0inClHO8+AGgiSSLu5e0021gFcuyewZmPvlgMlVP8INwFcywiS7LmCTiAJVmVrqpzmwORJ1VWsaNksyUpBzOEnwbLdnpSLKyXWNMMz4JamusZvbRLPYkBY1UCHJqWIVr8o1LBMdOQDEhhwMZtmO1/LL+CovXcgpSxDbR+MZs/o2muRZMsOSTiVmXPtGN+0j8Nf6Ff6TGHdsgoQEkuXJ11PGN6YxBSSA4IqRqGiX/wBHwwbnQ01GyxOLp7QbIfZi9fU5aVIwKUmlWyObuGNWiWx3clCkqSTsvSlXfdzia32MrIILMGr1+cdbZyc9XiJFpV+7iY7qw5kNqRUBoZdNtM1woJoAdknXmS0Sy7OoSRLzIGmXtE/CGXXZlIKsQAdKRTh1jPWqve4mt89MtIUoEuWoHahL5ilIyr9SJlmWpL+yTWh2S5+EaN9SsSEhidsGj5MrdFKckiyqGgQtwoEnU5vGdTjtd/y0w+yZT35CVFsChhLb0kFITRiNHiK+u0czvyiWcKUYg4I2mKa/GGdk5ijaZbqdOGazHKsuhDBvnihLDcYnWcKwpExayvEaHDjALHUFDlsnbnHqxv8AFz122rB2lQcWOjBwd/A7leUaF13mmeKULOU8D6Rz0y7UpnSxIThwYgpya7LgktVVT48opykzbPaklTsTU5uKvlpz5xdrwdfaLpkLBSqUhjmwwvUGpSxzAPQRQndnJRBCVLDgjPFo3vVPjG4TDCqFxl9sbscJf1wKlkT+8SQkpBBGE12QwBIzI10MQ2uaB3e8KLu2Rwh2bKnHKNXt3amlBIPvJ8lfURy95TGwrAyO7NlA5+kcc8ZL03KtXSAVzQagTprMxB9pmccmiG8bEicqSFjGJqUpSkKUgOErW5yBGbOaP4RWXA0yWkgpVMwA0oChzmGo/DKsY1zpnzLWiaqsuW4G0GYSygEB2rQ03mI1Pbp09j5YOH93Q+bKWCW3tiiZPZhKCEiVJQVZBs25COltSgbSMi8s/FURXifx5P6lf7fnHPXXt363JqemLKuLaUgGUClgQEmj1Huh4jtV3CWWVNIcOyUkhqjVQ3GN2y/+4nDij/TGXf8AVacNdjMV95W6HGa2uN3nx+NEmdn0gOZijnkAMg+sULHYJMxRT+JQPVSd4G7jHTWmcAAKnE4oCWpruEYNzy1JWSUqAwHMHemLcYzhllccrUN6XbKlJcIxVAqTqCdOUMveyy5OHDLTUl8TnJuMXr8SVy2SkviBy0wq+cV7+RjCcNWJeoG7fEsm+lwytk3T5ljlpdkIodw4+cJEk62ortDPeOPGFjp08/8ANmJvFKpUpR2TODJGbnCVN4AxTtcmWtCBMCS4SlzmMRAFcxWMGZOOCxD8i1H+tPoTCWW1oBAnYijvFk4T+UpWnzJjzYYfT15ZfbSFzyUEEKSOOEGh0fE4ixYVJkysPey1SnoCkA+2RU4z5gDjEN6W+ypT+GVflL4ikZN7Qd45+VbUlJQt0oKqKVlm+bmj8dR07yb3NOGV9VuSOz3fkmSUqQFVJNBqzJ5kaZDfGzKvH90R3djkqcgY501O0th7oWzpFWam4Vcz3RbZcpASmlEk4ah9rCeoOUZFst6Z4xyylaUMCHKDjoKlaRSo4VOsau2WnfA7yRLWyTMKTjJAxDEnEXYb3po8WLpkFMopd2fLecJPrHI2m8pkmWgLlnDOCsAC0uwDKJbEKE5bmqGMVpd9T0KsoRMWlExe2mhCgJrEVDpLU6CNfDD0OTKOAOWdJ4Zgb+UPAQ5LuS+QJzZ+GkZybckbIS5ArSpZnzzz3w+0Xi2MAVSlZrk6Ag6F2OMeBjjzdeK0m8UKmd0gupKhiT+WhIcaUaHdnLQtUhJerqqak7as3jnxaZoMxeMukKKHJIGwCHSThNX0ibs9aVhNlAUyVLnhYYMpgsjRwxGkay3Mb/r+zGyu3kqOpeNsywcwDzjmLHMJWtyWDNHTgxw3tvWiCUg6J8okTZ06DwJjy3tBZkfvNoJSlzMNSn+Eax1d+zALHZqkOZYGHMnulMBUfYjeOO7Izb06abLYGqsj7x3c45vsQ6hM2lMAjd/HwiO0qUm7bRhWvEHZRdKh7HEkbs4q/s8nEzJicRIEsUej94vTe3xj0THj48/8xn5jtShX5vED0aM6+SoSlg4SMCtCNDrVjHO9vL9mIV3UsqSEgFakFlEqqA7ggMxoavFLspf65oXImKWoFCigrqoFLukkkkhnNcm8PHPJOWnW+O62W5bQUJllQ2toKKX3KJw8Nc9NY6aRaksjC2FSRhbLeAOkedrvH8dMsEulRrXVBU46NGzabWshBDGXjaYKukZunmddCeMfSwx3h08fKS9unAcd4oNgWQ7moPtZZh28Iyr1lEql4SVYAS+ZOQ8nz+LxNZrewEo6FYUVF8TEF2OhAPjGLft8hKmBIqKjVt24Ddx5xeDphn2dLnjCCJiAaZuNN4zLw5FqmvSeCN3eH4GMvGwG0kCnv8N2nwiuq0EKzHkY8dvT7f49rXaKYtUpSlKKlJWnLiQ+QrkPvKpbZj2dYcAhSedVZxQvTaUE0qmuLLM5vyipbZaE2dThJU6ScjTEkZjq/wBY3O5Hyv8AkamdkaYUpKglySwIzepOXBqaaRPYFhE2Y1EgqYMCxALbJz5RzhmSgEHCEngMxiJjVsttAJRiBQcYKWFMiqpatcno43xdW+nGWb7diu3LzMyoDP3SPiVRAu3q/wCoqn8KB6xFZ5iZhDFww0AB4kgnQjwgvGyGUsoWUvQgoqGViYHKownLfHCb+Y9/8NyFNuVXbmdCB6Qhtp/NN/8A0/8AGKgrRJdRUlIxAMMWur/WE9nEmYQVIVgJQAxZKFO2ntN0ipvHlxPnWwDNUzqv5JiGzWtM0kJqwfaURRn3CvD6RPNlKCe8Ck4QrCUMHKWDknOr+cV5iEbQYnCFHSuEEtlqzdY1LNftJZb/AIUrReEsPQa/nOXIwz99QckjwmepitdVuVNXMQsI2Uk7AUkhiA20S4rzpFxRTuP+Yf8AbGsuPqRMbL2iM8EUSnwPqYWLxsiTj/ECSgsEvmCSBssxy13VgjLnfLjv05K02ikoAEsT4Egv4/CIJ9UilXUc+m7gIlvItNQP4Qf6lfKEsdkXMCcA0YndkxZ66xZhHG52qsyarz4u7btdYeLvIC1KCxQKZlD2QaB8zyjpLDdKJO0RiUc1Hju3CI5iitRz3dK69D5R1kkZttczZb6tADoUpkpSohgdnEoU3hilgfy6DNLHa5kpSUqmzFmYkEMSwBOe8qYPl1jpZVzICCge9LEup90Ymy1qYWTcRQULlnalpmBIUSQ6xQPmlIPPWNI5q3z5s0SkpKiZQwBiMkskHAmqSxLks78Imtt22qXIlTFSpgwKVtkL9oqBSSVJFXGYJHGrQ3s5YVy7eE4V4XWl1gjEGIBcirqAMdxZ73mWhc6yqlgJkkbTk48VRiBpuPSFhK5i5r/nG0hK2UhTpyZtnEk8wwHWN2+Ld3dokpAxJmCcqZwQJaaDc5SK8OMWJlypOSQOI+UVLf2fK2LYlJBwuS/J3yeMfjxXlUPZu802obQYkkEPmMIyLDQtHWWayywUYQ2AkpAoHUCCaZu5jkLt7P2iUQUoql6aFx96xvyf3nWR/U3ziZeOZfJjlxnpu2JLTZinO1h13PlujrTMAqSw3mOFs4muCZJf9SfUiNG9FzJ0tcvulDEGfEilQfzRynh/bd8jVm3DZZylTCnEVEklMxbEjZPsqbRukX513S1y0ylA4ENhDmmEYRXM0jkuxlltFksqZK0hagpaipSy5xrKqsFVrWsbotc8kUlAajEovyOEN5xqeP8Aac/0v/8ACpXcqkMe7XmHPDXPQRHdFxSLMVKlJIKgxdRNHfWIDOnH3pY/lUfURRsN2zJa8YtMwuS6VFSk14KWWbTdF4XWtpz/AE5nt5NH71MBB/8AjNML+ylmcHWM3spOHfJb8s7/AELj0K0WNSwQqYa5lKEAtzIJisLqSE4O8mlNfeS9c64Xjj/1+/fzt1/P1rXxp53arUkKRNADku+HMYTRR31A6xs3PazMOOWglAcFykOA4Zn51jeHY+y/kWecxfkxDRbs3ZyRLThQhSUnQTJjVf8Ai4nxj24+TLGajy3GVyF636kLJSiY0uiqJLEAI2iCzONeEY1225E60oLAgEMldQS7VGvH6x6TL7PWYYmlI2wQt64waHG/tPxeFl3BZ0+zIlDlLR8ofkyWRzFgv0C0zZJloBBwElQSCQAoHCEFixjM/wCYBaUTFYUoUgUQFYsRdmfCPhHoYsCAKISBwSB6QvcD7aM7rfKvHrMiZPmlEyXNlggsUpVoXG0UtVh4xo2y5ZkmTNwICssJXVRqMjiAFTu93nHpxswiNdkTqPIQ7SvKpnZJDAK7zZBqkqc7gQCzDgBEguXumMvGr/EfGlRO2lAdJbZOyK849NVY0nQeUQqu9J0I5Ewl1UvblbtsYXJUkqwFSCj9OyA9a05w+x3WJSF455mOynOIkBILgYlKNc2fN46Bd3N7x6xXnWBwRidwzP6xLJWpnlNdsAykWiSruZ+FylltkQynSHG+H3ddBloKVTjMJWVYiKl0oSxdRf2Y0pN0JlpZCMKXfZAAfLJNIVcgapHTCD8IcIv5Mt72xLwuxlKnGcQkMopOMhkpAOyFM9N3jDVXpZiVETqkLoUL95JG7jGtbbAibLVLUFMc2wuK6FozldmLPvX1hwhPJlHN9n5qJc1RmLSkKQoOyqE1q4jTVaZH/WHgYlndj5KlOFqDZjEGOfX+0MV2RlD3j5/MROEWeSz0kFslrJwFJLk8WJ5cYIbYbjElZUhRLhmroXzBfd4QRqYxztILhSohS1OQGoG1J38Y0pN1pFAVUyruixIEXpfr/f5RnS7UP+Gg6q8YBdCAXr1JHDTpGkF06E/KHFAeoGe4a/WLo2r2ewpHLqYmnSMBbC40Oh+/vR50Dx9frFmzKHsqDjQ7vr97wRtk/uyVrClygcI2SpjhLghhvzrFuz2VCFLWlCQqY2M1qUhg4dsqRorlBGg4Fh9/eoh6VRq3ftJ0rJJ0HgIXAs6HwHyi3BGRTFnXx8R84eizK3t1+UWokSYptCiUrenz9BE6Je/yhzxIEHcYgaJcKqmbCHFJH2IfhIqfn8IBqekOhRM4+XzhSRu9PKASFxcTAG3ffQw8IOYHl8/nAMxQqQd0PSSNW5N6QiiDmQeQP0gEY/ZA+MItG8Dwf4QKw7j4/wB4QqA08foYoYyRu8PrA4P0cekLiJo4hFhWRfrSARaTqPEiGEcvB/MQ0yQM/IqhiinR/L6wAtY3nwPziJahz5k/KHmZu9fn6RGuer81eH0EAikn8oHGnrEak8QOX/jAQo6PyaEEg6jqS3kATARrbVz09STEWMDTxf5CFmFIzJJ0YYadc/CE/eBoMP8AUfOAawVkkHlT4NEcyzDUt1HwYmHrmP7x65eEQqPEeXygKk+QNFEj9IitMkEZV8B8SIvKBJoATwPyMN/diaq2Rzr0EUZi8afzdCPnCRanz0SwTtFtSSw6DSCG0QSVfIc/v1i6lbPwHn9tGfKmJ4luUaACQkkg5IVU6rUwFNzRBPvHD5xJnrmPv4xWlWh1FgMhod6t8SybSWQXbJ2AGY4cWgq3LS+Wo8CPvyiVEsnMN6HJw+nx6xU7xRJS7mhFfDzBidCSWOEsRWng/mPCCL0ldMKvIim7kM2OleMIqXhzPkX4/wBuXCKwQXbZcb1Co4gV+oi5LWkjCVBW7MdHVQEZB+UFMSocS4owFeTnyMJPmhIohS33KHm9ekKtATqS/Bgd7PUEGhBYv0MImYMxydRPmKRBEi2LP/1+ZK4vy5w1A8K+efOIUrP5QC2VH/lKvWHCarSg4U8WqnnAWilWaSSPD7ENKTqw5qD+ZiArO8vz+wfjE8ue4ZW0Or/MfdYBcI1I8/vrDkqSDQnoG83rDjZgzpcDcUny+njCGzsKlIHUv0H1gh3eDUDm/wAgHh6VjQNzD/HKGDCPeJ5D1Jp5QoWn8r7gT/YHo8A/a0L/AKS3lSECCdD4Q0Wg5AAcAK+LfKHotChqT4GAXuCM6cyB5ZwBIeq/AE/FhAFJOaeo+WsIUA5KruVRooFqToD1p5CEMwaADo/xhFylD3X5GFFmURk3OjQDCtR97o7RGUnd5fKJVSUiil/5Q/npDDaEJOyl/wBSviBpBUAfTyiQWdWZYD+NhCKthd3HQfZiNcwHNPmQfWAcpCBmp/0g/FRbyiAzEjQdawxWF6E8iH8WMNUh8lA9W+PzgCZOJ988mYeUVlytxB6/OBUtQFR1aIy51z4fCkA5SFjJ24Et4iITNP8AcA+kWJVioVKUw3uM/gk8CQYbNtKEBk4lcySPOvgAeMAyXKUr3BzLjwYwTZctPtKc7kmnU/ZiBduWXxGh0P3XqTEC54/K3JX9xATrtYZk7A4AEnq7+UUJpr7Tk/md4cVJrmPP1iCYBliHIuIoitCSUqGIMxBZWnpCQ2dILFmP6WPkKwQRURkevwjatSiyv1p/0AwQRBDI9s8k/wC6Ni75SSgOkHmBoaQsEAtoWQoAEgMcjxEVyslCnJPt+RLQkEBZme71+EOs3vc/9ogggNWaNhf6ZKupJBPMijxVPtdPWCCIEV7KuDtwbJt0PmFlJbjBBAXLvQCSCAQ4oekXbZsp2aZZU14QQRRRKiV1rTWNGxVAerkgvqAKPBBEGdaaHr6w4e0BveFggCWKrG7LhnCyj+G+u/XXWCCAnTp974JSQVgaboIIDRmJACmAHKIrUNnkmCCKMm00wga5xGsbaRo2XhBBAMA2oYc1coIIKrzjlyhQNpuPygggIJSjiNdT6xfWdlB1JY8RSh3wQQFG8v8AEUNzAcAwoN0ZmnWCCCIh7IgX7L8IIIKrr9kcniD5QQRRRtKjgJ1b1EEEEB//2Q==",
    thumbnail: "data:image/jpeg;base64,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"
  }, {
    title: "Prima Școală Românească",
    subtitle: "Muzeu",
    link: "/",
    image: "data:image/jpeg;base64,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",
    thumbnail: "data:image/jpeg;base64,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"
  }, {
    title: "Filarmonica Brașov",
    subtitle: "Filarmonica",
    link: "/",
    image: "data:image/jpeg;base64,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",
    thumbnail: "data:image/jpeg;base64,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"
  }]
}];
/* harmony default export */ __webpack_exports__["default"] = (parteneri_table);

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/page_components/parteneri.js":
/*!*************************************************!*\
  !*** ./components/page_components/parteneri.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _common_portofoliu_card__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/portofoliu/card */ "./components/common/portofoliu/card.js");
/* harmony import */ var react_grid_system__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-grid-system */ "./node_modules/react-grid-system/build/index.js");
/* harmony import */ var react_grid_system__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_grid_system__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _components_common_Headline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../components/common/Headline */ "./components/common/Headline.js");
/* harmony import */ var _components_common_tables_parteneri_table__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../components/common/tables/parteneri_table */ "./components/common/tables/parteneri_table.js");

var _jsxFileName = "G:\\MDMax\\go brasov\\site_nextjs\\gobv-site\\components\\page_components\\parteneri.js";


 // Components





function Parteneri() {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("section", {
    className: "section section-portfolio section-portfolio-1 bg-gradient-side overlay-color",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
      className: "bg-color bg-dark-60"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 14,
      columnNumber: 13
    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "display-spacing",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_grid_system__WEBPACK_IMPORTED_MODULE_4__["Container"], {
        className: "container",
        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_common_Headline__WEBPACK_IMPORTED_MODULE_5__["default"], {
          label: "Portfolio",
          title: "Let's See Our portfolio",
          divider_1: true,
          position: "center"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 17,
          columnNumber: 21
        }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_common_portofoliu_card__WEBPACK_IMPORTED_MODULE_3__["default"], {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 18,
          columnNumber: 21
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 16,
        columnNumber: 17
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 15,
      columnNumber: 13
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 13,
    columnNumber: 9
  }, this);
}

_c = Parteneri;
/* harmony default export */ __webpack_exports__["default"] = (Parteneri);

var _c;

$RefreshReg$(_c, "Parteneri");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/clsx/dist/clsx.m.js":
/*!******************************************!*\
  !*** ./node_modules/clsx/dist/clsx.m.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function toVal(mix) {
	var k, y, str='';

	if (typeof mix === 'string' || typeof mix === 'number') {
		str += mix;
	} else if (typeof mix === 'object') {
		if (Array.isArray(mix)) {
			for (k=0; k < mix.length; k++) {
				if (mix[k]) {
					if (y = toVal(mix[k])) {
						str && (str += ' ');
						str += y;
					}
				}
			}
		} else {
			for (k in mix) {
				if (mix[k]) {
					str && (str += ' ');
					str += k;
				}
			}
		}
	}

	return str;
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
	var i=0, tmp, x, str='';
	while (i < arguments.length) {
		if (tmp = arguments[i++]) {
			if (x = toVal(tmp)) {
				str && (str += ' ');
				str += x
			}
		}
	}
	return str;
});


/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var assign=Object.assign.bind(Object);module.exports=assign;module.exports.default=module.exports;
//# sourceMappingURL=object-assign.js.map

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Fportfolio&absolutePagePath=G%3A%5CMDMax%5Cgo%20brasov%5Csite_nextjs%5Cgobv-site%5Cpages%5Cportfolio.js!./":
/*!*************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Fportfolio&absolutePagePath=G%3A%5CMDMax%5Cgo%20brasov%5Csite_nextjs%5Cgobv-site%5Cpages%5Cportfolio.js ***!
  \*************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


    (window.__NEXT_P = window.__NEXT_P || []).push([
      "/portfolio",
      function () {
        return __webpack_require__(/*! ./pages/portfolio.js */ "./pages/portfolio.js");
      }
    ]);
  

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js");

var _s = $RefreshSig$();

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

exports.__esModule = true;
exports["default"] = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js");

var _router2 = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

var cachedObserver;
var listeners = new Map();
var IntersectionObserver = true ? window.IntersectionObserver : undefined;
var prefetched = {};

function getObserver() {
  // Return shared instance of IntersectionObserver if already created
  if (cachedObserver) {
    return cachedObserver;
  } // Only create shared IntersectionObserver if supported in browser


  if (!IntersectionObserver) {
    return undefined;
  }

  return cachedObserver = new IntersectionObserver(function (entries) {
    entries.forEach(function (entry) {
      if (!listeners.has(entry.target)) {
        return;
      }

      var cb = listeners.get(entry.target);

      if (entry.isIntersecting || entry.intersectionRatio > 0) {
        cachedObserver.unobserve(entry.target);
        listeners["delete"](entry.target);
        cb();
      }
    });
  }, {
    rootMargin: '200px'
  });
}

var listenToIntersections = function listenToIntersections(el, cb) {
  var observer = getObserver();

  if (!observer) {
    return function () {};
  }

  observer.observe(el);
  listeners.set(el, cb);
  return function () {
    try {
      observer.unobserve(el);
    } catch (err) {
      console.error(err);
    }

    listeners["delete"](el);
  };
};

function prefetch(router, href, as, options) {
  if (false) {}
  if (!(0, _router.isLocalURL)(href)) return; // Prefetch the JSON page if asked (only in the client)
  // We need to handle a prefetch error here since we may be
  // loading with priority which can reject but we don't
  // want to force navigation since this is only a prefetch

  router.prefetch(href, as, options)["catch"](function (err) {
    if (true) {
      // rethrow to show invalid URL errors
      throw err;
    }
  }); // Join on an invalid URI character

  prefetched[href + '%' + as] = true;
}

function isModifiedEvent(event) {
  var target = event.currentTarget.target;
  return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
  event.nativeEvent && event.nativeEvent.which === 2;
}

function linkClicked(e, router, href, as, replace, shallow, scroll, locale) {
  var nodeName = e.currentTarget.nodeName;

  if (nodeName === 'A' && (isModifiedEvent(e) || !(0, _router.isLocalURL)(href))) {
    // ignore click for browser’s default behavior
    return;
  }

  e.preventDefault(); //  avoid scroll for urls with anchor refs

  if (scroll == null) {
    scroll = as.indexOf('#') < 0;
  } // replace state instead of push if prop is present


  router[replace ? 'replace' : 'push'](href, as, {
    shallow: shallow,
    locale: locale
  }).then(function (success) {
    if (!success) return;

    if (scroll) {
      window.scrollTo(0, 0);
      document.body.focus();
    }
  });
}

function Link(props) {
  _s();

  if (true) {
    var createPropError = function createPropError(args) {
      return new Error("Failed prop type: The prop `".concat(args.key, "` expects a ").concat(args.expected, " in `<Link>`, but got `").concat(args.actual, "` instead.") + (true ? "\nOpen your browser's console to view the Component stack trace." : undefined));
    }; // TypeScript trick for type-guarding:


    var requiredPropsGuard = {
      href: true
    };
    var requiredProps = Object.keys(requiredPropsGuard);
    requiredProps.forEach(function (key) {
      if (key === 'href') {
        if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {
          throw createPropError({
            key: key,
            expected: '`string` or `object`',
            actual: props[key] === null ? 'null' : typeof props[key]
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var _ = key;
      }
    }); // TypeScript trick for type-guarding:

    var optionalPropsGuard = {
      as: true,
      replace: true,
      scroll: true,
      shallow: true,
      passHref: true,
      prefetch: true,
      locale: true
    };
    var optionalProps = Object.keys(optionalPropsGuard);
    optionalProps.forEach(function (key) {
      var valType = typeof props[key];

      if (key === 'as') {
        if (props[key] && valType !== 'string' && valType !== 'object') {
          throw createPropError({
            key: key,
            expected: '`string` or `object`',
            actual: valType
          });
        }
      } else if (key === 'locale') {
        if (props[key] && valType !== 'string') {
          throw createPropError({
            key: key,
            expected: '`string`',
            actual: valType
          });
        }
      } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch') {
        if (props[key] != null && valType !== 'boolean') {
          throw createPropError({
            key: key,
            expected: '`boolean`',
            actual: valType
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var _ = key;
      }
    }); // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes
    // eslint-disable-next-line react-hooks/rules-of-hooks

    var hasWarned = _react["default"].useRef(false);

    if (props.prefetch && !hasWarned.current) {
      hasWarned.current = true;
      console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://err.sh/vercel/next.js/prefetch-true-deprecated');
    }
  }

  var p = props.prefetch !== false;

  var _react$default$useSta = _react["default"].useState(),
      _react$default$useSta2 = _slicedToArray(_react$default$useSta, 2),
      childElm = _react$default$useSta2[0],
      setChildElm = _react$default$useSta2[1];

  var router = (0, _router2.useRouter)();
  var pathname = router && router.pathname || '/';

  var _react$default$useMem = _react["default"].useMemo(function () {
    var _ref = (0, _router.resolveHref)(pathname, props.href, true),
        _ref2 = _slicedToArray(_ref, 2),
        resolvedHref = _ref2[0],
        resolvedAs = _ref2[1];

    return {
      href: resolvedHref,
      as: props.as ? (0, _router.resolveHref)(pathname, props.as) : resolvedAs || resolvedHref
    };
  }, [pathname, props.href, props.as]),
      href = _react$default$useMem.href,
      as = _react$default$useMem.as;

  _react["default"].useEffect(function () {
    if (p && IntersectionObserver && childElm && childElm.tagName && (0, _router.isLocalURL)(href)) {
      // Join on an invalid URI character
      var isPrefetched = prefetched[href + '%' + as];

      if (!isPrefetched) {
        return listenToIntersections(childElm, function () {
          prefetch(router, href, as);
        });
      }
    }
  }, [p, childElm, href, as, router]);

  var children = props.children,
      replace = props.replace,
      shallow = props.shallow,
      scroll = props.scroll,
      locale = props.locale; // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag

  if (typeof children === 'string') {
    children = /*#__PURE__*/_react["default"].createElement("a", null, children);
  } // This will return the first child, if multiple are provided it will throw an error


  var child = _react.Children.only(children);

  var childProps = {
    ref: function ref(el) {
      if (el) setChildElm(el);

      if (child && typeof child === 'object' && child.ref) {
        if (typeof child.ref === 'function') child.ref(el);else if (typeof child.ref === 'object') {
          child.ref.current = el;
        }
      }
    },
    onClick: function onClick(e) {
      if (child.props && typeof child.props.onClick === 'function') {
        child.props.onClick(e);
      }

      if (!e.defaultPrevented) {
        linkClicked(e, router, href, as, replace, shallow, scroll, locale);
      }
    }
  };

  if (p) {
    childProps.onMouseEnter = function (e) {
      if (!(0, _router.isLocalURL)(href)) return;

      if (child.props && typeof child.props.onMouseEnter === 'function') {
        child.props.onMouseEnter(e);
      }

      prefetch(router, href, as, {
        priority: true
      });
    };
  } // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
  // defined, we specify the current 'href', so that repetition is not needed by the user


  if (props.passHref || child.type === 'a' && !('href' in child.props)) {
    childProps.href = (0, _router.addBasePath)((0, _router.addLocale)(as, typeof locale !== 'undefined' ? locale : router && router.locale, router && router.defaultLocale));
  }

  return /*#__PURE__*/_react["default"].cloneElement(child, childProps);
}

_s(Link, "Yt4+dEXpDdcToH476p06kPk14D0=");

_c = Link;
var _default = Link;
exports["default"] = _default;

var _c;

$RefreshReg$(_c, "Link");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/normalize-trailing-slash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.removePathTrailingSlash = removePathTrailingSlash;
exports.normalizePathTrailingSlash = void 0;
/**
* Removes the trailing slash of a path if there is one. Preserves the root path `/`.
*/

function removePathTrailingSlash(path) {
  return path.endsWith('/') && path !== '/' ? path.slice(0, -1) : path;
}
/**
* Normalizes the trailing slash of a path according to the `trailingSlash` option
* in `next.config.js`.
*/


var normalizePathTrailingSlash =  false ? undefined : removePathTrailingSlash;
exports.normalizePathTrailingSlash = normalizePathTrailingSlash;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _construct = __webpack_require__(/*! @babel/runtime/helpers/construct */ "./node_modules/next/node_modules/@babel/runtime/helpers/construct.js");

var _s = $RefreshSig$();

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useRouter = useRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports.createRouter = exports.withRouter = exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js"));

exports.Router = _router2["default"];
exports.NextRouter = _router2.NextRouter;

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ "./node_modules/next/dist/client/with-router.js"));

exports.withRouter = _withRouter["default"];
/* global window */

var singletonRouter = {
  router: null,
  // holds the actual router instance
  readyCallbacks: [],
  ready: function ready(cb) {
    if (this.router) return cb();

    if (true) {
      this.readyCallbacks.push(cb);
    }
  }
}; // Create public properties and methods of the router in the singletonRouter

var urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath', 'locale', 'locales', 'defaultLocale'];
var routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
var coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it

Object.defineProperty(singletonRouter, 'events', {
  get: function get() {
    return _router2["default"].events;
  }
});
urlPropertyFields.forEach(function (field) {
  // Here we need to use Object.defineProperty because, we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  Object.defineProperty(singletonRouter, field, {
    get: function get() {
      var router = getRouter();
      return router[field];
    }
  });
});
coreMethodFields.forEach(function (field) {
  // We don't really know the types here, so we add them later instead
  ;

  singletonRouter[field] = function () {
    var router = getRouter();
    return router[field].apply(router, arguments);
  };
});
routerEvents.forEach(function (event) {
  singletonRouter.ready(function () {
    _router2["default"].events.on(event, function () {
      var eventField = "on".concat(event.charAt(0).toUpperCase()).concat(event.substring(1));
      var _singletonRouter = singletonRouter;

      if (_singletonRouter[eventField]) {
        try {
          _singletonRouter[eventField].apply(_singletonRouter, arguments);
        } catch (err) {
          console.error("Error when running the Router event: ".concat(eventField));
          console.error("".concat(err.message, "\n").concat(err.stack));
        }
      }
    });
  });
});

function getRouter() {
  if (!singletonRouter.router) {
    var message = 'No router instance found.\n' + 'You should only use "next/router" inside the client side of your app.\n';
    throw new Error(message);
  }

  return singletonRouter.router;
} // Export the singletonRouter and this is the public API.


var _default = singletonRouter; // Reexport the withRoute HOC

exports["default"] = _default;

function useRouter() {
  _s();

  return _react["default"].useContext(_routerContext.RouterContext);
} // INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.


_s(useRouter, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

var createRouter = function createRouter() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  singletonRouter.router = _construct(_router2["default"], args);
  singletonRouter.readyCallbacks.forEach(function (cb) {
    return cb();
  });
  singletonRouter.readyCallbacks = [];
  return singletonRouter.router;
}; // This function is used to create the `withRouter` router instance


exports.createRouter = createRouter;

function makePublicRouterInstance(router) {
  var _router = router;
  var instance = {};

  var _iterator = _createForOfIteratorHelper(urlPropertyFields),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var property = _step.value;

      if (typeof _router[property] === 'object') {
        instance[property] = Object.assign(Array.isArray(_router[property]) ? [] : {}, _router[property]); // makes sure query is not stateful

        continue;
      }

      instance[property] = _router[property];
    } // Events is a static property on the router, the router doesn't have to be initialized to use it

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  instance.events = _router2["default"].events;
  coreMethodFields.forEach(function (field) {
    instance[field] = function () {
      return _router[field].apply(_router, arguments);
    };
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = withRouter;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

function withRouter(ComposedComponent) {
  function WithRouterWrapper(props) {
    return /*#__PURE__*/_react["default"].createElement(ComposedComponent, Object.assign({
      router: (0, _router.useRouter)()
    }, props));
  }

  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app
  ;
  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;

  if (true) {
    var name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
    WithRouterWrapper.displayName = "withRouter(".concat(name, ")");
  }

  return WithRouterWrapper;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/compiled/path-to-regexp/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-to-regexp/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Tokenize input string.
 */
function lexer(str) {
    var tokens = [];
    var i = 0;
    while (i < str.length) {
        var char = str[i];
        if (char === "*" || char === "+" || char === "?") {
            tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
            continue;
        }
        if (char === "\\") {
            tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
            continue;
        }
        if (char === "{") {
            tokens.push({ type: "OPEN", index: i, value: str[i++] });
            continue;
        }
        if (char === "}") {
            tokens.push({ type: "CLOSE", index: i, value: str[i++] });
            continue;
        }
        if (char === ":") {
            var name = "";
            var j = i + 1;
            while (j < str.length) {
                var code = str.charCodeAt(j);
                if (
                // `0-9`
                (code >= 48 && code <= 57) ||
                    // `A-Z`
                    (code >= 65 && code <= 90) ||
                    // `a-z`
                    (code >= 97 && code <= 122) ||
                    // `_`
                    code === 95) {
                    name += str[j++];
                    continue;
                }
                break;
            }
            if (!name)
                throw new TypeError("Missing parameter name at " + i);
            tokens.push({ type: "NAME", index: i, value: name });
            i = j;
            continue;
        }
        if (char === "(") {
            var count = 1;
            var pattern = "";
            var j = i + 1;
            if (str[j] === "?") {
                throw new TypeError("Pattern cannot start with \"?\" at " + j);
            }
            while (j < str.length) {
                if (str[j] === "\\") {
                    pattern += str[j++] + str[j++];
                    continue;
                }
                if (str[j] === ")") {
                    count--;
                    if (count === 0) {
                        j++;
                        break;
                    }
                }
                else if (str[j] === "(") {
                    count++;
                    if (str[j + 1] !== "?") {
                        throw new TypeError("Capturing groups are not allowed at " + j);
                    }
                }
                pattern += str[j++];
            }
            if (count)
                throw new TypeError("Unbalanced pattern at " + i);
            if (!pattern)
                throw new TypeError("Missing pattern at " + i);
            tokens.push({ type: "PATTERN", index: i, value: pattern });
            i = j;
            continue;
        }
        tokens.push({ type: "CHAR", index: i, value: str[i++] });
    }
    tokens.push({ type: "END", index: i, value: "" });
    return tokens;
}
/**
 * Parse a string for the raw tokens.
 */
function parse(str, options) {
    if (options === void 0) { options = {}; }
    var tokens = lexer(str);
    var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
    var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
    var result = [];
    var key = 0;
    var i = 0;
    var path = "";
    var tryConsume = function (type) {
        if (i < tokens.length && tokens[i].type === type)
            return tokens[i++].value;
    };
    var mustConsume = function (type) {
        var value = tryConsume(type);
        if (value !== undefined)
            return value;
        var _a = tokens[i], nextType = _a.type, index = _a.index;
        throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
    };
    var consumeText = function () {
        var result = "";
        var value;
        // tslint:disable-next-line
        while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
            result += value;
        }
        return result;
    };
    while (i < tokens.length) {
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
            var prefix = char || "";
            if (prefixes.indexOf(prefix) === -1) {
                path += prefix;
                prefix = "";
            }
            if (path) {
                result.push(path);
                path = "";
            }
            result.push({
                name: name || key++,
                prefix: prefix,
                suffix: "",
                pattern: pattern || defaultPattern,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
            path += value;
            continue;
        }
        if (path) {
            result.push(path);
            path = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
            var prefix = consumeText();
            var name_1 = tryConsume("NAME") || "";
            var pattern_1 = tryConsume("PATTERN") || "";
            var suffix = consumeText();
            mustConsume("CLOSE");
            result.push({
                name: name_1 || (pattern_1 ? key++ : ""),
                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                prefix: prefix,
                suffix: suffix,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        mustConsume("END");
    }
    return result;
}
exports.parse = parse;
/**
 * Compile a string to a template function for the path.
 */
function compile(str, options) {
    return tokensToFunction(parse(str, options), options);
}
exports.compile = compile;
/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens, options) {
    if (options === void 0) { options = {}; }
    var reFlags = flags(options);
    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
    // Compile all the tokens into regexps.
    var matches = tokens.map(function (token) {
        if (typeof token === "object") {
            return new RegExp("^(?:" + token.pattern + ")$", reFlags);
        }
    });
    return function (data) {
        var path = "";
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (typeof token === "string") {
                path += token;
                continue;
            }
            var value = data ? data[token.name] : undefined;
            var optional = token.modifier === "?" || token.modifier === "*";
            var repeat = token.modifier === "*" || token.modifier === "+";
            if (Array.isArray(value)) {
                if (!repeat) {
                    throw new TypeError("Expected \"" + token.name + "\" to not repeat, but got an array");
                }
                if (value.length === 0) {
                    if (optional)
                        continue;
                    throw new TypeError("Expected \"" + token.name + "\" to not be empty");
                }
                for (var j = 0; j < value.length; j++) {
                    var segment = encode(value[j], token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError("Expected all \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                    }
                    path += token.prefix + segment + token.suffix;
                }
                continue;
            }
            if (typeof value === "string" || typeof value === "number") {
                var segment = encode(String(value), token);
                if (validate && !matches[i].test(segment)) {
                    throw new TypeError("Expected \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                }
                path += token.prefix + segment + token.suffix;
                continue;
            }
            if (optional)
                continue;
            var typeOfMessage = repeat ? "an array" : "a string";
            throw new TypeError("Expected \"" + token.name + "\" to be " + typeOfMessage);
        }
        return path;
    };
}
exports.tokensToFunction = tokensToFunction;
/**
 * Create path match function from `path-to-regexp` spec.
 */
function match(str, options) {
    var keys = [];
    var re = pathToRegexp(str, keys, options);
    return regexpToFunction(re, keys, options);
}
exports.match = match;
/**
 * Create a path match function from `path-to-regexp` output.
 */
function regexpToFunction(re, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;
    return function (pathname) {
        var m = re.exec(pathname);
        if (!m)
            return false;
        var path = m[0], index = m.index;
        var params = Object.create(null);
        var _loop_1 = function (i) {
            // tslint:disable-next-line
            if (m[i] === undefined)
                return "continue";
            var key = keys[i - 1];
            if (key.modifier === "*" || key.modifier === "+") {
                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {
                    return decode(value, key);
                });
            }
            else {
                params[key.name] = decode(m[i], key);
            }
        };
        for (var i = 1; i < m.length; i++) {
            _loop_1(i);
        }
        return { path: path, index: index, params: params };
    };
}
exports.regexpToFunction = regexpToFunction;
/**
 * Escape a regular expression string.
 */
function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
/**
 * Get the flags for a regexp from the options.
 */
function flags(options) {
    return options && options.sensitive ? "" : "i";
}
/**
 * Pull out keys from a regexp.
 */
function regexpToRegexp(path, keys) {
    if (!keys)
        return path;
    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g);
    if (groups) {
        for (var i = 0; i < groups.length; i++) {
            keys.push({
                name: i,
                prefix: "",
                suffix: "",
                modifier: "",
                pattern: ""
            });
        }
    }
    return path;
}
/**
 * Transform an array into a regexp.
 */
function arrayToRegexp(paths, keys, options) {
    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });
    return new RegExp("(?:" + parts.join("|") + ")", flags(options));
}
/**
 * Create a path regexp from string input.
 */
function stringToRegexp(path, keys, options) {
    return tokensToRegexp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 */
function tokensToRegexp(tokens, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;
    var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
    var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
    var route = start ? "^" : "";
    // Iterate over the tokens and create our regexp string.
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (typeof token === "string") {
            route += escapeString(encode(token));
        }
        else {
            var prefix = escapeString(encode(token.prefix));
            var suffix = escapeString(encode(token.suffix));
            if (token.pattern) {
                if (keys)
                    keys.push(token);
                if (prefix || suffix) {
                    if (token.modifier === "+" || token.modifier === "*") {
                        var mod = token.modifier === "*" ? "?" : "";
                        route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
                    }
                    else {
                        route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
                    }
                }
                else {
                    route += "(" + token.pattern + ")" + token.modifier;
                }
            }
            else {
                route += "(?:" + prefix + suffix + ")" + token.modifier;
            }
        }
    }
    if (end) {
        if (!strict)
            route += delimiter + "?";
        route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
    }
    else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string"
            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
            : // tslint:disable-next-line
                endToken === undefined;
        if (!strict) {
            route += "(?:" + delimiter + "(?=" + endsWith + "))?";
        }
        if (!isEndDelimited) {
            route += "(?=" + delimiter + "|" + endsWith + ")";
        }
    }
    return new RegExp(route, flags(options));
}
exports.tokensToRegexp = tokensToRegexp;
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 */
function pathToRegexp(path, keys, options) {
    if (path instanceof RegExp)
        return regexpToRegexp(path, keys);
    if (Array.isArray(path))
        return arrayToRegexp(path, keys, options);
    return stringToRegexp(path, keys, options);
}
exports.pathToRegexp = pathToRegexp;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/mitt.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/mitt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = mitt;
/*
MIT License
Copyright (c) Jason Miller (https://jasonformat.com/)
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// This file is based on https://github.com/developit/mitt/blob/v1.1.3/src/index.js
// It's been edited for the needs of this script
// See the LICENSE at the top of the file

function mitt() {
  var all = Object.create(null);
  return {
    on: function on(type, handler) {
      ;
      (all[type] || (all[type] = [])).push(handler);
    },
    off: function off(type, handler) {
      if (all[type]) {
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },
    emit: function emit(type) {
      for (var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        evts[_key - 1] = arguments[_key];
      }

      // eslint-disable-next-line array-callback-return
      ;
      (all[type] || []).slice().map(function (handler) {
        handler.apply(void 0, evts);
      });
    }
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router-context.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router-context.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.RouterContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var RouterContext = /*#__PURE__*/_react["default"].createContext(null);

exports.RouterContext = RouterContext;

if (true) {
  RouterContext.displayName = 'RouterContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/router.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js");

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/next/node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/next/node_modules/@babel/runtime/helpers/createClass.js");

exports.__esModule = true;
exports.addLocale = addLocale;
exports.delLocale = delLocale;
exports.hasBasePath = hasBasePath;
exports.addBasePath = addBasePath;
exports.delBasePath = delBasePath;
exports.isLocalURL = isLocalURL;
exports.interpolateAs = interpolateAs;
exports.resolveHref = resolveHref;
exports.markLoadingError = markLoadingError;
exports["default"] = void 0;

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

var _denormalizePagePath = __webpack_require__(/*! ../../server/denormalize-page-path */ "./node_modules/next/dist/next-server/server/denormalize-page-path.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var _querystring = __webpack_require__(/*! ./utils/querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _resolveRewrites = _interopRequireDefault(__webpack_require__(/*! ./utils/resolve-rewrites */ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js"));

var _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

var _escapePathDelimiters = _interopRequireDefault(__webpack_require__(/*! ./utils/escape-path-delimiters */ "./node_modules/next/dist/next-server/lib/router/utils/escape-path-delimiters.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/* global __NEXT_DATA__ */
// tslint:disable:no-console


var basePath =  false || '';

function buildCancellationError() {
  return Object.assign(new Error('Route Cancelled'), {
    cancelled: true
  });
}

function addPathPrefix(path, prefix) {
  return prefix && path.startsWith('/') ? path === '/' ? (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(prefix) : "".concat(prefix).concat(path) : path;
}

function addLocale(path, locale, defaultLocale) {
  if (false) {}

  return path;
}

function delLocale(path, locale) {
  if (false) {}

  return path;
}

function hasBasePath(path) {
  return path === basePath || path.startsWith(basePath + '/');
}

function addBasePath(path) {
  // we only add the basepath on relative urls
  return addPathPrefix(path, basePath);
}

function delBasePath(path) {
  return path.slice(basePath.length) || '/';
}
/**
* Detects whether a given url is routable by the Next.js router (browser only).
*/


function isLocalURL(url) {
  if (url.startsWith('/')) return true;

  try {
    // absolute urls can be local if they are on the same origin
    var locationOrigin = (0, _utils.getLocationOrigin)();
    var resolved = new URL(url, locationOrigin);
    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);
  } catch (_) {
    return false;
  }
}

function interpolateAs(route, asPathname, query) {
  var interpolatedRoute = '';
  var dynamicRegex = (0, _routeRegex.getRouteRegex)(route);
  var dynamicGroups = dynamicRegex.groups;
  var dynamicMatches = // Try to match the dynamic route against the asPath
  (asPathname !== route ? (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href
  // TODO: should this take priority; also need to change in the router.
  query;
  interpolatedRoute = route;
  var params = Object.keys(dynamicGroups);

  if (!params.every(function (param) {
    var value = dynamicMatches[param] || '';
    var _dynamicGroups$param = dynamicGroups[param],
        repeat = _dynamicGroups$param.repeat,
        optional = _dynamicGroups$param.optional; // support single-level catch-all
    // TODO: more robust handling for user-error (passing `/`)

    var replaced = "[".concat(repeat ? '...' : '').concat(param, "]");

    if (optional) {
      replaced = "".concat(!value ? '/' : '', "[").concat(replaced, "]");
    }

    if (repeat && !Array.isArray(value)) value = [value];
    return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present
    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(_escapePathDelimiters["default"]).join('/') : (0, _escapePathDelimiters["default"])(value)) || '/');
  })) {
    interpolatedRoute = ''; // did not satisfy all requirements
    // n.b. We ignore this error because we handle warning for this case in
    // development in the `<Link>` component directly.
  }

  return {
    params: params,
    result: interpolatedRoute
  };
}

function omitParmsFromQuery(query, params) {
  var filteredQuery = {};
  Object.keys(query).forEach(function (key) {
    if (!params.includes(key)) {
      filteredQuery[key] = query[key];
    }
  });
  return filteredQuery;
}
/**
* Resolves a given hyperlink with a certain router state (basePath not included).
* Preserves absolute urls.
*/


function resolveHref(currentPath, href, resolveAs) {
  // we use a dummy base url for relative urls
  var base = new URL(currentPath, 'http://n');
  var urlAsString = typeof href === 'string' ? href : (0, _utils.formatWithValidation)(href);

  try {
    var finalUrl = new URL(urlAsString, base);
    finalUrl.pathname = (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(finalUrl.pathname);
    var interpolatedAs = '';

    if ((0, _isDynamic.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
      var query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);

      var _interpolateAs = interpolateAs(finalUrl.pathname, finalUrl.pathname, query),
          result = _interpolateAs.result,
          params = _interpolateAs.params;

      if (result) {
        interpolatedAs = (0, _utils.formatWithValidation)({
          pathname: result,
          hash: finalUrl.hash,
          query: omitParmsFromQuery(query, params)
        });
      }
    } // if the origin didn't change, it means we received a relative href


    var resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;
  } catch (_) {
    return resolveAs ? [urlAsString] : urlAsString;
  }
}

var PAGE_LOAD_ERROR = Symbol('PAGE_LOAD_ERROR');

function markLoadingError(err) {
  return Object.defineProperty(err, PAGE_LOAD_ERROR, {});
}

function prepareUrlAs(router, url, as) {
  // If url and as provided as an object representation,
  // we'll format them into the string version here.
  return {
    url: addBasePath(resolveHref(router.pathname, url)),
    as: as ? addBasePath(resolveHref(router.pathname, as)) : as
  };
}

var manualScrollRestoration =  false && false;
var SSG_DATA_NOT_FOUND_ERROR = 'SSG Data NOT_FOUND';

function fetchRetry(url, attempts) {
  return fetch(url, {
    // Cookies are required to be present for Next.js' SSG "Preview Mode".
    // Cookies may also be required for `getServerSideProps`.
    //
    // > `fetch` won’t send cookies, unless you set the credentials init
    // > option.
    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
    //
    // > For maximum browser compatibility when it comes to sending &
    // > receiving cookies, always supply the `credentials: 'same-origin'`
    // > option instead of relying on the default.
    // https://github.com/github/fetch#caveats
    credentials: 'same-origin'
  }).then(function (res) {
    if (!res.ok) {
      if (attempts > 1 && res.status >= 500) {
        return fetchRetry(url, attempts - 1);
      }

      if (res.status === 404) {
        // TODO: handle reloading in development from fallback returning 200
        // to on-demand-entry-handler causing it to reload periodically
        throw new Error(SSG_DATA_NOT_FOUND_ERROR);
      }

      throw new Error("Failed to load static props");
    }

    return res.json();
  });
}

function fetchNextData(dataHref, isServerRender) {
  return fetchRetry(dataHref, isServerRender ? 3 : 1)["catch"](function (err) {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      markLoadingError(err);
    }

    throw err;
  });
}

var Router = /*#__PURE__*/function () {
  /**
  * Map of all components loaded in `Router`
  */
  // Static Data Cache
  function Router(_pathname, _query, _as, _ref) {
    var _this = this;

    var initialProps = _ref.initialProps,
        pageLoader = _ref.pageLoader,
        App = _ref.App,
        wrapApp = _ref.wrapApp,
        Component = _ref.Component,
        initialStyleSheets = _ref.initialStyleSheets,
        err = _ref.err,
        subscription = _ref.subscription,
        isFallback = _ref.isFallback,
        locale = _ref.locale,
        locales = _ref.locales,
        defaultLocale = _ref.defaultLocale;

    _classCallCheck(this, Router);

    this.route = void 0;
    this.pathname = void 0;
    this.query = void 0;
    this.asPath = void 0;
    this.basePath = void 0;
    this.components = void 0;
    this.sdc = {};
    this.sub = void 0;
    this.clc = void 0;
    this.pageLoader = void 0;
    this._bps = void 0;
    this.events = void 0;
    this._wrapApp = void 0;
    this.isSsr = void 0;
    this.isFallback = void 0;
    this._inFlightRoute = void 0;
    this._shallow = void 0;
    this.locale = void 0;
    this.locales = void 0;
    this.defaultLocale = void 0;

    this.onPopState = function (e) {
      var state = e.state;

      if (!state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        var _pathname2 = _this.pathname,
            query = _this.query;

        _this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname2),
          query: query
        }), (0, _utils.getURL)());

        return;
      }

      if (!state.__N) {
        return;
      }

      var url = state.url,
          as = state.as,
          options = state.options;

      var _ref2 = (0, _parseRelativeUrl.parseRelativeUrl)(url),
          pathname = _ref2.pathname; // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site


      if (_this.isSsr && as === _this.asPath && pathname === _this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (_this._bps && !_this._bps(state)) {
        return;
      }

      _this.change('replaceState', url, as, Object.assign({}, options, {
        shallow: options.shallow && _this._shallow,
        locale: options.locale || _this.defaultLocale
      }));
    }; // represents the current component key


    this.route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(_pathname); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (_pathname !== '/_error') {
      this.components[this.route] = {
        Component: Component,
        styleSheets: initialStyleSheets,
        props: initialProps,
        err: err,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components['/_app'] = {
      Component: App,
      styleSheets: [
        /* /_app does not need its stylesheets managed */
      ]
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = _pathname;
    this.query = _query; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    this.asPath = // @ts-ignore this is temporarily global (attached to window)
    (0, _isDynamic.isDynamicRoute)(_pathname) && __NEXT_DATA__.autoExport ? _pathname : _as;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;

    if (false) {}

    if (true) {
      // make sure "as" doesn't start with double slashes or else it can
      // throw an error as it's considered invalid
      if (_as.substr(0, 2) !== '//') {
        // in order for `e.state` to work on the `onpopstate` event
        // we have to register the initial route upon initialization
        this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname),
          query: _query
        }), (0, _utils.getURL)());
      }

      window.addEventListener('popstate', this.onPopState); // enable custom scroll restoration handling when available
      // otherwise fallback to browser's default handling

      if (false) { var debouncedScrollSave, scrollDebounceTimeout; }
    }
  }

  _createClass(Router, [{
    key: "reload",
    value: function reload() {
      window.location.reload();
    }
    /**
    * Go back in history
    */

  }, {
    key: "back",
    value: function back() {
      window.history.back();
    }
    /**
    * Performs a `pushState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "push",
    value: function push(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      ;

      var _prepareUrlAs = prepareUrlAs(this, url, as);

      url = _prepareUrlAs.url;
      as = _prepareUrlAs.as;
      return this.change('pushState', url, as, options);
    }
    /**
    * Performs a `replaceState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "replace",
    value: function replace(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      ;

      var _prepareUrlAs2 = prepareUrlAs(this, url, as);

      url = _prepareUrlAs2.url;
      as = _prepareUrlAs2.as;
      return this.change('replaceState', url, as, options);
    }
  }, {
    key: "change",
    value: function () {
      var _change = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(method, url, as, options) {
        var _this2 = this;

        var _require, normalizeLocalePath, localePathResult, cleanedAs, pages, _yield$this$pageLoade, rewrites, parsed, _parsed, pathname, query, route, _options$shallow, shallow, resolvedAs, potentialHref, parsedAs, asPathname, routeRegex, routeMatch, shouldInterpolate, interpolatedAs, missingParams, routeInfo, error, props, __N_SSG, __N_SSP, destination, parsedHref, appComp;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (isLocalURL(url)) {
                  _context.next = 3;
                  break;
                }

                window.location.href = url;
                return _context.abrupt("return", false);

              case 3:
                if (false) {}

                if (!options._h) {
                  this.isSsr = false;
                } // marking route changes as a navigation start entry


                if (_utils.ST) {
                  performance.mark('routeChange');
                }

                if (this._inFlightRoute) {
                  this.abortComponentLoad(this._inFlightRoute);
                }

                as = addLocale(as, options.locale, this.defaultLocale);
                cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);
                this._inFlightRoute = as; // If the url change is only related to a hash change
                // We should not proceed. We should only change the state.
                // WARNING: `_h` is an internal option for handing Next.js client-side
                // hydration. Your app should _never_ use this property. It may change at
                // any time without notice.

                if (!(!options._h && this.onlyAHashChange(cleanedAs))) {
                  _context.next = 18;
                  break;
                }

                this.asPath = cleanedAs;
                Router.events.emit('hashChangeStart', as); // TODO: do we need the resolved href when only a hash change?

                this.changeState(method, url, as, options);
                this.scrollToHash(cleanedAs);
                this.notify(this.components[this.route]);
                Router.events.emit('hashChangeComplete', as);
                return _context.abrupt("return", true);

              case 18:
                _context.next = 20;
                return this.pageLoader.getPageList();

              case 20:
                pages = _context.sent;
                _context.next = 23;
                return this.pageLoader.promisedBuildManifest;

              case 23:
                _yield$this$pageLoade = _context.sent;
                rewrites = _yield$this$pageLoade.__rewrites;
                parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
                _parsed = parsed, pathname = _parsed.pathname, query = _parsed.query;
                parsed = this._resolveHref(parsed, pages);

                if (parsed.pathname !== pathname) {
                  pathname = parsed.pathname;
                  url = (0, _utils.formatWithValidation)(parsed);
                } // url and as should always be prefixed with basePath by this
                // point by either next/link or router.push/replace so strip the
                // basePath from the pathname to match the pages dir 1-to-1


                pathname = pathname ? (0, _normalizeTrailingSlash.removePathTrailingSlash)(delBasePath(pathname)) : pathname; // If asked to change the current URL we should reload the current page
                // (not location.reload() but reload getInitialProps and other Next.js stuffs)
                // We also need to set the method = replaceState always
                // as this should not go into the history (That's how browsers work)
                // We should compare the new asPath to the current asPath, not the url

                if (!this.urlIsNew(cleanedAs)) {
                  method = 'replaceState';
                }

                route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);
                _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow; // we need to resolve the as value using rewrites for dynamic SSG
                // pages to allow building the data URL correctly

                resolvedAs = as;

                if (true) {
                  resolvedAs = (0, _resolveRewrites["default"])((0, _parseRelativeUrl.parseRelativeUrl)(as).pathname, pages, basePath, rewrites, query, function (p) {
                    return _this2._resolveHref({
                      pathname: p
                    }, pages).pathname;
                  });

                  if (resolvedAs !== as) {
                    potentialHref = (0, _normalizeTrailingSlash.removePathTrailingSlash)(this._resolveHref(Object.assign({}, parsed, {
                      pathname: resolvedAs
                    }), pages, false).pathname); // if this directly matches a page we need to update the href to
                    // allow the correct page chunk to be loaded

                    if (pages.includes(potentialHref)) {
                      route = potentialHref;
                      pathname = potentialHref;
                      parsed.pathname = pathname;
                      url = (0, _utils.formatWithValidation)(parsed);
                    }
                  }
                }

                resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);

                if (!(0, _isDynamic.isDynamicRoute)(route)) {
                  _context.next = 51;
                  break;
                }

                parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(resolvedAs);
                asPathname = parsedAs.pathname;
                routeRegex = (0, _routeRegex.getRouteRegex)(route);
                routeMatch = (0, _routeMatcher.getRouteMatcher)(routeRegex)(asPathname);
                shouldInterpolate = route === asPathname;
                interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};

                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {
                  _context.next = 50;
                  break;
                }

                missingParams = Object.keys(routeRegex.groups).filter(function (param) {
                  return !query[param];
                });

                if (!(missingParams.length > 0)) {
                  _context.next = 48;
                  break;
                }

                if (true) {
                  console.warn("".concat(shouldInterpolate ? "Interpolating href" : "Mismatching `as` and `href`", " failed to manually provide ") + "the params: ".concat(missingParams.join(', '), " in the `href`'s `query`"));
                }

                throw new Error((shouldInterpolate ? "The provided `href` (".concat(url, ") value is missing query values (").concat(missingParams.join(', '), ") to be interpolated properly. ") : "The provided `as` value (".concat(asPathname, ") is incompatible with the `href` value (").concat(route, "). ")) + "Read more: https://err.sh/vercel/next.js/".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));

              case 48:
                _context.next = 51;
                break;

              case 50:
                if (shouldInterpolate) {
                  as = (0, _utils.formatWithValidation)(Object.assign({}, parsedAs, {
                    pathname: interpolatedAs.result,
                    query: omitParmsFromQuery(query, interpolatedAs.params)
                  }));
                } else {
                  // Merge params into `query`, overwriting any specified in search
                  Object.assign(query, routeMatch);
                }

              case 51:
                Router.events.emit('routeChangeStart', as);
                _context.prev = 52;
                _context.next = 55;
                return this.getRouteInfo(route, pathname, query, as, shallow);

              case 55:
                routeInfo = _context.sent;
                error = routeInfo.error, props = routeInfo.props, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP; // handle redirect on client-transition

                if (!((__N_SSG || __N_SSP) && props && props.pageProps && props.pageProps.__N_REDIRECT)) {
                  _context.next = 66;
                  break;
                }

                destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt
                // client-navigation if it is falling back to hard navigation if
                // it's not

                if (!destination.startsWith('/')) {
                  _context.next = 64;
                  break;
                }

                parsedHref = (0, _parseRelativeUrl.parseRelativeUrl)(destination);

                this._resolveHref(parsedHref, pages);

                if (!pages.includes(parsedHref.pathname)) {
                  _context.next = 64;
                  break;
                }

                return _context.abrupt("return", this.change(method, destination, destination, options));

              case 64:
                window.location.href = destination;
                return _context.abrupt("return", new Promise(function () {}));

              case 66:
                Router.events.emit('beforeHistoryChange', as);
                this.changeState(method, url, addLocale(as, options.locale, this.defaultLocale), options);

                if (true) {
                  appComp = this.components['/_app'].Component;
                  window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;
                }

                _context.next = 71;
                return this.set(route, pathname, query, cleanedAs, routeInfo)["catch"](function (e) {
                  if (e.cancelled) error = error || e;else throw e;
                });

              case 71:
                if (!error) {
                  _context.next = 74;
                  break;
                }

                Router.events.emit('routeChangeError', error, cleanedAs);
                throw error;

              case 74:
                if (false) {}

                Router.events.emit('routeChangeComplete', as);
                return _context.abrupt("return", true);

              case 79:
                _context.prev = 79;
                _context.t0 = _context["catch"](52);

                if (!_context.t0.cancelled) {
                  _context.next = 83;
                  break;
                }

                return _context.abrupt("return", false);

              case 83:
                throw _context.t0;

              case 84:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[52, 79]]);
      }));

      function change(_x, _x2, _x3, _x4) {
        return _change.apply(this, arguments);
      }

      return change;
    }()
  }, {
    key: "changeState",
    value: function changeState(method, url, as) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (true) {
        if (typeof window.history === 'undefined') {
          console.error("Warning: window.history is not available.");
          return;
        }

        if (typeof window.history[method] === 'undefined') {
          console.error("Warning: window.history.".concat(method, " is not available"));
          return;
        }
      }

      if (method !== 'pushState' || (0, _utils.getURL)() !== as) {
        this._shallow = options.shallow;
        window.history[method]({
          url: url,
          as: as,
          options: options,
          __N: true
        }, // Most browsers currently ignores this parameter, although they may use it in the future.
        // Passing the empty string here should be safe against future changes to the method.
        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
        '', as);
      }
    }
  }, {
    key: "handleRouteInfoError",
    value: function () {
      var _handleRouteInfoError = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(err, pathname, query, as, loadErrorFail) {
        var Component, styleSheets, props, ssg404, mod, _yield$this$fetchComp, _yield$this$fetchComp2, routeInfo;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!err.cancelled) {
                  _context2.next = 2;
                  break;
                }

                throw err;

              case 2:
                if (!(PAGE_LOAD_ERROR in err || loadErrorFail)) {
                  _context2.next = 6;
                  break;
                }

                Router.events.emit('routeChangeError', err, as); // If we can't load the page it could be one of following reasons
                //  1. Page doesn't exists
                //  2. Page does exist in a different zone
                //  3. Internal error while loading the page
                // So, doing a hard reload is the proper way to deal with this.

                window.location.href = as; // Changing the URL doesn't block executing the current code path.
                // So let's throw a cancellation error stop the routing logic.

                throw buildCancellationError();

              case 6:
                _context2.prev = 6;
                ssg404 = err.message === SSG_DATA_NOT_FOUND_ERROR;

                if (!ssg404) {
                  _context2.next = 24;
                  break;
                }

                _context2.prev = 9;
                _context2.next = 12;
                return this.fetchComponent('/404');

              case 12:
                _yield$this$fetchComp = _context2.sent;
                Component = _yield$this$fetchComp.page;
                styleSheets = _yield$this$fetchComp.styleSheets;
                mod = _yield$this$fetchComp.mod;

                if (!(mod && mod.__N_SSG)) {
                  _context2.next = 20;
                  break;
                }

                _context2.next = 19;
                return this._getStaticData(this.pageLoader.getDataHref('/404', '/404', true, this.locale));

              case 19:
                props = _context2.sent;

              case 20:
                _context2.next = 24;
                break;

              case 22:
                _context2.prev = 22;
                _context2.t0 = _context2["catch"](9);

              case 24:
                if (!(typeof Component === 'undefined' || typeof styleSheets === 'undefined')) {
                  _context2.next = 31;
                  break;
                }

                ;
                _context2.next = 28;
                return this.fetchComponent('/_error');

              case 28:
                _yield$this$fetchComp2 = _context2.sent;
                Component = _yield$this$fetchComp2.page;
                styleSheets = _yield$this$fetchComp2.styleSheets;

              case 31:
                routeInfo = {
                  props: props,
                  Component: Component,
                  styleSheets: styleSheets,
                  err: ssg404 ? undefined : err,
                  error: ssg404 ? undefined : err
                };

                if (routeInfo.props) {
                  _context2.next = 43;
                  break;
                }

                _context2.prev = 33;
                _context2.next = 36;
                return this.getInitialProps(Component, {
                  err: err,
                  pathname: pathname,
                  query: query
                });

              case 36:
                routeInfo.props = _context2.sent;
                _context2.next = 43;
                break;

              case 39:
                _context2.prev = 39;
                _context2.t1 = _context2["catch"](33);
                console.error('Error in error page `getInitialProps`: ', _context2.t1);
                routeInfo.props = {};

              case 43:
                return _context2.abrupt("return", routeInfo);

              case 46:
                _context2.prev = 46;
                _context2.t2 = _context2["catch"](6);
                return _context2.abrupt("return", this.handleRouteInfoError(_context2.t2, pathname, query, as, true));

              case 49:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 46], [9, 22], [33, 39]]);
      }));

      function handleRouteInfoError(_x5, _x6, _x7, _x8, _x9) {
        return _handleRouteInfoError.apply(this, arguments);
      }

      return handleRouteInfoError;
    }()
  }, {
    key: "getRouteInfo",
    value: function () {
      var _getRouteInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(route, pathname, query, as) {
        var _this3 = this;

        var shallow,
            cachedRouteInfo,
            routeInfo,
            Component,
            __N_SSG,
            __N_SSP,
            _require2,
            isValidElementType,
            dataHref,
            props,
            _args3 = arguments;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                shallow = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : false;
                _context3.prev = 1;
                cachedRouteInfo = this.components[route];

                if (!(shallow && cachedRouteInfo && this.route === route)) {
                  _context3.next = 5;
                  break;
                }

                return _context3.abrupt("return", cachedRouteInfo);

              case 5:
                if (!cachedRouteInfo) {
                  _context3.next = 9;
                  break;
                }

                _context3.t0 = cachedRouteInfo;
                _context3.next = 12;
                break;

              case 9:
                _context3.next = 11;
                return this.fetchComponent(route).then(function (res) {
                  return {
                    Component: res.page,
                    styleSheets: res.styleSheets,
                    __N_SSG: res.mod.__N_SSG,
                    __N_SSP: res.mod.__N_SSP
                  };
                });

              case 11:
                _context3.t0 = _context3.sent;

              case 12:
                routeInfo = _context3.t0;
                Component = routeInfo.Component, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP;

                if (false) {}

                _require2 = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js"), isValidElementType = _require2.isValidElementType;

                if (isValidElementType(Component)) {
                  _context3.next = 18;
                  break;
                }

                throw new Error("The default export is not a React Component in page: \"".concat(pathname, "\""));

              case 18:
                if (__N_SSG || __N_SSP) {
                  dataHref = this.pageLoader.getDataHref((0, _utils.formatWithValidation)({
                    pathname: pathname,
                    query: query
                  }), delBasePath(as), __N_SSG, this.locale);
                }

                _context3.next = 21;
                return this._getData(function () {
                  return __N_SSG ? _this3._getStaticData(dataHref) : __N_SSP ? _this3._getServerData(dataHref) : _this3.getInitialProps(Component, // we provide AppTree later so this needs to be `any`
                  {
                    pathname: pathname,
                    query: query,
                    asPath: as
                  });
                });

              case 21:
                props = _context3.sent;
                routeInfo.props = props;
                this.components[route] = routeInfo;
                return _context3.abrupt("return", routeInfo);

              case 27:
                _context3.prev = 27;
                _context3.t1 = _context3["catch"](1);
                return _context3.abrupt("return", this.handleRouteInfoError(_context3.t1, pathname, query, as));

              case 30:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[1, 27]]);
      }));

      function getRouteInfo(_x10, _x11, _x12, _x13) {
        return _getRouteInfo.apply(this, arguments);
      }

      return getRouteInfo;
    }()
  }, {
    key: "set",
    value: function set(route, pathname, query, as, data) {
      this.isFallback = false;
      this.route = route;
      this.pathname = pathname;
      this.query = query;
      this.asPath = as;
      return this.notify(data);
    }
    /**
    * Callback to execute before replacing router state
    * @param cb callback to be executed
    */

  }, {
    key: "beforePopState",
    value: function beforePopState(cb) {
      this._bps = cb;
    }
  }, {
    key: "onlyAHashChange",
    value: function onlyAHashChange(as) {
      if (!this.asPath) return false;

      var _this$asPath$split = this.asPath.split('#'),
          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),
          oldUrlNoHash = _this$asPath$split2[0],
          oldHash = _this$asPath$split2[1];

      var _as$split = as.split('#'),
          _as$split2 = _slicedToArray(_as$split, 2),
          newUrlNoHash = _as$split2[0],
          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same


      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
        return true;
      } // If the urls are change, there's more than a hash change


      if (oldUrlNoHash !== newUrlNoHash) {
        return false;
      } // If the hash has changed, then it's a hash only change.
      // This check is necessary to handle both the enter and
      // leave hash === '' cases. The identity case falls through
      // and is treated as a next reload.


      return oldHash !== newHash;
    }
  }, {
    key: "scrollToHash",
    value: function scrollToHash(as) {
      var _as$split3 = as.split('#'),
          _as$split4 = _slicedToArray(_as$split3, 2),
          hash = _as$split4[1]; // Scroll to top if the hash is just `#` with no value


      if (hash === '') {
        window.scrollTo(0, 0);
        return;
      } // First we check if the element by id is found


      var idEl = document.getElementById(hash);

      if (idEl) {
        idEl.scrollIntoView();
        return;
      } // If there's no element with the id, we check the `name` property
      // To mirror browsers


      var nameEl = document.getElementsByName(hash)[0];

      if (nameEl) {
        nameEl.scrollIntoView();
      }
    }
  }, {
    key: "urlIsNew",
    value: function urlIsNew(asPath) {
      return this.asPath !== asPath;
    }
  }, {
    key: "_resolveHref",
    value: function _resolveHref(parsedHref, pages) {
      var applyBasePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var pathname = parsedHref.pathname;
      var cleanPathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)((0, _denormalizePagePath.denormalizePagePath)(applyBasePath ? delBasePath(pathname) : pathname));

      if (cleanPathname === '/404' || cleanPathname === '/_error') {
        return parsedHref;
      } // handle resolving href for dynamic routes


      if (!pages.includes(cleanPathname)) {
        // eslint-disable-next-line array-callback-return
        pages.some(function (page) {
          if ((0, _isDynamic.isDynamicRoute)(page) && (0, _routeRegex.getRouteRegex)(page).re.test(cleanPathname)) {
            parsedHref.pathname = applyBasePath ? addBasePath(page) : page;
            return true;
          }
        });
      }

      return parsedHref;
    }
    /**
    * Prefetch page code, you may wait for the data during page rendering.
    * This feature only works in production!
    * @param url the href of prefetched page
    * @param asPath the as path of the prefetched page
    */

  }, {
    key: "prefetch",
    value: function () {
      var _prefetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(url) {
        var asPath,
            options,
            parsed,
            _parsed2,
            pathname,
            pages,
            route,
            _args4 = arguments;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                asPath = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : url;
                options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
                parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
                _parsed2 = parsed, pathname = _parsed2.pathname;
                _context4.next = 6;
                return this.pageLoader.getPageList();

              case 6:
                pages = _context4.sent;
                parsed = this._resolveHref(parsed, pages);

                if (parsed.pathname !== pathname) {
                  pathname = parsed.pathname;
                  url = (0, _utils.formatWithValidation)(parsed);
                } // Prefetch is not supported in development mode because it would trigger on-demand-entries


                if (false) {}

                return _context4.abrupt("return");

              case 11:
                route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);
                _context4.next = 14;
                return Promise.all([this.pageLoader.prefetchData(url, asPath, this.locale, this.defaultLocale), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);

              case 14:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function prefetch(_x14) {
        return _prefetch.apply(this, arguments);
      }

      return prefetch;
    }()
  }, {
    key: "fetchComponent",
    value: function () {
      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(route) {
        var cancelled, cancel, componentResult, error;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                cancelled = false;

                cancel = this.clc = function () {
                  cancelled = true;
                };

                _context5.next = 4;
                return this.pageLoader.loadPage(route);

              case 4:
                componentResult = _context5.sent;

                if (!cancelled) {
                  _context5.next = 9;
                  break;
                }

                error = new Error("Abort fetching component for route: \"".concat(route, "\""));
                error.cancelled = true;
                throw error;

              case 9:
                if (cancel === this.clc) {
                  this.clc = null;
                }

                return _context5.abrupt("return", componentResult);

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function fetchComponent(_x15) {
        return _fetchComponent.apply(this, arguments);
      }

      return fetchComponent;
    }()
  }, {
    key: "_getData",
    value: function _getData(fn) {
      var _this4 = this;

      var cancelled = false;

      var cancel = function cancel() {
        cancelled = true;
      };

      this.clc = cancel;
      return fn().then(function (data) {
        if (cancel === _this4.clc) {
          _this4.clc = null;
        }

        if (cancelled) {
          var err = new Error('Loading initial props cancelled');
          err.cancelled = true;
          throw err;
        }

        return data;
      });
    }
  }, {
    key: "_getStaticData",
    value: function _getStaticData(dataHref) {
      var _this5 = this;

      var _URL = new URL(dataHref, window.location.href),
          cacheKey = _URL.href;

      if (false) {}

      return fetchNextData(dataHref, this.isSsr).then(function (data) {
        _this5.sdc[cacheKey] = data;
        return data;
      });
    }
  }, {
    key: "_getServerData",
    value: function _getServerData(dataHref) {
      return fetchNextData(dataHref, this.isSsr);
    }
  }, {
    key: "getInitialProps",
    value: function getInitialProps(Component, ctx) {
      var App = this.components['/_app'].Component;

      var AppTree = this._wrapApp(App);

      ctx.AppTree = AppTree;
      return (0, _utils.loadGetInitialProps)(App, {
        AppTree: AppTree,
        Component: Component,
        router: this,
        ctx: ctx
      });
    }
  }, {
    key: "abortComponentLoad",
    value: function abortComponentLoad(as) {
      if (this.clc) {
        Router.events.emit('routeChangeError', buildCancellationError(), as);
        this.clc();
        this.clc = null;
      }
    }
  }, {
    key: "notify",
    value: function notify(data) {
      return this.sub(data, this.components['/_app'].Component);
    }
  }]);

  return Router;
}();

exports["default"] = Router;
Router.events = (0, _mitt["default"])();

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/escape-path-delimiters.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/escape-path-delimiters.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = escapePathDelimiters; // escape delimiters used by path-to-regexp

function escapePathDelimiters(segment) {
  return segment.replace(/[/#?]/g, function (_char) {
    return encodeURIComponent(_char);
  });
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/format-url.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.formatUrl = formatUrl;

var querystring = _interopRequireWildcard(__webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
} // Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var slashedProtocols = /https?|ftp|gopher|file/;

function formatUrl(urlObj) {
  var auth = urlObj.auth,
      hostname = urlObj.hostname;
  var protocol = urlObj.protocol || '';
  var pathname = urlObj.pathname || '';
  var hash = urlObj.hash || '';
  var query = urlObj.query || '';
  var host = false;
  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';

  if (urlObj.host) {
    host = auth + urlObj.host;
  } else if (hostname) {
    host = auth + (~hostname.indexOf(':') ? "[".concat(hostname, "]") : hostname);

    if (urlObj.port) {
      host += ':' + urlObj.port;
    }
  }

  if (query && typeof query === 'object') {
    query = String(querystring.urlQueryToSearchParams(query));
  }

  var search = urlObj.search || query && "?".concat(query) || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash[0] !== '#') hash = '#' + hash;
  if (search && search[0] !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, encodeURIComponent);
  search = search.replace('#', '%23');
  return "".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.isDynamicRoute = isDynamicRoute; // Identify /[param]/ in route string

var TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;

function isDynamicRoute(route) {
  return TEST_ROUTE.test(route);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.parseRelativeUrl = parseRelativeUrl;

var _utils = __webpack_require__(/*! ../../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _querystring = __webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var DUMMY_BASE = new URL(false ? undefined : (0, _utils.getLocationOrigin)());
/**
* Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative
* (e.g. `./hello`) then at least base must be.
* Absolute urls are rejected with one exception, in the browser, absolute urls that are on
* the current origin will be parsed as relative
*/

function parseRelativeUrl(url, base) {
  var resolvedBase = base ? new URL(base, DUMMY_BASE) : DUMMY_BASE;

  var _URL = new URL(url, resolvedBase),
      pathname = _URL.pathname,
      searchParams = _URL.searchParams,
      search = _URL.search,
      hash = _URL.hash,
      href = _URL.href,
      origin = _URL.origin,
      protocol = _URL.protocol;

  if (origin !== DUMMY_BASE.origin || protocol !== 'http:' && protocol !== 'https:') {
    throw new Error('invariant: invalid relative URL');
  }

  return {
    pathname: pathname,
    query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
    search: search,
    hash: hash,
    href: href.slice(DUMMY_BASE.origin.length)
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/path-match.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/path-match.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty.js");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

exports.__esModule = true;
exports.pathToRegexp = exports["default"] = exports.customRouteMatcherOptions = exports.matcherOptions = void 0;

var pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ "./node_modules/next/dist/compiled/path-to-regexp/index.js"));

exports.pathToRegexp = pathToRegexp;

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var matcherOptions = {
  sensitive: false,
  delimiter: '/'
};
exports.matcherOptions = matcherOptions;

var customRouteMatcherOptions = _objectSpread(_objectSpread({}, matcherOptions), {}, {
  strict: true
});

exports.customRouteMatcherOptions = customRouteMatcherOptions;

var _default = function _default() {
  var customRoute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  return function (path) {
    var keys = [];
    var matcherRegex = pathToRegexp.pathToRegexp(path, keys, customRoute ? customRouteMatcherOptions : matcherOptions);
    var matcher = pathToRegexp.regexpToFunction(matcherRegex, keys);
    return function (pathname, params) {
      var res = pathname == null ? false : matcher(pathname);

      if (!res) {
        return false;
      }

      if (customRoute) {
        var _iterator = _createForOfIteratorHelper(keys),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var key = _step.value;

            // unnamed params should be removed as they
            // are not allowed to be used in the destination
            if (typeof key.name === 'number') {
              delete res.params[key.name];
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return _objectSpread(_objectSpread({}, params), res.params);
    };
  };
};

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

exports.__esModule = true;
exports["default"] = prepareDestination;

var _querystring = __webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _parseRelativeUrl = __webpack_require__(/*! ./parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ "./node_modules/next/dist/compiled/path-to-regexp/index.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function prepareDestination(destination, params, query, appendParamsToQuery, basePath) {
  var parsedDestination = {};

  if (destination.startsWith('/')) {
    parsedDestination = (0, _parseRelativeUrl.parseRelativeUrl)(destination);
  } else {
    var _URL = new URL(destination),
        pathname = _URL.pathname,
        searchParams = _URL.searchParams,
        hash = _URL.hash,
        hostname = _URL.hostname,
        port = _URL.port,
        protocol = _URL.protocol,
        search = _URL.search,
        href = _URL.href;

    parsedDestination = {
      pathname: pathname,
      query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
      hash: hash,
      protocol: protocol,
      hostname: hostname,
      port: port,
      search: search,
      href: href
    };
  }

  var destQuery = parsedDestination.query;
  var destPath = "".concat(parsedDestination.pathname).concat(parsedDestination.hash || '');
  var destPathParamKeys = [];
  pathToRegexp.pathToRegexp(destPath, destPathParamKeys);
  var destPathParams = destPathParamKeys.map(function (key) {
    return key.name;
  });
  var destinationCompiler = pathToRegexp.compile(destPath, // we don't validate while compiling the destination since we should
  // have already validated before we got to this point and validating
  // breaks compiling destinations with named pattern params from the source
  // e.g. /something:hello(.*) -> /another/:hello is broken with validation
  // since compile validation is meant for reversing and not for inserting
  // params from a separate path-regex into another
  {
    validate: false
  });
  var newUrl; // update any params in query values

  for (var _i = 0, _Object$entries = Object.entries(destQuery); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        key = _Object$entries$_i[0],
        strOrArray = _Object$entries$_i[1];

    var value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray;

    if (value) {
      // the value needs to start with a forward-slash to be compiled
      // correctly
      value = "/".concat(value);
      var queryCompiler = pathToRegexp.compile(value, {
        validate: false
      });
      value = queryCompiler(params).substr(1);
    }

    destQuery[key] = value;
  } // add path params to query if it's not a redirect and not
  // already defined in destination query or path


  var paramKeys = Object.keys(params);

  if (appendParamsToQuery && !paramKeys.some(function (key) {
    return destPathParams.includes(key);
  })) {
    var _iterator = _createForOfIteratorHelper(paramKeys),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _key = _step.value;

        if (!(_key in destQuery)) {
          destQuery[_key] = params[_key];
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  var shouldAddBasePath = destination.startsWith('/') && basePath;

  try {
    newUrl = "".concat(shouldAddBasePath ? basePath : '').concat(destinationCompiler(params));

    var _newUrl$split = newUrl.split('#'),
        _newUrl$split2 = _slicedToArray(_newUrl$split, 2),
        _pathname = _newUrl$split2[0],
        _hash = _newUrl$split2[1];

    parsedDestination.pathname = _pathname;
    parsedDestination.hash = "".concat(_hash ? '#' : '').concat(_hash || '');
    delete parsedDestination.search;
  } catch (err) {
    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {
      throw new Error("To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match");
    }

    throw err;
  } // Query merge order lowest priority to highest
  // 1. initial URL query values
  // 2. path segment values
  // 3. destination specified query values


  parsedDestination.query = _objectSpread(_objectSpread({}, query), parsedDestination.query);
  return {
    newUrl: newUrl,
    parsedDestination: parsedDestination
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/querystring.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js");

exports.__esModule = true;
exports.searchParamsToUrlQuery = searchParamsToUrlQuery;
exports.urlQueryToSearchParams = urlQueryToSearchParams;
exports.assign = assign;

function searchParamsToUrlQuery(searchParams) {
  var query = {};
  searchParams.forEach(function (value, key) {
    if (typeof query[key] === 'undefined') {
      query[key] = value;
    } else if (Array.isArray(query[key])) {
      ;
      query[key].push(value);
    } else {
      query[key] = [query[key], value];
    }
  });
  return query;
}

function stringifyUrlQueryParam(param) {
  if (typeof param === 'string' || typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
    return String(param);
  } else {
    return '';
  }
}

function urlQueryToSearchParams(urlQuery) {
  var result = new URLSearchParams();
  Object.entries(urlQuery).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    if (Array.isArray(value)) {
      value.forEach(function (item) {
        return result.append(key, stringifyUrlQueryParam(item));
      });
    } else {
      result.set(key, stringifyUrlQueryParam(value));
    }
  });
  return result;
}

function assign(target) {
  for (var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    searchParamsList[_key - 1] = arguments[_key];
  }

  searchParamsList.forEach(function (searchParams) {
    Array.from(searchParams.keys()).forEach(function (key) {
      return target["delete"](key);
    });
    searchParams.forEach(function (value, key) {
      return target.append(key, value);
    });
  });
  return target;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

exports.__esModule = true;
exports["default"] = resolveRewrites;

var _pathMatch = _interopRequireDefault(__webpack_require__(/*! ./path-match */ "./node_modules/next/dist/next-server/lib/router/utils/path-match.js"));

var _prepareDestination = _interopRequireDefault(__webpack_require__(/*! ./prepare-destination */ "./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js"));

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var customRouteMatcher = (0, _pathMatch["default"])(true);

function resolveRewrites(asPath, pages, basePath, rewrites, query, resolveHref) {
  if (!pages.includes(asPath)) {
    var _iterator = _createForOfIteratorHelper(rewrites),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var rewrite = _step.value;
        var matcher = customRouteMatcher(rewrite.source);
        var params = matcher(asPath);

        if (params) {
          if (!rewrite.destination) {
            // this is a proxied rewrite which isn't handled on the client
            break;
          }

          var destRes = (0, _prepareDestination["default"])(rewrite.destination, params, query, true, rewrite.basePath === false ? '' : basePath);
          asPath = destRes.parsedDestination.pathname;
          Object.assign(query, destRes.parsedDestination.query);

          if (pages.includes((0, _normalizeTrailingSlash.removePathTrailingSlash)(asPath))) {
            // check if we now match a page as this means we are done
            // resolving the rewrites
            break;
          } // check if we match a dynamic-route, if so we break the rewrites chain


          var resolvedHref = resolveHref(asPath);

          if (resolvedHref !== asPath && pages.includes(resolvedHref)) {
            break;
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  return asPath;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteMatcher = getRouteMatcher;

function getRouteMatcher(routeRegex) {
  var re = routeRegex.re,
      groups = routeRegex.groups;
  return function (pathname) {
    var routeMatch = re.exec(pathname);

    if (!routeMatch) {
      return false;
    }

    var decode = function decode(param) {
      try {
        return decodeURIComponent(param);
      } catch (_) {
        var err = new Error('failed to decode param');
        err.code = 'DECODE_FAILED';
        throw err;
      }
    };

    var params = {};
    Object.keys(groups).forEach(function (slugName) {
      var g = groups[slugName];
      var m = routeMatch[g.pos];

      if (m !== undefined) {
        params[slugName] = ~m.indexOf('/') ? m.split('/').map(function (entry) {
          return decode(entry);
        }) : g.repeat ? [decode(m)] : decode(m);
      }
    });
    return params;
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module
// to reduce bytes

function escapeRegex(str) {
  return str.replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&');
}

function parseParameter(param) {
  var optional = param.startsWith('[') && param.endsWith(']');

  if (optional) {
    param = param.slice(1, -1);
  }

  var repeat = param.startsWith('...');

  if (repeat) {
    param = param.slice(3);
  }

  return {
    key: param,
    repeat: repeat,
    optional: optional
  };
}

function getRouteRegex(normalizedRoute) {
  var segments = (normalizedRoute.replace(/\/$/, '') || '/').slice(1).split('/');
  var groups = {};
  var groupIndex = 1;
  var parameterizedRoute = segments.map(function (segment) {
    if (segment.startsWith('[') && segment.endsWith(']')) {
      var _parseParameter = parseParameter(segment.slice(1, -1)),
          key = _parseParameter.key,
          optional = _parseParameter.optional,
          repeat = _parseParameter.repeat;

      groups[key] = {
        pos: groupIndex++,
        repeat: repeat,
        optional: optional
      };
      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';
    } else {
      return "/".concat(escapeRegex(segment));
    }
  }).join(''); // dead code eliminate for browser since it's only needed
  // while generating routes-manifest

  if (false) { var namedParameterizedRoute, routeKeys, getSafeRouteKey, routeKeyCharLength, routeKeyCharCode; }

  return {
    re: new RegExp("^".concat(parameterizedRoute, "(?:/)?$")),
    groups: groups
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/next/node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator.js");

exports.__esModule = true;
exports.execOnce = execOnce;
exports.getLocationOrigin = getLocationOrigin;
exports.getURL = getURL;
exports.getDisplayName = getDisplayName;
exports.isResSent = isResSent;
exports.loadGetInitialProps = loadGetInitialProps;
exports.formatWithValidation = formatWithValidation;
exports.ST = exports.SP = exports.urlObjectKeys = void 0;

var _formatUrl = __webpack_require__(/*! ./router/utils/format-url */ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js");
/**
* Utils
*/


function execOnce(fn) {
  var used = false;
  var result;
  return function () {
    if (!used) {
      used = true;
      result = fn.apply(void 0, arguments);
    }

    return result;
  };
}

function getLocationOrigin() {
  var _window$location = window.location,
      protocol = _window$location.protocol,
      hostname = _window$location.hostname,
      port = _window$location.port;
  return "".concat(protocol, "//").concat(hostname).concat(port ? ':' + port : '');
}

function getURL() {
  var href = window.location.href;
  var origin = getLocationOrigin();
  return href.substring(origin.length);
}

function getDisplayName(Component) {
  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}

function isResSent(res) {
  return res.finished || res.headersSent;
}

function loadGetInitialProps(_x, _x2) {
  return _loadGetInitialProps.apply(this, arguments);
}

function _loadGetInitialProps() {
  _loadGetInitialProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(App, ctx) {
    var _App$prototype, message, res, props, _message;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (false) {}

            if (!((_App$prototype = App.prototype) == null ? void 0 : _App$prototype.getInitialProps)) {
              _context.next = 4;
              break;
            }

            message = "\"".concat(getDisplayName(App), ".getInitialProps()\" is defined as an instance method - visit https://err.sh/vercel/next.js/get-initial-props-as-an-instance-method for more information.");
            throw new Error(message);

          case 4:
            // when called from _app `ctx` is nested in `ctx`
            res = ctx.res || ctx.ctx && ctx.ctx.res;

            if (App.getInitialProps) {
              _context.next = 12;
              break;
            }

            if (!(ctx.ctx && ctx.Component)) {
              _context.next = 11;
              break;
            }

            _context.next = 9;
            return loadGetInitialProps(ctx.Component, ctx.ctx);

          case 9:
            _context.t0 = _context.sent;
            return _context.abrupt("return", {
              pageProps: _context.t0
            });

          case 11:
            return _context.abrupt("return", {});

          case 12:
            _context.next = 14;
            return App.getInitialProps(ctx);

          case 14:
            props = _context.sent;

            if (!(res && isResSent(res))) {
              _context.next = 17;
              break;
            }

            return _context.abrupt("return", props);

          case 17:
            if (props) {
              _context.next = 20;
              break;
            }

            _message = "\"".concat(getDisplayName(App), ".getInitialProps()\" should resolve to an object. But found \"").concat(props, "\" instead.");
            throw new Error(_message);

          case 20:
            if (true) {
              if (Object.keys(props).length === 0 && !ctx.ctx) {
                console.warn("".concat(getDisplayName(App), " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://err.sh/vercel/next.js/empty-object-getInitialProps"));
              }
            }

            return _context.abrupt("return", props);

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadGetInitialProps.apply(this, arguments);
}

var urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];
exports.urlObjectKeys = urlObjectKeys;

function formatWithValidation(url) {
  if (true) {
    if (url !== null && typeof url === 'object') {
      Object.keys(url).forEach(function (key) {
        if (urlObjectKeys.indexOf(key) === -1) {
          console.warn("Unknown key passed via urlObject into url.format: ".concat(key));
        }
      });
    }
  }

  return (0, _formatUrl.formatUrl)(url);
}

var SP = typeof performance !== 'undefined';
exports.SP = SP;
var ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';
exports.ST = ST;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/server/denormalize-page-path.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/server/denormalize-page-path.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
exports.__esModule=true;exports.normalizePathSep=normalizePathSep;exports.denormalizePagePath=denormalizePagePath;function normalizePathSep(path){return path.replace(/\\/g,'/');}function denormalizePagePath(page){page=normalizePathSep(page);if(page.startsWith('/index/')){page=page.slice(6);}else if(page==='/index'){page='/';}return page;}
//# sourceMappingURL=denormalize-page-path.js.map

/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/client/link */ "./node_modules/next/dist/client/link.js")


/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/construct.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/construct.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/next/node_modules/@babel/runtime/helpers/setPrototypeOf.js");

var isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct */ "./node_modules/next/node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/createClass.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/createClass.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/next/node_modules/@babel/runtime/helpers/typeof.js");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/next/node_modules/@babel/runtime/helpers/arrayWithHoles.js");

var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ "./node_modules/next/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/next/node_modules/@babel/runtime/helpers/nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/typeof.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/typeof.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/regenerator/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/regenerator/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/react-grid-system/build/config.js":
/*!********************************************************!*\
  !*** ./node_modules/react-grid-system/build/config.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setConfiguration = exports.getConfiguration = void 0;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var configuration = {
  breakpoints: [576, 768, 992, 1200, 1600],
  containerWidths: [540, 750, 960, 1140, 1540],
  gutterWidth: 30,
  gridColumns: 12,
  defaultScreenClass: 'xxl',
  maxScreenClass: 'xxl'
};

var getConfiguration = function getConfiguration() {
  return configuration;
};

exports.getConfiguration = getConfiguration;

var setConfiguration = function setConfiguration(newConfiguration) {
  configuration = _objectSpread(_objectSpread({}, configuration), newConfiguration);
};

exports.setConfiguration = setConfiguration;

/***/ }),

/***/ "./node_modules/react-grid-system/build/context/ScreenClassProvider/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/react-grid-system/build/context/ScreenClassProvider/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ScreenClassContext = exports.NO_PROVIDER_FLAG = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));

var _utils = __webpack_require__(/*! ../../utils */ "./node_modules/react-grid-system/build/utils.js");

var _config = __webpack_require__(/*! ../../config */ "./node_modules/react-grid-system/build/config.js");

var _primitives = __webpack_require__(/*! ../../primitives */ "./node_modules/react-grid-system/build/primitives/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var NO_PROVIDER_FLAG = 'NO_PROVIDER_FLAG';
exports.NO_PROVIDER_FLAG = NO_PROVIDER_FLAG;

var ScreenClassContext = /*#__PURE__*/_react.default.createContext(NO_PROVIDER_FLAG);

exports.ScreenClassContext = ScreenClassContext;

var ScreenClassProvider = function ScreenClassProvider(_ref) {
  var useOwnWidth = _ref.useOwnWidth,
      children = _ref.children,
      fallbackScreenClass = _ref.fallbackScreenClass;
  var screenClassRef = (0, _react.useRef)();

  var _useState = (0, _react.useState)(false),
      _useState2 = _slicedToArray(_useState, 2),
      mounted = _useState2[0],
      setMounted = _useState2[1];

  var detectedScreenClass = (0, _utils.useScreenClass)(screenClassRef, fallbackScreenClass);

  var _getConfiguration = (0, _config.getConfiguration)(),
      defaultScreenClass = _getConfiguration.defaultScreenClass;

  var screenClass = mounted ? detectedScreenClass : fallbackScreenClass || defaultScreenClass;
  (0, _react.useEffect)(function () {
    return setMounted(true);
  }, []);
  return /*#__PURE__*/_react.default.createElement(ScreenClassContext.Provider, {
    value: screenClass
  }, useOwnWidth ? /*#__PURE__*/_react.default.createElement(_primitives.Div, {
    ref: useOwnWidth ? screenClassRef : null
  }, children) : /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, children));
};

ScreenClassProvider.propTypes = {
  /**
   * Children of the ScreenClassProvider.
   * This should be all your child React nodes that are using `react-grid-system`.
   */
  children: _propTypes.default.node.isRequired,

  /**
   * Boolean to determine whether own width should be used as source.
   * When provided, the screen class is derived from own dimensions instead of the window.
   */
  useOwnWidth: _propTypes.default.bool,

  /**
   * Screen class to use when it cannot be determined otherwise.
   * Useful for server side rendering.
   */
  fallbackScreenClass: _propTypes.default.oneOf([null, 'xs', 'sm', 'md', 'lg', 'xl', 'xxl'])
};
ScreenClassProvider.defaultProps = {
  useOwnWidth: false,
  fallbackScreenClass: null
};
var _default = ScreenClassProvider;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/context/ScreenClassResolver/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/react-grid-system/build/context/ScreenClassResolver/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));

var _ScreenClassProvider = _interopRequireWildcard(__webpack_require__(/*! ../ScreenClassProvider */ "./node_modules/react-grid-system/build/context/ScreenClassProvider/index.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ScreenClassResolver = function ScreenClassResolver(_ref) {
  var children = _ref.children;
  return /*#__PURE__*/_react.default.createElement(_ScreenClassProvider.ScreenClassContext.Consumer, null, function (screenClassCheck) {
    if (screenClassCheck === _ScreenClassProvider.NO_PROVIDER_FLAG) {
      return /*#__PURE__*/_react.default.createElement(_ScreenClassProvider.default, null, /*#__PURE__*/_react.default.createElement(_ScreenClassProvider.ScreenClassContext.Consumer, null, function (screenClassResolved) {
        return children(screenClassResolved);
      }));
    }

    return children(screenClassCheck);
  });
};

ScreenClassResolver.propTypes = {
  children: _propTypes.default.func.isRequired
};
var _default = ScreenClassResolver;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/grid/Col/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-grid-system/build/grid/Col/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));

var _style = _interopRequireDefault(__webpack_require__(/*! ./style */ "./node_modules/react-grid-system/build/grid/Col/style.js"));

var _config = __webpack_require__(/*! ../../config */ "./node_modules/react-grid-system/build/config.js");

var _Row = __webpack_require__(/*! ../Row */ "./node_modules/react-grid-system/build/grid/Row/index.js");

var _ScreenClassResolver = _interopRequireDefault(__webpack_require__(/*! ../../context/ScreenClassResolver */ "./node_modules/react-grid-system/build/context/ScreenClassResolver/index.js"));

var _primitives = __webpack_require__(/*! ../../primitives */ "./node_modules/react-grid-system/build/primitives/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var Col = function Col(_ref) {
  var children = _ref.children,
      xs = _ref.xs,
      sm = _ref.sm,
      md = _ref.md,
      lg = _ref.lg,
      xl = _ref.xl,
      xxl = _ref.xxl,
      offset = _ref.offset,
      pull = _ref.pull,
      push = _ref.push,
      debug = _ref.debug,
      style = _ref.style,
      component = _ref.component,
      width = _ref.width,
      otherProps = _objectWithoutProperties(_ref, ["children", "xs", "sm", "md", "lg", "xl", "xxl", "offset", "pull", "push", "debug", "style", "component", "width"]);

  return /*#__PURE__*/_react.default.createElement(_ScreenClassResolver.default, null, function (screenClass) {
    return /*#__PURE__*/_react.default.createElement(_Row.GutterWidthContext.Consumer, null, function (gutterWidth) {
      var theStyle = (0, _style.default)({
        forceWidth: width,
        width: {
          xs: xs,
          sm: sm,
          md: md,
          lg: lg,
          xl: xl,
          xxl: xxl
        },
        offset: offset,
        pull: pull,
        push: push,
        debug: debug,
        screenClass: screenClass,
        gutterWidth: gutterWidth,
        gridColumns: (0, _config.getConfiguration)().gridColumns,
        moreStyle: style
      });
      return /*#__PURE__*/(0, _react.createElement)(component, _objectSpread(_objectSpread({
        style: theStyle
      }, otherProps), {}, {
        children: children
      }));
    });
  });
};

Col.propTypes = {
  /**
   * Content of the column
   */
  children: _propTypes.default.node,

  /**
   * The width of the column for screenclass `xs`, either a number between 0 and 12, or "content"
   */
  xs: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.oneOf(['content'])]),

  /**
   * The width of the column for screenclass `sm`, either a number between 0 and 12, or "content"
   */
  sm: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.oneOf(['content'])]),

  /**
   * The width of the column for screenclass `md`, either a number between 0 and 12, or "content"
   */
  md: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.oneOf(['content'])]),

  /**
   * The width of the column for screenclass `lg`, either a number between 0 and 12, or "content"
   */
  lg: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.oneOf(['content'])]),

  /**
   * The width of the column for screenclass `xl`, either a number between 0 and 12, or "content"
   */
  xl: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.oneOf(['content'])]),

  /**
   * The width of the column for screenclass `xxl`, either a number between 0 and 12, or "content"
   */
  xxl: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.oneOf(['content'])]),

  /**
   * A fixed width of the column for all screenclasses"
   */
  width: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),

  /**
   * The offset of this column for all screenclasses
   */
  offset: _propTypes.default.shape({
    xs: _propTypes.default.number,
    sm: _propTypes.default.number,
    md: _propTypes.default.number,
    lg: _propTypes.default.number,
    xl: _propTypes.default.number,
    xxl: _propTypes.default.number
  }),

  /**
   * The amount this column is pushed to the right for all screenclasses
   */
  push: _propTypes.default.shape({
    xs: _propTypes.default.number,
    sm: _propTypes.default.number,
    md: _propTypes.default.number,
    lg: _propTypes.default.number,
    xl: _propTypes.default.number,
    xxl: _propTypes.default.number
  }),

  /**
   * The amount this column is pulled to the left for all screenclasses
   */
  pull: _propTypes.default.shape({
    xs: _propTypes.default.number,
    sm: _propTypes.default.number,
    md: _propTypes.default.number,
    lg: _propTypes.default.number,
    xl: _propTypes.default.number,
    xxl: _propTypes.default.number
  }),

  /**
   * Optional styling
   */
  style: _propTypes.default.objectOf(_propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])),

  /**
   * Set to apply some debug styling
   */
  debug: _propTypes.default.bool,

  /**
   * Use your own component
   */
  component: _propTypes.default.elementType
};
Col.defaultProps = {
  children: null,
  xs: null,
  sm: null,
  md: null,
  lg: null,
  xl: null,
  xxl: null,
  width: null,
  offset: {},
  push: {},
  pull: {},
  style: {},
  debug: false,
  component: _primitives.Div
};
var _default = Col;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/grid/Col/style.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-grid-system/build/grid/Col/style.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utils = __webpack_require__(/*! ../../utils */ "./node_modules/react-grid-system/build/utils.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var hasWidth = function hasWidth(widths) {
  return Object.keys(widths).reduce(function (acc, cur) {
    return acc || widths[cur];
  }, false);
};

var getWidth = function getWidth(width, gridColumns) {
  if (typeof width !== 'number') return undefined;
  var normalizedWidth = Math.max(0, Math.min(gridColumns, width));
  return "".concat(100 / gridColumns * normalizedWidth, "%");
};

var _default = function _default(_ref) {
  var _ref$forceWidth = _ref.forceWidth,
      forceWidth = _ref$forceWidth === void 0 ? null : _ref$forceWidth,
      _ref$width = _ref.width,
      width = _ref$width === void 0 ? {} : _ref$width,
      _ref$offset = _ref.offset,
      offset = _ref$offset === void 0 ? {} : _ref$offset,
      _ref$pull = _ref.pull,
      pull = _ref$pull === void 0 ? {} : _ref$pull,
      _ref$push = _ref.push,
      push = _ref$push === void 0 ? {} : _ref$push,
      debug = _ref.debug,
      screenClass = _ref.screenClass,
      gutterWidth = _ref.gutterWidth,
      moreStyle = _ref.moreStyle,
      gridColumns = _ref.gridColumns;
  var styles = {
    boxSizing: 'border-box',
    minHeight: 1,
    position: 'relative',
    paddingLeft: gutterWidth / 2,
    paddingRight: gutterWidth / 2,
    width: '100%'
  };

  if (debug) {
    styles.outline = '1px solid silver';
    styles.background = 'rgba(0,0,0,.05)';
    styles.lineHeight = '32px';
  }

  styles.flexBasis = '100%';
  styles.flexGrow = 0;
  styles.flexShrink = 0;
  styles.maxWidth = '100%';
  styles.marginLeft = '0%';
  styles.right = 'auto';
  styles.left = 'auto';

  _utils.screenClasses.forEach(function (size, index) {
    if (_utils.screenClasses.indexOf(screenClass) >= index) {
      var currentWidth = getWidth(width[size], gridColumns);
      var isSizedToContent = width[size] === 'content';
      styles.flexBasis = isSizedToContent ? 'auto' : currentWidth || styles.flexBasis;
      styles.width = styles.flexBasis;
      styles.maxWidth = currentWidth || styles.maxWidth;
      styles.marginLeft = getWidth(offset[size], gridColumns) || styles.marginLeft;
      styles.right = getWidth(pull[size], gridColumns) || styles.right;
      styles.left = getWidth(push[size], gridColumns) || styles.left;
    }
  });

  if (!hasWidth(width)) {
    styles.flexBasis = 0;
    styles.flexGrow = 1;
  }

  if (forceWidth) {
    styles.flexBasis = 'unset';
    styles.flexGrow = 'unset';
    styles.flexShrink = 'unset';
    styles.width = forceWidth;
  }

  return _objectSpread(_objectSpread({}, styles), moreStyle);
};

exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/grid/Container/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-grid-system/build/grid/Container/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));

var _style = _interopRequireWildcard(__webpack_require__(/*! ./style */ "./node_modules/react-grid-system/build/grid/Container/style.js"));

var _config = __webpack_require__(/*! ../../config */ "./node_modules/react-grid-system/build/config.js");

var _ScreenClassResolver = _interopRequireDefault(__webpack_require__(/*! ../../context/ScreenClassResolver */ "./node_modules/react-grid-system/build/context/ScreenClassResolver/index.js"));

var _primitives = __webpack_require__(/*! ../../primitives */ "./node_modules/react-grid-system/build/primitives/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var Container = function Container(_ref) {
  var children = _ref.children,
      fluid = _ref.fluid,
      xs = _ref.xs,
      sm = _ref.sm,
      md = _ref.md,
      lg = _ref.lg,
      xl = _ref.xl,
      xxl = _ref.xxl,
      style = _ref.style,
      component = _ref.component,
      otherProps = _objectWithoutProperties(_ref, ["children", "fluid", "xs", "sm", "md", "lg", "xl", "xxl", "style", "component"]);

  return /*#__PURE__*/_react.default.createElement(_ScreenClassResolver.default, null, function (screenClass) {
    return /*#__PURE__*/(0, _react.createElement)(component, _objectSpread({
      style: (0, _style.default)({
        fluid: fluid,
        xs: xs,
        sm: sm,
        md: md,
        lg: lg,
        xl: xl,
        xxl: xxl,
        screenClass: screenClass,
        containerWidths: (0, _config.getConfiguration)().containerWidths,
        gutterWidth: (0, _config.getConfiguration)().gutterWidth,
        moreStyle: style
      })
    }, otherProps), /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, children, /*#__PURE__*/_react.default.createElement(_primitives.Span, {
      style: (0, _style.getAfterStyle)()
    })));
  });
};

Container.propTypes = {
  /**
   * Content of the component
   */
  children: _propTypes.default.node.isRequired,

  /**
   * True makes the container full-width, false fixed-width
   */
  fluid: _propTypes.default.bool,

  /**
   * This is in combination with fluid enabled
   * True makes container fluid only in xs, not present means fluid everywhere
   */
  xs: _propTypes.default.bool,

  /**
   * This is in combination with fluid enabled
   * True makes container fluid only in sm, not present means fluid everywhere
   */
  sm: _propTypes.default.bool,

  /**
   * This is in combination with fluid enabled
   * True makes container fluid only in md, not present means fluid everywhere
   */
  md: _propTypes.default.bool,

  /**
   * This is in combination with fluid enabled
   * True makes container fluid only in lg, not present means fluid everywhere
   */
  lg: _propTypes.default.bool,

  /**
   * This is in combination with fluid enabled
   * True makes container fluid only in xl, not present means fluid everywhere
   */
  xl: _propTypes.default.bool,

  /**
   * This is in combination with fluid enabled
   * True makes container fluid only in xxl, not present means fluid everywhere
   */
  xxl: _propTypes.default.bool,

  /**
   * Optional styling
   */
  style: _propTypes.default.objectOf(_propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])),

  /**
   * Use your own component
   */
  component: _propTypes.default.elementType
};
Container.defaultProps = {
  fluid: false,
  xs: false,
  sm: false,
  md: false,
  lg: false,
  xl: false,
  xxl: false,
  style: {},
  component: _primitives.Div
};
var _default = Container;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/grid/Container/style.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-grid-system/build/grid/Container/style.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAfterStyle = exports.default = void 0;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = function _default(_ref) {
  var fluid = _ref.fluid,
      xs = _ref.xs,
      sm = _ref.sm,
      md = _ref.md,
      lg = _ref.lg,
      xl = _ref.xl,
      xxl = _ref.xxl,
      screenClass = _ref.screenClass,
      containerWidths = _ref.containerWidths,
      gutterWidth = _ref.gutterWidth,
      moreStyle = _ref.moreStyle;
  var styles = {
    boxSizing: 'border-box',
    position: 'relative',
    marginLeft: 'auto',
    marginRight: 'auto',
    paddingLeft: gutterWidth / 2,
    paddingRight: gutterWidth / 2
  };

  if (fluid && !sm && !md && !lg && !xl) {
    return _objectSpread(_objectSpread({}, styles), moreStyle);
  }

  if (screenClass === 'sm' && containerWidths[0] && !sm && !xs) {
    styles.maxWidth = containerWidths[0];
  }

  if (screenClass === 'md' && containerWidths[1] && !md) {
    styles.maxWidth = containerWidths[1];
  }

  if (screenClass === 'lg' && containerWidths[2] && !lg) {
    styles.maxWidth = containerWidths[2];
  }

  if (screenClass === 'xl' && containerWidths[3] && !xl) {
    styles.maxWidth = containerWidths[3];
  }

  if (screenClass === 'xxl' && containerWidths[4] && !xxl) {
    styles.maxWidth = containerWidths[4];
  }

  return _objectSpread(_objectSpread({}, styles), moreStyle);
};

exports.default = _default;

var getAfterStyle = function getAfterStyle() {
  return {
    display: 'table',
    clear: 'both'
  };
};

exports.getAfterStyle = getAfterStyle;

/***/ }),

/***/ "./node_modules/react-grid-system/build/grid/Row/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-grid-system/build/grid/Row/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.GutterWidthContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));

var _config = __webpack_require__(/*! ../../config */ "./node_modules/react-grid-system/build/config.js");

var _style = _interopRequireDefault(__webpack_require__(/*! ./style */ "./node_modules/react-grid-system/build/grid/Row/style.js"));

var _primitives = __webpack_require__(/*! ../../primitives */ "./node_modules/react-grid-system/build/primitives/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var GutterWidthContext = /*#__PURE__*/_react.default.createContext(false);

exports.GutterWidthContext = GutterWidthContext;

var Row = function Row(_ref) {
  var children = _ref.children,
      style = _ref.style,
      align = _ref.align,
      justify = _ref.justify,
      debug = _ref.debug,
      nogutter = _ref.nogutter,
      gutterWidth = _ref.gutterWidth,
      component = _ref.component,
      nowrap = _ref.nowrap,
      otherProps = _objectWithoutProperties(_ref, ["children", "style", "align", "justify", "debug", "nogutter", "gutterWidth", "component", "nowrap"]);

  var theGutterWidth = (0, _config.getConfiguration)().gutterWidth;
  if (nogutter) theGutterWidth = 0;
  if (typeof gutterWidth === 'number') theGutterWidth = gutterWidth;
  var theStyle = (0, _style.default)({
    gutterWidth: theGutterWidth,
    align: align,
    justify: justify,
    debug: debug,
    moreStyle: style,
    nowrap: nowrap
  });
  return /*#__PURE__*/_react.default.createElement(component, _objectSpread({
    style: theStyle
  }, otherProps), /*#__PURE__*/_react.default.createElement(GutterWidthContext.Provider, {
    value: theGutterWidth
  }, children));
};

Row.propTypes = {
  /**
   * Content of the element
   */
  children: _propTypes.default.node.isRequired,

  /**
   * Vertical column alignment
   */
  align: _propTypes.default.oneOf(['normal', 'start', 'center', 'end', 'stretch']),

  /**
   * Horizontal column alignment
   */
  justify: _propTypes.default.oneOf(['start', 'center', 'end', 'between', 'around', 'initial', 'inherit']),

  /**
   * No gutter for this row
   */
  nogutter: _propTypes.default.bool,

  /**
   * Custom gutter width for this row
   */
  gutterWidth: _propTypes.default.number,

  /**
   * Optional styling
   */
  style: _propTypes.default.objectOf(_propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])),

  /**
   * Set to apply some debug styling
   */
  debug: _propTypes.default.bool,

  /**
   * Use your own component
   */
  component: _propTypes.default.elementType,

  /**
   * Whether the cols should not wrap
   */
  nowrap: _propTypes.default.bool
};
Row.defaultProps = {
  align: 'normal',
  justify: 'start',
  nogutter: false,
  gutterWidth: null,
  style: {},
  debug: false,
  component: _primitives.Div,
  nowrap: false
};
var _default = Row;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/grid/Row/style.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-grid-system/build/grid/Row/style.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = function _default(_ref) {
  var gutterWidth = _ref.gutterWidth,
      align = _ref.align,
      justify = _ref.justify,
      debug = _ref.debug,
      moreStyle = _ref.moreStyle,
      nowrap = _ref.nowrap;
  // Vertical alignment
  var alignItems = align;
  if (align === 'start') alignItems = 'flex-start';
  if (align === 'end') alignItems = 'flex-end'; // Horizontal alignment

  var justifyContent = justify;
  if (justify === 'start') justifyContent = 'flex-start';
  if (justify === 'end') justifyContent = 'flex-end';
  if (justify === 'between') justifyContent = 'space-between';
  if (justify === 'around') justifyContent = 'space-around';
  if (justify === 'center') justifyContent = 'center';
  if (justify === 'initial') justifyContent = 'initial';
  if (justify === 'inherit') justifyContent = 'inherit';
  var styles = {
    marginLeft: -gutterWidth / 2,
    marginRight: -gutterWidth / 2,
    display: 'flex',
    flexWrap: nowrap ? 'nowrap' : 'wrap',
    flexGrow: 0,
    flexShrink: 0,
    alignItems: alignItems,
    justifyContent: justifyContent
  };

  if (debug) {
    styles.background = 'rgba(128,128,128,.05)';
  }

  return _objectSpread(_objectSpread({}, styles), moreStyle);
};

exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-grid-system/build/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Col", {
  enumerable: true,
  get: function get() {
    return _Col.default;
  }
});
Object.defineProperty(exports, "Container", {
  enumerable: true,
  get: function get() {
    return _Container.default;
  }
});
Object.defineProperty(exports, "Row", {
  enumerable: true,
  get: function get() {
    return _Row.default;
  }
});
Object.defineProperty(exports, "Hidden", {
  enumerable: true,
  get: function get() {
    return _Hidden.default;
  }
});
Object.defineProperty(exports, "Visible", {
  enumerable: true,
  get: function get() {
    return _Visible.default;
  }
});
Object.defineProperty(exports, "ScreenClassRender", {
  enumerable: true,
  get: function get() {
    return _ScreenClassRender.default;
  }
});
Object.defineProperty(exports, "ScreenClassProvider", {
  enumerable: true,
  get: function get() {
    return _ScreenClassProvider.default;
  }
});
Object.defineProperty(exports, "ScreenClassContext", {
  enumerable: true,
  get: function get() {
    return _ScreenClassProvider.ScreenClassContext;
  }
});
Object.defineProperty(exports, "setConfiguration", {
  enumerable: true,
  get: function get() {
    return _config.setConfiguration;
  }
});
Object.defineProperty(exports, "useScreenClass", {
  enumerable: true,
  get: function get() {
    return _utils.useScreenClass;
  }
});

var _Col = _interopRequireDefault(__webpack_require__(/*! ./grid/Col */ "./node_modules/react-grid-system/build/grid/Col/index.js"));

var _Container = _interopRequireDefault(__webpack_require__(/*! ./grid/Container */ "./node_modules/react-grid-system/build/grid/Container/index.js"));

var _Row = _interopRequireDefault(__webpack_require__(/*! ./grid/Row */ "./node_modules/react-grid-system/build/grid/Row/index.js"));

var _Hidden = _interopRequireDefault(__webpack_require__(/*! ./utilities/Hidden */ "./node_modules/react-grid-system/build/utilities/Hidden/index.js"));

var _Visible = _interopRequireDefault(__webpack_require__(/*! ./utilities/Visible */ "./node_modules/react-grid-system/build/utilities/Visible/index.js"));

var _ScreenClassRender = _interopRequireDefault(__webpack_require__(/*! ./utilities/ScreenClassRender */ "./node_modules/react-grid-system/build/utilities/ScreenClassRender/index.js"));

var _ScreenClassProvider = _interopRequireWildcard(__webpack_require__(/*! ./context/ScreenClassProvider */ "./node_modules/react-grid-system/build/context/ScreenClassProvider/index.js"));

var _config = __webpack_require__(/*! ./config */ "./node_modules/react-grid-system/build/config.js");

var _utils = __webpack_require__(/*! ./utils */ "./node_modules/react-grid-system/build/utils.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "./node_modules/react-grid-system/build/primitives/Div/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-grid-system/build/primitives/Div/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = 'div';
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/primitives/Span/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-grid-system/build/primitives/Span/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = 'span';
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/primitives/Window/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-grid-system/build/primitives/Window/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/* global window */
var _default = typeof window !== 'undefined' ? window : undefined;

exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/primitives/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/react-grid-system/build/primitives/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Div", {
  enumerable: true,
  get: function get() {
    return _Div.default;
  }
});
Object.defineProperty(exports, "Span", {
  enumerable: true,
  get: function get() {
    return _Span.default;
  }
});
Object.defineProperty(exports, "Window", {
  enumerable: true,
  get: function get() {
    return _Window.default;
  }
});

var _Div = _interopRequireDefault(__webpack_require__(/*! ./Div */ "./node_modules/react-grid-system/build/primitives/Div/index.js"));

var _Span = _interopRequireDefault(__webpack_require__(/*! ./Span */ "./node_modules/react-grid-system/build/primitives/Span/index.js"));

var _Window = _interopRequireDefault(__webpack_require__(/*! ./Window */ "./node_modules/react-grid-system/build/primitives/Window/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "./node_modules/react-grid-system/build/utilities/Hidden/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-grid-system/build/utilities/Hidden/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));

var style = _interopRequireWildcard(__webpack_require__(/*! ./style */ "./node_modules/react-grid-system/build/utilities/Hidden/style.js"));

var _ScreenClassResolver = _interopRequireDefault(__webpack_require__(/*! ../../context/ScreenClassResolver */ "./node_modules/react-grid-system/build/context/ScreenClassResolver/index.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Hidden = function Hidden(_ref) {
  var children = _ref.children,
      xs = _ref.xs,
      sm = _ref.sm,
      md = _ref.md,
      lg = _ref.lg,
      xl = _ref.xl,
      xxl = _ref.xxl;
  return /*#__PURE__*/_react.default.createElement(_ScreenClassResolver.default, null, function (screenClass) {
    return style.hidden({
      screenClass: screenClass,
      xs: xs,
      sm: sm,
      md: md,
      lg: lg,
      xl: xl,
      xxl: xxl
    }) ? null : children;
  });
};

Hidden.propTypes = {
  /**
   * Content of the component
   */
  children: _propTypes.default.node.isRequired,

  /**
   * Hide on extra small devices
   */
  xs: _propTypes.default.bool,

  /**
   * Hide on small devices
   */
  sm: _propTypes.default.bool,

  /**
   * Hide on medium devices
   */
  md: _propTypes.default.bool,

  /**
   * Hide on large devices
   */
  lg: _propTypes.default.bool,

  /**
   * Hide on xlarge devices
   */
  xl: _propTypes.default.bool,

  /**
   * Hide on xxlarge devices
   */
  xxl: _propTypes.default.bool
};
Hidden.defaultProps = {
  xs: false,
  sm: false,
  md: false,
  lg: false,
  xl: false,
  xxl: false
};
var _default = Hidden;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/utilities/Hidden/style.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-grid-system/build/utilities/Hidden/style.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.hidden = void 0;

var hidden = function hidden(_ref) {
  var screenClass = _ref.screenClass,
      xs = _ref.xs,
      sm = _ref.sm,
      md = _ref.md,
      lg = _ref.lg,
      xl = _ref.xl,
      xxl = _ref.xxl;
  if (screenClass === 'xxl') return xxl;
  if (screenClass === 'xl') return xl;
  if (screenClass === 'lg') return lg;
  if (screenClass === 'md') return md;
  if (screenClass === 'sm') return sm;
  return xs;
};

exports.hidden = hidden;
var _default = hidden;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/utilities/ScreenClassRender/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/react-grid-system/build/utilities/ScreenClassRender/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));

var _ScreenClassResolver = _interopRequireDefault(__webpack_require__(/*! ../../context/ScreenClassResolver */ "./node_modules/react-grid-system/build/context/ScreenClassResolver/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ScreenClassRender = function ScreenClassRender(_ref) {
  var render = _ref.render;
  return /*#__PURE__*/_react.default.createElement(_ScreenClassResolver.default, null, function (screenClass) {
    return render(screenClass);
  });
};

ScreenClassRender.propTypes = {
  /**
   * The function which return value will be rendered.
   * Will be called with one argument: the screen class.
   */
  render: _propTypes.default.func.isRequired
};
var _default = ScreenClassRender;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/utilities/Visible/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-grid-system/build/utilities/Visible/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));

var style = _interopRequireWildcard(__webpack_require__(/*! ./style */ "./node_modules/react-grid-system/build/utilities/Visible/style.js"));

var _ScreenClassResolver = _interopRequireDefault(__webpack_require__(/*! ../../context/ScreenClassResolver */ "./node_modules/react-grid-system/build/context/ScreenClassResolver/index.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Visible = function Visible(_ref) {
  var children = _ref.children,
      xs = _ref.xs,
      sm = _ref.sm,
      md = _ref.md,
      lg = _ref.lg,
      xl = _ref.xl,
      xxl = _ref.xxl;
  return /*#__PURE__*/_react.default.createElement(_ScreenClassResolver.default, null, function (screenClass) {
    return !style.visible({
      screenClass: screenClass,
      xs: xs,
      sm: sm,
      md: md,
      lg: lg,
      xl: xl,
      xxl: xxl
    }) ? null : children;
  });
};

Visible.propTypes = {
  /**
   * Content of the component
   */
  children: _propTypes.default.node.isRequired,

  /**
   * Show on extra small devices
   */
  xs: _propTypes.default.bool,

  /**
   * Show on small devices
   */
  sm: _propTypes.default.bool,

  /**
   * Show on medium devices
   */
  md: _propTypes.default.bool,

  /**
   * Show on large devices
   */
  lg: _propTypes.default.bool,

  /**
   * Show on xlarge devices
   */
  xl: _propTypes.default.bool,

  /**
   * Show on xxlarge devices
   */
  xxl: _propTypes.default.bool
};
Visible.defaultProps = {
  xs: false,
  sm: false,
  md: false,
  lg: false,
  xl: false,
  xxl: false
};
var _default = Visible;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/utilities/Visible/style.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-grid-system/build/utilities/Visible/style.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.visible = void 0;

var visible = function visible(_ref) {
  var screenClass = _ref.screenClass,
      xs = _ref.xs,
      sm = _ref.sm,
      md = _ref.md,
      lg = _ref.lg,
      xl = _ref.xl,
      xxl = _ref.xxl;
  if (screenClass === 'xxl') return xxl;
  if (screenClass === 'xl') return xl;
  if (screenClass === 'lg') return lg;
  if (screenClass === 'md') return md;
  if (screenClass === 'sm') return sm;
  return xs;
};

exports.visible = visible;
var _default = visible;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-grid-system/build/utils.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useScreenClass = exports.screenClasses = void 0;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var _config = __webpack_require__(/*! ./config */ "./node_modules/react-grid-system/build/config.js");

var _primitives = __webpack_require__(/*! ./primitives */ "./node_modules/react-grid-system/build/primitives/index.js");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var getViewPort = function getViewPort(source) {
  if (source && source.current && source.current.clientWidth) {
    return source.current.clientWidth;
  }

  if (typeof _primitives.Window !== 'undefined' && _primitives.Window.innerWidth) {
    return _primitives.Window.innerWidth;
  }

  return null;
};

var screenClasses = ['xs', 'sm', 'md', 'lg', 'xl', 'xxl'];
exports.screenClasses = screenClasses;

var useScreenClass = function useScreenClass(source, fallbackScreenClass) {
  var getScreenClass = function getScreenClass() {
    var _getConfiguration = (0, _config.getConfiguration)(),
        breakpoints = _getConfiguration.breakpoints,
        defaultScreenClass = _getConfiguration.defaultScreenClass,
        maxScreenClass = _getConfiguration.maxScreenClass;

    var newScreenClass = defaultScreenClass;
    var viewport = getViewPort(source);

    if (viewport) {
      newScreenClass = 'xs';
      if (breakpoints[0] && viewport >= breakpoints[0]) newScreenClass = 'sm';
      if (breakpoints[1] && viewport >= breakpoints[1]) newScreenClass = 'md';
      if (breakpoints[2] && viewport >= breakpoints[2]) newScreenClass = 'lg';
      if (breakpoints[3] && viewport >= breakpoints[3]) newScreenClass = 'xl';
      if (breakpoints[4] && viewport >= breakpoints[4]) newScreenClass = 'xxl';
    } else if (fallbackScreenClass) {
      newScreenClass = fallbackScreenClass;
    }

    var newScreenClassIndex = screenClasses.indexOf(newScreenClass);
    var maxScreenClassIndex = screenClasses.indexOf(maxScreenClass);

    if (maxScreenClassIndex >= 0 && newScreenClassIndex > maxScreenClassIndex) {
      newScreenClass = screenClasses[maxScreenClassIndex];
    }

    return newScreenClass;
  };

  var _useState = (0, _react.useState)(getScreenClass()),
      _useState2 = _slicedToArray(_useState, 2),
      screenClass = _useState2[0],
      setScreenClass = _useState2[1];

  (0, _react.useEffect)(function () {
    var handleWindowResized = function handleWindowResized() {
      return setScreenClass(getScreenClass());
    };

    _primitives.Window.addEventListener('resize', handleWindowResized, false);

    return function () {
      _primitives.Window.removeEventListener('resize', handleWindowResized, false);
    };
  }, []);
  return screenClass;
};

exports.useScreenClass = useScreenClass;

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react-tabs/esm/components/Tab.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-tabs/esm/components/Tab.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Tab; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }




var DEFAULT_CLASS = 'react-tabs__tab';

var Tab = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Tab, _Component);

  function Tab() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = Tab.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.checkFocus();
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    this.checkFocus();
  };

  _proto.checkFocus = function checkFocus() {
    var _this$props = this.props,
        selected = _this$props.selected,
        focus = _this$props.focus;

    if (selected && focus) {
      this.node.focus();
    }
  };

  _proto.render = function render() {
    var _cx,
        _this = this;

    var _this$props2 = this.props,
        children = _this$props2.children,
        className = _this$props2.className,
        disabled = _this$props2.disabled,
        disabledClassName = _this$props2.disabledClassName,
        focus = _this$props2.focus,
        id = _this$props2.id,
        panelId = _this$props2.panelId,
        selected = _this$props2.selected,
        selectedClassName = _this$props2.selectedClassName,
        tabIndex = _this$props2.tabIndex,
        tabRef = _this$props2.tabRef,
        attributes = _objectWithoutPropertiesLoose(_this$props2, ["children", "className", "disabled", "disabledClassName", "focus", "id", "panelId", "selected", "selectedClassName", "tabIndex", "tabRef"]);

    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("li", _extends({}, attributes, {
      className: Object(clsx__WEBPACK_IMPORTED_MODULE_2__["default"])(className, (_cx = {}, _cx[selectedClassName] = selected, _cx[disabledClassName] = disabled, _cx)),
      ref: function ref(node) {
        _this.node = node;
        if (tabRef) tabRef(node);
      },
      role: "tab",
      id: id,
      "aria-selected": selected ? 'true' : 'false',
      "aria-disabled": disabled ? 'true' : 'false',
      "aria-controls": panelId,
      tabIndex: tabIndex || (selected ? '0' : null)
    }), children);
  };

  return Tab;
}(react__WEBPACK_IMPORTED_MODULE_1__["Component"]);

Tab.defaultProps = {
  className: DEFAULT_CLASS,
  disabledClassName: DEFAULT_CLASS + "--disabled",
  focus: false,
  id: null,
  panelId: null,
  selected: false,
  selectedClassName: DEFAULT_CLASS + "--selected"
};

Tab.propTypes =  true ? {
  children: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.array, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string]),
  className: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.array, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object]),
  disabled: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  tabIndex: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  disabledClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  focus: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  // private
  id: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  // private
  panelId: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  // private
  selected: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  // private
  selectedClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  tabRef: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func // private

} : undefined;
Tab.tabsRole = 'Tab';

/***/ }),

/***/ "./node_modules/react-tabs/esm/components/TabList.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-tabs/esm/components/TabList.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TabList; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }





var TabList = /*#__PURE__*/function (_Component) {
  _inheritsLoose(TabList, _Component);

  function TabList() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = TabList.prototype;

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        className = _this$props.className,
        attributes = _objectWithoutPropertiesLoose(_this$props, ["children", "className"]);

    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("ul", _extends({}, attributes, {
      className: Object(clsx__WEBPACK_IMPORTED_MODULE_2__["default"])(className),
      role: "tablist"
    }), children);
  };

  return TabList;
}(react__WEBPACK_IMPORTED_MODULE_1__["Component"]);

TabList.defaultProps = {
  className: 'react-tabs__tab-list'
};

TabList.propTypes =  true ? {
  children: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.array]),
  className: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.array, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object])
} : undefined;
TabList.tabsRole = 'TabList';

/***/ }),

/***/ "./node_modules/react-tabs/esm/components/TabPanel.js":
/*!************************************************************!*\
  !*** ./node_modules/react-tabs/esm/components/TabPanel.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TabPanel; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }




var DEFAULT_CLASS = 'react-tabs__tab-panel';

var TabPanel = /*#__PURE__*/function (_Component) {
  _inheritsLoose(TabPanel, _Component);

  function TabPanel() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = TabPanel.prototype;

  _proto.render = function render() {
    var _cx;

    var _this$props = this.props,
        children = _this$props.children,
        className = _this$props.className,
        forceRender = _this$props.forceRender,
        id = _this$props.id,
        selected = _this$props.selected,
        selectedClassName = _this$props.selectedClassName,
        tabId = _this$props.tabId,
        attributes = _objectWithoutPropertiesLoose(_this$props, ["children", "className", "forceRender", "id", "selected", "selectedClassName", "tabId"]);

    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", _extends({}, attributes, {
      className: Object(clsx__WEBPACK_IMPORTED_MODULE_2__["default"])(className, (_cx = {}, _cx[selectedClassName] = selected, _cx)),
      role: "tabpanel",
      id: id,
      "aria-labelledby": tabId
    }), forceRender || selected ? children : null);
  };

  return TabPanel;
}(react__WEBPACK_IMPORTED_MODULE_1__["Component"]);

TabPanel.defaultProps = {
  className: DEFAULT_CLASS,
  forceRender: false,
  selectedClassName: DEFAULT_CLASS + "--selected"
};

TabPanel.propTypes =  true ? {
  children: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,
  className: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.array, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object]),
  forceRender: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  id: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  // private
  selected: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  // private
  selectedClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  tabId: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string // private

} : undefined;
TabPanel.tabsRole = 'TabPanel';

/***/ }),

/***/ "./node_modules/react-tabs/esm/components/Tabs.js":
/*!********************************************************!*\
  !*** ./node_modules/react-tabs/esm/components/Tabs.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Tabs; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _helpers_propTypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/propTypes */ "./node_modules/react-tabs/esm/helpers/propTypes.js");
/* harmony import */ var _UncontrolledTabs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./UncontrolledTabs */ "./node_modules/react-tabs/esm/components/UncontrolledTabs.js");
/* harmony import */ var _helpers_count__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/count */ "./node_modules/react-tabs/esm/helpers/count.js");
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }






var MODE_CONTROLLED = 0;
var MODE_UNCONTROLLED = 1;

var Tabs = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Tabs, _Component);

  function Tabs(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.handleSelected = function (index, last, event) {
      var onSelect = _this.props.onSelect;
      var mode = _this.state.mode; // Call change event handler

      if (typeof onSelect === 'function') {
        // Check if the change event handler cancels the tab change
        if (onSelect(index, last, event) === false) return;
      }

      var state = {
        // Set focus if the change was triggered from the keyboard
        focus: event.type === 'keydown'
      };

      if (mode === MODE_UNCONTROLLED) {
        // Update selected index
        state.selectedIndex = index;
      }

      _this.setState(state);
    };

    _this.state = Tabs.copyPropsToState(_this.props, {}, props.defaultFocus);
    return _this;
  }

  Tabs.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    return Tabs.copyPropsToState(props, state);
  };

  Tabs.getModeFromProps = function getModeFromProps(props) {
    return props.selectedIndex === null ? MODE_UNCONTROLLED : MODE_CONTROLLED;
  };

  // preserve the existing selectedIndex from state.
  // If the state has not selectedIndex, default to the defaultIndex or 0
  Tabs.copyPropsToState = function copyPropsToState(props, state, focus) {
    if (focus === void 0) {
      focus = false;
    }

    if ( true && state.mode !== undefined && state.mode !== Tabs.getModeFromProps(props)) {
      throw new Error("Switching between controlled mode (by using `selectedIndex`) and uncontrolled mode is not supported in `Tabs`.\nFor more information about controlled and uncontrolled mode of react-tabs see the README.");
    }

    var newState = {
      focus: focus,
      mode: Tabs.getModeFromProps(props)
    };

    if (newState.mode === MODE_UNCONTROLLED) {
      var maxTabIndex = Object(_helpers_count__WEBPACK_IMPORTED_MODULE_4__["getTabsCount"])(props.children) - 1;
      var selectedIndex = null;

      if (state.selectedIndex != null) {
        selectedIndex = Math.min(state.selectedIndex, maxTabIndex);
      } else {
        selectedIndex = props.defaultIndex || 0;
      }

      newState.selectedIndex = selectedIndex;
    }

    return newState;
  };

  var _proto = Tabs.prototype;

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        defaultIndex = _this$props.defaultIndex,
        defaultFocus = _this$props.defaultFocus,
        props = _objectWithoutPropertiesLoose(_this$props, ["children", "defaultIndex", "defaultFocus"]);

    var _this$state = this.state,
        focus = _this$state.focus,
        selectedIndex = _this$state.selectedIndex;
    props.focus = focus;
    props.onSelect = this.handleSelected;

    if (selectedIndex != null) {
      props.selectedIndex = selectedIndex;
    }

    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_UncontrolledTabs__WEBPACK_IMPORTED_MODULE_3__["default"], props, children);
  };

  return Tabs;
}(react__WEBPACK_IMPORTED_MODULE_1__["Component"]);

Tabs.defaultProps = {
  defaultFocus: false,
  forceRenderTabPanel: false,
  selectedIndex: null,
  defaultIndex: null
};

Tabs.propTypes =  true ? {
  children: _helpers_propTypes__WEBPACK_IMPORTED_MODULE_2__["childrenPropType"],
  direction: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOf(['rtl', 'ltr']),
  className: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.array, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object]),
  defaultFocus: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  defaultIndex: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,
  disabledTabClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  domRef: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,
  forceRenderTabPanel: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  onSelect: _helpers_propTypes__WEBPACK_IMPORTED_MODULE_2__["onSelectPropType"],
  selectedIndex: _helpers_propTypes__WEBPACK_IMPORTED_MODULE_2__["selectedIndexPropType"],
  selectedTabClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  selectedTabPanelClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string
} : undefined;
Tabs.tabsRole = 'Tabs';

/***/ }),

/***/ "./node_modules/react-tabs/esm/components/UncontrolledTabs.js":
/*!********************************************************************!*\
  !*** ./node_modules/react-tabs/esm/components/UncontrolledTabs.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UncontrolledTabs; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
/* harmony import */ var _helpers_uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/uuid */ "./node_modules/react-tabs/esm/helpers/uuid.js");
/* harmony import */ var _helpers_propTypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/propTypes */ "./node_modules/react-tabs/esm/helpers/propTypes.js");
/* harmony import */ var _helpers_count__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/count */ "./node_modules/react-tabs/esm/helpers/count.js");
/* harmony import */ var _helpers_childrenDeepMap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/childrenDeepMap */ "./node_modules/react-tabs/esm/helpers/childrenDeepMap.js");
/* harmony import */ var _helpers_elementTypes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/elementTypes */ "./node_modules/react-tabs/esm/helpers/elementTypes.js");
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }










function isNode(node) {
  return node && 'getAttribute' in node;
} // Determine if a node from event.target is a Tab element


function isTabNode(node) {
  return isNode(node) && node.getAttribute('role') === 'tab';
} // Determine if a tab node is disabled


function isTabDisabled(node) {
  return isNode(node) && node.getAttribute('aria-disabled') === 'true';
}

var canUseActiveElement;

try {
  canUseActiveElement = !!(typeof window !== 'undefined' && window.document && window.document.activeElement);
} catch (e) {
  // Work around for IE bug when accessing document.activeElement in an iframe
  // Refer to the following resources:
  // http://stackoverflow.com/a/10982960/369687
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12733599
  canUseActiveElement = false;
}

var UncontrolledTabs = /*#__PURE__*/function (_Component) {
  _inheritsLoose(UncontrolledTabs, _Component);

  function UncontrolledTabs() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.tabNodes = [];

    _this.handleKeyDown = function (e) {
      var direction = _this.props.direction;

      if (_this.isTabFromContainer(e.target)) {
        var index = _this.props.selectedIndex;
        var preventDefault = false;
        var useSelectedIndex = false;

        if (e.keyCode === 32 || e.keyCode === 13) {
          preventDefault = true;
          useSelectedIndex = false;

          _this.handleClick(e);
        }

        if (e.keyCode === 37 || e.keyCode === 38) {
          // Select next tab to the left
          if (direction === 'rtl') {
            index = _this.getNextTab(index);
          } else {
            index = _this.getPrevTab(index);
          }

          preventDefault = true;
          useSelectedIndex = true;
        } else if (e.keyCode === 39 || e.keyCode === 40) {
          // Select next tab to the right
          if (direction === 'rtl') {
            index = _this.getPrevTab(index);
          } else {
            index = _this.getNextTab(index);
          }

          preventDefault = true;
          useSelectedIndex = true;
        } else if (e.keyCode === 35) {
          // Select last tab (End key)
          index = _this.getLastTab();
          preventDefault = true;
          useSelectedIndex = true;
        } else if (e.keyCode === 36) {
          // Select first tab (Home key)
          index = _this.getFirstTab();
          preventDefault = true;
          useSelectedIndex = true;
        } // This prevents scrollbars from moving around


        if (preventDefault) {
          e.preventDefault();
        } // Only use the selected index in the state if we're not using the tabbed index


        if (useSelectedIndex) {
          _this.setSelected(index, e);
        }
      }
    };

    _this.handleClick = function (e) {
      var node = e.target;

      do {
        if (_this.isTabFromContainer(node)) {
          if (isTabDisabled(node)) {
            return;
          }

          var index = [].slice.call(node.parentNode.children).filter(isTabNode).indexOf(node);

          _this.setSelected(index, e);

          return;
        } // eslint-disable-next-line no-cond-assign

      } while ((node = node.parentNode) != null);
    };

    return _this;
  }

  var _proto = UncontrolledTabs.prototype;

  _proto.setSelected = function setSelected(index, event) {
    // Check index boundary
    if (index < 0 || index >= this.getTabsCount()) return;
    var _this$props = this.props,
        onSelect = _this$props.onSelect,
        selectedIndex = _this$props.selectedIndex; // Call change event handler

    onSelect(index, selectedIndex, event);
  };

  _proto.getNextTab = function getNextTab(index) {
    var count = this.getTabsCount(); // Look for non-disabled tab from index to the last tab on the right

    for (var i = index + 1; i < count; i++) {
      if (!isTabDisabled(this.getTab(i))) {
        return i;
      }
    } // If no tab found, continue searching from first on left to index


    for (var _i = 0; _i < index; _i++) {
      if (!isTabDisabled(this.getTab(_i))) {
        return _i;
      }
    } // No tabs are disabled, return index


    return index;
  };

  _proto.getPrevTab = function getPrevTab(index) {
    var i = index; // Look for non-disabled tab from index to first tab on the left

    while (i--) {
      if (!isTabDisabled(this.getTab(i))) {
        return i;
      }
    } // If no tab found, continue searching from last tab on right to index


    i = this.getTabsCount();

    while (i-- > index) {
      if (!isTabDisabled(this.getTab(i))) {
        return i;
      }
    } // No tabs are disabled, return index


    return index;
  };

  _proto.getFirstTab = function getFirstTab() {
    var count = this.getTabsCount(); // Look for non disabled tab from the first tab

    for (var i = 0; i < count; i++) {
      if (!isTabDisabled(this.getTab(i))) {
        return i;
      }
    }

    return null;
  };

  _proto.getLastTab = function getLastTab() {
    var i = this.getTabsCount(); // Look for non disabled tab from the last tab

    while (i--) {
      if (!isTabDisabled(this.getTab(i))) {
        return i;
      }
    }

    return null;
  };

  _proto.getTabsCount = function getTabsCount() {
    var children = this.props.children;
    return Object(_helpers_count__WEBPACK_IMPORTED_MODULE_5__["getTabsCount"])(children);
  };

  _proto.getPanelsCount = function getPanelsCount() {
    var children = this.props.children;
    return Object(_helpers_count__WEBPACK_IMPORTED_MODULE_5__["getPanelsCount"])(children);
  };

  _proto.getTab = function getTab(index) {
    return this.tabNodes["tabs-" + index];
  };

  _proto.getChildren = function getChildren() {
    var _this2 = this;

    var index = 0;
    var _this$props2 = this.props,
        children = _this$props2.children,
        disabledTabClassName = _this$props2.disabledTabClassName,
        focus = _this$props2.focus,
        forceRenderTabPanel = _this$props2.forceRenderTabPanel,
        selectedIndex = _this$props2.selectedIndex,
        selectedTabClassName = _this$props2.selectedTabClassName,
        selectedTabPanelClassName = _this$props2.selectedTabPanelClassName;
    this.tabIds = this.tabIds || [];
    this.panelIds = this.panelIds || [];
    var diff = this.tabIds.length - this.getTabsCount(); // Add ids if new tabs have been added
    // Don't bother removing ids, just keep them in case they are added again
    // This is more efficient, and keeps the uuid counter under control

    while (diff++ < 0) {
      this.tabIds.push(Object(_helpers_uuid__WEBPACK_IMPORTED_MODULE_3__["default"])());
      this.panelIds.push(Object(_helpers_uuid__WEBPACK_IMPORTED_MODULE_3__["default"])());
    } // Map children to dynamically setup refs


    return Object(_helpers_childrenDeepMap__WEBPACK_IMPORTED_MODULE_6__["deepMap"])(children, function (child) {
      var result = child; // Clone TabList and Tab components to have refs

      if (Object(_helpers_elementTypes__WEBPACK_IMPORTED_MODULE_7__["isTabList"])(child)) {
        var listIndex = 0; // Figure out if the current focus in the DOM is set on a Tab
        // If it is we should keep the focus on the next selected tab

        var wasTabFocused = false;

        if (canUseActiveElement) {
          wasTabFocused = react__WEBPACK_IMPORTED_MODULE_1___default.a.Children.toArray(child.props.children).filter(_helpers_elementTypes__WEBPACK_IMPORTED_MODULE_7__["isTab"]).some(function (tab, i) {
            return document.activeElement === _this2.getTab(i);
          });
        }

        result = Object(react__WEBPACK_IMPORTED_MODULE_1__["cloneElement"])(child, {
          children: Object(_helpers_childrenDeepMap__WEBPACK_IMPORTED_MODULE_6__["deepMap"])(child.props.children, function (tab) {
            var key = "tabs-" + listIndex;
            var selected = selectedIndex === listIndex;
            var props = {
              tabRef: function tabRef(node) {
                _this2.tabNodes[key] = node;
              },
              id: _this2.tabIds[listIndex],
              panelId: _this2.panelIds[listIndex],
              selected: selected,
              focus: selected && (focus || wasTabFocused)
            };
            if (selectedTabClassName) props.selectedClassName = selectedTabClassName;
            if (disabledTabClassName) props.disabledClassName = disabledTabClassName;
            listIndex++;
            return Object(react__WEBPACK_IMPORTED_MODULE_1__["cloneElement"])(tab, props);
          })
        });
      } else if (Object(_helpers_elementTypes__WEBPACK_IMPORTED_MODULE_7__["isTabPanel"])(child)) {
        var props = {
          id: _this2.panelIds[index],
          tabId: _this2.tabIds[index],
          selected: selectedIndex === index
        };
        if (forceRenderTabPanel) props.forceRender = forceRenderTabPanel;
        if (selectedTabPanelClassName) props.selectedClassName = selectedTabPanelClassName;
        index++;
        result = Object(react__WEBPACK_IMPORTED_MODULE_1__["cloneElement"])(child, props);
      }

      return result;
    });
  };

  /**
   * Determine if a node from event.target is a Tab element for the current Tabs container.
   * If the clicked element is not a Tab, it returns false.
   * If it finds another Tabs container between the Tab and `this`, it returns false.
   */
  _proto.isTabFromContainer = function isTabFromContainer(node) {
    // return immediately if the clicked element is not a Tab.
    if (!isTabNode(node)) {
      return false;
    } // Check if the first occurrence of a Tabs container is `this` one.


    var nodeAncestor = node.parentElement;

    do {
      if (nodeAncestor === this.node) return true;
      if (nodeAncestor.getAttribute('data-tabs')) break;
      nodeAncestor = nodeAncestor.parentElement;
    } while (nodeAncestor);

    return false;
  };

  _proto.render = function render() {
    var _this3 = this;

    // Delete all known props, so they don't get added to DOM
    var _this$props3 = this.props,
        children = _this$props3.children,
        className = _this$props3.className,
        disabledTabClassName = _this$props3.disabledTabClassName,
        domRef = _this$props3.domRef,
        focus = _this$props3.focus,
        forceRenderTabPanel = _this$props3.forceRenderTabPanel,
        onSelect = _this$props3.onSelect,
        selectedIndex = _this$props3.selectedIndex,
        selectedTabClassName = _this$props3.selectedTabClassName,
        selectedTabPanelClassName = _this$props3.selectedTabPanelClassName,
        attributes = _objectWithoutPropertiesLoose(_this$props3, ["children", "className", "disabledTabClassName", "domRef", "focus", "forceRenderTabPanel", "onSelect", "selectedIndex", "selectedTabClassName", "selectedTabPanelClassName"]);

    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", _extends({}, attributes, {
      className: Object(clsx__WEBPACK_IMPORTED_MODULE_2__["default"])(className),
      onClick: this.handleClick,
      onKeyDown: this.handleKeyDown,
      ref: function ref(node) {
        _this3.node = node;
        if (domRef) domRef(node);
      },
      "data-tabs": true
    }), this.getChildren());
  };

  return UncontrolledTabs;
}(react__WEBPACK_IMPORTED_MODULE_1__["Component"]);

UncontrolledTabs.defaultProps = {
  className: 'react-tabs',
  focus: false
};

UncontrolledTabs.propTypes =  true ? {
  children: _helpers_propTypes__WEBPACK_IMPORTED_MODULE_4__["childrenPropType"],
  direction: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOf(['rtl', 'ltr']),
  className: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.array, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object]),
  disabledTabClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  domRef: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,
  focus: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  forceRenderTabPanel: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  onSelect: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func.isRequired,
  selectedIndex: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,
  selectedTabClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  selectedTabPanelClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string
} : undefined;

/***/ }),

/***/ "./node_modules/react-tabs/esm/helpers/childrenDeepMap.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-tabs/esm/helpers/childrenDeepMap.js ***!
  \****************************************************************/
/*! exports provided: deepMap, deepForEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepMap", function() { return deepMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepForEach", function() { return deepForEach; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _elementTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elementTypes */ "./node_modules/react-tabs/esm/helpers/elementTypes.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




function isTabChild(child) {
  return Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTab"])(child) || Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTabList"])(child) || Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTabPanel"])(child);
}

function deepMap(children, callback) {
  return react__WEBPACK_IMPORTED_MODULE_0__["Children"].map(children, function (child) {
    // null happens when conditionally rendering TabPanel/Tab
    // see https://github.com/reactjs/react-tabs/issues/37
    if (child === null) return null;

    if (isTabChild(child)) {
      return callback(child);
    }

    if (child.props && child.props.children && typeof child.props.children === 'object') {
      // Clone the child that has children and map them too
      return Object(react__WEBPACK_IMPORTED_MODULE_0__["cloneElement"])(child, _objectSpread(_objectSpread({}, child.props), {}, {
        children: deepMap(child.props.children, callback)
      }));
    }

    return child;
  });
}
function deepForEach(children, callback) {
  return react__WEBPACK_IMPORTED_MODULE_0__["Children"].forEach(children, function (child) {
    // null happens when conditionally rendering TabPanel/Tab
    // see https://github.com/reactjs/react-tabs/issues/37
    if (child === null) return;

    if (Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTab"])(child) || Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTabPanel"])(child)) {
      callback(child);
    } else if (child.props && child.props.children && typeof child.props.children === 'object') {
      if (Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTabList"])(child)) callback(child);
      deepForEach(child.props.children, callback);
    }
  });
}

/***/ }),

/***/ "./node_modules/react-tabs/esm/helpers/count.js":
/*!******************************************************!*\
  !*** ./node_modules/react-tabs/esm/helpers/count.js ***!
  \******************************************************/
/*! exports provided: getTabsCount, getPanelsCount */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTabsCount", function() { return getTabsCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPanelsCount", function() { return getPanelsCount; });
/* harmony import */ var _childrenDeepMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./childrenDeepMap */ "./node_modules/react-tabs/esm/helpers/childrenDeepMap.js");
/* harmony import */ var _elementTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elementTypes */ "./node_modules/react-tabs/esm/helpers/elementTypes.js");


function getTabsCount(children) {
  var tabCount = 0;
  Object(_childrenDeepMap__WEBPACK_IMPORTED_MODULE_0__["deepForEach"])(children, function (child) {
    if (Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTab"])(child)) tabCount++;
  });
  return tabCount;
}
function getPanelsCount(children) {
  var panelCount = 0;
  Object(_childrenDeepMap__WEBPACK_IMPORTED_MODULE_0__["deepForEach"])(children, function (child) {
    if (Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTabPanel"])(child)) panelCount++;
  });
  return panelCount;
}

/***/ }),

/***/ "./node_modules/react-tabs/esm/helpers/elementTypes.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-tabs/esm/helpers/elementTypes.js ***!
  \*************************************************************/
/*! exports provided: isTab, isTabList, isTabPanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTab", function() { return isTab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTabList", function() { return isTabList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTabPanel", function() { return isTabPanel; });
function makeTypeChecker(tabsRole) {
  return function (element) {
    return !!element.type && element.type.tabsRole === tabsRole;
  };
}

var isTab = makeTypeChecker('Tab');
var isTabList = makeTypeChecker('TabList');
var isTabPanel = makeTypeChecker('TabPanel');

/***/ }),

/***/ "./node_modules/react-tabs/esm/helpers/propTypes.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-tabs/esm/helpers/propTypes.js ***!
  \**********************************************************/
/*! exports provided: childrenPropType, onSelectPropType, selectedIndexPropType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "childrenPropType", function() { return childrenPropType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onSelectPropType", function() { return onSelectPropType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectedIndexPropType", function() { return selectedIndexPropType; });
/* harmony import */ var _childrenDeepMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./childrenDeepMap */ "./node_modules/react-tabs/esm/helpers/childrenDeepMap.js");
/* harmony import */ var _elementTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elementTypes */ "./node_modules/react-tabs/esm/helpers/elementTypes.js");


function childrenPropType(props, propName, componentName) {
  var error;
  var tabsCount = 0;
  var panelsCount = 0;
  var tabListFound = false;
  var listTabs = [];
  var children = props[propName];
  Object(_childrenDeepMap__WEBPACK_IMPORTED_MODULE_0__["deepForEach"])(children, function (child) {
    if (Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTabList"])(child)) {
      if (child.props && child.props.children && typeof child.props.children === 'object') {
        Object(_childrenDeepMap__WEBPACK_IMPORTED_MODULE_0__["deepForEach"])(child.props.children, function (listChild) {
          return listTabs.push(listChild);
        });
      }

      if (tabListFound) {
        error = new Error("Found multiple 'TabList' components inside 'Tabs'. Only one is allowed.");
      }

      tabListFound = true;
    }

    if (Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTab"])(child)) {
      if (!tabListFound || listTabs.indexOf(child) === -1) {
        error = new Error("Found a 'Tab' component outside of the 'TabList' component. 'Tab' components " + "have to be inside the 'TabList' component.");
      }

      tabsCount++;
    } else if (Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTabPanel"])(child)) {
      panelsCount++;
    }
  });

  if (!error && tabsCount !== panelsCount) {
    error = new Error("There should be an equal number of 'Tab' and 'TabPanel' in `" + componentName + "`. " + ("Received " + tabsCount + " 'Tab' and " + panelsCount + " 'TabPanel'."));
  }

  return error;
}
function onSelectPropType(props, propName, componentName, location, propFullName) {
  var prop = props[propName];
  var name = propFullName || propName;
  var error = null;

  if (prop && typeof prop !== 'function') {
    error = new Error("Invalid " + location + " `" + name + "` of type `" + typeof prop + "` supplied " + ("to `" + componentName + "`, expected `function`."));
  } else if (props.selectedIndex != null && prop == null) {
    error = new Error("The " + location + " `" + name + "` is marked as required in `" + componentName + "`, but " + "its value is `undefined` or `null`.\n" + "`onSelect` is required when `selectedIndex` is also set. Not doing so will " + "make the tabs not do anything, as `selectedIndex` indicates that you want to " + "handle the selected tab yourself.\n" + "If you only want to set the inital tab replace `selectedIndex` with `defaultIndex`.");
  }

  return error;
}
function selectedIndexPropType(props, propName, componentName, location, propFullName) {
  var prop = props[propName];
  var name = propFullName || propName;
  var error = null;

  if (prop != null && typeof prop !== 'number') {
    error = new Error("Invalid " + location + " `" + name + "` of type `" + typeof prop + "` supplied to " + ("`" + componentName + "`, expected `number`."));
  } else if (props.defaultIndex != null && prop != null) {
    return new Error("The " + location + " `" + name + "` cannot be used together with `defaultIndex` " + ("in `" + componentName + "`.\n") + ("Either remove `" + name + "` to let `" + componentName + "` handle the selected ") + "tab internally or remove `defaultIndex` to handle it yourself.");
  }

  return error;
}

/***/ }),

/***/ "./node_modules/react-tabs/esm/helpers/uuid.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-tabs/esm/helpers/uuid.js ***!
  \*****************************************************/
/*! exports provided: default, reset */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return uuid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reset", function() { return reset; });
// Get a universally unique identifier
var count = 0;
function uuid() {
  return "react-tabs-" + count++;
}
function reset() {
  count = 0;
}

/***/ }),

/***/ "./node_modules/react-tabs/esm/index.js":
/*!**********************************************!*\
  !*** ./node_modules/react-tabs/esm/index.js ***!
  \**********************************************/
/*! exports provided: Tabs, TabList, Tab, TabPanel, resetIdCounter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _components_Tabs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/Tabs */ "./node_modules/react-tabs/esm/components/Tabs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tabs", function() { return _components_Tabs__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _components_TabList__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/TabList */ "./node_modules/react-tabs/esm/components/TabList.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TabList", function() { return _components_TabList__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _components_Tab__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/Tab */ "./node_modules/react-tabs/esm/components/Tab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tab", function() { return _components_Tab__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _components_TabPanel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/TabPanel */ "./node_modules/react-tabs/esm/components/TabPanel.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TabPanel", function() { return _components_TabPanel__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _helpers_uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers/uuid */ "./node_modules/react-tabs/esm/helpers/uuid.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resetIdCounter", function() { return _helpers_uuid__WEBPACK_IMPORTED_MODULE_4__["reset"]; });







/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentName(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (Array.isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (Array.isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    if (type === exports.Fragment) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev

var jsxDEV$1 =  jsxWithValidation ;

exports.jsxDEV = jsxDEV$1;
  })();
}


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.1';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
exports.StrictMode = 0xeacc;
exports.Profiler = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
exports.Suspense = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  exports.StrictMode = symbolFor('react.strict_mode');
  exports.Profiler = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  exports.Suspense = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  transition: 0
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var ReactDebugCurrentFrame = {};
var currentExtraStackFrame = null;
function setExtraStackFrame(stack) {
  {
    currentExtraStackFrame = stack;
  }
}

{
  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
    {
      currentExtraStackFrame = stack;
    }
  }; // Stack implementation injected by the current renderer.


  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentExtraStackFrame) {
      stack += currentExtraStackFrame;
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

/**
 * Used by act() to track whether you're inside an act() scope.
 */
var IsSomeRendererActing = {
  current: false
};

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner,
  IsSomeRendererActing: IsSomeRendererActing,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
}

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
    }
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

_assign(pureComponentPrototype, Component.prototype);

pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case exports.Profiler:
      return 'Profiler';

    case exports.StrictMode:
      return 'StrictMode';

    case exports.Suspense:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

function warnIfStringRefCannotBeAutoConverted(config) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (!!(element === null || element === undefined)) {
    {
      throw Error( "React.cloneElement(...): The argument must be a React element, but you passed " + element + "." );
    }
  }

  var propName; // Original props are copied

  var props = _assign({}, element.props); // Reserved names are extracted


  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = key.replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return text.replace(userProvidedKeyEscapeRegex, '$&/');
}
/**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getElementKey(element, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof element === 'object' && element !== null && element.key != null) {
    // Explicit key
    return escape('' + element.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    var _child = children;
    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows:

    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

    if (Array.isArray(mappedChild)) {
      var escapedChildKey = '';

      if (childKey != null) {
        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
      }

      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
        return c;
      });
    } else if (mappedChild != null) {
      if (isValidElement(mappedChild)) {
        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
      }

      array.push(mappedChild);
    }

    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getElementKey(child, i);
      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {
      var iterableChildren = children;

      {
        // Warn about using Maps as children
        if (iteratorFn === iterableChildren.entries) {
          if (!didWarnAboutMaps) {
            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
          }

          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(iterableChildren);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getElementKey(child, ii++);
        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
      }
    } else if (type === 'object') {
      var childrenString = '' + children;

      {
        {
          throw Error( "Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead." );
        }
      }
    }
  }

  return subtreeCount;
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  var count = 0;
  mapIntoArray(children, result, '', '', function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  var n = 0;
  mapChildren(children, function () {
    n++; // Don't return anything
  });
  return n;
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  mapChildren(children, function () {
    forEachFunc.apply(this, arguments); // Don't return anything.
  }, forEachContext);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  return mapChildren(children, function (child) {
    return child;
  }) || [];
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    {
      throw Error( "React.Children.only expected to receive a single React element child." );
    }
  }

  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
      }
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;
  var hasWarnedAboutDisplayNameOnConsumer = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;

            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;

            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      },
      displayName: {
        get: function () {
          return context.displayName;
        },
        set: function (displayName) {
          if (!hasWarnedAboutDisplayNameOnConsumer) {
            warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

            hasWarnedAboutDisplayNameOnConsumer = true;
          }
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

var Uninitialized = -1;
var Pending = 0;
var Resolved = 1;
var Rejected = 2;

function lazyInitializer(payload) {
  if (payload._status === Uninitialized) {
    var ctor = payload._result;
    var thenable = ctor(); // Transition to the next state.

    var pending = payload;
    pending._status = Pending;
    pending._result = thenable;
    thenable.then(function (moduleObject) {
      if (payload._status === Pending) {
        var defaultExport = moduleObject.default;

        {
          if (defaultExport === undefined) {
            error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
          }
        } // Transition to the next state.


        var resolved = payload;
        resolved._status = Resolved;
        resolved._result = defaultExport;
      }
    }, function (error) {
      if (payload._status === Pending) {
        // Transition to the next state.
        var rejected = payload;
        rejected._status = Rejected;
        rejected._result = error;
      }
    });
  }

  if (payload._status === Resolved) {
    return payload._result;
  } else {
    throw payload._result;
  }
}

function lazy(ctor) {
  var payload = {
    // We use these fields to store the result.
    _status: -1,
    _result: ctor
  };
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _payload: payload,
    _init: lazyInitializer
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes; // $FlowFixMe

    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          defaultProps = newDefaultProps; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          propTypes = newPropTypes; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      if (render.length !== 0 && render.length !== 2) {
        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
      }
    }

    if (render != null) {
      if (render.defaultProps != null || render.propTypes != null) {
        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
      }
    }
  }

  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (render.displayName == null) {
          render.displayName = name;
        }
      }
    });
  }

  return elementType;
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  var elementType = {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (type.displayName == null) {
          type.displayName = name;
        }
      }
    });
  }

  return elementType;
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  if (!(dispatcher !== null)) {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }

  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();

  {
    if (unstable_observedBits !== undefined) {
      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');
    } // TODO: add a more generic warning for invalid values.


    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context, unstable_observedBits);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
function useLayoutEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
function useCallback(callback, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, deps);
}
function useMemo(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
function useImperativeHandle(ref, create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, deps);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher$1.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher$1.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case exports.Suspense:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      setExtraStackFrame(stack);
    } else {
      setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
  }

  {
    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    {
      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === exports.Fragment) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
var didWarnAboutDeprecatedCreateFactory = false;
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;

  {
    if (!didWarnAboutDeprecatedCreateFactory) {
      didWarnAboutDeprecatedCreateFactory = true;

      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
    } // Legacy hook: remove it


    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

{

  try {
    var frozenObject = Object.freeze({});
    /* eslint-disable no-new */

    new Map([[frozenObject, null]]);
    new Set([frozenObject]);
    /* eslint-enable no-new */
  } catch (e) {
  }
}

var createElement$1 =  createElementWithValidation ;
var cloneElement$1 =  cloneElementWithValidation ;
var createFactory =  createFactoryWithValidation ;
var Children = {
  map: mapChildren,
  forEach: forEachChildren,
  count: countChildren,
  toArray: toArray,
  only: onlyChild
};

exports.Children = Children;
exports.Component = Component;
exports.PureComponent = PureComponent;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
exports.cloneElement = cloneElement$1;
exports.createContext = createContext;
exports.createElement = createElement$1;
exports.createFactory = createFactory;
exports.createRef = createRef;
exports.forwardRef = forwardRef;
exports.isValidElement = isValidElement;
exports.lazy = lazy;
exports.memo = memo;
exports.useCallback = useCallback;
exports.useContext = useContext;
exports.useDebugValue = useDebugValue;
exports.useEffect = useEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemo = useMemo;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useState = useState;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js");
}


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./pages/portfolio.js":
/*!****************************!*\
  !*** ./pages/portfolio.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Despre; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _components_page_components_parteneri__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/page_components/parteneri */ "./components/page_components/parteneri.js");


var _jsxFileName = "G:\\MDMax\\go brasov\\site_nextjs\\gobv-site\\pages\\portfolio.js";

function Despre() {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["Fragment"], {
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_page_components_parteneri__WEBPACK_IMPORTED_MODULE_1__["default"], {}, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 5,
      columnNumber: 9
    }, this)
  }, void 0, false);
}
_c = Despre;

var _c;

$RefreshReg$(_c, "Despre");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ })

},[["./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Fportfolio&absolutePagePath=G%3A%5CMDMax%5Cgo%20brasov%5Csite_nextjs%5Cgobv-site%5Cpages%5Cportfolio.js!./","webpack"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9jb21tb24vSGVhZGxpbmUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvY29tbW9uL3BvcnRvZm9saXUvY2FyZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9jb21tb24vdGFibGVzL3BhcnRlbmVyaV90YWJsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9wYWdlX2NvbXBvbmVudHMvcGFydGVuZXJpLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvb2JqZWN0LWFzc2lnbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1jbGllbnQtcGFnZXMtbG9hZGVyLmpzIiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L2xpbmsudHN4Iiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvd2l0aC1yb3V0ZXIudHN4Iiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL21pdHQudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyLWNvbnRleHQudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlci50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvZXNjYXBlLXBhdGgtZGVsaW1pdGVycy50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9wYXRoLW1hdGNoLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9wcmVwYXJlLWRlc3RpbmF0aW9uLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZy50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcmVzb2x2ZS1yZXdyaXRlcy50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXgudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvdXRpbHMudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvc2VydmVyL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbGluay5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtc3lzdGVtL2J1aWxkL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtc3lzdGVtL2J1aWxkL2NvbnRleHQvU2NyZWVuQ2xhc3NQcm92aWRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtc3lzdGVtL2J1aWxkL2NvbnRleHQvU2NyZWVuQ2xhc3NSZXNvbHZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtc3lzdGVtL2J1aWxkL2dyaWQvQ29sL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1zeXN0ZW0vYnVpbGQvZ3JpZC9Db2wvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLXN5c3RlbS9idWlsZC9ncmlkL0NvbnRhaW5lci9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtc3lzdGVtL2J1aWxkL2dyaWQvQ29udGFpbmVyL3N0eWxlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1zeXN0ZW0vYnVpbGQvZ3JpZC9Sb3cvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLXN5c3RlbS9idWlsZC9ncmlkL1Jvdy9zdHlsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtc3lzdGVtL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1zeXN0ZW0vYnVpbGQvcHJpbWl0aXZlcy9EaXYvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLXN5c3RlbS9idWlsZC9wcmltaXRpdmVzL1NwYW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLXN5c3RlbS9idWlsZC9wcmltaXRpdmVzL1dpbmRvdy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtc3lzdGVtL2J1aWxkL3ByaW1pdGl2ZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLXN5c3RlbS9idWlsZC91dGlsaXRpZXMvSGlkZGVuL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1zeXN0ZW0vYnVpbGQvdXRpbGl0aWVzL0hpZGRlbi9zdHlsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtc3lzdGVtL2J1aWxkL3V0aWxpdGllcy9TY3JlZW5DbGFzc1JlbmRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtc3lzdGVtL2J1aWxkL3V0aWxpdGllcy9WaXNpYmxlL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1zeXN0ZW0vYnVpbGQvdXRpbGl0aWVzL1Zpc2libGUvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLXN5c3RlbS9idWlsZC91dGlscy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFicy9lc20vY29tcG9uZW50cy9UYWIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC10YWJzL2VzbS9jb21wb25lbnRzL1RhYkxpc3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC10YWJzL2VzbS9jb21wb25lbnRzL1RhYlBhbmVsLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFicy9lc20vY29tcG9uZW50cy9UYWJzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFicy9lc20vY29tcG9uZW50cy9VbmNvbnRyb2xsZWRUYWJzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFicy9lc20vaGVscGVycy9jaGlsZHJlbkRlZXBNYXAuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC10YWJzL2VzbS9oZWxwZXJzL2NvdW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFicy9lc20vaGVscGVycy9lbGVtZW50VHlwZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC10YWJzL2VzbS9oZWxwZXJzL3Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRhYnMvZXNtL2hlbHBlcnMvdXVpZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRhYnMvZXNtL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovL19OX0UvKHdlYnBhY2spL2J1aWxkaW4vaGFybW9ueS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL3BvcnRmb2xpby5qcyJdLCJuYW1lcyI6WyJIZWFkbGluZSIsInByb3BzIiwibGFiZWwiLCJ0aXRsZSIsInN1YnRpdGxlIiwiZGl2aWRlcl8xIiwiZGl2aWRlcl8yIiwicG9zaXRpb24iLCJjbGFzc05hbWUiLCJDYXJkcyIsInBvcnRmb2xpbyIsIm1hcCIsImNhdGVnb3J5IiwiY2F0ZWdvcnlJbmRleCIsIm5hbWUiLCJpdGVtcyIsIml0ZW0iLCJpbmRleCIsImxpbmsiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJpbWFnZSIsInBhcnRlbmVyaV90YWJsZSIsInRodW1ibmFpbCIsIlBhcnRlbmVyaSIsImxpc3RlbmVycyIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwid2luZG93IiwicHJlZmV0Y2hlZCIsImNhY2hlZE9ic2VydmVyIiwiZW50cmllcyIsImVudHJ5IiwiY2IiLCJyb290TWFyZ2luIiwibGlzdGVuVG9JbnRlcnNlY3Rpb25zIiwib2JzZXJ2ZXIiLCJnZXRPYnNlcnZlciIsImNvbnNvbGUiLCJyb3V0ZXIiLCJlcnIiLCJocmVmIiwiZXZlbnQiLCJ0YXJnZXQiLCJlIiwibm9kZU5hbWUiLCJpc01vZGlmaWVkRXZlbnQiLCJzY3JvbGwiLCJhcyIsInJlcGxhY2UiLCJzaGFsbG93IiwibG9jYWxlIiwic3VjY2VzcyIsImRvY3VtZW50IiwiYXJncyIsImtleSIsImV4cGVjdGVkIiwicmVxdWlyZWRQcm9wc0d1YXJkIiwicmVxdWlyZWRQcm9wcyIsIk9iamVjdCIsImNyZWF0ZVByb3BFcnJvciIsImFjdHVhbCIsIl8iLCJvcHRpb25hbFByb3BzR3VhcmQiLCJwYXNzSHJlZiIsInByZWZldGNoIiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJoYXNXYXJuZWQiLCJSZWFjdCIsInAiLCJwYXRobmFtZSIsInJlc29sdmVkQXMiLCJjaGlsZEVsbSIsImlzUHJlZmV0Y2hlZCIsImNoaWxkcmVuIiwiY2hpbGQiLCJDaGlsZHJlbiIsImNoaWxkUHJvcHMiLCJyZWYiLCJlbCIsInNldENoaWxkRWxtIiwib25DbGljayIsImxpbmtDbGlja2VkIiwicHJpb3JpdHkiLCJMaW5rIiwicGF0aCIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwicHJvY2VzcyIsInNpbmdsZXRvblJvdXRlciIsInJlYWR5Q2FsbGJhY2tzIiwicmVhZHkiLCJ1cmxQcm9wZXJ0eUZpZWxkcyIsInJvdXRlckV2ZW50cyIsImNvcmVNZXRob2RGaWVsZHMiLCJnZXQiLCJSb3V0ZXIiLCJmaWVsZCIsImdldFJvdXRlciIsImV2ZW50RmllbGQiLCJfc2luZ2xldG9uUm91dGVyIiwibWVzc2FnZSIsIlJvdXRlckNvbnRleHQiLCJjcmVhdGVSb3V0ZXIiLCJfcm91dGVyIiwiaW5zdGFuY2UiLCJBcnJheSIsIkNvbXBvc2VkQ29tcG9uZW50IiwiZ2V0SW5pdGlhbFByb3BzIiwiV2l0aFJvdXRlcldyYXBwZXIiLCJhbGwiLCJvbiIsIm9mZiIsImVtaXQiLCJoYW5kbGVyIiwiYmFzZVBhdGgiLCJjYW5jZWxsZWQiLCJwcmVmaXgiLCJhZGRQYXRoUHJlZml4IiwidXJsIiwibG9jYXRpb25PcmlnaW4iLCJyZXNvbHZlZCIsImhhc0Jhc2VQYXRoIiwiaW50ZXJwb2xhdGVkUm91dGUiLCJkeW5hbWljUmVnZXgiLCJkeW5hbWljR3JvdXBzIiwiZHluYW1pY01hdGNoZXMiLCJhc1BhdGhuYW1lIiwicGFyYW1zIiwicGFyYW0iLCJ2YWx1ZSIsInJlcGxhY2VkIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJlc2NhcGVQYXRoRGVsaW1pdGVycyIsInJlc3VsdCIsImZpbHRlcmVkUXVlcnkiLCJxdWVyeSIsImJhc2UiLCJ1cmxBc1N0cmluZyIsImZpbmFsVXJsIiwiaW50ZXJwb2xhdGVkQXMiLCJpbnRlcnBvbGF0ZUFzIiwiaGFzaCIsIm9taXRQYXJtc0Zyb21RdWVyeSIsInJlc29sdmVkSHJlZiIsInJlc29sdmVBcyIsIlBBR0VfTE9BRF9FUlJPUiIsIlN5bWJvbCIsImFkZEJhc2VQYXRoIiwicmVzb2x2ZUhyZWYiLCJtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiIsIlNTR19EQVRBX05PVF9GT1VORF9FUlJPUiIsImNyZWRlbnRpYWxzIiwicmVzIiwiYXR0ZW1wdHMiLCJmZXRjaFJldHJ5IiwiaXNTZXJ2ZXJSZW5kZXIiLCJtYXJrTG9hZGluZ0Vycm9yIiwiY29uc3RydWN0b3IiLCJyb3V0ZSIsImFzUGF0aCIsImNvbXBvbmVudHMiLCJzZGMiLCJzdWIiLCJjbGMiLCJwYWdlTG9hZGVyIiwiX2JwcyIsImV2ZW50cyIsIl93cmFwQXBwIiwiaXNTc3IiLCJpc0ZhbGxiYWNrIiwiX2luRmxpZ2h0Um91dGUiLCJfc2hhbGxvdyIsImxvY2FsZXMiLCJkZWZhdWx0TG9jYWxlIiwic3RhdGUiLCJvcHRpb25zIiwiQ29tcG9uZW50Iiwic3R5bGVTaGVldHMiLCJfX05fU1NHIiwiaW5pdGlhbFByb3BzIiwiX19OX1NTUCIsIl9fTkVYVF9EQVRBX18iLCJyZWxvYWQiLCJiYWNrIiwicHVzaCIsInByZXBhcmVVcmxBcyIsImlzTG9jYWxVUkwiLCJTVCIsInBlcmZvcm1hbmNlIiwiYWRkTG9jYWxlIiwiY2xlYW5lZEFzIiwiZGVsTG9jYWxlIiwiZGVsQmFzZVBhdGgiLCJwYWdlcyIsIl9fcmV3cml0ZXMiLCJwYXJzZWQiLCJtZXRob2QiLCJwb3RlbnRpYWxIcmVmIiwicGFyc2VkQXMiLCJyb3V0ZVJlZ2V4Iiwicm91dGVNYXRjaCIsInNob3VsZEludGVycG9sYXRlIiwibWlzc2luZ1BhcmFtcyIsInJvdXRlSW5mbyIsImRlc3RpbmF0aW9uIiwicGFyc2VkSHJlZiIsImFwcENvbXAiLCJlcnJvciIsIl9fTiIsImJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IiLCJzc2c0MDQiLCJwYWdlIiwibW9kIiwiY2FjaGVkUm91dGVJbmZvIiwicmVxdWlyZSIsImlzVmFsaWRFbGVtZW50VHlwZSIsImRhdGFIcmVmIiwiYmVmb3JlUG9wU3RhdGUiLCJvbmx5QUhhc2hDaGFuZ2UiLCJuZXdIYXNoIiwib2xkVXJsTm9IYXNoIiwib2xkSGFzaCIsInNjcm9sbFRvSGFzaCIsImlkRWwiLCJuYW1lRWwiLCJ1cmxJc05ldyIsIl9yZXNvbHZlSHJlZiIsImFwcGx5QmFzZVBhdGgiLCJjbGVhblBhdGhuYW1lIiwiUHJvbWlzZSIsImNhbmNlbCIsImNvbXBvbmVudFJlc3VsdCIsImZuIiwiZGF0YSIsIl9nZXRTdGF0aWNEYXRhIiwiZmV0Y2hOZXh0RGF0YSIsIl9nZXRTZXJ2ZXJEYXRhIiwiQXBwVHJlZSIsImN0eCIsImFib3J0Q29tcG9uZW50TG9hZCIsIm5vdGlmeSIsInNlZ21lbnQiLCJjaGFyIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2xhc2hlZFByb3RvY29scyIsInByb3RvY29sIiwidXJsT2JqIiwiaG9zdCIsImF1dGgiLCJob3N0bmFtZSIsIlN0cmluZyIsInF1ZXJ5c3RyaW5nIiwic2VhcmNoIiwiVEVTVF9ST1VURSIsIkRVTU1ZX0JBU0UiLCJyZXNvbHZlZEJhc2UiLCJvcmlnaW4iLCJtYXRjaGVyT3B0aW9ucyIsInNlbnNpdGl2ZSIsImRlbGltaXRlciIsImN1c3RvbVJvdXRlTWF0Y2hlck9wdGlvbnMiLCJzdHJpY3QiLCJjdXN0b21Sb3V0ZSIsImtleXMiLCJtYXRjaGVyUmVnZXgiLCJwYXRoVG9SZWdleHAiLCJtYXRjaGVyIiwicGFyc2VkRGVzdGluYXRpb24iLCJwb3J0IiwiZGVzdFF1ZXJ5IiwiZGVzdFBhdGgiLCJkZXN0UGF0aFBhcmFtS2V5cyIsImRlc3RQYXRoUGFyYW1zIiwiZGVzdGluYXRpb25Db21waWxlciIsInZhbGlkYXRlIiwic3RyT3JBcnJheSIsInF1ZXJ5Q29tcGlsZXIiLCJwYXJhbUtleXMiLCJhcHBlbmRQYXJhbXNUb1F1ZXJ5Iiwic2hvdWxkQWRkQmFzZVBhdGgiLCJuZXdVcmwiLCJzZWFyY2hQYXJhbXMiLCJpc05hTiIsInN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0iLCJzZWFyY2hQYXJhbXNMaXN0IiwiY3VzdG9tUm91dGVNYXRjaGVyIiwicmV3cml0ZSIsImRlc3RSZXMiLCJyZSIsImRlY29kZSIsImRlY29kZVVSSUNvbXBvbmVudCIsInNsdWdOYW1lIiwiZyIsImdyb3VwcyIsIm0iLCJzdHIiLCJzZWdtZW50cyIsIm5vcm1hbGl6ZWRSb3V0ZSIsImdyb3VwSW5kZXgiLCJwYXJhbWV0ZXJpemVkUm91dGUiLCJwYXJzZVBhcmFtZXRlciIsInBvcyIsImVzY2FwZVJlZ2V4IiwidXNlZCIsImdldExvY2F0aW9uT3JpZ2luIiwiQXBwIiwiZ2V0RGlzcGxheU5hbWUiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwicGFnZVByb3BzIiwiaXNSZXNTZW50IiwidXJsT2JqZWN0S2V5cyIsIlNQIiwiRGVzcHJlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQSxTQUFTQSxRQUFULENBQWtCQyxLQUFsQixFQUF5QjtBQUFBLE1BQ2JDLEtBRGEsR0FDeURELEtBRHpELENBQ2JDLEtBRGE7QUFBQSxNQUNOQyxLQURNLEdBQ3lERixLQUR6RCxDQUNORSxLQURNO0FBQUEsTUFDQ0MsUUFERCxHQUN5REgsS0FEekQsQ0FDQ0csUUFERDtBQUFBLE1BQ1dDLFNBRFgsR0FDeURKLEtBRHpELENBQ1dJLFNBRFg7QUFBQSxNQUNzQkMsU0FEdEIsR0FDeURMLEtBRHpELENBQ3NCSyxTQUR0QjtBQUFBLE1BQ2lDQyxRQURqQyxHQUN5RE4sS0FEekQsQ0FDaUNNLFFBRGpDO0FBQUEsTUFDMkNDLFNBRDNDLEdBQ3lEUCxLQUR6RCxDQUMyQ08sU0FEM0M7QUFFckIsc0JBQ0k7QUFBUSxhQUFTLHdCQUFp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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRCQUE0QjtBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVSxLQUFxQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QkFBTyxDQUFDLGdGQUFlOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOEZBQThGLGVBQWU7QUFDN0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVAsaURBQWlEO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1FQUFtRTs7QUFFbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLGNBQWM7QUFDekIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLDJEQUEyRCxTQUFTO0FBQ3BFLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxFQUFFO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNERBQTREO0FBQzVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsRUFBRTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJDQUEyQzs7QUFFM0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7OztBQ2xyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLGdGQUFlOztBQUVyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGVBQWU7QUFDN0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVAsaURBQWlEO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhNQUE4TTs7QUFFOU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekIsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7O0FBRW5EOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNi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Q0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1FQUFtRTs7QUFFbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxFQUFFO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBEQUEwRDtBQUMxRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBMEIsb0JBQW9CLFNBQUU7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMzdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckJBO0FBRWUsU0FBUzRILE1BQVQsR0FBa0I7QUFDN0Isc0JBQ0U7QUFBQSwyQkFBRSxxRUFBQyw2RUFBRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUYsbUJBREY7QUFHRDtLQUpxQkEsTSIsImZpbGUiOiJzdGF0aWMvY2h1bmtzL3BhZ2VzL3BvcnRmb2xpby5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcclxuXHJcbmZ1bmN0aW9uIEhlYWRsaW5lKHByb3BzKSB7XHJcbiAgICBjb25zdCB7IGxhYmVsLCB0aXRsZSwgc3VidGl0bGUsIGRpdmlkZXJfMSwgZGl2aWRlcl8yLCBwb3NpdGlvbiwgY2xhc3NOYW1lIH0gPSBwcm9wcztcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGhlYWRlciBjbGFzc05hbWU9e2BlbC1oZWFkbGluZSAke3Bvc2l0aW9uIHx8IFwic2lkZVwifSAke2NsYXNzTmFtZX1gfT5cclxuICAgICAgICAgICAge2xhYmVsICYmIChcclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZWwtaGVhZGxpbmUtbGFiZWxcIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj57bGFiZWx9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgIHt0aXRsZSAmJiAoXHJcbiAgICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwiZWwtaGVhZGxpbmUtdGl0bGVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj57dGl0bGV9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgPC9oMz5cclxuICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAge2RpdmlkZXJfMSAmJiAoXHJcbiAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGl2aWRlciBkaXZpZGVyLTEtcmV2ZXJzZSBkaXZpZGVyLTEtMVwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGl2aWRlciBkaXZpZGVyLTEtcmV2ZXJzZSBkaXZpZGVyLTEtMlwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgIHtkaXZpZGVyXzIgJiYgKFxyXG4gICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRpdmlkZXIgZGl2aWRlci0xLXJldmVyc2UgZGl2aWRlci0xLTIgZGl2aWRlci1zaW5nbGVcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICApfVxyXG4gICAgICAgICAgICB7c3VidGl0bGUgJiYgPHA+e3N1YnRpdGxlfTwvcD59XHJcbiAgICAgICAgPC9oZWFkZXI+XHJcbiAgICApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBIZWFkbGluZTsiLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCBMaW5rIGZyb20gJ25leHQvbGluayc7XHJcbmltcG9ydCB7IENvbnRhaW5lciwgUm93LCBDb2wgfSBmcm9tIFwicmVhY3QtZ3JpZC1zeXN0ZW1cIjtcclxuaW1wb3J0IHsgVGFiLCBUYWJzLCBUYWJMaXN0LCBUYWJQYW5lbCB9IGZyb20gXCJyZWFjdC10YWJzXCI7XHJcblxyXG5cclxuaW1wb3J0IHBvcnRmb2xpbyBmcm9tIFwiLi4vdGFibGVzL3BhcnRlbmVyaV90YWJsZVwiO1xyXG5cclxuXHJcbmZ1bmN0aW9uIENhcmRzKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgIFxyXG4gICAgICAgICAgICBcclxuICAgICAgICA8VGFicyBjbGFzc05hbWU9e2BlbC10YWJzIGVsLXRhYnMtMSAke3BvcnRmb2xpby5jbGFzc31gfXNlbGVjdGVkVGFiQ2xhc3NOYW1lPVwiYWN0aXZlXCI+XHJcbiAgICAgICAgPFRhYkxpc3QgY2xhc3NOYW1lPXtgZWwtdGFicy1saW5rcyAke3BvcnRmb2xpby5jbGFzc31gfT5cclxuICAgICAgICAgICAge3BvcnRmb2xpby5tYXAoKGNhdGVnb3J5LCBjYXRlZ29yeUluZGV4KSA9PiAoXHJcbiAgICAgICAgICAgICAgICA8VGFiIGtleT17Y2F0ZWdvcnlJbmRleH0+e2NhdGVnb3J5Lm5hbWV9PC9UYWI+XHJcbiAgICAgICAgICAgICkpfVxyXG4gICAgICAgIDwvVGFiTGlzdD5cclxuICAgICAgICB7cG9ydGZvbGlvLm1hcCgoY2F0ZWdvcnksIGNhdGVnb3J5SW5kZXgpID0+IChcclxuICAgICAgICAgICAgPFRhYlBhbmVsIGtleT17Y2F0ZWdvcnlJbmRleH0+XHJcbiAgICAgICAgICAgICAgICA8Um93IGNsYXNzTmFtZT1cInJvdy1jZW50ZXIgbWItLTMwXCI+XHJcbiAgICAgICAgICAgICAgICAgICAge2NhdGVnb3J5Lml0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgICAgICAgICAgPENvbCBrZXk9e2luZGV4fSB4cz17Nn0gc209ezZ9IG1kPXs2fSBsZz17M30geGw9ezN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwb3J0Zm9saW8taXRlbVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxMaW5rIGhyZWY9e2AvcGFydGVuZXJpX2RldGFpbHMke2l0ZW0ubGlua31gfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwb3J0Zm9saW8tY2FyZFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbWFnZSBvdmVybGF5LWltYWdlXCIgc3R5bGU9e3sgYmFja2dyb3VuZEltYWdlOiBgdXJsKCR7aXRlbS5pbWFnZX0pYCB9fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250ZW50XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+e2l0ZW0udGl0bGV9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoMz57aXRlbS5zdWJ0aXRsZX08L2gzPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWUgPSB7Y2F0ZWdvcnkuY2xhc3N9PntpdGVtLnRpdGxlfTwvcD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQ29sPlxyXG4gICAgICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgICAgPC9Sb3c+XHJcbiAgICAgICAgICAgIDwvVGFiUGFuZWw+XHJcbiAgICAgICAgKSl9XHJcbiAgICA8L1RhYnM+XHJcbiAgICAgICAgICAgICBcclxuICAgICk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IENhcmRzOyIsIlxyXG5cclxuXHJcblxyXG5cclxuY29uc3QgcGFydGVuZXJpX3RhYmxlID0gW1xyXG5cclxuICAgIHtcclxuICAgICAgICBuYW1lOiBcIkN1bGVzZSBkaW4gdG9hdGVcIixcclxuICAgICAgICBjbGFzczogXCJDdWxlc2VfZGluX3RvYXRlXCIsXHJcbiAgICAgICAgaXRlbXM6IFsge1xyXG4gICAgICAgICAgICB0aXRsZTogXCJIb3RlbCBTdG9wXCIsXHJcbiAgICAgICAgICAgIGxpbms6IFwiL2hvdGVsMlwiLFxyXG4gICAgICAgICAgICBzdWJ0aXRsZTogXCJCcmHImW92XCIsXHJcbiAgICAgICAgICAgIGltYWdlOiBcIi9pbWFnZXMvcGFydGVuZXJpL2hvdGVsMi5qcGdcIixcclxuICAgICAgICAgICAgdGh1bWJuYWlsOiBcIi9pbWFnZXMvcGFydGVuZXJpL2hvdGVsMi5qcGdcIixcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGl0bGU6IFwiTGUgUG9tcG9uIFJvdWdlXCIsXHJcbiAgICAgICAgICAgIHN1YnRpdGxlOiBcIlJlc3RhdXJhbnQgRnJhbsibdXplc2NcIixcclxuICAgICAgICAgICAgbGluazogXCIvcmVzdGF1cmFudDFcIixcclxuICAgICAgICAgICAgaW1hZ2U6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvcmVzdGF1cmFudDUuanBnXCIsXHJcbiAgICAgICAgICAgIHRodW1ibmFpbDogXCIvaW1hZ2VzL3BhcnRlbmVyaS9yZXN0YXVyYW50NS5qcGdcIixcclxuICAgICAgICB9LHtcclxuICAgICAgICAgICAgdGl0bGU6IFwiRW5nbGlzaCBDbHViXCIsXHJcbiAgICAgICAgICAgIHN1YnRpdGxlOiBcIkJhciBlbmdsZXplc2NcIixcclxuICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgIGltYWdlOiBcIi9pbWFnZXMvcGFydGVuZXJpL2JhcjEuanBnXCIsXHJcbiAgICAgICAgICAgIHRodW1ibmFpbDogXCIvaW1hZ2VzL3BhcnRlbmVyaS9iYXIxLmpwZ1wiLFxyXG4gICAgICAgIH0se1xyXG4gICAgICAgICAgICB0aXRsZTogXCJJcm9uIFdpbGxcIixcclxuICAgICAgICAgICAgc3VidGl0bGU6IFwiZml0bmVzc1wiLFxyXG4gICAgICAgICAgICBsaW5rOiBcIi9cIixcclxuICAgICAgICAgICAgaW1hZ2U6IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndDRUFBa0dCeE1URWhVVEV4TVZGUlVYRnhVWUZ4Y1lGeGNWRnhjWEZSWVdGeGdWRlJjWUhTZ2dHaDBsSFJjWElURWhKU2tyTGk0dUdCOHpPRE10TnlndExpc0JDZ29LRFEwTkZROFBGU3NaRlJrckt5c3RMUzByS3kwckxTc3JLeXNyS3kwckt6Y3RLemMzTFMwckt6YzNLeXN0TFMwdEt5c3JLeXNyTFMwckt5c3JLLy9BQUJFSUFMY0JFd01CSWdBQ0VRRURFUUgveEFBY0FBQUNBZ01CQVFBQUFBQUFBQUFBQUFBRUJRTUdBQUlIQVFqL3hBQkpFQUFDQVFJREF3Z0ZDQWdGQkFJREFBQUJBaEVBQXdRU0lRVXhRUVlUSWxGaGNZR3hCektSb2NFVUkwSlNZbkt5MFNRelkzT0NrcUx3RlVPend1RWxVOFBTUlBFMGc1UC94QUFYQVFFQkFRRUFBQUFBQUFBQUFBQUFBQUFBQVFJRC84UUFHUkVCQVFFQUF3QUFBQUFBQUFBQUFBQUFBQkVCSVRGQi85b0FEQU1CQUFJUkF4RUFQd0RtYm1vV05Oc1JzUzRENnkrOGZDaFRzbTU5bjJuOHE2SUN6VjVub283TXUvVkIvaUh4clQvRGJ2MUQ3Vi9PZ0J2SFd2RnFURzJHUWdNTXZmV2lVSG9yWVZnRmJSVUhnYXZjMWVSWGxCN05aTllLeUtEQ2E5VTE0UldDZ2xWcUt0WWlQNy81b0t0bGFnWU5pZVBaNW4zNjBIZHVFOGV6K3pYaGJ3OGZNMUc5QjR6MW9XcjBpdFlvUEMxYjI3a0dhMElyQUtDeWJLMm5rMUJqMmFuMlJHN3Q5cG9uYTIxbWNTZFowN0J4TW5XTzRWV1Z1eEJIeE5TdmRuKy9HZ2d4RDBSZ2pvS0R1VWJneDBSVkMwdHZyQTFlTnZQZlhnb0pVYXBWZW9FcVphQ1VYSzJWNmpGYmdVQnVHdlZZOW00aUNOZkdxdFpNZjNyUjFyRVIvd0RlN3QwcUM1LzRoMmorWS9BVmxWaE1ZWS9PVDhheWluMjByT3BwWXlVK3h5elN1NWJvQXdsVDJyTmJwYm91MGxBNDVMY2oyeG5PRmJ4dFpNZ2dUck9mWFE5bGE4cXVSVDRTMkhlOXpnTzRRZXNEV2Urcmg2TFAva0Q5ei81ZnlvbjBvcE9HSFlmOXlWTHlPTFhObmFrRFdDZm9xZmhVWjJZT3ovOEFtdjVWMVQwVjJsTjdFaGxCNk5zaVFEeGJyNzZ0NzNMUWZYRGlBU1BVVFhoU2o1MXU3S0gyZlpIbFNySDRmSXlpQnJQWHdqdDdhK25lVU96TFB5ZG1GcEZhVTFDcUNKZFpFanNKRmZObTJWbTZnN0Q3U2RmSVZjMERXc01DTzNUNHo4S2xYQkE5ZEd0aHlxejJqeVA1VnZZdEZqb0tJOHdXd09jQmdYR2lKS3dZbWQrblpXWWprOFY0WEIzcVB6RmRaOUNZZ1lyL0FQUi81cWs5S2R1WHRuN3cvb0ZTcTR4L2hmMy9BT1FmKzFSdnM2T0o4Vkk4cHJ1SEova0ZocitHdFhXTndNNkt4Z2lKTytOS2wyaDZOTU1xTXd1WGRBVEVydzhLVWNBdUlBWW4zTitWWXVIWnZWRTkzL05NdHQ0Y0RFRzJCNnVZZUFZZ2VWRmJLdzVrd09JSDRvcW9SL0pIK3FhbUd6TGtBNVJIM2s4cG1yU2NGY0dhVWdBeEpJTTlVQ2F2Mk41T1lkZGsycjYyZ0xwdzlwaTJzNWpia25mRytsVnhVN091ZlVZOXdKOHExT0JmNmpqK0VqNFYxSFlISUY4WmJhNmpXbEFkbGhnWjZNZFE3YTAyOTZON3VIdE5kZHJSVlFTY3VhZEFUeEE2cVZITCtZSTNqMmcxbVU4UDc3cUp0MjVaNDNCbUE3cE5OYkdEbUpYU0JxQXBPN3FKSG5WRmV1V2oyK05GNFZPaVA3NG1tRzM5bVhNT0xlZFZYbk14QTZKYUZ5NmtEZDZ3aWxXZGxBZ3dJbjNrZkNnQmEzcWExSzFmYlhvNjJoY1BSd1J5blVNMTYwb0lPNXZXblVhMGJzLzBVWXA4UUxGMTdWb2xPY0pWbXV3dWJMcUlVVFBiVW81dmFXcHd0ZGJ0ZWhqTXJOYnhlb1oxaDdjU1VZcnZWdEFTSjNHSjQwdXZlaURIcWRCaDNIV0x6QSt4clE4NlhCemxWcVcybFdURmNrSHMzZWJ1dmxZSHBBQU5HdTROTUh2aW84SnlkdmtuSkw1UUNTdGdYUGFKUHZGQWhDUlc0b3ZhMkJ2V2lCY0lXZHdObm15ZTdvVnRzYllXTHhSSXNJYmhXSmhsU00wNWRYS2pYS2ZaUVFoZjdtdmFiUHlVMmdoeXRadUFqaG5YanJ3YU9OWlRnV0RFTlFWdzBSZGFoV3FLOVFWTUxxcnZJSGVZcUZLMDJndWc3ejVWUjBuMFYzVkxZaktRZExPN3Z1MDE5STZ6aGozSDhTVlZmUTBDTVJpd2VOdkRuMkc2dndxNDh2bG5ETjNONVQ4S3o2SzE2TDlNUmVIWGF0bjhQNTEwcXVhZWpiVEYzUit3WDNjMStkZExwb0IyMnMyWC9oOXpMWHpEdHBJdjIvNHZ4Q3ZxSGFnK2Fidzh4WHpUeWlzeGZ0OTcvaUZYQVp0RG9XczBHQ3lnKy9Velh1QXc3M0ZaMEM1RUhTTFBiWGVyRVJMYW1FYmRPbzdhWVl2SFdyZUd1aHdYejI4Z3lGU3lQemx0bGVDZUJYZFZ4WEhXTVpzbjVhYk5rWFZWMXVFSWlOblFNTXVZQ1FDY3A4UlZEcjBhYkN2NFZzUUw2Qk00c2xZWlduS2JzK3FUMWlvUFNaYmsyKy96VnZ5cXdjbDhWaGJrdGhsVlExdTJXQ3JsNHRFamQ5YmRTZjBrSitwUDJ4NVBXZlE5NUZmL0FJT0grNThUVFBhQSthZjdyZVJwWHlKUDZEWSs2ZmM3VTJ4ZytiZjdyZVJxRDVuMjViLzZndyswL3dEcVBURkxXUWdnVDAxbmhBeXZyUW5LQWY4QVVXKy9jLzFHcTBZYkFJOXB5ZjFnYTN6V3BBekVYQzBqajBWTy92cllTWW5HM0N6SG1ueWhGYVRJR2xrUEIwMDZ1K3I1c2Zid3h1dzNJdDVEWkJzbGMyYWVidENHbUJ2QkdsT3ZrbHBzTnRCYlRCZzYzRW5PSEVERHJsT25lZkd1ZStpdTZUczdhVnZnQ0gvbXRPcC9BS2c2UDZMeCtpM1AzOXp5U21ITHhad1Y3N2ovQUlHb0gwWmo5R3UvdjMvQmJwbnl6V2NIZS9kditCcW5vK2M5aVdjeHVEN2JlWnAwaXVtb1VOR1dCbUFKMEdva2RmYlFQSmUzTDNmdnQrSTEwWGF1eTdTWVcxZkdIVzZSWVpuV1dVc0VWdXJ3OWxhSE9lWFcwVGVOZ2xXVXF0d0VNSTRvTkNORDZ2Q3EvZjhBVlQ3aC9HOU4rVnVMRnhjT1JadDJ0THArYloyREJqYklCVnljcFhYVUhXZHdpaytKYm9wKzcvM3ZWSGVmU055aXZZWEFXSHd0NEk4b3JRTGJrQTJpZFE0TWJodzQxSnlLNVMyMnc1eG1KdWczT1pzcTVqcEUycmVlNDJWQnBMT1RvSTNWUU52YkN2cGdjUmV1RUtvdW9GdDVGQmJQRGM2Ym04NkVDSk84blNhckNiVmEzaExLMjNJTDgvenVabk5zQURJcWkyRGx6RUlOVE85ZXFzd2QrNUU3YnRYMHZGU1lEODVtSUlCVzdKRENkWWxXSGdhYjdPMjdoNzhjMWVSODJhQk1FNVFyTU1wMTBEcVQzaXZtV3p5aXhKVmJDTWdYbTFTT2JTY3F0bkV2R2YxaWR6RGZWdDVGWWU5aU1YYXQyOFZpTFE1dk14dHVQbXlTeUVLclN1NjNiR29tSTdLUVd6YjJ5cjEvRjNibHEyem9IS2xoRUFxWVpaNndhdEhKWEFtMWNWV1FJM3lXM25HazVoY3VTVEc4Njc2bTVHNFo3Vmk5YnVPMXhseEdJQmRvelAweVF6UnBKQkIwcHBiWDlKSi9aRC9VYW9PY2VtWEFaNzJGSStxNDk0SStOSmVUZTJQOE53K014QlZHY0N3cUkzMDNacmdFR1FRQkpKaldCVnY5SmRxY1JoRDltOS9zcXFiZXdhbXlRK3Z6bHM1ZE5ZRnpXSTEzeHY4QXBWYzZGSHgzcEYyamNkbk9JQ3p3VzFheWlCRURNcE1kNU5aUU9NMkV3ZG9BanMzZG9IWldWb1crZWlPNFZHVFcxMDZVUHpsUVRod0FTZEFOVDRVRnREYUZ0Z3VWME9wM09rN3UxcU10TldtMUQwVjcvaFFYYjBRM0ZPSXZGUVFEYVVhNnprZnJCSStudW1mYUt1L0xSSnc1L2kvMDNxaCtpRzZUaXJnSkorWmJlWi96TGRkQzVWTE5nL3hmNmIxbmV4VmVRK0VGdkVpNFcvV29iUVhxS2hXbnVpMlIzeFhRcW9uSkZ3MTlGSTlWV1lkOFI4VFY3cG9IMmgrcmJ1OHErZnR2WVdjWlpYcnVNUDYxcjZCeDQrYmY3cmVWY1QyM2FqSFdUMVhMeC9sR2I0VXdjLzJxaHVZeDhva2wzNEUvV080QW1yOXlOd242RmlzSTdFTXlMaUlHWVpRQ0ZPWkNRZFJ6WjFHNmVvVHpwN3pDODdLeFVpZWtPQVpncFA4QVZYVGRoWUJMREpkUURObEtuVTlOWFhLUTUra1RPOHpyV2hZUFFwaVNVdW9ZaEZTTjBqTTkzTUNRSlBTQk9zeE9sUDhBMGdXOHdzajdhKytSVlo5RHQzOUp4YTZUbHRzMGZXWjdoSTkvdnEyOHRVa1cvdkw1bXA2RHVTTnNKaDF0Q1R6Y2dFL1NERXRQdEpIOE04YWE0cjFHKzYza2FWY2tubkRJeDlZNXA4SFlDbXVJMVJ2dXQ1R3NqZ1cxOWxvK091TzJKczJTdDI2QWo4NFdicGt5b1JUcHJIaFRIRlhlYUNoYnlIcEJwVmI0SnlwY1VoUzFvQWRHNHhrbmhTemxqWmphUTdYdWZpcWZiNUtvcEJqMTU3c2gzMXNKdlJZYmd4MTE3ZGszUnpGMVhnbE1pdERaaXcrNUVIZko0MTV5SzIyMkZ1NHJEaXkxMDRpTFFBWUxEQTNOVElPa1pqMlFhZmVoV3kzTjQ2NWJaRWNoRXpYSnlpRll4b2RDUy9iNnU2Z2VRRnRmOFZ4S3NBVHpHSWREdmh1akRML0E3anVOUWRPNUhYOFJidEZiZUVCek1YSk45UjBzdHNHT2llR1gzMFh5bHhlTGJEWFEyRlJWS1BKRjhNUU1qU1FNb25UaE5IY2pCOHk4OEgvOGR1anVVYXpoN28reGMvMDJxRDUrNU5vUmN1NUFXT2RwekFMQms2QWhqTld6Rzh2aFlGcXk5dEhOdENyS3B6R0drWlhEUUFZMWdFNkVkWXBGeVl0UmV2ajlvMzRqVmY1YllZTGlEY1VhRXc1KzNMUVA1QVBZSzBJZG8zOFBjQ1pudXJFN3JTR1pqOXJwdTk5RDNyZUdLck4yOTZwQStaVTZabS9hOTlMYngwSGpXWERvTzc0bXFqbyszT1ZIeXZDWExDcVJ6ZlNZeEVtMnVYNnhnZEU4S291QnNHOHFXb0lBTFFWaGlTVzNaU1Y0a2Nhc1BKNjVtK1dyQkg2TGVPOEdXVWs1aG9JMGdScnVtZFlBZklqQ2M0elN4VlVMNW9NRnN5b0ZRbmVCTW5UZnFLaXBiZHF6YkFWcnpqTEtqOUhVbmVmcEMvck05UXB0eWN4aVlPOXpsbTY1YzVWeTNNTkFQMHdOTVF1OGYzTko5czRGTFRncUlBT2FPSEhoNzZuNVZPWHVKbHlBaEV6RWtnbGdHamNPcHZLZ3VXMU9VR1BTTG9mSUxqWHdxclpYSmN1UGFERU5HS0psVkVxZElKTTV0dzZac0xGTmRGcTQwWm53OXRtamNDeEpJSGpYRUxtT3V1TEZpM2FSaWc1eHJuT0xmUUM2bVhTVkJScFJnMGRjZHRQZHU4dDc5cXlGc3ZidEVXMHRFckxYQUFTU3luMVY2dHhxUVc3MG1ZdExWekR0Y1lLb1c2U1QyWk4zRTl3cmxtMytXWE9BcFpTRitzMnJHQ0NDQU5CcUJ4TkljWHRibm5EWHJseTYyN05jZG5JazhNeE1Ec29tM2hjckszTnlBUVlPNGpxcXdBTnRPNlRKWSt3ZmxXVTlURTJvMXcrdjhQOEE2MWxCQmc5c3ZlelRidElCSHFLd0pKbmVXWTFzMXd6UU95MENxUklra3RvUWROQkdoODZKbldnWTRacTkycS9SWHY4QWhWVjJ0ajdxWFlWeW9nUUJ1M2FuMnpYbHJiVi8vdWUwS2ZoUWRVOUQ5MzlPSTY3RnozUGFOZFQ1UWtjMXFRQkoza0Q2RGRkY1k5RE9QZTV0TVoySitZdWpjRkc5RDZvNDZiNnRuS2owVkppTGpYV3hMZEs1Y2JwVzFjam5YWjh1Wmo2b21BS205aGp5YnhWbE1RcE4yMk9nd1BUWHQ3YXMySTVUNEpKelkzREwzM3JRODJybUd6L1E5aDJjSytJdXdabktscFRwTzZWYnFxdzJmUTNnVi96Y1VmNDdZL0RiRlRnV2NjcWNGZVc2bHJGMkhJUmljdHhTSWpmTXdmQ3VZY29zVlpOOHN0MjA1VVlrOUYxWTZwQTNIck5YaXg2Tk5uMnM3bEh1eXBBVzYvT0lDTmN3QitsMjF6dmx0eVpzV0d2T2xwVlhMTnVKQVVsMEJBNGNkT3cxY0hQTFFCVy85WWhBQnhNM0ZZKzVhYjdBMnplUjdhM0hibVZQR0RBQU1heG1qc29UWitGellURlhJbGhjdzZxUUpJMWN0SEVUSW1nc001dDNGWnd3eW1ZaUR1MDBQaFdrZEw5R1czc05oY1hpcmwyNnhXNkJsT1M0NUpGeGlBQXFrZ0JTTjlYSGxCeTJ3dHdES3VKZlVIVEQzUnVKK3NCU2IwVkVmNGpmSzdud3R0K3drdUZKL3A5OWRLMnNOUEFlZFkzdFZIMk55MFJMZHRWd08wcmhCT3FZUWxkV0o5WXNCeHB2YzVZM1dWZ3V5dG9iajZ5V2s4ZGJsTjhIZFZRbzE2Sk82TzNyUGJSRjdhSXlrUWRaM2tEZlFjVDVRTmliK09EREEzUXdXNi9ORjBERVNvelNOTkdkSkc4ejQwbTI3dHE4VmUxY3d4dEZjd0p6aGlEcXBCQUFxK2NvTVMveThOWmFHK1M0bVNPbEV2aDRQdEE5aHFxOHY3UUZwcms5Tm1LbnQxa2s5dTZ0QlB5STVUWWpCMjNXeHpZNTU1WXNxT1lRQlFPbGNRTHZiZVRQVU9PK3pMdHkxak0xdG1URXRiSUU4M2xaR3RpUW9DM0FUa0UrQnF0NExHODBxbk1NMHpsS2h4QjZ3Zjc3dDlPTmpiZURiU3dON0tFQ1BoN2JFa0tDUDFiUDFJSWJkSmlOOUVYZmtoNldMZUdXNG1MNXk2U3dLRzIyR2FBRmdnbWJmVU5JUEhYaFRuSGVtakFYRVpCWnhNa01QL2pjVkkvNy9iVHArVVdGRTVuc0hyK2R3NzZ4OWx5YVU3UzVUN1BqVTRieFM2MzRiQkh2ckt1ZWJMNVQyYmQyNitTNlE3bGhITlNBVE92em0ray9LREhHL2NZb0dDRjg4TmttY29YZ1R3SFhVWEswMlRmRFduUjBacEpSQ2lyTEhvNVR2Z1JyQTMwbVJWblZSSGRXMEYzN0xRTkRwUXozdUh4SDUxNDl0UVlnYitvVEJBMG12U0JHNFVEYlkyMmJxT3h0V2MrYTNjUndvdVBLM0psaUZHOEE5MmdyVFkrMVhzQzZVZ2dsUVFlTTVqb2VCNkk5OU5MV013OW5wMnJqSTNObFdEZy9yVGJpVklFeHZHNDZrSHRxdDJ0YzRHN29uMlNQalFQOXY0clBaUjkyYXlwN3VqQkh1TkM0TnJyMjFZc1NZZ3lNMGhRRlVtUWR3VWExb0Jud3lLRDZvdUlUMUUzSGNEMk1LZzJuZEp0NGNaZWt0dTJ1dkhwUEVIcTBqd2lvcTU3U3hiMnNIaDFBUE8zYlNGb2trQWpvb3Nra0RVbU8ya2xqWjkzbXIzT0pMdUZ5YWdrUVNUSjRjUFpWeHhRVTRwZ2Q5cTJpcjJhUWZMMzB2dTNlbXcwZ0dJNHhsbk5QVk9sQld0aTNMYWRCMVZYM0VsQVc5cC9LbXVGeC9SZ2xOTkJPOHhwOFBmU2ZsV0FHUmwwWXlQWkIvT29kdXIwTU0yLzV0WjdkOUJaUGxxL3MvZCtkWlZKeWRjVDJHdktvTlJvT2hwbmg3Wk5WN250YXNXemNXTXRFUzR2QUM0aFE5V2g0ZzhEVldhMWxUS2RHa2tqdEJ5Z1QvTjdhdUlDdnhJOFlwTnRYWW5GS0tzSG9YYkp0TzJXSUVwZEcvWDFDMm80ZXJYMEJqTVVDdWdKZ2c2Q2QzZFh5enNuYWx6RHNXdHNWWkpLc3JNcEdaWUlrUWVQblJkL2xsakgzM25QZmN1dDV2V2R3ZC84QWxiQS9xcjQ3ZWF1RDM1WXJMdTJRUFdrZmV1MjAvRzRyNXd2Yll2TnFXRTl3UDRwcVAvRXJ2MXo0QlI1Q2tIMEplMi9hUDA3UGpmc3QrQm1xbDh2OW9oOEsrVjdURE1naEdkb25NZGN5S09IQW11V05qcnAzM0gvbWI4NllXNzUrUlBKSkxYZ05UUHFXd2VQMzZRTitTZUpXM2dyMHN1YzNzd1V5SlZFVVJNUkoxcHRoY1Ridkt3ZGN2UkFLc0JBSVRLd3R6T2trYWU4OE9mYk9BTGF4RU5xZTQxMEhDOURDbThkVXQyeTZUcUpHbzd5TGdnZGlSdWJXZ0xrZnkwWEFzamkyYm56VDJtQnVGU2c1eVZPaUdkRkhBYjZmN1E5TG9jUU1Pdmk5MCtSU3VUWnBKZ2tnWlFKQUVka0RUU1Q1NlRXVFNJNkJjOUo5ejZObTJPL25XL0hmSTkxQTMvU1BpVDZxV1Y3ck5pZmExc24zMVRLd0NUQUJKTUFBYWtrN2dCeE5JTEsvTHZHa2tpNWxMYnlvVkNZM1R6WVdvTnE3WHZYOElHdlhHYzg4d0JabWJRSWgra1R4SnFERjdLdDJyVXU3dGRndVVSUmxWQVF1Wm1QMGN4eTVvMVBxaGhEbUxhR21Gc0NDSjV4b0lnNnNRRDNRQlFDSllLcm55cDBZSkpiVmcwQUFBOVhkeDQ2VnBlWW5LMEVMbUVIV1BvblFuODZrdjN3STV0VjZobUFlNVAzVzBIWVF2alVOMUxqaHJqRm15NVFTeEpqTUdJWFg3cDA3S284ZTR4M3NUM2ttb2lLMlkxb2FEYTRlaDQvbFd0dHQxYkJKVnV5RDdKbW83Vzd4b0NyL0FLM2dLM1RSV2VBY29FQTdpekdCUFh4TWNjc1ZwZkV3UndFSHMxNDlWVE9zV0JwcTl3K3kyb0E5OTF2WlFIY25ObVc3bDlGdWt0SkVpWUo2TEdDZC9BYm8zMUJoY0dHeEwyMUtvUG5OVE9VQkRQa3ZsUmVFNVFHeW9Gb1N3SUpNTEdhQU5XSWs5d3BaaEx4NThNdzFPZVJxb2hsYVIxOGRPMktDWEI1N2JrTU9peHl0OWxsSUV4djBMUWUrbTJ6U0RmdDIyVUhPTGRuZE1NTVNMZ1lRd2pRd1RyeDBNMExpUUlJTW5PRTZYVm9DSjdUR3ZkMXpKSEpPL254bUZCRWtNQ2REL2wyMmFlL28xQXg1VDdWYTNqSGRlc2dqZ1JPNzNVVFp4OXU0QVJmdEtTTlZZdktucWFFSTlrMGoyazR1WXB5ZFFTM3VOZWhRTjI2aXBkcFlRc1NTOXArcklYSUE0em1VZGxMM3c5d3dHdVNBSUFNNkFVY25IdXJVbWlBZmtUZldGWlIwMTVRVnJQUmRyRVJRNHR6UlZuQUUxUVpoY2FSeHAzaGNVR0VHa2d3Qm9teGJLMUJKdFRCZ0t4RytQQ05aK0h2cXZpcmtxNTBJUFVhcWVMczVISW9xS3NGZVRXVFJIczB5eFdtRHRmYWU2M3ZDZjdLV1RUSGF4aXhoMS9aay93QTd1Mys0VUF1eXhMcUl6U0RwSkU5RThSVjV2S1RzdTdxVkNtMk1nMWtDN2FWaUR2MENNSTR6TlVMQWs1eGxFbldBQkpKZzZBY2F1dHZhVGpaMTFTakl5aE16UnBQT1d3b1ljRHI1ZldvcW5ZaEFGMFZ4cnZZUVBEU2hacGxhUzdpR0ZwZFNUeE1LSUJKSkozQUNhYTNzUGhzTWhVSG5ycEVaNGdLVC93QnRlSGZSRmQ1aC9xTi9LZnlvN1pWMXNQZVc2d2hsekZRU29ZRXFRR0tIcGFUT280Q2dMcWF6clVVQURRVlFmdGpiVnk5ZnVNSEtLK1JRbzlVTGJYS2dBK3lOM1VTU0tONVc0b08xc2hWVmNnS3F1aXF2MFZBNmdBS1FXN2NtTmN4SWpTUVpQRXpwNzZ0R0kyQTJJam1yaU02cXFtMU1YQUZVYXFEby9nWjdLQ3FtU0ozZFVEalRiRnNCaGJZQWpuYnJQNFc3YUlCL00xeWdyK0FaR0N1Q3V2ckhSZERydzBQWVJQWlJHMklVMjdZM1c3U0R4ZWJwL3dCUWV5Z0NOYW1zcnlnbnduMGg5aytYL05iM01NMlZZQitjWmd1bStOSUhzUHRyYkFYa1ZXbTJXWWtRMHRDZ2FrWlYzejFrNlJwV3lZcTVOc0FraTFuWlJ3V1lMTlFBWG96RURRQ1FQRDQxTVNlYkVra0RkM3R3OXhvZlBEU1lPcFB0b3pINHBuVlZPVVpBcTZBRDFRUnIxbnROQm1Cdm9IK2NNTEU1aHFSeGpTaTlxT3B2UXVpaFFCd0o2T2t4dU9vb0hBbVdVQWRLUkhHRE84anFxWFBtZTRkOGs5dW1hUjVDZ2JZakdGN0ZwUVBva2J0Y3dNeVQxRU1SL0R3MXB0eUp3b241Uk90c1g0R25DeUFEMTczSThEU213ck5oeTBDRXVRMm11VjlZbmh4NzVqcW96a2dHTnk2Zm9peTJuVkxJZk5SVUFIK2VlNDBWUVZ0cHZudWFqQ2FEZE9QZFdocjFEdjdxMUpvTnF5c0ZaUUFiUHdIRTAwV0JYaTZDSzFacUNYUFhvcUROVXFVQkdIdXdhUWJiTXZOT1RRT093bWZjeTl1WmxRRHhjaWZDYUtSVFQ3QWJNWDVIZHhKQ3V3WUtxdG15cU5RWE9VaVRPZ21SNDdsZC9CaFFmbnJURWZSWG5XSjdtNXZKL1ZUekZiUVpObklqbGM5d3JrUUFBaXlpd3J2SEZqcU9KM21pSzJ4NGoyZFJwaHQxU09iVDZ0cTBQWmJXYVdXcnVYZUF3NGd6QjhScUQyaW0yMG9mRUxKSVZtUVNOU0ZNRFR3cWhkWWdOcVlHdXZTSHdxMmJKZkNwaCtaYTRsek1WSlJYeWpvdG5VT1NRU1FaMEhXWU5MTm80ZkRneGJ6ejkvTUIzbU5UMkNnRGhRZVB0QU5BWnRNWFJjTnhGZFZuUlFyQkFJaUFOeEhzcGJZZGlTV0duRW1hOGJCaWRJNzRpTzBtZEtpdDRUTVdoZ1NvbmNkZFFOSjc2QWk3ZVJqdkNpTityVDJ3S0hoUHJud1VreDF3MEQzMHd0N0pWRkRYMlpaOVcySTV4dThSMFIzMERlYTJwYm9FUUcwbVNEQnk1aTNiRWdjSjNHZzl0NGhFSUtobU1NTlNGM3FSSVVCdDB6djRWN2N4ckYrY0F5dHZCRTZkUkVtckdjR2x2REMycXE5NXdjMjhrM0FuT3R1M0paUmxYS3ZyM0cxbktBVUY4TVU2WHIyMlpHN0NDZjhBa2VGQkpleDkvRk1sdTdkZTVtWlZFbWQ1Q3pBRytPTy9TdGIySHVZaS9jTnBHZVhhSUdnRTlFVHVIUmpmVzJ4bmhpK2c1dEhieEM1Vi9xWUdnYmJRcEU2SGVOUDdOQlpzRDZPOW9YQm1GcEVIVzEyMy9zTEgyMUh0SGtGamJJbHhaajkvYlgzM0NvcEpaMmpjUUVXM1pKK3F4WHlxVFp1Mjc5bk9iZHhsWjR6UFBUTWJ1a2RmZlU1RXVIMlZqRkpGdEx3a2FtMFdaV0FCMEwyU1ZQSFNlUGJVTnpabHpuQ0NqVzRVbVNyTEVBekU3OU5JcDVoZVZXTkNITmZ6THBMc1V1c0NaZ1FaYVQxYnRLU2JVMmpjWTlLOHpzZldHVUpIVURsZ1QxZ1NCMTFRSmc4TVd1S3JDSk1tUkhSVUZtOXdOUnZCSkprU1Rydkg5NzZOMmNkTHJuWExhWWVOeGxUeVpxRHNvSm5QbFBqNTBCV3pWQ3RtM3dHYWZ1cVNQZUJVV0ZKQUpHK1J1ME83VFgyMU5oN1lBdXNHemRDTjBhc3lqODZnY0VJc0RmUGlkL2t3b0hHelhaclYxUnVKVE5KSkVGYnF5ZkVyNGdVNjVIaUxPTFkvVXREd0piVCttcXpzdlVPckVpVUpFSDZhbm85Mjl0ZTJyTHNCL3dCRHhMZGJvdmZDaytiVkJYOE1mbmozTlJ4Tkw4SCtzUGNhUG9ObE8vdXJRbXRsNDkxYUdna0JyS2pyS0NmUFVEdlhoYW9iaG9JbXhCSjBvekIzVFMrMWJNMDJzMmdCVkV6TlFlTk9sVE05QjR4OUtnVVB4bzNhV0s1OWtPNXNsdEkzQWxGQ0NPK0JRZVFuZ2FsdzFnNTExQTZTOFo0anFxaWZCWWRiZDFlZUFpQ1lPb08rSmplSkc3alJHMm1EZ1hGM0h1MGc5bE1jVHlkdlhiaXN3TnUyVURCbUhDVHVCSVBiTzdkSkVpb01aaExTMjJ0MjNMNVRKYmVOUU5BWTdQZlFDcXd5aHVzVFdqc2VvOXdFc2Z5SGFhRXRZa0tJTXlOeGlZN2hVVDRnbmZKN3lUUVQzMllqTEFVYjRrZS9XVFcyeTJ5WFZZTkdzYVR4MG5YcU1Id29Ocmg3dTZ2RG1QV2FBeTlkWU14WWt0T3BKMVB0MTlsTHcydXU0a0U5c0hqVERISm1ZSDZ3QjhTTlI3WnFGOEM0VTlDUVlPYmlzVE9uYlB1b0M3ZTF6YWNYRVVNd1Y4aFlrODI3dm1GMVFDQVdYZXM2QXdZTUNoTm10T1pUOUlUNGloeW1vTFNGbU0wYWRzR3RzRXJHNkJiQll6b0FOWW1KUFZRRW9jdHE3MXNVWHdFc2ZKYTBUQnNlRlQyU3kzaGxLcVNZbDFSMUU4U3JnclZvdFhNVkdnd1YzNzFoRjk5dUtDczJ0bE1kODE1c3ZCWjNkVDlHUGlQaFZzK1U0ampnY08vN3U0NmU0dUJTalo5dTVZdTNiajRhOFE1SnlxSnlqTVNPa0EweE1icWlwTVJzWTIxbFZBVkxiM1NRZU1MQkk3RlkrK3FnNU84OGRmYlRUYVdQY3RjSFNVRU1NcG1ZTEVnR1FPRGRRcFhjYVk3Z1BacFZRWGNzTXFvc0VjNFF3a1JLN2w3OTgrTlE0amVRTndwaGQyaVd2V1dNRVcxVUtPQXlLQW9qK0ZmWlNvNzVQRW1na3p3SVVucEFTUHRBa0FlUjhhZHN5QzZRVU9SVGxnYWtCZEJHbStsR3prbTliQSt1dnNEQW4zQTFkTVRnclQ2c2dKNi9qUWUvSTdQTkYxTUFvMnU0aVFlRlE3S2YvcDl3L1d2TjdrU295Z3RqS2taWjlVN3V2V3ArYkNZQUFjYmpueUZSVmR3UitjUGNhWVVCZ0FNeDY0MCtOSFVSNnA4cTFyMGZDdGFCdGdzTmh5Z0x1UTJzak1vNG1ORHJ1cktrMmRqY010dFJjdFptRXljb002bmpQVldVQ0ROVVROVWEzSzFacW9uUzVVcHhWQTU2MUwwQnB2MTZSSW9GV3B2czVrQkJ1VGxHK0FEN2p2b0ZXVVR1bnY4QStLc095OE1tR3k0aThWRERwSmJoU2RSb1dERGZyUFlZT3NSWHQvRVdRNStTMldaenVKVTVVKzZHSmp2SnFmQmJPdkFsM1N6ZFk3K2RUbkI0U2RQQ29wZnRYbEExOGtzV2dtY29KbHUxMjNuKzRpbDJFdVhDNGtRcEJFRGNKM2UrS3ZHSFFxSU9BdzdEcVUrUzNRUVBDaUJkd3Y4QW03T3ZXKzIzbWI4TEZSL0xRY3krVGxueWpmckVDZDNkUlEyYVJ2MDc5UE9wY1V3dFlsWEU1VnVBNmpwWk0yc2d4cmw0YVYxREJXOE0zcTMwUGZ4L2x6Q3FPWjJ0bEhxb3Uxc3F1bXJzckRFNjh6UFgwVlB0ME5FcnlTdzc2ak1PMWJoYjNOSXFVY2cyMWh6YnlNT0h3TTBmaVVkbDZJaEdBTWdBbURydk5YVGw3eVNGdkJ0Y1JpM05sVEJVVERFS2RWZ2FTRHU0VXQ1Q2JOZkU0UU11UW0yelcyQllodElaZE1zZXF5OGVGS0tZbXo3cWlGZGdOZE5RTmV3VnRhT0p0K3FWOE5LdjJQMld5SFZZUDNrOGcwKzZsZUl3NEExZ25xMTE4YUNrWWk0eVhGdUVRd09Zamh2MUhjZGFzK0V4TnU0TmJRQjdERkpOczJiMXc2V2xFZFQ1akhlWThxSzJhWEZ0UVFRUnBIZHVQc2lxaDZsZ2ZSWjE5OVJ2ZnVBeG5CNzZXdmlqMW1oSHVtZDlSV3ZLSFpseTQzT0RLVEFCQU1aZ054MTQva0tyMTdDWEYzb1IvZlhWaWJFdDEwTGR2TVNDZUJCalNEMkdxaFhpcllTNHk2OUhvejFNSTh5Q1BHaDFiZ2QydmhQR2pidHNrc1NaekVrejFtb3pZRkJ2c3k4RnVoK0FCaWU3S04zR0tjdHRLZU5KSU5lQ2FCempRY3FzU2RSSkgzaWNnOWlsdkVVVFp2RTRPRHdkNDhkYVVQZXpLSk80RFR1VlYvMisrbkZ3SDVJakg2UlkrQU1EeXFCVmdEMGoxeFIxQVlQMXZBMGRRZWl0Q2E5bXRDYUIvc3k1ZkZwY2xrTXVzRWtDZWtaNDlkWlVPQTU3bTF5M1FxOEJsbUpKNHhYdEIxTGEzSVBacVJLS3BQVVc4Z2ZoVk81WThrc0xidGxyQ1BQQTdsOSt2dXJvWEtDSlhYalN6YjFyTlpianA4S2l1QXNhMW1wOFVrT3c2aWZPb2FxSkxJMXB0aExZWWhUdU5LN08rbStCOWRPOGVkQmRzTnNlNnFBcUZjUnVNZytkR1lhNWJINnhXdG51ekQyaXJqc0RCTHpTOGRCUnVKMmJiSTlVVktxdVlPM1pmMWJpdDRpanhzMGRuaFNqYU95TFdZOUFUMTd2S2dNaW9ZbTRuYzdSUVZEMHE3TTV2RUs0R2x4QWY0bDZKOTJYMjFaT1IreU1IaThGWnVQaDdaZkxrZGdNakZyWnlra3BCa3dENDB1NWQyT2N3NGZuQy9OdHgzZ1AwVHIzNWFwbXc5czQ2MnJZZkNNd0RNWElWUVdCZ0tUbUk2STBGVWRUeFBJdkNxc3JmdjRjRGlMM1I4ZWRCODZxVzFjVlpzSDVyYWd1bjZ2TWM0Zkc0akFDbCtINUg0ekZITmljUUZuNjdtOHcvaG5MNzZ0dXl2UnZnVTF1RzVlUDJteXIvS2tIMmswRmV4WEtObXN0YkY4dVhCVmdjeUNEb1JsWmo1MFhzSEphc2xFdVpjNWx3cjVaTzdXRE5YVzl5VXdETEh5V3lOSWxWeUgrWllQdnBOalBSM2hENmh2Vy91M0F3L3JCUHZvRWQ1b0J5dTQvallqK29rVlg4UnQwYWpuWjcwbjNpS2kybnNMbXNhdUZ2M1N0c2taYm1ucXRPUWtFd05SbFBhRFR6R2Y0WlpBVkxLM0dIWm1udkxiL0FIMEZaWGE5MXpsdG9HYUNZZ3pBRXpFOVd0YWJJd2o0aTZiYjNtdDZGdFFTREJFZ0NRQnZxYmJ1TVpyeVloVTVrZ0FDU0JPWFNZUFlZM2JvcDNzNnhrZ3MyWmpxU1BMdXFoZ2VUdHFGQzNMZ2dBYjFPNFJycFVGN2swUU9qZEhjVWozZy9DbWxtS3pFWGlCVUZWeG16YmlmVmJ1SitJRks3aFliMVBuNVZZOFppNlRYNzA4S0lXUGM3S2pMVVk3R3RzTmgxWTYxUUJtcnlqOFJoRURRSzArU0RnYWdDcTFiUzB3ZUdIN09mYVNhUUhCSGhGV0RiQ1pjTGhnZDR0TFFWL0NldjRHalNhRHdxbk5QQ0RSWm9NQnJXYTlGYVVCMkdTM2xHWmlEcklEUng2b3JLanNNbVVTaEoxMWp0cktCdHRIbGZpcmhub2lEMjFPdkxlNlVLdXZEZUROWldWWUtmaTJ6TXpkWm1oU2F5c29Kc1B2cHZaRUVIdEZaV1ZCM1hremNteXZjS094V0pnVmxaV1ZWbkhYQ1dvREUyODIrc3JLb0F4K0NEMjN0L1dVanhqUSsydWRjbU1SeldNdDlUazIyN24wSDlXWDJWbFpWSFVma1FQRDN4V05oR1VFaTRRQjQxbFpVQ0xGOHNsdE5sREY0K3pBOSt0UXZ5dnZYdWphaE9zOVhuN2hXVmxVVmJsTXJzd0x1Ymo3cDNSdUlBblhpZXFnZmxUZ2RHRjdRQUQ3ZDlaV1ZVYUF0Y0lEbVJNMDlzdnVyS3lnZFlGcEZFWHJKSXJ5c3FLVTRyQ1VCZHc5WldVQWoyNml5VmxaUkdaYTN5VmxaUWJLS2I4b3YxRmo5MHZsV1ZsQW13aCtiUGY4QWxYaHJLeWc4RmExbFpRSEpmYUIwVHVHNXlvZ0RUUUdzckt5Zy85az1cIixcclxuICAgICAgICAgICAgdGh1bWJuYWlsOiBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFELzJ3Q0VBQWtHQnhNVEVoVVRFeE1WRlJVWEZ4VVlGeGNZRnhjVkZ4Y1hGUllXRnhnVkZSY1lIU2dnR2gwbEhSY1hJVEVoSlNrckxpNHVHQjh6T0RNdE55Z3RMaXNCQ2dvS0RRME5GUThQRlNzWkZSa3JLeXN0TFMwckt5MHJMU3NyS3lzckt5MHJLemN0S3pjM0xTMHJLemMzS3lzdExTMHRLeXNyS3lzckxTMHJLeXNySy8vQUFCRUlBTGNCRXdNQklnQUNFUUVERVFIL3hBQWNBQUFDQWdNQkFRQUFBQUFBQUFBQUFBQUVCUU1HQUFJSEFRai94QUJKRUFBQ0FRSURBd2dGQ0FnRkJBSURBQUFCQWhFQUF3UVNJUVV4UVFZVElsRmhjWUd4QnpLUm9jRVVJMEpTWW5LeTBTUXpZM09Da3FMd0ZVT3p3dUVsVThQU1JQRTBnNVAveEFBWEFRRUJBUUVBQUFBQUFBQUFBQUFBQUFBQUFRSUQvOFFBR1JFQkFRRUFBd0FBQUFBQUFBQUFBQUFBQUJFQklURkIvOW9BREFNQkFBSVJBeEVBUHdEbWJtb1dOTnNSc1M0RDZ5KzhmQ2hUc201OW4ybjhxNklDelY1bm9vN011L1ZCL2lIeHJUL0RidjFEN1YvT2dCdkhXdkZxVEcyR1FnTU12ZldpVUhvcllWZ0ZiUlVIZ2F2YzFlUlhsQjdOWk5ZS3lLRENhOVUxNFJXQ2dsVnFLdFlpUDcvNW9LdGxhZ1lOaWVQWjVuMzYwSGR1RThleit6WGhidzhmTTFHOUI0ejFvV3IwaXRZb1BDMWIyN2tHYTBJckFLQ3liSzJuazFCajJhbjJSRzd0OXBvbmEyMW1jU2RaMDdCeE1uV080VldWdXhCSHhOU3ZkbisvR2dneEQwUmdqb0tEdVViZ3gwUlZDMHR2ckExZU52UGZYZ29KVWFwVmVvRXFaYUNVWEsyVjZqRmJnVUJ1R3ZWWTltNGlDTmZHcXRaTWYzclIxckVSL3dEZTd0MHFDNS80aDJqK1kvQVZsVmhNWVkvT1Q4YXlpbjIwck9wcFl5VSt4eXpTdTVib0F3bFQyck5icGJvdTBsQTQ1TGNqMnhuT0ZieHRaTWdnVHJPZlhROWxhOHF1UlQ0UzJIZTl6Z080UWVzRFdlK3JoNkxQL2tEOXovNWZ5b24wb3BPR0hZZjl5Vkx5T0xYTm5ha0RXQ2ZvcWZoVVoyWU96LzhBbXY1VjFUMFYybE43RWhsQjZOc2lRRHhicjc2dDczTFFmWERpQVNQVVRYaFNqNTF1N0tIMmZaSGxTckg0Zkl5aUJyUFh3anQ3YStuZVVPekxQeWRtRnBGYVUxQ3FDSmRaRWpzSkZmTm0yVm02ZzdEN1NkZklWYzBEV3NNQ08zVDR6OEtsWEJBOWRHdGh5cXoyanlQNVZ2WXRGam9LSTh3V3dPY0JnWEdpSkt3WW1kK25aV1lqazhWNFhCM3FQekZkWjlDWWdZci9BUFIvNXFrOUtkdVh0bjd3L29GU3E0eC9oZjMvQU9RZisxUnZzNk9KOFZJOHBydUhKL2tGaHIrR3RYV053TTZLeGdpSk8rTktsMmg2Tk1NcU13dVhkQVRFcnc4S1VjQXVJQVluM04rVll1SFp2VkU5My9OTXR0NGNERUcyQjZ1WWVBWWdlVkZiS3c1a3dPSUg0b3FvUi9KSCtxYW1HekxrQTVSSDNrOHBtclNjRmNHYVVnQXhKSU05VUNhdjJONU9ZZGRrMnI2MmdMcHc5cGkyczVqYmtuZkcrbFZ4VTdPdWZVWTl3SjhxMU9CZjZqaitFajRWMUhZSElGOFpiYTZqV2xBZGxoZ1o2TWRRN2EwMjk2Tjd1SHROZGRyUlZRU2N1YWRBVHhBNnFWSEwrWUkzajJnMW1VOFA3N3FKdDI1WjQzQm1BN3BOTmJHRG1KWFNCcUFwTzdxSkhuVkZldVdqMitORjRWT2lQNzRtbUczOW1YTU9MZWRWWG5NeEE2SmFGeTZrRGQ2d2lsV2RsQWd3SW4za2ZDZ0JhM3FhMUsxZmJYbzYyaGNQUndSeW5VTTE2MG9JTzV2V25VYTBicy8wVVlwOFFMRjE3Vm9sT2NKVm11d3ViTHFJVVRQYlVvNXZhV3B3dGRidGVoak1yTmJ4ZW9aMWg3Y1NVWXJ2VnRBU0ozR0o0MHV2ZWlESHFkQmgzSFdMekEreHJRODZYQnpsVnFXMmxXVEZja0hzM2VidXZsWUhwQUFOR3U0Tk1IdmlvOEp5ZHZrbkpMNVFDU3RnWFBhSlB2RkFoQ1JXNG92YTJCdldpQmNJV2R3Tm5teWU3b1Z0c2JZV0x4UklzSWJoV0pobFNNMDVkWEtqWEtmWlFRaGY3bXZhYlB5VTJnaHl0WnVBamhuWGpyd2FPTlpUZ1dERU5RVncwUmRhaFdxSzlRVk1McXJ2SUhlWXFGSzAyZ3VnN3o1VlIwbjBWM1ZMWWpLUWRMTzd2dTAxOUk2emhqM0g4U1ZWZlEwQ01SaXdlTnZEbjJHNnZ3cTQ4dmxuRE4zTjVUOEt6NksxNkw5TVJlSFhhdG44UDUxMHF1YWVqYlRGM1Ird1gzYzErZGRMcG9CMjJzMlgvaDl6TFh6RHRwSXYyLzR2eEN2cUhhZythYnc4eFh6VHlpc3hmdDk3L2lGWEFadERvV3MwR0N5ZysvVXpYdUF3NzNGWjBDNUVIU0xQYlhlckVSTGFtRWJkT283YVlZdkhXcmVHdWh3WHoyOGd5RlN5UHpsdGxlQ2VCWGRWeFhIV01ac241YWJOa1hWVjF1RUlpTm5RTU11WUNRQ2NwOFJWRHIwYWJDdjRWc1FMNkJNNHNsWVpXbkticytxVDFpb1BTWmJrMisvelZ2eXF3Y2w4Vmhia3RobFZRMXUyV0NybDR0RWpkOWJkU2Ywa0orcFAyeDVQV2ZROTVGZi9BSU9IKzU4VFRQYUErYWY3cmVScFh5SlA2RFkrNmZjN1UyeGcrYmY3cmVScUQ1bjI1Yi82Z3crMC93RHFQVEZMV1FnZ1QwMW5oQXl2clFuS0FmOEFVVysvYy8xR3EwWWJBSTlweWYxZ2EzeldwQXpFWEMwamowVk8vdnJZU1luRzNDekhtbnloRmFUSUdsa1BCMDA2dStyNXNmYnd4dXczSXQ1RFpCc2xjMmFlYnRDR21CdkJHbE92a2xwc050QmJUQmc2M0VuT0hFRERybE9uZWZHdWUraXU2VHM3YVZ2Z0NIL210T3AvQUtnNlA2THgraTNQMzl6eVNtSEx4WndWNzdqL0FJR29IMFpqOUd1L3YzL0JicG55eldjSGUvZHYrQnFubytjOWlXY3h1RDdiZVpwMGl1bW9VTkdXQm1BSjBHb2tkZmJRUEplM0wzZnZ0K0kxMFhhdXk3U1lXMWZHSFc2UllabldXVXNFVnVydzlsYUhPZVhXMFRlTmdsV1VxdHdFTUk0b05DTkQ2dkNxL2Y4QVZUN2gvRzlOK1Z1TEZ4Y09SWnQydExwK2JaMkRCamJJQlZ5Y3BYWFVIV2R3aWsrSmJvcCs3LzN2VkhlZlNOeWl2WVhBV0h3dDRJOG9yUUxia0EyaWRRNE1iaHc0MUp5SzVTMjJ3NXhtSnVnM09ac3E1anBFMnJlZTQyVkJwTE9Ub0kzVlFOdmJDdnBnY1JldUVLb3VvRnQ1RkJiUERjNmJtODZFQ0pPOG5TYXJDYlZhM2hMSzIzSUw4L3p1Wm5Oc0FESXFpMkRsekVJTlRPOWVxc3dkKzVFN2J0WDB2RlNZRDg1bUlJQlc3SkRDZFlsV0hnYWI3TzI3aDc4YzFlUjgyYUJNRTVRck1NcDEwRHFUM2l2bVd6eWl4SlZiQ01nWG0xU09iU2NxdG5FdkdmMWlkekRmVnQ1RlllOWlNWGF0MjhWaUxRNXZNeHR1UG15U3lFS3JTdTYzYkdvbUk3S1FXemIyeXIxL0YzYmxxMnpvSEtsaEVBcVlaWjZ3YXRISlhBbTFjVldRSTN5VzNuR2s1aGN1U1RHODY3Nm01RzRaN1ZpOWJ1TzF4bHhHSUJkb3pQMHlRelJwSkJCMHBwYlg5SkovWkQvVWFvT2NlbVhBWjcyRkkrcTQ5NEkrTkplVGUyUDhOdytNeEJWR2NDd3FJMzAzWnJnRUdRUUJKSmpXQlZ2OUpkcWNSaEQ5bTkvc3FxYmV3YW15USt2emxzNWROWUZ6V0kxM3h2OEFwVmM2Rkh4M3BGMmpjZG5PSUN6d1cxYXlpQkVETXBNZDVOWlFPTTJFd2RvQWpzM2RvSFpXVm9XK2VpTzRWR1RXMTA2VVB6bFFUaHdBU2RBTlQ0VUZ0RGFGdGd1VjBPcDNPazd1MXFNdE5XbTFEMFY3L2hRWGIwUTNGT0l2RlFRRGFVYTZ6a2ZyQkkrbnVtZmFLdS9MUkp3NS9pLzAzcWgraUc2VGlyZ0pKK1piZVovekxkZEM1VkxOZy94ZjZiMW5leFZlUStFRnZFaTRXL1dvYlFYcUtoV251aTJSM3hYUXFvbkpGdzE5Rkk5VldZZDhSOFRWN3BvSDJoK3JidThxK2Z0dllXY1paWHJ1TVA2MXI2Qng0K2JmN3JlVmNUMjNhakhXVDFYTHgvbEdiNFV3Yy8ycWh1WXg4b2tsMzRFL1dPNEFtcjl5TnduNkZpc0k3RU15TGlJR1laUUNGT1pDUWRSeloxRzZlb1R6cDd6Qzg3S3hVaWVrT0FaZ3BQOEFWWFRkaFlCTERKZFFETmxLblU5TlhYS1E1K2tUTzh6cldoWVBRcGlTVXVvWWhGU04wak05M01DUUpQU0JPc3hPbFA4QTBnVzh3c2o3YSsrUlZaOUR0MzlKeGE2VGx0czBmV1o3aEk5L3ZxMjh0VWtXL3ZMNW1wNkR1U05zSmgxdENUemNnRS9TREV0UHRKSDhNOGFhNHIxRys2M2thVmNrbm5ESXg5WTVwOEhZQ211STFSdnV0NUdzamdXMTlsbytPdU8ySnMyU3QyNkFqODRXYnBreW9SVHBySGhUSEZYZWFDaGJ5SHBCcFZiNEp5cGNVaFMxb0FkRzR4a25oU3psalpqYVE3WHVmaXFmYjVLb3BCajE1N3NoMzFzSnZSWWJneDExN2RrM1J6RjFYZ2xNaXREWml3KzVFSGZKNDE1eUsyMjJGdTRyRGl5MTA0aUxRQVlMREEzTlRJT2taajJRYWZlaFd5M040NjViWkVjaEV6WEp5aUZZeG9kQ1MvYjZ1NmdlUUZ0ZjhWeEtzQVR6R0lkRHZodWpETC9BN2p1TlFkTzVIWDhSYnRGYmVFQnpNWEpOOVIwc3RzR09pZUdYMzBYeWx4ZUxiRFhRMkZSVktQSkY4TVFNalNRTW9uVGhOSGNqQjh5ODhILzhkdWp1VWF6aDdvK3hjLzAycUQ1KzVOb1JjdTVBV09kcHpBTEJrNkFoak5Xekc4dmhZRnF5OXRITnRDcktwekdHa1pYRFFBWTFnRTZFZFlwRnlZdFJldmo5bzM0alZmNWJZWUxpRGNVYUV3NSszTFFQNUFQWUswSWRvMzhQY0NabnVyRTdyU0daajlycHU5OUQzcmVHS3JOMjk2cEErWlU2Wm0vYTk5TGJ4MEhqV1hEb083NG1xam8rM09WSHl2Q1hMQ3FSemZTWXhFbTJ1WDZ4Z2RFOEtvdUJzRzhxV29JQUxRVmhpU1czWlNWNGtjYXNQSjY1bStXckJINkxlTzhHV1VrNWhvSTBnUnJ1bWRZQWZJakNjNHpTeFZVTDVvTUZzeW9GUW5lQk1uVGZxS2lwYmRxemJBVnJ6akxLajlIVW5lZnBDL3JNOVFwdHljeGlZTzl6bG02NWM1VnkzTU5BUDB3Tk1RdThmM05KOXM0RkxUZ3FJQU9hT0hIaDc2bjVWT1h1Smx5QWhFekVrZ2xnR2pjT3B2S2d1VzFPVUdQU0xvZklMalh3cXJaWEpjdVBhREVOR0tKbFZFcWRJSk01dHc2WnNMRk5kRnE0MFpudzl0bWpjQ3hKSUhqWEVMbU91dUxGaTNhUmlnNXhybk9MZlFDNm1YU1ZCUnBSZzBkY2R0UGR1OHQ3OXF5RnN2YnRFVzB0RXJMWEFBU1N5bjFWNnR4cVFXNzBtWXRMVnpEdGNZS29XNlNUMlpOM0U5d3JsbTMrV1hPQXBaU0YrczJyR0NDQ0FOQnFCeE5JY1h0Ym5uRFhybHk2MjdOY2RuSWs4TXhNRHNvbTNoY3JLM055QVFZTzRqcXF3QU50TzZUSlkrd2ZsV1U5VEUybzF3K3Y4UDhBNjFsQkJnOXN2ZXpUYnRJQkhxS3dKSm5lV1kxczF3elFPeTBDcVJJa2t0b1FkTkJHaDg2Sm5XZ1k0WnE5MnEvUlh2OEFoVlYydGo3cVhZVnlvZ1FCdTNhbjJ6WGxyYlYvL3VlMEtmaFFkVTlEOTM5T0k2N0Z6M1BhTmRUNVFrYzFxUUJKM2tENkRkZGNZOURPUGU1dE1aMkorWXVqY0ZHOUQ2bzQ2YjZ0bktqMFZKaUxqWFd4TGRLNWNicFcxY2puWFo4dVpqNm9tQUttOWhqeWJ4VmxNUXBOMjJPZ3dQVFh0N2FzMkk1VDRKSnpZM0RMMzNyUTgycm1Hei9ROWgyY0srSXV3Wm5LbHBUcE82VmJxcXcyZlEzZ1YvemNVZjQ3WS9EYkZUZ1djY3FjRmVXNmxyRjJISVJpY3R4U0lqZk13ZkN1WWNvc1ZaTjhzdDIwNVVZazlGMVk2cEEzSHJOWGl4Nk5ObjJzN2xIdXlwQVc2L09JQ05jd0IrbDIxenZsdHlac1dHdk9scFZYTE51SkFVbDBCQTRjZE93MWNIUExRQlcvOVloQUJ4TTNGWSs1YWI3QTJ6ZVI3YTNIYm1WUEdEQUFNYXhtanNvVForRnpZVEZYSWxoY3c2cVFKSTFjdEhFVEltZ3NNNXQzRlp3d3ltWWlEdTAwUGhXa2RMOUdXM3NOaGNYaXJsMjZ4VzZCbE9TNDVKRnhpQUFxa2dCU045WEhsQnkyd3R3REt1SmZVSFREM1J1SitzQlNiMFZFZjRqZks3bnd0dCt3a3VGSi9wOTlkSzJzTlBBZWRZM3RWSDJOeTBSTGR0VndPMHJoQk9xWVFsZFdKOVlzQnhwdmM1WTNXVmd1eXRvYmo2eVdrOGRibE44SGRWUW8xNkpPNk8zclBiUkY3YUl5a1FkWjNrRGZRY1Q1UU5pYitPRERBM1F3VzYvTkYwREVTb3pTTk5HZEpHOHo0MG0yN3RxOFZlMWN3eHRGY3dKemhpRHFwQkFBcStjb01TL3k4TlphRytTNG1TT2xFdmg0UHRBOWhxcTh2N1FGcHJrOU5tS250MWtrOXU2dEJQeUk1VFlqQjIzV3h6WTU1NVlzcU9ZUUJRT2xjUUx2YmVUUFVPTyt6THR5MWpNMXRtVEV0YklFODNsWkd0aVFvQzNBVGtFK0JxdDRMRzgwcW5NTTB6bEtoeEI2d2Y3N3Q5T05qYmVEYlN3TjdLRUNQaDdiRWtLQ1AxYlAxSUliZEppTjlFWGZraDZXTGVHVzRtTDV5NlN3S0cyMkdhQUZnZ21iZlVOSVBIWGhUbkhlbWpBWEVaQlp4TWtNUC9qY1ZJLzcvYlRwK1VXRkU1bnNIcitkdzc2eDlseWFVN1M1VDdQalU0YnhTNjM0YkJIdnJLdWViTDVUMmJkMjYrUzZRN2xoSE5TQVRPdnptK2svS0RIRy9jWW9HQ0Y4OE5rbWNvWGdUd0hYVVhLMDJUZkRXblIwWnBKUkNpckxIbzVUdmdSckEzMG1SVm5WUkhkVzBGMzdMUU5EcFF6M3VIeEg1MTQ5dFFZZ2Irb1RCQTBtdlNCRzRVRGJZMjJicU94dFdjK2EzY1J3b3VQSzNKbGlGRzhBOTJnclRZKzFYc0M2VWdnbFFRZU01am9lQjZJOTlOTFdNdzlucDJyakkzTmxXRGcvclRiaVZJRXh2RzQ2a0h0cXQydGM0RzdvbjJTUGpRUDl2NHJQWlI5MmF5cDd1akJIdU5DNE5ycjIxWXNTWWd5TTBoUUZVbVFkd1VhMW9Cbnd5S0Q2b3VJVDFFM0hjRDJNS2cybmRKdDRjWmVrdHUydXZIcFBFSHEwandpb3E1N1N4YjJzSGgxQVBPM2JTRm9ra0Fqb29za2tEVW1PMmtsalo5M21yM09KTHVGeWFna1FTVEo0Y1BaVnh4UVU0cGdkOXEyaXIyYVFmTDMwdnUzZW13MGdHSTR4bG5OUFZPbEJXdGkzTGFkQjFWWDNFbEFXOXAvS211RngvUmdsTk5CTzh4cDhQZlNmbFdBR1JsMFl5UFpCL09vZHVyME1NMi81dFo3ZDlCWlBscS9zL2QrZFpWSnlkY1QyR3ZLb05Sb09ocG5oN1pOVjdudGFzV3pjV010RVM0dkFDNGhROVdoNGc4RFZXYTFsVEtkR2tranRCeWdUL043YXVJQ3Z4SThZcE50WFluRktLc0hvWGJKdE8yV0lFcGRHL1gxQzJvNGVyWDBCak1VQ3VnSmdnNkNkM2RYeXpzbmFsekRzV3RzVlpKS3NyTXBHWllJa1FlUG5SZC9sbGpIMzNuUGZjdXQ1dldkd2QvOEFsYkEvcXI0N2VhdUQzNVlyTHUyUVBXa2ZldTIwL0c0cjV3dmJZdk5xV0U5d1A0cHFQL0VydjF6NEJSNUNrSDBKZTIvYVAwN1BqZnN0K0JtcWw4djlvaDhLK1Y3VERNZ2hHZG9uTWRjeUtPSEFtdVdOanJwMzNIL21iODZZVzc1K1JQSkpMWGdOVFBxV3dlUDM2UU4rU2VKVzNncjBzdWMzc3dVeUpWRVVSTVJKMXB0aGNUYnZLd2RjdlJBS3NCQUlUS3d0ek9ra2FlODhPZmJPQUxheEVOcWU0MTBIQzlEQ204ZFV0Mnk2VHFKR283eUxnZ2RpUnViV2dMa2Z5MFhBc2ppMmJuelQybUJ1RlNnNXlWT2lHZEZIQWI2ZjdROUxvY1FNT3ZpOTArUlN1VFpwSmdrZ1pRSkFFZGtEVFNUNTZUV1RTSTZCYzlKOXo2Tm0yTy9uVy9IZkk5MUEzL1NQaVQ2cVdWN3JOaWZhMXNuMzFUS3dDVEFCSk1BQWFrazdnQnhOSUxLL0x2R2traTVsTGJ5b1ZDWTNUellXb05xN1h2WDhJR3ZYR2M4OHdCWm1iUUloK2tUeEpxREY3S3QyclV1N3RkZ3VVUlJsVkFRdVptUDBjeHk1bzFQcWhoRG1MYUdtRnNDQ0o1eG9JZzZzUUQzUUJRQ0pZS3JueXAwWUpKYlZnMEFBQTlYZHg0NlZwZVluSzBFTG1FSFdQb25Rbjg2a3Yzd0k1dFY2aG1BZTVQM1cwSFlRdmpVTjFMamhyakZteTVRU3hKak1HSVhYN3AwN0tvOGU0eDNzVDNrbW9pSzJZMW9hRGE0ZWg0L2xXdHR0MWJCSlZ1eUQ3Sm1vN1c3eG9Dci9BSzNnSzNUUldlQWNvRUE3aXpHQlBYeE1jY3NWcGZFd1J3RUhzMTQ5VlRPc1dCcHE5dyt5Mm9BOTkxdlpRSGNuTm1XN2w5RnVrdEpFaVlKNkxHQ2QvQWJvMzFCaGNHR3hMMjFLb1BuTlRPVUJEUGt2bFJlRTVRR3lvRm9Td0lKTUxHYUFOV0lrOXdwWmhMeDU4TXcxT2VScW9obGFSMThkTzJLQ1hCNTdia01PaXh5dDlsbElFeHYwTFFlK20yelNEZnQyMlVIT0xkbmRNTU1TTGdZUXdqUXdUcngwTTBMaVFJSU1uT0U2WFZvQ0o3VEd2ZDF6SkhKTy9ueG1GQkVrTUNkRC9sMjJhZS9vMUF4NVQ3VmEzakhkZXNnamdSTzczVVRaeDl1NEFSZnRLU05WWXZLbnFhRUk5azBqMms0dVlweWRRUzN1TmVoUU4yNmlwZHBZUXNTUzlwK3JJWElBNHptVWRsTDN3OXd3R3VTQUlBTTZBVWNuSHVyVW1pQWZrVGZXRlpSMDE1UVZyUFJkckVSUTR0elJWbkFFMVFaaGNhUnhwM2hjVUdFR2tnd0JvbXhiSzFCSnRUQmdLeEcrUENOWitIdnF2aXJrcTUwSVBVYXFlTHM1SElvcUtzRmVUV1RSSHMweXhXbUR0ZmFlNjN2Q2Y3S1dUVEhheGl4aDEvWmsvd0E3dTMrNFVBdXl4THFJelNEcEpFOUU4UlY1dktUc3U3cVZDbTJNZzFrQzdhVmlEdjBDTUk0ek5VTEFrNXhsRW5XQUJKSmc2QWNhdXR2YVRqWjExU2pJeWhNelJwUE9Xd29ZY0RyNWZXb3FuWWhBRjBWeHJ2WVFQRFNoWnBsYVM3aUdGcGRTVHhNS0lCSkpKM0FDYWEzc1Boc01oVUhucnBFWjRnS1Qvd0J0ZUhmUkZkNWgvcU4vS2Z5bzdaVjFzUGVXNndobHpGUVNvWUVxUUdLSHBhVE9vNENnTHFhenJVVUFEUVZRZnRqYlZ5OWZ1TUhLSytSUW85VUxiWEtnQSt5TjNVU1NLTjVXNG9PMXNoVlZjZ0txdWlxdjBWQTZnQUtRVzdjbU5jeElqU1FaUEV6cDc2dEdJMkEySWptcmlNNnFxbTFNWEFGVWFxRG8vZ1o3S0NxbVNKM2RVRGpUYkZzQmhiWUFqbmJyUDRXN2FJQi9NMXlncitBWkdDdUN1dnJIUmREcncwUFlSUFpSRzJJVTI3WTNXN1NEeGVicC93QlFleWdDTmFtc3J5Z253bjBoOWsrWC9OYjNNTTJWWUIrY1pndW0rTklIc1B0cmJBWGtWV20yV1lrUTB0Q2dha1pWM3oxazZScFd5WXE1TnNBa2kxblpSd1dZTE5RQVhvekVEUUNRUEQ0MU1TZWJFa2tEZDN0dzl4b2ZQRFNZT3BQdG96SDRwblZWT1VaQXE2QUQxUVJyMW50TkJtQnZvSCtjTUxFNWhxUnhqU2k5cU9wdlF1aWhRQndKNk9reHVPb29IQW1XVUFkS1JIR0RPOGpxcVhQbWU0ZDhrOXVtYVI1Q2diWWpHRjdGcFFQb2tidGN3TXlUMUVNUi9EdzFwdHlKd29uNVJPdHNYNEduQ3lBRDE3M0k4RFNtd3JOaHkwQ0V1UTJtdVY5WW5oeDc1anFvemtnR055NmZvaXkyblZMSWZOUlVBSCtlZTQwVlFWdHB2bnVhakNhRGRPUGRXaHIxRHY3cTFKb05xeXNGWlFBYlB3SEUwMFdCWGk2Q0sxWnFDWFBYb3FETlVxVUJHSHV3YVFiYk12Tk9UUU9Pd21mY3k5dVpsUUR4Y2lmQ2FLUlRUN0FiTVg1SGR4SkN1d1lLcXRteXFOUVhPVWlUT2dtUjQ3bGQvQmhRZm5yVEVmUlhuV0o3bTV2Si9WVHpGYlFaTm5JamxjOXdya1FBQWl5aXdydkhGanFPSjNtaUsyeDRqMmRScGh0MVNPYlQ2dHEwUFpiV2FXV3J1WGVBdzRnekI4UnFEMmltMjBvZkVMSklWbVFTTlNGTURUd3FoZFlnTnFZR3V2U0h3cTJiSmZDcGgrWmE0bHpNVkpSWHlqb3RuVU9TUVNRWjBIV1lOTE5vNGZEZ3hieno5L01CM21OVDJDZ0RoUWVQdEFOQVp0TVhSY054RmRWblJRckJBSWlBTnhIc3BiWWRpU1dHbkVtYThiQmlkSTc0aU8wbWRLaXQ0VE1XaGdTb25jZGRRTko3NkFpN2VSanZDaU4rclQyd0tIaFBybndVa3gxdzBEMzB3dDdKVkZEWDJaWjlXMkk1eHU4UjBSMzBEZWEycGJvRVFHMG1TREJ5NWkzYkVnY0ozR2c5dDRoRUlLaG1NTU5TRjNxUklVQnQwenY0VjdjeHJGK2NBeXR2QkU2ZFJFbXJHY0dsdkRDMnFxOTV3YzI4azNBbk90dTNKWlJsWEt2cjNHMW5LQVVGOE1VNlhyMjJaRzdDQ2Y4QWtlRkJKZXg5L0ZNbHU3ZGU1bVpWRW1kNUN6QUcrT08vU3RiMkh1WWkvY05wR2VYYUlHZ0U5RVR1SFJqZlcyeG5oaStnNXRIYnhDNVYvcVlHZ2JiUXBFNkhlTlA3TkJac0Q2TzlvWEJtRnBFSFcxMjMvc0xIMjFIdEhrRmpiSWx4Wmo5L2JYMzNDb3BKWjJqY1FFVzNaSitxeFh5cVRadTI3OW5PYmR4bFo0elBQVE1idWtkZmZVNUV1SDJWakZKRnRMd2thbTBXWldBQjBMMlNWUEhTZVBiVU56Wmx6bkNDalc0VW1TckxFQXpFNzlOSXA1aGVWV05DSE5mekxwTHNVdXNDWmdRWmFUMWJ0S1NiVTJqY1k5Szh6c2ZXR1VKSFVEbGdUMWdTQjExUUpnOE1XdUtyQ0pNbVJIUlVGbTl3TlJ2QkpKa1NUcnZIOTc2TjJjZExyblhMYVllTnhsVHlacURzb0puUGxQajUwQld6VkN0bTN3R2FmdXFTUGVCVVdGSkFKRytSdTBPN1RYMjFOaDdZQXVzR3pkQ04wYXN5ajg2Z2NFSXNEZlBpZC9rd29IR3pYWnJWMVJ1SlROSkpFRmJxeWZFcjRnVTY1SGlMT0xZL1V0RHdKYlQrbXF6c3ZVT3JFaVVKRUg2YW5vOTI5dGUyckxzQi93QkR4TGRib3ZmQ2srYlZCWDhNZm5qM05SeE5MOEgrc1BjYVBvTmxPL3VyUW10bDQ5MWFHZ2tCcktqcktDZlBVRHZYaGFvYmhvSW14Qkowb3pCM1RTKzFiTTAyczJnQlZFek5RZU5PbFRNOUI0eDlLZ1VQeG8zYVdLNTlrTzVzbHRJM0FsRkNDTytCUWVRbmdhbHcxZzUxMUE2UzhaNGpxcWlmQllkYmQxZWVBaUNZT29PK0pqZUpHN2pSRzJtRGdYRjNIdTBnOWxNY1R5ZHZYYmlzd051MlVEQm1IQ1R1QklQYk83ZEpFaW9NWmhMUzIydDIzTDVUSmJlTlFOQVk3UGZRQ3F3eWh1c1RXanNlbzl3RXNmeUhhYUV0WWtLSU15TnhpWTdoVVQ0Z25mSjd5VFFUMzJZakxBVWI0a2UvV1RXMnkyeVhWWU5Hc2FUeDBuWHFNSHdvTnJoN3U2dkRtUFdhQXk5ZFlNeFlrdE9wSjFQdDE5bEx3MnV1NGtFOXNIalRESEptWUg2d0I4U05SN1pxRjhDNFU5Q1FZT2Jpc1RPbmJQdW9DN2UxemFjWEVVTXdWOGhZazgyN3ZtRjFRQ0FXWGVzNkF3WU1DaE5tdE9aVDlJVDRpaHltb0xTRm1NMGFkc0d0c0VyRzZCYkJZem9BTlltSlBWUUVvY3RxNzFzVVh3RXNmSmEwVEJzZUZUMlN5M2hsS3FTWWwxUjFFOFNyZ3JWb3RYTVZHZ3dWMzcxaEY5OXVLQ3MydGxNZDgxNXN2QlozZFQ5R1BpUGhWcytVNGpqZ2NPLzd1NDZlNHVCU2paOXU1WXUzYmo0YThRNUp5cUp5ak1TT2tBMHhNYnFpcE1Sc1kyMWxWQVZMYjNTUWVNTEJJN0ZZKytxZzVPODhkZmJUVGFXUGN0Y0hTVUVNTXBtWUxFZ0dRT0RkUXBYY2FZN2dQWnBWUVhjc01xb3NFYzRRd2tSSzdsNzk4K05RNGplUU53cGhkMmlXdldXTUVXMVVLT0F5S0FvaitGZlpTbzc1UEVtZ2t6d0lVbnBBU1B0QWtBZVI4YWRzeUM2UVVPUlRsZ2FrQmRCR20rbEd6a205YkErdXZzREFuM0ExZE1UZ3JUNnNnSjYvalFlL0k3UE5GMU1BbzJ1NGlRZUZRN0tmL3A5dy9Xdk43a1NveWd0aktrWlo5VTd1dldwK2JDWUFBY2JqbnlGUlZkd1IrY1BjYVlVQmdBTXg2NDArTkhVUjZwOHExcjBmQ3RhQnRnc05oeWdMdVEyc2pNbzRtTkRydXJLazJkamNNdHRSY3RabUV5Y29NNm5qUFZXVUNETlVUTlVhM0sxWnFvblM1VXB4VkE1NjFMMEJwdjE2UklvRldwdnM1a0JCdVRsRytBRDdqdm9GV1VUdW52OEErS3NPeThNbUd5NGk4VkREcEpiaFNkUm9XRERmclBZWU9zUlh0L0VXUTUrUzJXWnp1SlU1VSs2R0pqdkpxZkJiT3ZBbDNTemRZNytkVG5CNFNkUENvcGZ0WGxBMThrc1dnbWNvSmx1MTIzbis0aWwyRXVYQzRrUXBCRURjSjNlK0t2R0hRcUlPQXc3RHFVK1MzUVFQQ2lCZHd2OEFtN092VysyM21iOExGUi9MUWN5K1RsbnlqZnJFQ2QzZFJRMmFSdjA3OVBPcGNVd3RZbFhFNVZ1QTZqcFpNMnNneHJsNGFWMURCVzhNM3EzMFBmeC9sekNxT1oydGxIcW91MXNxdW1yc3JERTY4elBYMFZQdDBORXJ5U3c3NmpNTzFiaGIzTklxVWNnMjFoemJ5TU9Id00wZmlVZGw2SWhHQU1nQW1EcnZOWFRsN3lTRnZCdGNSaTNObFRCVVRERUtkVmdhU0R1NFV0NUNiTmZFNFFNdVFtMnpXMkJZaHRJWmRNc2VxeThlRktLWW16N3FpRmRnTmROUU5ld1Z0YU9KdCtxVjhOS3YyUDJXeUhWWVAzazhnMCs2bGVJdzRBMWducTExOGFDa1lpNHlYRnVFUXdPWWpodjFIY2RhcytFeE51NE5iUUI3REZKTnMyYjF3NldsRWRUNWpIZVk4cUsyYVhGdFFRUVJwSGR1UHNpcWg2bGdmUloxOTlSdmZ1QXhuQjc2V3ZpajFtaEh1bWQ5Uld2S0habHk0M09ES1RBQkFNWmdOeDE0L2tLcjE3Q1hGM29SL2ZYVmliRXQxMExkdk1TQ2VCQmpTRDJHcWhYaXJZUzR5NjlIb3oxTUk4eUNQR2gxYmdkMnZoUEdqYnRza3NTWnpFa3oxbW96WUZCdnN5OEZ1aCtBQmllN0tOM0dLY3R0S2VOSklOZUNhQnpqUWNxc1NkUkpIM2ljZzlpbHZFVVRadkU0T0R3ZDQ4ZGFVUGV6S0pPNERUdVZWLzIrK25Gd0g1SWpINlJZK0FNRHlxQlZnRDBqMXhSMUFZUDF2QTBkUWVpdENhOW10Q2FCL3N5NWZGcGNsa011c0VrQ2VrWjQ5ZFpVT0E1N20xeTNRcThCbG1KSjR4WHRCMUxhM0lQWnFSS0twUFVXOGdmaFZPNVk4a3NMYnRsckNQUEE3bDkrdnVyb1hLQ0pYWGpTemIxck5aYmpwOEtpdUFzYTFtcDhVa093NmlmT29hcUpMSTFwdGhMWVloVHVOSzdPK20rQjlkTzhlZEJkc05zZTZxQXFGY1J1TWcrZEdZYTViSDZ4V3RudXpEMmlyanNEQkx6UzhkQlJ1SjJiYkk5VVZLcXVZTzNaZjFiaXQ0aWp4czBkbmhTamFPeUxXWTlBVDE3dktnTWlvWW00bmM3UlFWRDBxN001dkVLNEdseEFmNGw2SjkyWDIxWk9SK3lNSGk4Rlp1UGg3WmZMa2RnTWpGclp5a2twQmt3RDQwdTVkMk9jdzRmbkMvTnR4M2dQMFRyMzVhcG13OXM0NjJyWWZDTXdETVhJVlFXQmdLVG1JNkkwRlVkVHhQSXZDcXNyZnY0Y0RpTDNSOGVkQjg2cVcxY1Zac0g1cmFndW42dk1jNGZHNGpBQ2wrSDVINHpGSE5pY1FGbjY3bTh3L2huTDc2dHV5dlJ2Z1UxdUc1ZVAybXlyL0trSDJrMEZleFhLTm1zdGJGOHVYQlZnY3lDRG9SbFpqNTBYc0hKYXNsRXVaYzVsd3I1Wk83V0ROWFc5eVV3RExIeVd5TklsVnlIK1pZUHZwTmpQUjNoRDZodlcvdTNBdy9yQlB2b0VkNW9CeXU0L2pZaitva1ZYOFJ0MGFqblo3MG4zaUtpMm5zTG1zYXVGdjNTdHNrWmJtbnF0T1FrRXdOUmxQYURUekdmNFpaQVZMSzNHSFptbnZMYi9BSDBGWlhhOTF6bHRvR2FDWWd6QUV6RTlXdGFiSXdqNGk2YmIzbXQ2RnRRU0RCRWdDUUJ2cWJidU1acnlZaFU1a2dBQ1NCT1hTWVBZWTNib3AzczZ4a2dzMlpqcVNQTHVxaGdlVHRxRkMzTGdnQWIxTzRScnBVRjdrMFFPamRIY1VqM2cvQ21sbUt6RVhpQlVGVnhtemJpZlZidUorSUZLN2hZYjFQbjVWWThaaTZUWDcwOEtJV1BjN0tqTFVZN0d0c05oMVk2MVFCbXJ5ajhSaEVEUUswK1NEZ2FnQ3ExYlMwd2VHSDdPZmFTYVFIQkhoRldEYkNaY0xoZ2Q0dExRVi9DZXY0R2pTYUR3cW5OUENEUlpvTUJyV2E5RmFVQjJHUzNsR1ppRHJJRFJ4Nm9yS2pzTW1VU2hKMTFqdHJLQnR0SGxmaXJobm9pRDIxT3ZMZTZVS3V2RGVETlpXVllLZmkyek16ZFptaFNheXNvSnNQdnB2WkVFSHRGWldWQjNYa3pjbXl2Y0tPeFdKZ1ZsWldWVm5IWENXb0RFMjgyK3NyS29BeCtDRDIzdC9XVWp4alErMnVkY21NUnpXTXQ5VGsyMjduMEg5V1gyVmxaVkhVZmtRUEQzeFdOaEdVRWk0UUI0MWxaVUNMRjhzbHRObERGNCt6QTkrdFF2eXZ2WHVqYWhPczlYbjdoV1ZsVVZibE1yc3dMdWJqN3AzUnVJQW5YaWVxZ2ZsVGdkR0Y3UUFEN2Q5WldWVWFBdGNJRG1STTA5c3Z1ckt5Z2RZRnBGRVhySklyeXNxS1U0ckNVQmR3OVpXVUFqMjZpeVZsWlJHWmEzeVZsWlFiS0tiOG92MUZqOTB2bFdWbEFtd2grYlBmOEFsWGhyS3lnOEZhMWxaUUhKZmFCMFR1RzV5b2dEVFFHc3JLeWcvOWs9XCIsXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgICB0aXRsZTogXCJTb2NhciBCcmHImW92XCIsXHJcbiAgICAgICAgICAgIHN1YnRpdGxlOiBcIkJlbnppbmFyaWVcIixcclxuICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgIGltYWdlOiBcImh0dHBzOi8vc3RvcmFnZTAuZG1zLm1waW50ZXJhY3Rpdi5yby9tZWRpYS8xLzE0ODEvMjEzMzAvMTY5NDU4MzkvMS9wb3phLTIuanBnXCIsXHJcbiAgICAgICAgICAgIHRodW1ibmFpbDogXCJodHRwczovL3N0b3JhZ2UwLmRtcy5tcGludGVyYWN0aXYucm8vbWVkaWEvMS8xNDgxLzIxMzMwLzE2OTQ1ODM5LzEvcG96YS0yLmpwZ1wiLFxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgICAgdGl0bGU6IFwiRmlsYXJtb25pY2EgQnJhyJlvdlwiLFxyXG4gICAgICAgICAgICBzdWJ0aXRsZTogXCJGaWxhcm1vbmljYVwiLFxyXG4gICAgICAgICAgICBsaW5rOiBcIi9cIixcclxuICAgICAgICAgICAgaW1hZ2U6IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndDRUFBa0dCeE1TRWhVU0V4TVZGaFVYR0JjWEdCY1hHQmNXRnhnWEZSVVhGaGNWRlJjYUhpZ2dHQm9sSGhVVklURWhKU2tyTGk0dUZ4OHpPRE10TnlndExpc0JDZ29LRGcwT0doQVFHeTBtSHlVdEx5MHRMUzB2TFMwdExpMHRMUzB0S3kwdExTMHRMUzB0TFMwdExTMHJMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMZi9BQUJFSUFMY0JFd01CSWdBQ0VRRURFUUgveEFBYkFBQUJCUUVCQUFBQUFBQUFBQUFBQUFBRkFBSURCQVlCQi8vRUFFRVFBQUlCQWdRREJnTUZCZ1FHQXdFQUFBRUNFUUFEQkJJaE1RVkJVUVlUSW1GeGtUS0JvVUpTc2NIUkZCVWpZdUh3TTNLU29sT0NzdExpOFJaRHdnZi94QUFhQVFBREFRRUJBUUFBQUFBQUFBQUFBQUFBQVFJREJBVUcvOFFBS0JFQUFnSUNBZ0lDQVFRREFRQUFBQUFBQUFFQ0VRTWhFakVUVVNKQllSUXlnYkdSb2ZBRS85b0FEQU1CQUFJUkF4RUFQd0FTMWRGTmMwNVRYejdQcEVTTFhNUXhpQnVkSjZIa2E2dE5WNWIwL0UvMG4zcG9HV3J1Q2V5UWx4V1V3SURDREhJMUJkUU1JSUJCNjFOZXZzMFppVEFnVHJvT1ZSRGVodmVnUzFzcllEQkpZTEZKR2ZTQ1pnRGVQZXJpNjBGN1dkNmoyV3RxeENoZzBDZFRCSU1lUzAzRGNjVEpPWUFuKzVyU2NKTko5bWNaeGkydWd6Y2JsVEpvUCs5ays4UGNWejk3cDk5ZmNVS0RCelhzTGswMHRRbzhZdC9mWDNGTlBHTGYzMTl4Undmb09jZllUWnFhR29XT0xJVEFZRW56RkVzTXdPdEpwcnNha24wVG9uV3BLNERTcURRN1NBcnBBQWswNnkrWVNBWTg5UG42VlNpUzVIRzBFZ0VucFRFc3NTQ3gyMlViVDU5YXVXN0pQcFZxM2FBL1dyU0laWHRZWW5mVDhhdElnR3dwNEZQQzAwaVd5cThrd0JUN1dHNjFLMXdDbzh4UHBWcEV0bkxqQlRwOUtrYkVyeXE5eGRNT0V0OXlXTFI0ODIwNmJmWDZVSEswMmlVeDc0Z0dtbW95bGNCaWdCeEZjcHdOY0lvR2NwVW9yb0ZBaHNWMWJaTlMyMG83d1BpQ1djMFcwdU1kQklMUjZBVTBoTm1lN2sxMmp6NEc2eExkeWRkZVErbktsUUl3NHVUVXlOVU51M29LZDNSNVZ5VWRpTEttckdGUzEzUmtQM3BNZ3lNdVdObUVUbTIxbWh3VWtoV09VRWdFbWRCT3BxN2RoV0toMWVER1paZytZbURUNlF1MkltcDhJQVBFZmw2OHFyMjF6R0t0WERycHNOcVMxc3J2UXgwekFnODkrUjE4NnlPTDdJT0NjcmdDVEdhVG9ZaVkyNTlkaFcvNFRnczVMTjhJK3AvU29PSnJyV21PY29iUm5saEdlbWVmanNsZC93Q0luczFQUFpGLytLc2Y1VCt0YXVhUmFyL1VUOW1YNmJINk1wLzhSYlgrTUo1ZUUvWFdrdlpJODczc25QOEExVnFHYWtxenZSK29uN0d2L05qOUdhdDlrei94dXYySTE1ZmFxSzFqSHc5enVydnlia3c1RWYzNVZycXE4UXdLWGx5dU9zSG1wSWlSU1daeTFQb2J3S080YVp6Q1hjNGtWY3RSeTE1ZjBxbHd6aHh0MnhiSk9oM0drajhxTFlmQ0FDSWdkQlU4VjlGSnY3SUJZekVhVEhzS3VXOE9CdnFhbVZZMEZQQzlhcElUWTBDcEFuV21tNUcxUmxpYXBJaHNsYTZCdFVUT1RTQzA0TFZDSXdLY0ZwOU5MVUFjSXB1V2tYcDlxNXJvSk5BaXdlRlhPN0Z3b2NoTUJvMG1xVjYxRzliTGhIQzcxOUFIY3JiR3lqWDJuUVVNN1FjSXNvOEMrb2dhcUllNFdrekoxeWphcXJWa2N0MFpSN3NIVC8zVXR1NkQ2OUtKNHZzLzNTTGVLYVA4TE1aWS9wUXpKcU5LVFJTZGlaNnEzY2FxNkZoUFRjK3dxNDlzRUVIbnA3MUhoN0NXL2dRQTlkejcwaHNsNFBiTjU0S09GaWN4MEJPbWdIUG5XMXdON0M0WWVOMUI2RHhON0NUV0xlOHgwa3gwMkZSUlRzVFZvM2o5dHNPREF0M0NPc0wrYlVxd2NVcXJteVBGRXIyN05FOERncE90VmtxOWgzcmpPNG00aHc0RWJDZzJONGFGMm1qalhpS2d4VjBFR2VsS3gwQ01LdVZQTWsrMjFQRlFFd2ZLbkRFQVV1eDlCaTFqY3FnRGxWREYzWnFtK0s5YWllNlRWV1JROW1waGFveVRYVU5JWktxOWFrbW93YW1TMzFwZGo2T0tKcnR0aG15N25uMEhxZVZUSW5TcDdXSEFxMUVoc3A0UEhxYnIydnRMbCtZWlFmenE1Y3hsdGZpZFI4eFE3ajNCTy9BYTJRbDBhQnRRQ3N6bFlqM0g5YUhZWHNleW1Ydi9BQ1JmT2QyUDVWMFJqQnEyem5sS2FkSkJxM3h5eXh5cTZrK3UvcDFxeUwwODZFWGV5MWtxQUdjRWZhT1VrK29nVFE5dUVZeXhyYWZ2RjZmK0xma2Fxby9USjVTWGFOVWlhelB5NVZJQldXdy9hTmtPVzliWlQ2SDZxZFI5YU5ZUGk5dTU4TEErWE1lb3BPTFExTk1KQmFhd05FdUE0dG5KczJ3RG5JVnZEbmpYYy9kQTlSUkRqSEM3TnJRM2d6L2RFYWZJYmZPaXRXSEpYUmwzdVJURkhTZm1ab2hpdXo0UW8xd0ZsZnhMSmtSUEliRGVyOTVMVmk4Q244UkJCMUVUMUVIYWloMkJiUERMdDVnbHN3VDVTZmxPbEV1RThLVzFmeTNDVlluS3pPWmpYbjBGUHZjUmk4YnRzWk5aVURsVlhGWXRyakZtTWs2azA5QzJ5OXgzRXVIYTB0NHRiR2d5bktwK1EzK2MwR1VSVDIxcHNVbXdTQ2RnZDViYlBkVmNnOEt0TEUrU2pZVUlkYWttbjJySll4UUJWTk5Cb3RqK0dpMllEcStreWtuNWJUUVRGNGhFM1A4QWZwdlJRV1RFVnlLZ3NZbmFSb2RqK3RUczRwRE9SU3FzM0ViWU1GMWtlWXBVQ3N1cWxXN0sxZHZjTVpUQkJGTUZpS3dhT2xNZ3VpcVdJYlExZnZMVkMvVVVVVVhGUXNsV3lsT1d3VHlvQUhzSzdscTlmd1RTQUJxZVZUL3VhN0dZbzBUbDJPL1NtbFlyb0U1YTR5MWF2WVpsSkJFRWJnMUdiZEZEc2ZZU3JhV2V0TEREb0tJcGdtaVltcmpHeUpTb3FxdlNuQ3IxcTJnbk9yYkdJMGh1Uk9oa1ZXS2l0T05HZkt4a21wN3Q4RkZYSW9LejRoT1pwKzlyeXFJaW1rMHhDQzFhVEFYQ21jS2NzeE1hVEV4VlJTYU84RnhGaTNyZlptNklzbVQ1OHZjMElUZElBWXEycEVPb0k4d0NCNzdVS2ZDMk1QOEF4d0lERlFZTXJyTUhYbDg2MDNHc1ZhdlBLMlFvRzJiWGYrVWFmalZXemhCZFBkdGt5blNIZ0pwcnJPZzIvQ3FUK2hOWHNpd1BhL0RXUXl1NFpXVWpLaEk4UjJKeS9uUTdDY2VzM0RDdHIwYlErM091dDJldytjc3laajVra2V3MEk5WnJtTjdQWWU2UGdDSGt5ZUUrMngrWXF2aVI4K3dzdUtKalhiYXBzYmZWMmxVQ0NCb0NTUFhYV3NpM0M4WFkxczNCZFg3cmFOOHBNZlVlbFhlRmNVdVhKVnJUSXltQ0drZk1TTlJTYTlEVXQ3RGFXaWRnVDZVMWxJb2wyZTcwSHZMaDdxMXFyc0Q0b1AyWVVHWjZUVmppYllSeUZ0Qnp5ek5NZXVwbjZVcUh5M1FBYTRPdE1OM29LS1crQTJiZDRDNkhkTnc0a2s5R1hOeW11NGZFV2JZY01pdElJVWs2cWV2blJRV0JDMTBraGJaSUgycEFHM3Y5S084RzRZU2h2WFJLcWZGbGtnZEJyRld1QTRzT0dzcm1kR2pNRXlneU5SNGp0VXZFdUc0aXphSVZmQ1k4T2ZRK3V3cDBLOWsxL3ROYUNHM2F3MGdnZzVpQm9SR3kvclZYaGVCdFhiZHorRGxjQ1ZDQlZYenpGdGFDVzdONHRxVlVlV3AyOU90YTdnSERiZTl6eEhvVElwMjJ5YVNXakhZbkRSTWtDcWlsVHN3MDByMGJpL0NNTzUwdEF1Mmc1OG9nTHR5NVZpZUo0UkVZckNnamNEU0NPb3BOVVZHVmcwNFZQdUw3Q2xUaEEwQnJ0U005WnVZeTFjdUFsQVJWSitDSTV1UVlKMVFjaDYxbkxQRUlOV1c0d1JzZGF5ZVJ0N1JmZ2NmMk9nWHhXd0VnQmd6U1E2Z0VaU0RHL09kOUtGbFpxYkgzNWFlWnFLeHpxRzdOb3FqaTJLdllXeFVLbXJGdS9GU1dqdHh3TVJiOHNuL1ZXMWZqQ0FScHVEOHh6cnppN2VtN1BtUHBWaDhVYWFiWFJuUEhHZjdndDIxeDZYSGhGV0d5bGpBelpsblVIbE02K2dyTXF0VFhXbmVrb3FtMit3akZSVkltd3lhaXRIaFlyUDJCcVBVZmpSaTFjcTRFekxtS3NxUnBRQzlaMm8xY3VhVlF1ck1mM3lOYUdZTU5zejVVaUFLSWQzVXY3TUR5b29BZFpSU1JKZ1RxUUpnZFk1MG50aVRHbzVWWnY0UWNxcU9yQ2dCM2NuZURUVHBSUGgzRkxkcFNMZ056bUZMNVZCaUpJRzUrVkQ3OTFIYVFBSjVEV2dWa1F1RDFvN3cvQUxjdCtQdTdVR2M3dEJQOHNTQlZYRWNHdUl2ZUJTVTVOR1dma2RhZGdNSmFaR054MHR3ZmlKTEhVYUxsSHBUU0UzclFNNGpoMkRrVzdpRmVzRS9vUHJWSGkxaS9sRFdTTTZ6NFcyWUhsTWlENjZVU1prVnRITEwxVlluL0FGVVJ4dkdiVHJsRmhpeEdydmNKYmFOdjYwSUdZOWJ2RWhiSTcyMUJJSnRiQXg1eHY4Nks0QzNkZUJteW5ucE5kdFcwQU9nQjBnbGlZSE1hNzh2YXJBc09FTndFNVFjcEkwRWtURTBOMkNqUnJzTnc2eXRuK0s1dU45NXp0NUtPbFozRjhPdHRMcUZLcXdFNlFDZFIrRkNyOTBzY3pFc2Vwcml2SEtpd1VUUThPNG5idzRVanhTSmhZa1FZZ2o3TlQ4VTdVaGpsVlNWMGt6QjVTSWoxRkFNTGlMZXZlekdVeGxLanhjcG5sVkc1ZEhYOGFMMEhGWFlYL2VvVzduQ0FvRElWdHlPakVmbFZURmNUZG1KRGxRU2ZDcElBSFRTaHh1aW8yeEFIVDVtbFk2TDlqRkZXemhtRERZZ21mZXJkckNtNnR5NUsrSFZzekFNWjZBNmswRFhGQTdRZlRXdXRpVDFqMm9zS0xKUGxTcWdjVVB2ajNwVWhoNEhXbzVKTTEzTlRMZ2tBYTdqWWtiYTh1VllIUVJEclVsazZHbzNydHM2VWhrcGF1QjZaWEtBSXZ0VkxOUXJ2VXRNUXFldGNGT0ZBRTFuY2V0RVZORHJIeENyNHJXSFJsUHNtemFVMGpiKytWTm1uSGxXaEIwQ3BrTlFpcEFhQUpIQU5WcmxtUWFubXUwZ0JGN0NEV3FuY2xUb1NQU2psMnExeTBEVEVDYjRjNmxtYi9NU2Z4cUJjVGwzZ2ZLaVZ4S0Y0MUtRRjBZOWNoVXJMRWdodFFRQk1pTnRkUGFxcHZqcFFjc1pPcDk2cVc4Y0RkN3NxZFpNbitXbGRqNk5DY1VCMDk2NGVJYVJtSHkxb1JoN29KWVI4SmoxL1NwODFUWlhFdE5qZk0reHFNNHJ5UHppZ0dMNDNsTGlJeXNGR3huZVoxMG1QclUzRHVJWjFCNmFHWW5UbVlxM0dTVmtLVVc2QzV4QjZEMy9wVEd2dDVmWDlhclBpQUJtTEFBYjZiaW9yOThBaHAzOElFNk1UQi9DSStkSkpzcHRJdHM3SG45QlFYRzhNdU8wcTRWZlUvcFJRd0pHY01jeEVBYmFEYnFQT29ydUlDa0FoOWVpTWZxQkh1YUU1SjZGSlJhMlVjQnd0cmJaamNuUWlOZjFvbGtIU3JkN0NLcVoxekVzUVJ0cEkyUDFxc2xwajluOHFVbTI5amlrbFNPWmFWUy9zN2RQcVAxcFZCWm9nYVJOTm11azFtYWtOdzYxMU5xaXVySjUrOFUwV3ZOdjlSL1dnQ3hGS0tIWW5HTGJkVUphV0U3bmFZcXZnYlp0NGk0TlN0eitJcmE3ODFuYno5S3JpVFlTdGJtcHhWZXh6L3ZuVTRxUmpoVDZqcm9wZ1dNTjhRL3ZsVjZxR0YrS3J0YXc2TXA5a2xQcUp6QVBwV2Z4SEVidVpFYnUyRE1ScWs3SXpkZjVhcHVpS05OWGFFNFBIWEd1S2paWUlPd0lPZzlhS3pRbllOVVBXbkEwd0duVXdHT2RhaGNVM0Y0bFVrc3dIbHorUW9QaWVPaVNFSG9XMzloVEVYOFJRcTZjeGlobC9pVjEyaVdVOVcwVWdiQmN2T3FWdDdobGd6emxNNTRtWjFGdUJ2dHZSVEZ5UWRHQVRmWDNxRmVFV2crZURtRS9hUFBmU2hxWHJoRFExd0FRUm5qT2ZKTXVuTG4xcHJYTGh6QU02cU5SbitNNmZDcFV4eSt0VHdmc3J5UjlCcGNIYkVuTHVaT3AxUFhlbi9zeWZkRlo1YnJ2S0t6S1BpbDgwem9JekIvbkZTWVN6ZHZPTE5wYnZpKzltWWpuT1lPSUdnL3MwdkcvWWVWZWdvM0M3R3Y4QUJ0Nm1US2d5ZGRUMU9wOTZkYndscGRGdG92b3FqOEJWL2gzQUxWZ1RkWTNiaEVGYzdHMkQ1a25YMEdubWFoZkNXdzVJUUQwbU51UXFKUytyTkl4dmRHZDdUSXBGdGRKTEhRRGxsTS9sVkRGWVFkNWJTUENGWDZUK2dyWS9zeWZkSHRVZC9CV2pxMXREQTVxRG9OYWNjaVFwWTJ6QmNFRndZck13Y0E1OVNERy9VK2xiSHZRZVlxOXc3Q0plQ2kzYlV6eXlqU05KUElDaWpZTEQ0ZVFsdTI5NC9FK1JZWHFCcHFmNzhxZVRKemQwVGp4dUNxenpyaDVjWDdtZG1JQk9YTXhJZ21kSk9uS3RFdUlYN3c5NkhjWndBTjVpQW9CZy9BdTVHdE5YRGtBYXI3UjdBYlZjdm5zaUw0YUMzN1F2VVZ5aGdRYzIxOVAvQUNwVlBqUlhrWnF3YVJOUllhK3JxR1V5Q0pCcVJqV0IwMlFMenB4TmN0ODZwOFh3eHUybXRLWVp3QUkxNWc3YzlxRlgyTktUMUZXdzFhczRlL2JDNVZjZ2ZHRzFCMzFqbDg2Q2NRbEhsdkN0dHdGRXhta2hjMGRJTzFaaXp4NU1KM2xxem56bVFYSmpLeS9aZ2p5UHpORGJ2RXJseitKYy9peG9EY0piVWtFd1puMnJxOE9qbDgyNlBRTFRnQWtrQURja3dQZXErTDR4YlRJQk56TVNCM2VWZ0lna3NaQUc0b1pmNEJpOFZZVzVtdGkxcTRWaVF6THVERWJBVEhXYU9XdUcyVXc5cVZNb1F4QUl6dXhBSkdXZGlmbHB2V1hCTHRsODIzMW9zVTRWUXhQRmJkc00xMGhNcFdRTXhBemJEcVRvYXBIdFpoUi85aC8wUCtsU3NjbjBpbmtpdTJhUENmRjhxZTJPVVhoWmd5VnpUcEhQVGVaMDZVRTRueFJyZUdhOWFCekZWeXlwbnhzb25MMWdrd2FBNEx0STZnWHJpbHJrNVZud2pKOW9OQTJrNkdKbnlyV0VYeE01eVhLajBLOGZDM29md3JOWTF3dHkwU1FGQmNra3dCL0RZYSs5V3gybHc3V1MvZUFFNlpZWXNEOGhxUE9nbkVMQnh5QmJCREFnNnpBblNKNXhJK2xEanRXSlMwNjdEdkNjVWx5NHJXMlZoRGFnenlGSGdheDNaVHM5ZXdSZHJvQnpEVElaWFFhU1NCQjFQMG9seEc3aWJoUGRqSXAreUdHb01hRXp5b3BSdElPVGFUYUROL0dva3lkUUNZNTZVRnZkcFErWkZPUWlBZEJtQklud3RQUWpsUWJIMkxxZ2wwQTAxSlpQTFhYZWhTY0h4UmMzd2pHMllKbFpQd3dQQVJ0NTAwcmZZbTlhUWF2c1dtVG1KNXpKOTVxTExBMlllWkIvR3FEM1NnbDB5LzVrajhDS00ydXpneGRwQVN0dEdoaVJPWWpjUXBrRDVtcUpwdm9nV3cyLy9kOU5LYVVnaVNJNXptL1NuOFM3UFhjSW9JSWUxTUsreDExQWNjankwMDArVlZ2MmlDUnFCckI3d3pIS1FmNzFvWUZobVQ3NC93QjM2VTF3di9FQitaL1N1NGR5MEFkNXZ1TGdJMTBuUVRIdlJqaExHMjhna2tuN1lramZVU05EVXlseEtqRnlHNEhzK2ZpdkVvdTRBZzNHOUFSNFI1bjJvd0hWRnlXMUNMekEzYnpkdDIvQ211eE9wTW5xYXpQSE9MbGI5cFZaZ3F0L0V5L2EyME9uTFhuenJMNVRkR3RSZ3JEOXg2RVluRnNISUFCMi9DcFU0a0h1TWlxWUNocytrR1kwamNIWDZHcTE4K0tvYXJzMFRLdUw0a3daSTBneXduUXFaM21xL2FMSDNqaHU5dHFSYjd4Rk54U1J2TUErcEFCOWZPcjR3aVBxU3dNZ2VHTmdDZFpIbWFreHBQN0sySFRTMnJHNFFkUzdCODh0dHBvQUFOb0hQV3RvY1ZUTU1uSjJyQVhZTGlWOFg3NnE3QzFsSXl5U0ZKY1pjczdHQTJvNlZxY1ZpMVFRWUxSb0pIMTZWbWVEdjNXWjRVRmxWUUFrQ1p6Wm1LNnNkVHFaK0t1NGZHdTdPYmxzeXZUeEVpZWthUitkUFB0dVNKd2Fpa3k4MkpsaVhLa21OeE1SeTNwdC9IQWFBTE1iZ2Yxb2J3dTYxck9wUm1Ec3pqTC9BRGRSQk0xSmNSWEdWeGNZR1BDVURlNG1xVWZaTGw2S3QzaXNFeEREcklwVTl1SXBiSlJMWUNnNkJrQk91cG5UenJsYVYrRE96YThLNFMxcTBsc2tTcWdIMWpYNjFjT0JQWDZVVVZCVHdvcmxhdDJkYTBxUm04Qlo3MjJIUmhCNUZkUWRpRERVSFZiall3VzFZZkhsSklPaWlNNUFub0NhTThDeEZ1dytLdHV3QVc2ekNUdG1Qd2dkQW5kZTlaYmdIYUhQZWJMa1IyaURkQklKZDlRSVlRU1k2NzhxcDRtM3BhTHc1NHdpM0o3YXBJOVE0WndEQldtTjFiS202K3B1TjRtSk84VG9zeHlpc3oyNjdJMjdoL2FiQkVvQm5zRVF0d0JpU1ZLN01kUWV2bHpKY0w0b3pmd3JvVlgreVZQZ1loWktpZFEwUzBIZUQwSXFUR1lsRVA4QUVZS2pBL0VRSjVIek80cmEyam4wWjFlMHVIbkpmdDVkTlF5RFlqUWFUSytRMzJvSDJxN1cyamRqRFduVmlGWXMwTkJaUThMWkJDamZtZE9sQzA0VWwrNjFtMWVHZFc4QllrZ3dUR1p0VHFOSTNuNndZYmgxL0QzbkxXTzh1UkM1V01ET0hVdEs2bUkxK3U5T0dER3RzeG5tbSt2OGxuaUdJYkZNbGk5ZnQyMlh4Rml1WE96QVpSa0pFRVppTkpHKzFXK0c5aUpDTzkyUm9TdVNKRTdFNWp2VmUzaExmN1IzMkx1aDFCbExRYVlZeG82azVsWFFjdGRKT211dndlTUpzb0FCM2h5SkV5b1o5SkowMEdzalRWU0tjNU5Lb2loRlNkek5OZ3piVUFLcWd4dWZpUHYrVlE0eXpaZVNVR2ZyQU05Sm1zeGR0WGNwdWQ4OEFFaFl0NWN1K3ZoME1jK1huR3NWM2ladGxjd2s1b0pBaVFVTEswY3ZoSWpxRFdQRTZ1WnJzVGNWTFpQaEVLWTJHdzBvSndWeFp0TGJrYlp0QnVYOFV6ODZEOW44TmJGMjREYTB1K1B4aFdoaXpFRUhvd0krWTIxcTd4KzVsWUtoZzVDeGlQQ3FSb0J5SnpBYTh2U254M1NKVS90aGNjUk9zSDgvcFFuaUdHdDVXdUFrTElabFRReVRCeVJFQXlESHJRNU1HUkI3MjVtSkFQakpIaUlVd3AwMG1mbFYvQjhDdWxBVnZSQkkySTFVbFNRWjIwUHlOSnJRK1R1Z2Z3M0FXN1Z3WFNXY25LVUx3Vnl1RklZVHFHR3EvaFdwYmlHVHhFaGZQUVZrTWR4RzNadkl0NitqQU0yWUljNUJLbi9FeWlRSk5jVGkyRVppOTI5Ykk4V1ZUNG9HWWdBQ0oyQU8zMnZJUmZCdlpIa2l0Qm50RlovYUF1VmJiaVplQ3VkbDhPMnhtSkcvVFdydkNMdTVnaGQxa1I0ZVdoMkdocnpEalBGMWU1Y05sR0NzUU0zaUI4TTVZRXd1a0Q1VnB1RmNadDNMS0lIQXpaQTRKR1lFRVp3WjVHRDhqVlBGSkVSelJibzFPTzQ1WjBSL0dqWmdSbEpWaUFDc0VqS2RZT2hvT25GdUdPcFkyeWdCeWtrWllQVDRxcWNRTnk2Mkg3aTViem9DNTd4NEc2SE1EdG1rRWYyYXR2ZTRobVlOWlc1YkFKVXhiZk1laEFxWktpMUt5YTIzRDJJRnU4VUpFZ1Jta0VTQ0F5bjZWYzRmWXNBNWx4VnRoSTVLcDBucEZaNStLaGY0bDdod1ZnY3NpeVZZYWJobDVjcWh1NHZob1Bkdmh6Yk56S2ZBN2lkZFBReVRVdU42My9ZS1ZiMS9SdjB0SWY4QTdGUG9SK3RZampuWjY2MTI2N1g3WVRMY3VETG1KOEFCQ3NzQUFtQU5DWmlZcHI0UEEzWVZNVGZ0bEJFQXFZSDgyaEorZFNYZUVhbHJlTWxTRC9DK0NkTmdacFJxSlVtNUFQQmNjc2gxY013Z0FRUnRBZ2FqbFc4UEEyY0IwZENHQUkzR2hFamtldGVldDJYeGpCQWJZdVJDaUdIaFVUb1duYjByVDRYR2NTczI0TnBtQ2dBS0FqYUNCcGxqK3hXMlpSa2xSamhsSk4yVzJLVzM3dHJ0dk1OWURheEJIUG5WREY4V3RoQ3NqTVprYXpEYlJ5TlBidFJjQXozOExFR1BGYllIeUkzMDh4VXR2dGZZWkE3V3hsT2s1dk9ObUFpc2VOZlJyenY3QTFuRkJFSmtTRlV4Q3NUdU12bHlOUHcrS0tzekRYTkhpQkFFY2h5a2VWR3Yzbmc3Z2tXeDY1RVllNE5ERTRkaGd4SzRxQVRPUnJZeWpXWUFBQUZVK0V0U0ZHVTRPNGtlSXNvZFRlWHJCVng5UUNLckw0aEFZQVR1eklCUE1tV210UU1GZ24wbTNQazVYNlpxNDNabkROOEpjZWpUK00wSm9UVHN5V0s0cFp6SG1kSjA1d0pwVUE3UVdoWnhOMjNxUXJHRDVIVVQ1NjBxN0ZoVFJ4U3pTVGFQZDY0Ym5uVmJBNG9YTGFYTXBYTW9hRHVKRXdhbUwxNTlIcHBtVjQ3aHJQN1M5OTBRaGJMTS9nVmlTbVdUcUNDY3JLUHpySi92NnlsM3ZMYWVBTm1BeUlwM3RITDcyei9yNlZyTzAxcTRMZUpjSkllMjRHc2taMXRwQUc1L3c1K2RlWldHS3RwS3R1TndaMjA4ek1WMVlrbWppeXlhWVZ0OXI4VURtRHJta05PVWJxVEhxTlR2MW9meFhqVi9Fc0d2M1djcm9KZ0FBa0hRS0FOd1Bhb2JnS2tqS0FmTURueWcrdEdjQndVNVVaOGlLNjN2RU5TU3BDbEJHbWNTZFBJNzZtdHZpdG1QeWxxd1h3bkc1SGdRRk15T3NBeFB6cThPS05uS08yYTJUQkhJZENQU2x4N0RrWXhnR1ZqbEJKVVpSSXR3ZENkOUlJNjhoVkUydThjS3BKa2J4RUFic2ZJYSsxSnFMZC9nRTVMWDVMdU92V0xUWlVCWWpSc3htQ09nQVVmVTFjZTlmdjRjdmJIZGpETXR3OG0xK0ZsMEdnS0NCSFB5b1BqY1REUGxWUEVRd2FKYUdHYlFuYVF3cVhzK1h1M0h0bHpCczM0Qlk1WjdwbzBwMXF3dmRGbTMydHhRVHU1UmxJSTFUWFhlQ0k2bWxoT01YTHVKdDNicEJoaDRWbGRwMlZmRVkzam1kT2RHdXltRXRqQ3RldVc3YktGekUzQ2RJYTRkQkJHMlVlMVUreG1EbHJ1SlpOUXA3c2RTK2RXS2p5aUI2bXBiaXIwV2xKMXZzMi9BTGlPQ1YxR1N6b1JFRUpHeDFCa1Y1N3grOWR3K092c3JETXpFK0lTQ2pnTUFmSWFEL2xyWTluN3d0a284NWpiczZUTU1sc0J4NUhVSHprMEg3WllnTGljTmVVUVVJekhUTkJmd3dEdkhqNWM2eWhxYlJyazNCUDBDY1YyaXYzZ2xxMmlXM2FGbFNTek1mQUluUlpuK3RlcllOVnRXMFJkRlJRb25vb2o4cThyeDFudThVTXgvd1VXNmRwQmJFWjJWUXNabzcwMXVMM0VpMW9tMlZZc3Zoa0VxWkhQeXBaVXFWRHd0Mjc3UE04TmcyeFYxN2s1VmU2MnNUQmZQYzFrZ2FCVHVSdUs3aStDRkZaODZsQm1qVUJ6bGRVMVNUbE1zTkpOYWpzdGdudzhLNnJJWjdnWWEvWVZBRDAzYXFuYVJqY0NBSTV6UGN6WkpnanZnMm9Ha3dOQ1J5SFFWdDVQbFM2TVBGVWJmWm92L0FPZDJiZHZCRzQ0bk83dWY4cWVBRC9ZVDg2RjlyK0NKYXNJd0NCeUI0Z29VbHBRUVFGMUpMYmsrZEVlREtpNFZiU1pnQ0RJYlVqTVpZZmlLc2NUd1A3VGtWeWNvTW1ER2dralgvTUZySGxVN04rRndTL0JGdy9zdWlTclpneXFnbGZHRG9kVHozbllBVk4rNW9iK0hmVE4wTW8zNHo5S01XU1F4WW5jS1BhZC9lcDdoRENHQUk2RUFqNjFsTGJzMmlxVkFYdWNiYjJMSDBiTjlHcXBmNGhkSCtOWVJoL05iL01hVWMvWTBId0Y3ZitSaUIvcE1yOUthd3ZqWjB1RG82NVQvQUtsMC93QnRJWm0wZkJzV1A3UGtMQWhqYmJjSGVScFZkZUNZUEt5Mjc5MjFtajRnVGxJNkdOUGVqK0pkRC9qWVFqK1pJdUQxMGdqMnFvTUpnN253WHNoNkV4cjZOVFVtUzRvb0RzL2Y3dFJZeE50M0IrSW5ValhRNzlSN1Vydjcwc29wQ200MnVZQnBXSjBpYXZYT3pqN3E2c1BQOVJVQnM0dTBaQmVPaXRtSHNhRTE2QnArMk12OXFzUlpSR3UyeVpBekxrMVV4cnRHbE1idFRoYmlCcnRpMlZiU1NCOVJCNkdwdjMvZVdBNFU5YzZRZnBGTXhQRXNMYzB2WVpTT3F3ZjAvR2hVRGJHb09HM1VJVzJVUnRDVTBIKzArbktsaCtBNFFLeTJyNUFia3htTkkwbUtZY0J3KzViTnRYZTBwNWErdk9RTnFaaE95WVdUYXhQZUFqUUVobzh4QjBwOXA3SnFtdERMWFpHNnJCbHhJdUtQc2tlWDNnYW9ZL2h1TXNrdVZRcE82a3lCUDlhbHQ5bnNkYmNIT0hRSFdEckh6SDUwM2lQRXNaWVlaVXVGWTEwWXdmcjVWVzNLcVRKMG8zdGY5L0prOGRkejNHYnFlWjE2YTBxMWxqdFBkWlFTQUR6bFJPaGpYU2xXNnpTU3JpYzd3d2s3NWY2UFZCYUFwRlJVcEZNSzF4bm9FTG9QL2RadmoyZDdsdTNheUtmR3pNUk1MQ29jbzVraHlQbldwYTNOVWJ2REVMWi90UmxuWGFaamZyVFRvbVN0SG1mR3VBbHNRWUppNHhsanFBVDRvQTNBaFQxNVZadDhJdUEyMGtsVll5UkpNWlRvQnlVeDd0Vyt1Y0l0c3lzWmxUSTljcFhYcm94cWRMQ3JzQVBwV25rZFVaK0ZYWjU0M1l1NWV1RjJjSXZMVE1RQjh3UC9BSFJkT3h0dFV5QzdjOC9oQVByQW1QS2ExN1ZFMUo1Sk1heFJXekFYK3dUbHY4WlF1bjJTV2dBQ0ltT1hXckQ5azdWaTI1WE96c3BUTnZHZndrZ0RiZXRveTAwclI1WkM4TWZSaFc0WXk0WjhPQVdVdG1HYlFnaUkyMzJtclhDRGRGdTNBaUxhcnRCMDJKOTYxajI2aTdtazV0bExHbDBBT0Y0TzZqczd2SmVKK1FnYVZGeHJnb3ZzcElKNjY3QUJvQTU3bXRJYlZOTm1rcE5iRzRKcW1ZMi93Vmd4ZFZsOU5TVHNDcC8vQUNLbDRMWXhDTVZaSXRtWWdpRjVpTlpqeTlLMW5kVjBXNmZOMVRGNDBuYUtGdXllZFNKZ2xBaVA3T3RYTWxMTFUyVlJYdDRZTG9BQjZWS2x1cElwUlJZVWRVMDhQVEJYWm9HUHpVczFNbXVHZ1JMbnFERVlkTG54b3JlbzE5OTY3TmRtZ0FjM0IxVXphZTVhUDhyRWo1Zy9yVGMyTXQ3TWwwZENJYjh2eE5FczFJbWdBVzNIRjJ2MldUeklrZldLak5uQlhmdXFUL3lHaTJibFZQRThNc3Y4U0NlbzhQNFVCUVB2ZGxsT3FYRDVUcUtHWW5zL2lFK0dENWd3ZnJSSzd3UjFNMkx6S2VobVBkZjBwdjdiamJYeG9MZzZnVC8wd2ZjVXlXQmx4V01zL2F1ajE4WStzaXA3UGEyOE5IVkhIcGxQMDI5cUtXKzAxczZYRUtubnorbTlUbTVoTDNORDYrRS9Xbi9CTmVtQy93RDVXblBEZjdoLzIwcXZIc3hoenFBZmt4ajhhNVQrSWZJOUJOTk5LbFdac05OTU5LbFFBMWhVVENsU3BpT1JYQ3RLbFNHTUtVd3JTcFVBTVlVMktWS2dRaUs1RktsUU00QlhLVktnQmhya1VxVkFqc1VwcmxLZ0JHa0tWS2dEazBwcFVxQkNwVXFWTURzVndpbFNvQVlUVFNhVktnQnBhbTVxN1NwQVJYN0NYTkhSVzlRRDdIbFF1LzJldEg0Q3lIL1VQWTYvV3UwcWRnMG1ETG5aeTdPald5UCtZZlNLVktsVDVNamdqLy9aXCIsXHJcbiAgICAgICAgICAgIHRodW1ibmFpbDogXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8yd0NFQUFrR0J4TVNFaFVTRXhNVkZoVVhHQmNYR0JjWEdCY1dGeGdYRlJVWEZoY1ZGUmNhSGlnZ0dCb2xIaFVWSVRFaEpTa3JMaTR1Rng4ek9ETXROeWd0TGlzQkNnb0tEZzBPR2hBUUd5MG1IeVV0THkwdExTMHZMUzB0TGkwdExTMHRLeTB0TFMwdExTMHRMUzB0TFMwckxTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExmL0FBQkVJQUxjQkV3TUJJZ0FDRVFFREVRSC94QUFiQUFBQkJRRUJBQUFBQUFBQUFBQUFBQUFGQUFJREJBWUJCLy9FQUVFUUFBSUJBZ1FEQmdNRkJnUUdBd0VBQUFFQ0VRQURCQkloTVFWQlVRWVRJbUZ4a1RLQm9VSlNzY0hSRkJVall1SHdNM0tTb2xPQ3N0TGk4UlpEd2dmL3hBQWFBUUFEQVFFQkFRQUFBQUFBQUFBQUFBQUFBUUlEQkFVRy84UUFLQkVBQWdJQ0FnSUNBUVFEQVFBQUFBQUFBQUVDRVFNaEVqRVRVU0pCWVJReWdiR1JvZkFFLzlvQURBTUJBQUlSQXhFQVB3QVMxZEZOYzA1VFh6N1BwRVNMWE1ReGlCdWRKNkhrYTZ0TlY1YjAvRS8wbjNwb0dXcnVDZXlRbHhXVXdJRENESEkxQmRRTUlJQkI2MU5ldnMwWmlUQWdUcm9PVlJEZWh2ZWdTMXNyWURCSllMRkpHZlNDWmdEZVBlcmk2MEY3V2Q2ajJXdHF4Q2hnMENkVEJJTWVTMDNEY2NUSk9ZQW4rNXJTY0pOSjltY1p4aTJ1Z3pjYmxUSm9QKzlrKzhQY1Z6OTdwOTlmY1VLREJ6WHNMazAwdFFvOFl0L2ZYM0ZOUEdMZjMxOXhSd2ZvT2NmWVRacWFHb1dPTElUQVlFbnpGRXNNd090SnByc2FrbjBUb25XcEs0RFNxRFE3U0FycEFBazA2eStZU0FZODlQbjZWU2lTNUhHMEVnRW5wVEVzc1NDeDIyVWJUNTlhdVc3SlBwVnEzYUEvV3JTSVpYdFlZbmZUOGF0SWdHd3A0RlBDMDBpV3lxOGt3QlQ3V0c2MUsxd0NvOHhQcFZwRXRuTGpCVHA5S2tiRXJ5cTl4ZE1PRXQ5eVdMUjQ4MjA2YmZYNlVISzAyaVV4NzRnR21tb3lsY0JpZ0J4RmNwd05jSW9HY3BVb3JvRkFoc1YxYlpOUzIwbzd3UGlDV2MwVzB1TWRCSUxSNkFVMGhObWU3azEyano0RzZ4TGR5ZGRlUStuS2xRSXc0dVRVeU5VTnUzb0tkM1I1VnlVZGlMS21yR0ZTMTNSa1AzcE1neU11V05tRVRtMjFtaHdVa2hXT1VFZ0VtZEJPcHE3ZGhXS2gxZURHWlpnK1ltRFQ2UXUySW1wOElBUEVmbDY4cXIyMXpHS3RYRHJwc05xUzFzcnZReDB6QWc4OStSMTg2eU9MN0lPQ2NyZ0NUR2FUb1lpWTI1OWRoVy80VGdzNUxOOEkrcC9Tb09KcnJXbU9jb2JSbmxoR2VtZWZqc2xkL3dDSW5zMVBQWkYvK0tzZjVUK3RhdWFSYXIvVVQ5bVg2Ykg2TXAvOFJiWCtNSjVlRS9YV2t2Wkk4NzNzblA4QTFWcUdha3F6dlIrb243R3YvTmo5R2F0OWt6L3h1djJJMTVmYXFLMWpIdzl6dXJ2eWJrdzVFZjM1VnJxcThRd0tYbHl1T3NIbXBJaVJTV1p5MVBvYndLTzRhWnpDWGM0a1ZjdFJ5MTVmMHFsd3poeHQyeGJKT2gzR2tqOHFMWWZDQUNJZ2RCVThWOUZKdjdJQll6RWFUSHNLdVc4T0J2cWFtVlkwRlBDOWFwSVRZMENwQW5XbW01RzFSbGlhcEloc2xhNkJ0VVRPVFNDMDRMVkNJd0tjRnA5TkxVQWNJcHVXa1hwOXE1cm9KTkFpd2VGWE83RndvY2hNQm8wbXFWNjFHOWJMaEhDNzE5QUhjcmJHeWpYMm5RVU03UWNJc284QytvZ2FxSWU0V2t6SjF5amFxclZrY3QwWlI3c0hULzNVdHU2RDY5S0o0dnMvM1NMZUthUDhMTVpZL3BRekpxTktUUlNkaVo2cTNjYXE2RmhQVGMrd3E0OXNFRUhucDcxSGg3Q1cvZ1FBOWR6NzBoc2w0UGJONTRLT0ZpY3gwQk9tZ0hQblcxd043QzRZZU4xQjZEeE43Q1RXTGU4eDBreDAyRlJSVHNUVm8zajl0c09EQXQzQ09zTCtiVXF3Y1Vxcm15UEZFcjI3TkU4RGdwT3RWa3E5aDNyak80bTRodzRFYkNnMk40YUYybWpqWGlLZ3hWMEVHZWxLeDBDTUt1VlBNaysyMVBGUUV3ZktuREVBVXV4OUJpMWpjcWdEbFZERjNacW0rSzlhaWU2VFZXUlE5bXBoYW95VFhVTklaS3E5YWttb3dhbVMzMXBkajZPS0pydHRobXk3bm4wSHFlVlRJblNwN1dIQXExRWhzcDRQSHFicjJ2dExsK1laUWZ6cTVjeGx0ZmlkUjh4UTdqM0JPL0FhMlFsMGFCdFFDc3psWWozSDlhSFlYc2V5bVh2L0FDUmZPZDJQNVYwUmpCcTJ6bmxLYWRKQnEzeHl5eHlxNmsrdS9wMXF5TDA4NkVYZXkxa3FBR2NFZmFPVWsrb2dUUTl1RVl5eHJhZnZGNmYrTGZrYXFvL1RKNVNYYU5VaWF6UHk1VklCV1d3L2FOa09XOWJaVDZINnFkUjlhTllQaTl1NThMQStYTWVvcE9MUTFOTUpCYWF3TkV1QTR0bkpzMndEbklWdkRualhjL2RBOVJSRGpIQzdOclEzZ3ovZEVhZkliZk9pdFdISlhSbDN1UlRGSFNmbVpvaGl1ejRRbzF3RmxmeExKa1JQSWJEZXI5NUxWaThDbjhSQkIxRVQxRUhhaWgyQmJQREx0NWdsc3dUNVNmbE9sRXVFOEtXMWZ5M0NWWW5Lek9aalhuMEZQdmNSaThidHNaTlpVRGxWWEZZdHJqRm1NazZrMDlDMnk5eDNFdUhhMHQ0dGJHZ3luS3ArUTMrYzBHVVJUMjFwc1Vtd1NDZGdkNWJiUGRWY2c4S3RMRStTallVSWRha21uMnJKWXhRQlZOTkJvdGorR2kyWURxK2t5a241YlRRVEY0aEUzUDhBZnB2UlFXVEVWeUtnc1luYVJvZGordFRzNHBET1JTcXMzRWJZTUYxa2VZcFVDc3VxbFc3SzFkdmNNWlRCQkZNRmlLd2FPbE1ndWlxV0liUTFmdkxWQy9VVVVVWEZRc2xXeWxPV3dUeW9BSHNLN2xxOWZ3VFNBQnFlVlQvdWE3R1lvMFRsMk8vU21sWXJvRTVhNHkxYXZZWmxKQkVFYmcxR2JkRkRzZllTcmFXZXRMRERvS0lwZ21pWW1yakd5SlNvcXF2U25DcjFxMmduT3JiR0kwaHVST2hrVldLaXRPTkdmS3hrbXA3dDhGRlhJb0t6NGhPWnArOXJ5cUlpbWsweENDMWFUQVhDbWNLY3N4TWFURXhWUlNhTzhGeEZpM3JmWm02SXNtVDU4dmMwSVRkSUFZcTJwRU9vSTh3Q0I3N1VLZkMyTVA4QXh3SURGUVlNcnJNSFhsODYwM0dzVmF2UEsyUW9HMmJYZitVYWZqVld6aEJkUGR0a3luU0hnSnByck9nMi9DcVQraE5Yc2l3UGEvRFdReXU0WldVaktoSThSMkp5L25RN0NjZXMzREN0cjBiUSszT3V0MmV3K2NzeVpqNWtrZXcwSTlacm1ON1BZZTZQZ0NIa3llRSsyeCtZcXZpUjgrd3N1S0pqWGJhcHNiZlYybFVDQ0JvQ1NQWFhXc2kzQzhYWTFzM0JkWDdyYU44cE1mVWVsWGVGY1V1WEpWclRJeW1DR2tmTVNOUlNhOURVdDdEYVdpZGdUNlUxbElvbDJlNzBIdkxoN3ExcXJzRDRvUDJZVUdaNlRWamliWVJ5RnRCenl6Tk1ldXBuNlVxSHkzUUFhNE90TU4zb0tLVytBMmJkNEM2SGROdzRrazlHWE55bXU0ZkVXYlljTWl0SUlVazZxZXZuUlFXQkMxMGtoYlpJSDJwQUczdjlLTzhHNFlTaHZYUktxZkZsa2dkQnJGV3VBNHNPR3NybWRHak1FeWd5TlI0anRVdkV1RzRpemFJVmZDWThPZlErdXdwMEs5azEvdE5hQ0czYXcwZ2dnNWlCb1JHeS9yVlhoZUJ0WGJkeitEbGNDVkNCVlh6ekZ0YUNXN040dHFWVWVXcDI5T3RhN2dIRGJlOXp4SG9USXAyMnlhU1dqSFluRFJNa0NxaWxUc3cwMHIwYmkvQ01PNTB0QXUyZzU4b2dMdHk1VmllSjRSRVlyQ2dqY0RTQ09vcE5VVkdWZzA0VlB1TDdDbFRoQTBCcnRTTTladVl5MWN1QWxBUlZKK0NJNXVRWUoxUWNoNjFuTFBFSU5XVzR3UnNkYXllUnQ3UmZnY2YyT2dYeFd3RWdCZ3pTUTZnRVpTREcvT2Q5S0ZsWnFiSDM1YWVacUt4enFHN05vcWppMkt2WVd4VUttckZ1L0ZTV2p0eHdNUmI4c24vVlcxZmpDQVJwdUQ4eHpyemk3ZW03UG1QcFZoOFVhYWJYUm5QSEdmN2d0MjF4NlhIaEZXR3lsakF6WmxuVUhsTTYrZ3JNcXRUWFduZWtvcW0yK3dqRlJWSW13eWFpdEhoWXJQMkJxUFVmalJpMWNxNEV6TG1Lc3FScFFDOVoybzFjdWFWUXVyTWYzeU5hR1lNTnN6NVVpQUtJZDNVdjdNRHlvb0FkWlJTUkpnVHFRSmdkWTUwbnRpVEdvNVZadjRRY3FxT3JDZ0IzY25lRFRUcFJQaDNGTGRwU0xnTnptRkw1VkJpSklHNStWRDc5MUhhUUFKNURXZ1ZrUXVEMW83dy9BTGN0K1B1N1VHYzd0QlA4c1NCVlhFY0d1SXZlQlNVNU5HV2ZrZGFkZ01KYVpHTngwdHdmaUpMSFVhTGxIcFRTRTNyUU00amgyRGtXN2lGZXNFL29QclZIaTFpL2xEV1NNNno0VzJZSGxNaUQ2NlVTWmtWdEhMTDFWWW4vQUZVUnh2R2JUcmxGaGl4R3J2Y0piYU52NjBJR1k5YnZFaGJJNzIxQklKdGJBeDV4djg2SzRDM2RlQm15bm5wTmR0VzBBT2dCMGdsaVlITWE3OHZhckFzT0VOd0U1UWNwSTBFa1RFME4yQ2pScnNOdzZ5dG4rSzV1Tjk1enQ1S09sWjNGOE90dExxRktxd0U2UUNkUitGQ3I5MHNjekVzZXByaXZIS2l3VVRROE80bmJ3NFVqeFNKaFlrUVlnajdOVDhVN1VoamxWU1Ywa3pCNVNJajFGQU1MaUxldmV6R1V4bEtqeGNwbmxWRzVkSFg4YUwwSEZYWVgvZW9XN25DQW9ESVZ0eU9qRWZsVlRGY1RkbUpEbFFTZkNwSUFIVFNoeHVpbzJ4QUhUNW1sWTZMOWpGRld6aG1ERFlnbWZlcmRyQ202dHk1SytIVnN6QU1aNkE2azBEWEZBN1FmVFd1dGlUMWoyb3NLTEpQbFNxZ2NVUHZqM3BVaGg0SFdvNUpNMTNOVExna0FhN2pZa2JhOHVWWUhRUkRyVWxrNkdvM3J0czZVaGtwYXVCNlpYS0FJdnRWTE5RcnZVdE1RcWV0Y0ZPRkFFMW5jZXRFVk5Eckh4Q3I0cldIUmxQc216YVUwamIrK1ZObW5IbFdoQjBDcGtOUWlwQWFBSkhBTlZybG1RYW5tdTBnQkY3Q0RXcW5jbFRvU1BTamwycTF5MERURUNiNGM2bG1iL01TZnhxQmNUbDNnZktpVnhLRjQxS1FGMFk5Y2hVckxFZ2h0UVFCTWlOdGRQYXFwdmpwUWNzWk9wOTZxVzhjRGQ3c3FkWk1uK1dsZGo2TkNjVUIwOTY0ZUlhUm1IeTFvUmg3b0pZUjhKajEvU3A4MVRaWEV0TmpmTSt4cU00cnlQemlnR0w0M2xMaUl5c0ZHeG5lWjEwbVByVTNEdUlaMUI2YUdZblRtWXEzR1NWa0tVVzZDNXhCNkQzL3BUR3Z0NWZYOWFyUGlBQm1MQUFiNmJpb3I5OEFocDM4SUU2TVRCL0NJK2RKSnNwdEl0czdIbjlCUVhHOE11TzBxNFZmVS9wUlF3SkdjTWN4RUFiYURicVBPb3J1SUNrQWg5ZWlNZnFCSHVhRTVKNkZKUmEyVWNCd3RyYlpqY25RaU5mMW9sa0hTcmQ3Q0txWjF6RXNRUnRwSTJQMXFzbHBqOW44cVVtMjlqaWtsU09aYVZTL3M3ZFBxUDFwVkJab2dhUk5ObXVrMW1ha053NjExTnFpdXJKNSs4VTBXdk52OVIvV2dDeEZLS0hZbkdMYmRVSmFXRTduYVlxdmdiWnQ0aTROU3R6K0lyYTc4MW5iejlLcmlUWVN0Ym1weFZleHovdm5VNHFSamhUNmpyb3BnV01OOFEvdmxWNnFHRitLcnRhdzZNcDlrbFBxSnpBUHBXZnhIRWJ1WkVidTJETVJxazdJemRmNWFwdWlLTk5YYUU0UEhYR3VLalpZSU93SU9nOWFLelFuWU5VUFduQTB3R25Vd0dPZGFoY1UzRjRsVWtzd0hseitRb1BpZU9pU0VIb1czOWhURVg4UlFxNmN4aWhsL2lWMTJpV1U5VzBVZ2JCY3ZPcVZ0N2hsZ3p6bE01NG1aMUZ1QnZ0dlJURnlRZEdBVGZYM3FGZUVXZytlRG1FL2FQUGZTaHFYcmhEUTF3QVFSbmpPZkpNdW5MbjFwclhMaHpBTTZxTlJuK002ZkNwVXh5K3RUd2ZzcnlSOUJwY0hiRW5MdVpPcDFQWGVuL3N5ZmRGWjVicnZLS3pLUGlsODB6b0l6Qi9uRlNZU3pkdk9MTnBidmkrOW1Zam5PWU9JR2cvczB2Ry9ZZVZlZ28zQzdHdjhBQnQ2bVRLZ3lkZFQxT3A5NmRid2xwZEZ0b3ZvcWo4QlYvaDNBTFZnVGRZM2JoRUZjN0cyRDVrblgwR25tYWhmQ1d3NUlRRDBtTnVRcUpTK3JOSXh2ZEdkN1RJcEZ0ZEpMSFFEbGxNL2xWREZZUWQ1YlNQQ0ZYNlQrZ3JZL3N5ZmRIdFVkL0JXanExdERBNXFEb05hY2NpUXBZMnpCY0VGd1lyTXdjQTU5U0RHL1UrbGJIdlFlWXE5dzdDSmVDaTNiVXp5eWpTTkpQSUNpallMRDRlUWx1Mjk0L0UrUllYcUJwcWY3OHFlVEp6ZDBUanh1Q3F6enJoNWNYN21kbUlCT1hNeElnbWRKT25LdEV1SVg3dzk2SGNad0FONWlBb0JnL0F1NUd0TlhEa0FhcjdSN0FiVmN2bnNpTDRhQzM3UXZVVnloZ1FjMjE5UC9BQ3BWUGpSWGtacXdhUk5SWWErcnFHVXlDSkJxUmpXQjAyUUx6cHhOY3Q4NnA4WHd4dTJtdEtZWndBSTE1ZzdjOXFGWDJOS1QxRld3MWFzNGUvYkM1VmNnZkdHMUIzMWpsODZDY1FsSGx2Q3R0d0ZFeG1raGMwZElPMVppeng1TUozbHF6bnptUVhKakt5L1pnanlQek5EYnZFcmx6K0pjL2l4b0RjSmJVa0V3Wm4ycnE4T2psODI2UFFMVGdBa2tBRGNrd1BlcStMNHhiVElCTnpNU0IzZVZnSWdrc1pBRzRvWmY0Qmk4VllXNW10aTFxNFZpUXpMdURFYkFUSFdhT1d1RzJVdzlxVk1vUXhBSXp1eEFKR1dkaWZscHZXWEJMdGw4MjMxb3NVNFZReFBGYmRzTTEwaE1wV1FNeEF6YkRxVG9hcEh0WmhSLzloLzBQK2xTc2NuMGlua2l1MmFQQ2ZGOHFlMk9VWGhaZ3lWelRwSFBUZVowNlVFNG54UnJlR2E5YUJ6RlZ5eXBueHNvbkwxZ2t3YUE0THRJNmdYcmlscms1Vm53ako5b05BMms2R0pueXJXRVh4TTV5WEtqMEs4ZkMzb2Z3ck5ZMXd0eTBTUUZCY2trd0IvRFlhKzlXeDJsdzdXUy9lQUU2WllZc0Q4aHFQT2duRUxCeHlCYkJEQWc2ekFuU0o1eEkrbERqdFdKUzA2N0R2Q2NVbHk0clcyVmhEYWd6eUZIZ2F4M1pUczlld1Jkcm9CekRUSVpYUWFTU0JCMVAwb2x4RzdpYmhQZGpJcCt5R0dvTWFFenlvcFJ0SU9UYVRhRE4vR29reWRRQ1k1NlVGdmRwUStaRk9RaUFkQm1CSW53dFBRamxRYkgyTHFnbDBBMDFKWlBMWFhlaFNjSHhSYzN3akcyWUpsWlB3d1BBUnQ1MDByZlltOWFRYXZzV21UbUo1eko5NXFMTEEyWWVaQi9HcUQzU2dsMHkvNWtqOENLTTJ1emd4ZHBBU3R0R2hpUk9ZamNRcGtENW1xSnB2b2dXdzIvL2Q5TkthVWdpU0k1em0vU244UzdQWGNJb0lJZTFNSyt4MTFBY2NqeTAwMCtWVnYyaUNScUJyQjd3ekhLUWY3MW9ZRmhtVDc0L3dCMzZVMXd2L0VCK1ovU3U0ZHkwQWQ1dnVMZ0kxMG5RVEh2UmpoTEcyOGdra243WWtqZlVTTkRVeWx4S2pGeUc0SHMrZml2RW91NEFnM0c5QVI0UjVuMm93SFZGeVcxQ0x6QTNiemR0Mi9DbXV4T3BNbnFhelBIT0xsYjlwVlpncXQvRXkvYTIwT25MWG56ckw1VGRHdFJnckQ5eDZFWW5Gc0hJQUIyL0NwVTRrSHVNaXFZQ2hzK2tHWTBqY0hYNkdxMTgrS29hcnMwVEt1TDRrd1pJMGd5d25RcVozbXEvYUxIM2podTl0cVJiN3hGTnhTUnZNQStwQUI5Zk9yNHdpUHFTd01nZUdOZ0NkWkhtYWt4cFA3SzJIVFMyckc0UWRTN0I4OHR0cG9BQU5vSFBXdG9jVlRNTW5KMnJBWFlMaVY4WDc2cTdDMWxJeXlTRkpjWmNzN0dBMm82VnFjVmkxUVFZTFJvSkgxNlZtZUR2M1daNFVGbFZRQWtDWnpabUs2c2RUcVorS3U0Zkd1N09ibHN5dlR4RWlla2FSK2RQUHR1U0p3YWlreTgySmxpWEtrbU54TVJ5M3B0L0hBYUFMTWJnZjFvYnd1NjFyT3BSbURzempML0FEZFJCTTFKY1JYR1Z4Y1lHUENVRGU0bXFVZlpMbDZLdDNpc0V4RERySXBVOXVJcGJKUkxZQ2c2QmtCT3VwblR6cmxhVitET3phOEs0UzFxMGxza1NxZ0gxalg2MWNPQlBYNlVVVkJUd29ybGF0MmRhMHFSbThCWjcyMkhSaEI1RmRRZGlERFVIVmJqWXdXMVlmSGxKSU9paU01QW5vQ2FNOEN4RnV3K0t0dXdBVzZ6Q1R0bVB3Z2RBbmRlOVpiZ0hhSFBlYkxrUjJpRGRCSUpkOVFJWVFTWTY3OHFwNG0zcGFMdzU0d2kzSjdhcEk5UTRad0RCV21OMWJLbTYrcHVONG1KTzhUb3N4eWlzejI2N0kyN2gvYWJCRW9CbnNFUXR3QmlTVks3TWRRZXZsekpjTDRvemZ3cm9WWCt5VlBnWWhaS2lkUTBTMEhlRDBJcVRHWWxFUDhBRVlLakEvRVFKNUh6TzRyYTJqbjBaMWUwdUhuSmZ0NWROUXlEWWpRYVRLK1EzMm9IMnE3VzJqZGpEV25WaUZZczBOQlpROExaQkNqZm1kT2xDMDRVbCs2MW0xZUdkVzhCWWtnd1RHWnRUcU5JM242d1liaDEvRDNuTFdPOHVSQzVXTURPSFV0SzZtSTErdTlPR0RHdHN4bm1tK3Y4bG5pR0liRk1saTlmdDIyWHhGaXVYT3pBWlJrSkVFWmlOSkcrMVcrRzlpSkNPOTJSb1N1U0pFN0U1anZWZTNoTGY3UjMyTHVoMUJsTFFhWVl4bzZrNWxYUWN0ZEpPbXV2d2VNSnNvQUIzaHlKRXlvWjlKSjAwR3NqVFZTS2M1TktvaWhGU2R6Tk5nemJVQUtxZ3h1ZmlQditWUTR5elplU1VHZnJBTTlKbXN4ZHRYY3B1ZDg4QUVoWXQ1Y3UrdmgwTWMrWG5Hc1YzaVp0bGN3azVvSkFpUVVMSzBjdmhJanFEV1BFNnVacnNUY1ZMWlBoRUtZMkd3MG9Kd1Z4WnRMYmtiWnRCdVg4VXo4NkQ5bjhOYkYyNERhMHUrUHhoV2hpekVFSG93SStZMjFxN3grNWxZS2hnNUN4aVBDcVJvQnlKekFhOHZTbngzU0pVL3RoY2NST3NIOC9wUW5pR0d0NVd1QWtMSVpsVFF5VEJ5UkVBeURIclE1TUdSQjcyNW1KQVBqSkhpSVV3cDAwbWZsVi9COEN1bEFWdlJCSTJJMVVsU1FaMjBQeU5KclErVHVnZnczQVc3VndYU1djbktVTHdWeXVGSVlUcUdHcS9oV3BiaUdUeEVoZlBRVmtNZHhHM1p2SXQ2K2pBTTJZSWM1QktuL0V5aVFKTmNUaTJFWmk5MjliSThXVlQ0b0dZZ0FDSjJBTzMydklSZkJ2WkhraXRCbnRGWi9hQXVWYmJpWmVDdWRsOE8yeG1KRy9UV3J2Q0x1NWdoZDFrUjRlV2gyR2hyekRqUEYxZTVjTmxHQ3NRTTNpQjhNNVlFd3VrRDVWcHVGY1p0M0xLSUhBelpBNEpHWUVFWndaNUdEOGpWUEZKRVJ6UmJvMU9PNDVaMFIvR2paZ1JsSlZpQUNzRWpLZFlPaG9PbkZ1R09wWTJ5Z0J5a2taWVBUNHFxY1FOeTYySDdpNWJ6b0M1N3g0RzZITUR0bWtFZjJhdHZlNGhtWU5aVzViQUpVeGJmTWVoQXFaS2kxS3lhMjNEMklGdThVSkVnUm1rRVNDQXluNlZjNGZZc0E1bHhWdGhJNUtwMG5wRlo1K0toZjRsN2h3Vmdjc2l5VllhYmhsNWNxaHU0dmhvUGR2aHpiTnpLZkE3aWRkUFF5VFV1TjYzL1lLVmIxL1J2MHRJZjhBN0ZQb1IrdFlqam5aNjYxMjY3WDdZVExjdURMbUo4QUJDc3NBQW1BTkNaaVlwcjRQQTNZVk1UZnRsQkVBcVlIODJoSitkU1hlRWFscmVNbFNEL0MrQ2ROZ1pwUnFKVW01QVBCY2NzaDFjTXdnQVFSdEFnYWpsVzhQQTJjQjBkQ0dBSTNHaEVqa2V0ZWV0Mlh4akJBYll1UkNpR0hoVVRvV25iMHJUNFhHY1NzMjROcG1DZ0FLQWphQ0JwbGoreFcyWlJrbFJqaGxKTjJXMktXMzd0cnR2TU5ZRGF4QkhQblZERjhXdGhDc2pNWmthekRiUnlOUGJ0UmNBejM4TEVHUEZiWUh5STMwOHhVdHZ0ZllaQTdXeGxPazV2T05tQWlzZU5mUnJ6djdBMW5GQkVKa1NGVXhDc1R1TXZseU5QdytLS3N6RFhOSGlCQUVjaHlrZVZHdjNuZzdna1d4NjVFWWU0TkRFNGRoZ3hLNHFBVE9Scll5aldZQUFBRlUrRXRTRkdVNE80a2VJc29kVGVYckJWeDlRQ0tyTDRoQVlBVHV6SUJQTW1XbXRRTUZnbjBtM1BrNVg2WnE0M1puRE44SmNlalQrTTBKb1RUc3lXSzRwWnpIbWRKMDV3SnBVQTdRV2haeE4yM3FRckdENUhVVDU2MHE3RmhUUnhTelNUYVBkNjRibm5WYkE0b1hMYVhNcFhNb2FEdUpFd2FtTDE1OUhwcG1WNDdoclA3Uzk5MFFoYkxNL2dWaVNtV1RxQ0NjcktQenJKL3Y2eWwzdkxhZUFObUF5SXAzdEhMNzJ6L3I2VnJPMDFxNExlSmNKSWUyNEdza1oxdHBBRzUvdzUrZGVaV0dLdHBLdHVOd1oyMDh6TVYxWWttaml5eWFZVnQ5cjhVRG1Ecm1rTk9VYnFUSHFOVHYxb2Z4WGpWL0VzR3YzV2Nyb0pnQUFrSFFLQU53UGFvYmdLa2pLQWZNRG55Zyt0R2NCd1U1VVo4aUs2M3ZFTlNTcENsQkdtY1NkUEk3Nm10dml0bVB5bHF3WHduRzVIZ1FGTXlPc0F4UHpxOE9LTm5LTzJhMlRCSElkQ1BTbHg3RGtZeGdHVmpsQkpVWlJJdHdkQ2Q5SUk2OGhWRTJ1OGNLcEprYnhFQWJzZklhKzFKcUxkL2dFNUxYNUx1T3ZXTFRaVUJZalJzeG1DT2dBVWZVMWNlOWZ2NGN2YkhkakRNdHc4bTErRmwwR2dLQ0JIUHlvUGpjVERQbFZQRVF3YUphR0diUW5hUXdxWHMrWHUzSHRsekJzMzRCWTVaN3BvMHAxcXd2ZEZtMzJ0eFFUdTVSbElJMVRYWGVDSTZtbGhPTVhMdUp0M2JwQmhoNFZsZHAyVmZFWTNqbWRPZEd1eW1FdGpDdGV1VzdiS0Z6RTNDZElhNGRCQkcyVWUxVSt4bURscnVKWk5RcDdzZFMrZFdLanlpQjZtcGJpcjBXbEoxdnMyL0FMaU9DVjFHU3pvUkVFSkd4MUJrVjU3eCs5ZHcrT3ZzckRNekUrSVNDamdNQWZJYUQvbHJZOW43d3Rrbzg1amJzNlRNTWxzQng1SFVIemswSDdaWWdMaWNOZVVRVUl6SFROQmZ3d0R2SGo1YzZ5aHFiUnJrM0JQMENjVjJpdjNnbHEyaVczYUZsU1N6TWZBSW5SWm4rdGVyWU5WdFcwUmRGUlFvbm9vajhxOHJ4MW51OFVNeC93VVc2ZHBCYkVaMlZRc1pvNzAxdUwzRWkxb20yVllzdmhrRXFaSFB5cFpVcVZEd3QyNzdQTThOZzJ4VjE3azVWZTYyc1RCZlBjMWtnYUJUdVJ1SzdpK0NGRlo4NmxCbWpVQnpsZFUxU1RsTXNOSk5hanN0Z253OEs2cklaN2dZYS9ZVkFEMDNhcW5hUmpjQ0FJNXpQY3paSmdqdmcyb0drd05DUnlIUVZ0NVBsUzZNUEZVYmZab3YvQU9kMmJkdkJHNDRuTzd1ZjhxZUFEL1lUODZGOXIrQ0phc0l3Q0J5QjRnb1VscFFRUUYxSkxiaytkRWVES2k0VmJTWmdDREliVWpNWllmaUtzY1R3UDdUa1Z5Y29NbURHZ2tqWC9NRnJIbFU3TitGd1MvQkZ3L3N1aVNyWmd5cWdsZkdEb2RUejNuWUFWTis1b2IrSGZUTjBNbzM0ejlLTVdTUXhZbmNLUGFkL2VwN2hEQ0dBSTZFQWo2MWxMYnMyaXFWQVh1Y2JiMkxIMGJOOUdxcGY0aGRIK05ZUmgvTmIvTWFVYy9ZMEh3RjdmK1JpQi9wTXI5S2F3dmpaMHVEbzY1VC9BS2wwL3dCdElabTBmQnNXUDdQa0xBaGpiYmNIZVJwVmRlQ1lQS3kyNzkyMW1qNGdUbEk2R05QZWorSmREL2pZUWorWkl1RDEwZ2oycW9NSmc3bndYc2g2RXhyNk5UVW1TNG9vRHMvZjd0Ull4TnQzQitJblVqWFE3OVI3VXJ2NzBzb3BDbTQydVlCcFdKMGlhdlhPemo3cTZzUFA5UlVCczR1MFpCZU9pdG1Ic2FFMTZCcCsyTXY5cXNSWlJHdTJ5WkF6TGsxVXhydEdsTWJ0VGhiaUJydGkyVmJTU0I5UkI2R3B2My9lV0E0VTljNlFmcEZNeFBFc0xjMHZZWlNPcXdmMC9HaFVEYkdvT0czVUlXMlVSdENVMEgrMCtuS2xoK0E0UUt5MnI1QWJreG1OSTBtS1ljQncrNWJOdFhlMHA1YSt2T1FOcVpoT3lZV1RheFBlQWpRRWhvOHhCMHA5cDdKcW10RExYWkc2ckJseEl1S1Bza2VYM2dhb1kvaHVNc2t1VlFwTzZreUJQOWFsdDluc2RiY0hPSFFIV0RySHpINTAzaVBFc1pZWVpVdUZZMTBZd2ZyNVZXM0txVEowbzN0ZjkvSms4ZGR6M0dicWVaMTZhMHExbGp0UGRaUVNBRHpsUk9oalhTbFc2elNTcmljN3d3azc1ZjZQVkJhQXBGUlVwRk1LMXhub0VMb1AvZFp2ajJkN2x1M2F5S2ZHek1STUxDb2NvNWtoeVBuV3BhM05VYnZERUxaL3RSbG5YYVpqZnJUVG9tU3RIbWZHdUFsc1FZSmk0eGxqcUFUNG9BM0FoVDE1Vlp0OEl1QTIwa2xWWXlSSk1aVG9CeVV4N3RXK3VjSXRzeXNabFRJOWNwWFhyb3hxZExDcnNBUHBXbmtkVVorRlhaNTQzWXU1ZXVGMmNJdkxUTVFCOHdQL0FIUmRPeHR0VXlDN2M4L2hBUHJBbVBLYTE3VkUxSjVKTWF4Uld6QVgrd1RsdjhaUXVuMlNXZ0FDSW1PWFdyRDlrN1ZpMjVYT3pzcFROdkdmd2tnRGJldG95MDByUjVaQzhNZlJoVzRZeTRaOE9BV1V0bUdiUWdpSTIzMm1yWENEZEZ1M0FpTGFydEIwMko5NjFqMjZpN21rNXRsTEdsMEFPRjRPNmpzN3ZKZUorUWdhVkZ4cmdvdnNwSUo2NjdBQm9BNTdtdEliVk5ObWtwTmJHNEpxbVkyL3dWZ3hkVmw5TlNUc0NwLy9BQ0tsNExZeENNVlpJdG1ZZ2lGNWlOWmp5OUsxbmRWMFc2Zk4xVEY0MG5hS0Z1eWVkU0pnbEFpUDdPdFhNbExMVTJWUlh0NFlMb0FCNlZLbHVwSXBSUllVZFUwOFBUQlhab0dQelVzMU1tdUdnUkxucURFWWRMbnhvcmVvMTk5NjdOZG1nQWMzQjFVemFlNWFQOHJFajVnL3JUYzJNdDdNbDBkQ0liOHZ4TkVzMUltZ0FXM0hGMnYyV1R6SWtmV0tqTm5CWGZ1cVQveUdpMmJsVlBFOE1zdjhTQ2VvOFA0VUJRUHZkbGxPcVhENVRxS0dZbnMvaUUrR0Q1Z3dmclJLN3dSMU0yTHpLZWhtUGRmMHB2N2JqYlh4b0xnNmdULzB3ZmNVeVdCbHhXTXMvYXVqMThZK3NpcDdQYTI4TkhWSEhwbFAwMjlxS1crMDFzNlhFS25ueittOVRtNWhMM05ENitFL1duL0JOZW1DL3dENVduUERmN2gvMjBxdkhzeGh6cUFma3hqOGE1VCtJZkk5Qk5OTktsV1pzTk5NTktsUUExaFVUQ2xTcGlPUlhDdEtsU0dNS1V3clNwVUFNWVUyS1ZLZ1FpSzVGS2xRTTRCWEtWS2dCaHJrVXFWQWpzVXBybEtnQkdrS1ZLZ0RrMHBwVXFCQ3BVcVZNRHNWd2lsU29BWVRUU2FWS2dCcGFtNXE3U3BBUlg3Q1hOSFJXOVFEN0hsUXUvMmV0SDRDeUgvVVBZNi9XdTBxZGcwbURMblp5N09qV3lQK1lmU0tWS2xUNU1qZ2ovL1pcIixcclxuICAgICAgICB9LHtcclxuICAgICAgICAgICAgdGl0bGU6IFwiSG90ZWwgQWxpbmFsZXhcIixcclxuICAgICAgICAgICAgbGluazogXCIvaG90ZWwzXCIsXHJcbiAgICAgICAgICAgIHN1YnRpdGxlOiBcIkJyYciZb3ZcIixcclxuICAgICAgICAgICAgaW1hZ2U6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvaG90ZWwzLmpwZ1wiLFxyXG4gICAgICAgICAgICB0aHVtYm5haWw6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvaG90ZWwzLmpwZ1wiLFxyXG4gICAgICAgIH0sICBcclxuICAgICAgICBdLFxyXG5cclxuXHJcblxyXG5cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZSA6IFwiSG90ZWx1cmlcIixcclxuICAgICAgICBjbGFzczogXCJob3RlbHVyaVwiLFxyXG4gICAgICAgIGl0ZW1zOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIlBpYXRyYSBNYXJlXCIsXHJcbiAgICAgICAgICAgICAgICBsaW5rOiBcIi9ob3RlbDFcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIlBvaWFuYSBCcmHImW92XCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9ob3RlbDEuanBnXCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvaG90ZWwxLmpwZ1wiLFxyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiSG90ZWwgU3RvcFwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvaG90ZWwyXCIsXHJcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZTogXCJCcmHImW92XCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9ob3RlbDIuanBnXCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvaG90ZWwyLmpwZ1wiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJIb3RlbCBBbGluYWxleFwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvaG90ZWwzXCIsXHJcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZTogXCJCcmHImW92XCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9ob3RlbDMuanBnXCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvaG90ZWwzLmpwZ1wiLFxyXG4gICAgICAgICAgICB9LCAgICB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJIb3RlbCBFc3ByaXRcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL2hvdGVsNFwiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiQnJhyJlvdlwiLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvaG90ZWw0LmpwZ1wiLFxyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsOiBcIi9pbWFnZXMvcGFydGVuZXJpL2hvdGVsNC5qcGdcIixcclxuICAgICAgICAgICAgfSx7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJIb3RlbCBLb2xwaW5nXCIsXHJcbiAgICAgICAgICAgICAgICBsaW5rOiBcIi9ob3RlbDVcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIkJyYciZb3ZcIixcclxuICAgICAgICAgICAgICAgIGltYWdlOiBcIi9pbWFnZXMvcGFydGVuZXJpL2hvdGVsNS5qcGdcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCIvaW1hZ2VzL3BhcnRlbmVyaS9ob3RlbDUuanBnXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgIH0sXHJcblxyXG5cclxuXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogXCJSZXN0YXVyYW50ZVwiLFxyXG4gICAgICAgIGNsYXNzOiBcInJlc3RhdXJhbnRlXCIsXHJcbiAgICAgICAgXHJcbiAgICAgICAgaXRlbXM6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiQ2Vhc3VsIFLEg3VcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIlJlc3RhdXJhbnQgVHJhZGl0aW9uYWxcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL3Jlc3RhdXJhbnQxXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9yZXN0YXVyYW50MS5qcGdcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCIvaW1hZ2VzL3BhcnRlbmVyaS9yZXN0YXVyYW50MS5qcGdcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiUGlsdmF4XCIsXHJcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZTogXCJSZXN0YXVyYW50IE1hZ2hpYXJcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL3Jlc3RhdXJhbnQxXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9yZXN0YXVyYW50Mi5qcGdcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCIvaW1hZ2VzL3BhcnRlbmVyaS9yZXN0YXVyYW50Mi5qcGdcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiR2F1cmEgRHVsY2VcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIlJlc3RhdXJhbnQgXCIsXHJcbiAgICAgICAgICAgICAgICBsaW5rOiBcIi9yZXN0YXVyYW50MVwiLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvcmVzdGF1cmFudDMuanBnXCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvcmVzdGF1cmFudDMuanBnXCIsXHJcbiAgICAgICAgICAgIH0sICB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJEZWkgRnJhdHRpXCIsXHJcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZTogXCJSZXN0YXVyYW50IEl0YWxpYW5cIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL3Jlc3RhdXJhbnQxXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9yZXN0YXVyYW50NC5qcGdcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCIvaW1hZ2VzL3BhcnRlbmVyaS9yZXN0YXVyYW50NC5qcGdcIixcclxuICAgICAgICAgICAgfSwgIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkxlIFBvbXBvbiBSb3VnZVwiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiUmVzdGF1cmFudCBGcmFuyJt1emVzY1wiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvcmVzdGF1cmFudDFcIixcclxuICAgICAgICAgICAgICAgIGltYWdlOiBcIi9pbWFnZXMvcGFydGVuZXJpL3Jlc3RhdXJhbnQ1LmpwZ1wiLFxyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsOiBcIi9pbWFnZXMvcGFydGVuZXJpL3Jlc3RhdXJhbnQ1LmpwZ1wiLFxyXG4gICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJQcmltYSDImGNvYWzEgyBSb23Dom5lYXNjxINcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIk11emV1XCIsXHJcbiAgICAgICAgICAgICAgICBsaW5rOiBcIi9cIixcclxuICAgICAgICAgICAgICAgIGltYWdlOiBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFELzJ3Q0VBQWtHQnhNVEVoVVRFeE1WRmhVV0Z4WVhHQmNZRnhnWkdCZ1lGeGdZR0IwWUZ4Y1lIU2dnR0JvbEhSWWFJVEVoSlNrckxpNHVGeDh6T0RNdE55Z3RMaXNCQ2dvS0RnME9HeEFRR3k4bEh5VXRMUzB0TFM4dkxTMHRMUzh0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TGYvQUFCRUlBTUlCQXdNQklnQUNFUUVERVFIL3hBQWNBQUFCQlFFQkFRQUFBQUFBQUFBQUFBQUZBQUlEQkFZQkJ3ai94QUJBRUFBQkFnUURCUVVHQlFNQ0JnTUFBQUFCQWhFQUF4SWhCREZCQlNKUllYRUdFektCa1VLaHNjSFI4QWNVSTFMaFlwTHhGWElrTXpSamdzTkRvckwveEFBYUFRQURBUUVCQVFBQUFBQUFBQUFBQUFBQkFnTUFCQVVHLzhRQUxoRUFBZ0lDQWdFQ0JRUUJCUUVBQUFBQUFBRUNFUU1oRWpFRUlrRVRNbUZ4Z1FValVmQ1JRcUhCNGZFVS85b0FEQU1CQUFJUkF4RUFQd0R6YWJ0QklTU2s3emtkT2I2dkZYWjdwS1ZFYnFsTUg4SjBPUkRNL3dBZUVWY0l0QVh2Z2hQUnk0dUxkUTNReGN3a2hhNWdDa0tvZkpOaUFYYlRtZlV4ejBvNkNlaDdPd3RLQUgwYzhYT2JtSmlpK1VDdGlZeEV0TktpcW9uSStLNXNGRjg3NU1Nb01TU1R2RzNMbnhqMGNIa3huU1gvQUlUbENocGs4b2pLWXRDYkhDQkhZbXlkRllpSENKRnRFYlF4amtjSWg3UW1nZ0dVeDJtSHRDYU1ZWUV3cVllMEpvd1JsTUttSHRDYU1BWlRIYVllMEpveGlPbUZURWpSeG93UmxNS21KR2hOQU1SMHdnbUpHaW5qNXJXY0FhdmsyZWNROGpOOE9OalJqWllLazZrQnRmUFdFbFFzT3BIT0JrbkVvY0FGNnQ0V0dkbFpQZDgvVExLSG9tcVM1Rnc3SHl6TDJHdnVqeW8rZTAxZlJWNHdpVVJ5bUhvSUl0d0JqclI3RUpxVVUwUmFvanBqbE1TdEhHaHJCUkhUSEtZbGFPTkJzeEhUQ2lSb1VFRkdMbkZDWmhJU2dxcERGZ1VtNzJ2YzZjbzZpZlVXUVVoS1R2S1NhU1hmd2xWM09XUmdSczdGTk5Ea01RUTltZTF5WXNZdVFFVklRbFMrOFpTZEFHT2RQQjh1SUE1eDgwNFU2WjFXWGNOalY5OEphWFVwMmZ4QktQM1gxdWJ4dGs0aEthVWplTEQvQURHRzJUc3hjczk0b1ZGbE1seGRyYTVqbHpqUTdMeEZha3VGVk9IQkdSQWRzN2Z6MGpvd1pZd2tvd1czMnhaTFd3K2VRaU14SU00ZXVWSHRyUkVybU9BUkpUQ3BoaFJqUW1oOU1kcGdtR05DYUpLWVZNWXhIVEhXaDdSMW94aU9tRlRFbE1Kb3hpT21PMHc5bzdUR01STkNhSktZN1RBTVJ0SEdpV21GVEFDUldnWGpaUk5TRkNwSjVnV09nNG4waTlpMXM0L2RaNzJ0dXNHNGc2NmNvQ3lwcTNWVWxnbFZpV1VBbm1mTzhlRjV2a3JJdU5iVE9qSEd0bE9UaDF5elNGYmd6RDBrR3d2d3lhK29pOTN3QUtsTzFUVzNkNWdRRGU3amh3Z0x0Q2JOUjRVN3JQVW9nVWdOWTNkd2ROWVVtZmtvbDByQWZNbE5nejlXUG1JNG5CeVZqM1JwY0xpZUkwWlAwdDVSb05oN1BNNVlTQTRBZFRIVHJ4T1VZdkJZcXBYRVh6Y05yYTJ2RDdQcFA0WllxVFdwQ2xFTEtSWldxcjJUYXpDN2RPY1V4NThtUDBwLzlHNHg3WUV4bUhvV3BQN1ZFZmJSQlRHbTdaNElKbWlZa2Jzd1p0bXBMQi9SdlNNODBlOWd5Yzhha1FtcWRFVFJ4b2xhT1V4WVFqYUZEMmhRUUhtbXdzQ3hLcHlTRXB5U1F6bmsvVGhCdVpOclFWaVdFdTVEaTluVUdxTGdaTVdNVk5xejZBVUZTUlY0YVdKWnJ1ZEM1NDhtZ1ZnSms1WmFtcElEVWxSVFlnc1J6REZ1RWZOdE9mclowbHZIWTBLOE5iRk8rUndVTEIyc0hJK3lZdmRrSng3NUtTb2p2THBKWWdzRFloenBiTzBEOEhzaVlhZ3VZRWlXUXlTNEpjV0FKRDVLTm1hL09KcVNaN0lOVXdHcFlOMGdCaVBOanB3enUwV3hUakNTcjJNMGVqekpMUnhDdElaaEppaWdPL0M0RCs2SmtvZVBjaTdWbk94aXBaNFJ5bUpXSTR3cWpESmlrVk1Kb2thRUV3d0JqUW1pU21HcVVBUURtY3ZLTlpoclIxb2ZUSGFZeGlOb1ZNU1V3cVl4aU9tT3RFbE1LbU1ZaWFPdEVsTWNKQWhKempGWEowTkdMZlF4b1ZNY21UUVA1eStzVlB6RHVORGtVa01TMlFPWkxNZUY0OC9OK3A0NGFqc3ZIeHBlK2dSMm43eVdwSzBFa0d5Z1M5UFFaZ0g0dHlZWW5GbFMxb1h1cFdBQW9YS2dvZ01MM3VEcThhR1lwTXlXdEttR2hCdGtCZnBmUEo0eC93Q1plZUphcWR3cUNWTUFBQ2xyaHdjd09Qazd4NWM4bngyNTFUTE9DaXRNdUtxU3BTVmxVeWtDazBzR0xueVpoYlFuakZJU1FaZHFWQlNpcFRFQXBEa2tDNC9wempSVGNNNkFra0ZSU0xYZDIxWlYyTGFRQXcrRnBDbFRTbnUxckpwQXVTYWJ1Y25ZMjV4TEhOUC9BR0ZhSnNGUzdNQWxSQkdSdUxWVzBJVnd6ZU5ac1hFakR5MUtDWG1ySVN5RWh5QTdnRXVmSmhrNzJqUFlXVWxKQUFBU0N3Q2dXTmg0aTE4elpzeUJwQm5aMkZFNllsS3lwS1ZUTEtTT0o4WUFlM2k5Qm9JV2N2VU1qZllUQ3FtN1BVcFlYV0NWcHFLaXdTNHBGVndBSEhsMGpNS1VPSWowekRmbHdrU0VxRTJqY1VTUXFraXhlbzdzWUhhR0VNcVl1V2ZaSkhscDdtajJQMCtkSncvSkhJdmNIMWNBVDVOOFdqbCtBOHo5SXNVeHltUFRJbGVsWEVmMm42d29ucGhSakhqa3FhNWNwSzFHek5aeUNEbHE5N1FmMmZzK1pLSlVwU0FRRFlxVG0yUkJPZDhqRU1pZWdUbVdRbFRFa3NFbmcxbnY1dnhpcHRhZkxRUkxrcXIzblVXSkxzTHBKQWF3SWJwNWZQU2JtK0tPaEJLYmp5dFJsekZnSmR3dEdUNTVzRGRtWm9zNEJZS2lpWFNoU2l5bEZuT2wxQy9FdHhIV0JNalpDeUVrTUVLQ1hTN0tYZTJUa0Z6cHhiakhkcjRzUzl5VUZKVmNGSnVRdzBKR1I5Yzd4b1FnNUpMb3p1ajByQ3MxTjJUWnpxM0I4K3NXS0JvWXpmWmpIbnU1YUNISkRxSWNoUEJ4a0NiK2thVUpqM3NjdVVVem1lbUlLTWNhSE5FYzJjbExPYzRhVTFGV3dVMlBDWTdURGhIUUlhd0RRbUlac3ZmUm1MSzBGeGJrL3BCVFp1Qk0yWWxBcytaNEpHWis5V2pWYlUyVkttZ1NnRUJhRWdvQ1ZEdlVESUZTVDRrKys5czQ0L0o4dU9GcGRsY2VQbHN3OU1LbUpWNFNkTEpFNUZCQUZuQkd0M0duVm80U09Jam9obnh6anlURmxqa25WREdoVXdqTUdsNGFWSGkzU09mSjUrS0hXL3NWaDQwNWZRY1JFYXBvMHY4QUQxaU5Tc2plN1o4NzZ4d0tqaHkvcVdSNmlxT2lIaVJYZXh4Sk9mcDlZN2lFWEJMK0ZPcDBBSHlocE1TVFNDbEJ6ZFBNKzJ2K0k4K1U1U2R5ZG5Tb3BkRlZTQmNIcHg1eG5NWGlCSlVwS2xBS1VRUllaRTVCaHh2Yko5WTB5UWN6Yys3V0tHMGNBaGY2aFFtc2FxczloRW5YYkZ5UnRXRDFsWVE5bklaMmZMUTVldkFjb0dUTUlLbFREZExBTWw2Z3BUVXFaam9DUE1EaEVSMmtaU2ozNFVsT1NRTGtsK3VUTVA4QUVTMUdjbFNaZFNsSVNTcTdKQkJkaStZekF2ZnBES01vL2IrVG51eStWcG1NcEpvS0NrS3FVb1ZlSEptWjJ5SE8wQ1p6S0lQZlZNcFlTMjZRdHlmRTRKQWFrZFlnUmk1aFVBcEJCU0NvazNKQlVFa2hyTytyWm1DTXpDeXhMclVBYkpLczNOMDhHWTNKZjE1c2w4Tmk5ako4eDBWTEtnSHFKNGx5RFlaa09QU0NXeXNTcHU4dzZtS0FrMUtJTFBiV3diNDlJR3laNG1IdXl0VlpTR1FVc2xLZFFWRThCcUk3aFpVMEJNdFlDVWtNRkZLbEo2a2F1WDlINWtjYis1clBSZnc0a1RqT0t3eGxwY1VsVEtMKzBMdG1vcUlIN2lITjRPOXQ4STB4TXdEUGRQVVhIdWYwZ2IrSE9BbkJRTXlZbWxLbEVJRkNsWGNBMmRrM3k1WldqYWRwTUlKc3BTUTFRM2dOWEYvaGJ6anI4YWZDU2w5VFNWcWp6WXBqalJLUkhDSTk2emxJcVlVU1V3b3hqeXpBSHVrcm1ncFoyU2tod2ViWm5oNm1JRTdSa1ZoWmxwY2h5RXVDOXN0R3pIRzJjVTV1MERTa0FKWUY2WGRKdWREbC9pS2lKSVdvc2FiMkRFdVR4dmJoWjQ4Tlk3dHlMaHFWakROVW9wU2tsS1hDYXFRS1Rha2FtNXQwNHdPeEV0YXlWTWJsbU9ZTHRUWVoyNERLTHlkaWszU2U3REVGemR0UTN0RExYMWdsZzFpVVFrK0pKR1JZTHpaUnp1T2ZEakM4NHgrVU5CUHNsaFZvVTNlbklDaHN2YVVBZUFKUHE4YlFDTVpzekZ5a3ZObkxUU2x5QVhLeVRTenNIellYNENORHNIYVl4RmF3U0JZQkphdzRsdFNYajBmRG5MajYrMlJuM29LTkdhMnpqTjg3cElCQXRmSTh1WWpRWTZiUWdxYktNaE9McXVYSnlHWXRuYzZaK2NRL1VzbW93L0krQmRzSnlOb0xDeG9rQU80Tm5JQmZwOWViYU9VWEFJeU1ZdVdpV1N5aTJTaTVVeldMSlRxU1FNK0JqWTdNbkJhQXBJTk53SHNTMnJhUlh3TW43YVRZTXkyYVBzaEtVWjRJQnBBTlhCaUxQNWdla2JVeVFNa2h3NUhVak4rTVFiTHdDWlNFSkFZZ0IrYW1Ea3hjTWNYazVGbGx5cjZEeFZLanpidGhLbUl4Um1LTmxvU3d5YWwrR1o0OG1nT2llRkZncDlML0FGempiOXZzSFZKQy93Qmg1NUt0cHpDWTh5a2xWUUJEWHp1eHZ4QmprTzNHN2lnd1F3eVBsZjhBbG9aTVV4Wm5MUGt3NFp3cDA4SURzNU9RR3BiSnpiMWl0S3J2KzVWendUd0FiaC9NSVVIWVpMRFRQUXZrV2lVa1ExRWtBRFdFVmlNMmFpT2ZNWVA4THhIS1VUWjdCMkRjU1NmVWt4SFB4c3BQaW1KSG5sYlFSUW45cDVLYkpKSi96eGpiTTBIQWc1L2ZsRVdQbEpVbWtodEFiQWgrQk9SNWlBbUU3UUttcW9RZ0FIMmxMWUN4dWVPUXNEcDFoazM4eVVxcW5KVE1jMHNBV0dkS3RSbVFMV3Q1STNUcGdja3V3Zk13aXBDdThJVVVpcXJOZG5Ta093TzZBbzlIZldLSkJWaUZKUlpGQldzcE9iT0FRNURLWWdjYkhyRjFDNTBzZ3JXVkd3WXFZSDl3RGxxaHV0a0x0QVBid1draGdFa3BLVmdXRnNoeVp6NitjZEdQMVNPU2JYc2FtUVpkbFBWUW5qa21wMlk2MjYyZ0ZpOW0vd0RNQ2xrQU1iUGV4dlNTMXlNdmZyQVhCN1M3c2tnT1Nta2h5TWd6dmM1ZncwWForMTJFdWNDa3FWVWxhTTJTRkVwdjBMZWtOSERPRDAvNzJKeXNLRlcra2QyazkyU0NidXRJWXVzNmtpNzgyamQ5a01STG1UV21wY3BTWml5cGlNbnVodzZVRlIzUTc4UkhtK0J4NE5LbEtBSUlDamNFaW14R1lkMUVGeG9JS3pzU0VCUmNrdHZKTmkyVHBiSVUvRFdKeVRpMGdwbS8yZnRkS1ZUQ21iTFhLU1ZCSXRLdWtMWmtnWkVsck1YUE56UGg5dkxYT1ZPbGxqUUFVc1Y3b0FxVnhBMHoxMWp6YVdYQ2N2M0pEcGVuaUNQUEtOMytIMkJSUG5wU0ZLWkxySkJaeUxVNStlWEhxRmJmSklOaExGeWlDN0ZsYndzMmZLSzVFYmZ0WGdLcFlXTGxQdzErc1kybVBlOGJMemhUN1dqbm5Hbm9ocGpzUGFGSFRZbEh6NnFZL253dDdoQlRBN0ptaGFTWFR1MWc1TndkOGk4U2ZsWlNGaStYRVBscnpMLzRpdlB4NmdzbEpJYytmMzlJOGh5Y3RSTGh6dkpxWHJTaWtDb0ZnTjV3TkFXTEU4ZktLT0ltaWdxQUxtNWNnWml3QTFHdVFObzVPMnE2R0Z5RXVmVnZsRkVMZTVJSjROa09la1NqQjl0R0NPQjJkTW0wUFNtV1JVNTVHazg2dVhCdXNlcDdMd2t1VWdTMERJQjdYTnN5UmFQSkVZK1pVaENWS3MxTjdDOWdBYkFQSHEydzhMM01sTlN0NVFjMUsxTjJlUFF3TldUbVZ0cTdVU3k1VndvMkJZc3E5dzQ4SkEwakw0bWVyZUNVaFJMbG5hMmgweXRlTG1PbTFUMWhydGNuUTVobVAzeXlpNXM3WUM1aWFsck11U0JkZjdyM29TTXlUckhuZVZrNVpkbHNVZEEvWjJ6VjRoZEVzVksvK29lbzM0QzQxMGowZnNqczhDZExsVkNhcEpKV1FBSlVzSXpTaEk4YW5zVkhKK05nR0dLVExSM1VoSWx5dVRWcjBkU3ZQSWV1a1NiQUMxekNnNGd5UllJVElTU3RkaTRxMHk1Q0l4eVMrVzlGL2hwS3oxakY0K1ZLRHpKaUVEK3BRSHhnQmlPM0dIY3BrSm00aFgvYlFhZjd6YUtPQzdLeXdYL0xLV3I5K0ltQW5yU0t2bEIxR3oxcFR2VFVTMGpTV2hLUVAvS1pVUjVORGNpZEl4ZmE3Yk9QbVNTK0hUS2xxYTFWU3pmSlJBSUExdHEwWTNEWW1jbDNsbTV6QkI5MmNlbmRvZG55M1JkUzFHOVNscVhwbzVZZVVDcEdEbEJZQ3lBRHhJK2RvVnVORlkydWpDNG5HcVNydkNDQmtBeGNDMXFTekE1djhXdEZQN1FXM1VDMzlWL1FSNk4ybzdMMHkrOWtncXBHOEVzQzM3Z0FHTGRJODh4WGRxekFQKzVJUHZFU2JSV01yQlUvYmswMkNtUEFKL2svQ0t5MXoxK3lwWFVxQTlDd2pTUzBwQXN3Nk1JcTRoU2V2cVl5a2hyWm5EczlmN2tvZitwL2NJWCttOFZLUFJQekxRVm00a0RJZkw0Ulc3NHFJRFovZVpoK1pOMk53NlVTMGtwU0VxR3JoeUNYY3RkeDhOSXNqSHZMcVVnbjJxNldKQUpCZmlYNXhReDZWcE56Wm5mUnV2V3p4Uk9LSWVzbGFGWDQwa0Z3UnlmU053VTlrWnF0aC9aV0lCRlR1b0tEQUlGZzFRTGx4cmJrMlJ0RDVyS1M1U042MTk1S1RlN0ZtOTJVVWNCT1Nrb21wU29HWURjby9UVFNraXFsODJBOUJsRTB6YXRhbFdTQmNxTEpwVE15djFEMmJVUkp3ZkowSllDN1FZRU1LV3Fkd2xDYk1TYmJ2dFhHYk8zR0JlRzJmVWlva0F2a1N5cjJHNnBxbkl6QjR4dXRudFNWTDdzRkNueXlBRjBqbkN4K0RySlhRaFNEdTNUN0lJWmdyWEkrN3JlUGxPUHBmK1FPSmdaY3dvU0ZPeDBEWk85NzIwdDl2cE1PSmhvN3lncThRVzRBV0NHQUZuSlo3UVRuWUpRRlVsTXRrK3p1NzVMa2xTRzNYNEphOXRXZ1JpTmpyS2pVbEtVRU1UVTdLSTlnQW05WEhwYUhlV09UNkFxaXhObkZLMVMxSUFUa2xZenVBQXgxQWN4cSt4VzFQeXkwcktRc09kYmk5eU9iTU5EQUhhZ1FoSVNTNENRQUJlek1TQU5MUDVIZ0lkczNGS1NUa1F3THBhOUllN0Z4a0hFYzBtNVJ0Qjl6M0ZIYW5EemtOVUFUWXBVQ0QwYlh5ak5ZeVRRdFNSY0EyNkc0OTBaRERZb1lpYkxUM2RLUVVnaENRQ3FvdVM2aTlRMEdWK2NhZkViSTdzVlNzWFlYN3FjaFNWRURNSXFZbnllT3p4ZkljSmI5elRncExSeFFQS0ZFd2hSN05uS2ZPczVKQk4zdVh6ejFoNkpaVjFoNlpvMVM1ZXh2RGpMZTlXOWJTUFBiTENrUzZYSnRZMmJPSmtUaXE1WmpZczFYbHdpdDM1TEFaOGVMeDJkTENjalUrbzQ2aUExZllTZkJKL1VUbmJSMjk4YXhJU1V2OCt1VVpDWFBZRTNmVGx6KytNWGRtTEpWV2JzZk04Z2ZsQWJhUUE3Z3NXaE5TNXExRUN3UWtWS2JMTmpTUHJFdUo3YmhJQ0VTMU1rTWtLc0FPVHVmV0tleXlBdGFnOUpTN0U1TWRQWDNlcW00OUZKSUk4WExTN085L1BsSEs2Y3RxeXNaMTBSVGUwbUpYa1FrY21IeGcvOEFodVppOXA0VXJVVmI1TnlUa2hmR01maFNTVkJPUXkwUG1CRzgvQ1ZKL3dCUmxwSVM1VE1Za09VRUlKcVNIellGTjlGR0tUaWt0SWRTYld6MDd0eHQ2ZmhGUzVxUzZLd2dTd1BHYmt2YmdDUFNDM2JDV2xXR1Vva3NsSldrQjNLZ0hGaG4vTVozOFVscWwvbFZKTytad1plU2swbFBodTEzOUhqVTlvcFFSaFp4UlVDRUVnMUZ3ZUljNXh4dUw0dXdwcTFSZ2V6KzBRVUlTdGR3VlVqTTA1c2VGM3RBWHRGaUpuNW81bE83UUU3eHBBRHVCY1hxZ2wyTmxnSlZ6bUx6enlFQzlyLzlZczViNlBna1FzMVVFaTBmbVo2b25HbVhnVkxsQXFVaEc2R0pMNUIwNXNIeTRDUEtGekJOQkNxU1M1Y01DNTZSdk1YaUV5c0RQVTlGS2ZFSEJEa0EzSFdEdXl1enVIUWxINlNDVXBHOFVnbFJhNmk0OUIvRFRsRnlhUXFrb1cvNVBJSk9ETklIS0lzZGdWcERtV3RpOTZkMEFaa2s1RG5IdmtyRHBUNFVwSFFBZkNBZmFRT3VXTE15cWdXWWdnaGkvV0xReGIySzg5OUk4Rjc5SlVFZ29LaVFBQXFva2tzekFjZWVzYkVkaEp5UURNVkpRU21wbEx6RE9Xc1gvaU14aEpDVVRKYkovd0Rra20xT1RxMUJQMjBlMjdha0NmaDFKbHFDWmxDVWhWU1I3T1ZRZHM3aG51UnE4VW5Tam8wbTB6eFhhcFJMSlJPc3BLaWs1MWRHVUxBV3R3Z1ZKMmJkUzZlOFVwVlNRK1YzMXlNU2Rvc1N1WXMxby9VU2Q4RndvbXlYVnZHNUthbUhFNlEvWmdwcFdFcUp5S1VncVlhWEJzYkdKdUxoSFRKUzdMTjAvcHIvQU9XZllZa2x4WWhJTjlXNmpsRE1WaHBJdzVNc0tRRWdrWGQwbTl6eFo5UmxGNDR1c0tUdTBrSlVmM1B2RGpadVd1ZWtVaHN1V2xHNmxadUJ2RWtCcjY1YTNpVVpWM29EQW1FeDZscWxCQ0FXQXFLa2tnbE5nd2N1YmhyTzdDRGVMMndzeVZHZ3BJejluZ1NhU056UFRyR2V4V0xUSW1CSXBVRTd5V2ZkVVJtV0FkUWN0ZG1Pc0VGYmJtVEpZV2dPcEZ6dWoya2gyNkVHT3FlUGswK09oVXdyTG5LbVMwTFVhcXdweUI0U0FhVFlBa05TTllINFBiSVhLS1YyVUVPa0d6c2xtRDNWcUxaR09iUG5LRHBJS0dGWWNEMnJrbHJVMjhQbEZnVDBwcldrZ2p3a2tPeFdHdFZZaHliRGpFdUtUYXI3QnNHRkt4TS9VSjN5ZEIvVVdBSXlzY21MblY0blJMbVZsSkFZQVhEaXAzRDd0bUlmVGhCRForRWxFZ3pWSUJVQk1MckJBSlM1SllPR0l5RHN3aVRZczlFNHFLMUZrcVlNbHdvSFVtNUJGaTNYakZKdHBYUUtOZDJSMlBObHkwekxsQklDcVFtc040Z29zb0JrcU9lajVORjNINGxZbW1UWTFJcUYzTE9RNFpSRDZFczlvZzdINCtYM3JHY3FVbFNjd2taZzNDbmNjVFVRV0ZuWndUM2FSY2dZaVRMWE5RNFNBWmhTQXdLbjhaczdMZlBYbkM0NXBMbVBWNnNBQk9KKzFJK2FJVUJadTNwcjJXbTF0TkxQbkhZOUQ0OFA1Wkhnenlpa3RaaDk4NFlGRVhpeXFlb0J5eDVYWWpwRWFwb0tiY1hwYlRKd2RJeXN4VHFJTWNCaXd0QVV6ZWpRMFNqRkxSaDhrWkVpMnJRY3crTGxVZDBnRk9wSkljOFJBU1JMSkxjdElzWWRQM2xFcDdNYVRCU1dTVnFERlFZQ3pzN3Q5MmdCdFdRQXBTa2tBT3hBdGZxd0dzRzUrSkV4a3NsMkxBTzdNYmhXUkRzT0VEOFhnQlFKaWZBWEFJOWtnc1FmTVJIQXZWdDAzMFA5alpmZzdzQ1JQbFl1YlBCSVFaSVN4YTU3d25SLzI1UjZGMlgyTGhrYlJVdVFnZ0lBQ1R2bTVRb0tja2thajNlZUwvQy9IMDRLZWd0dlRrRFAyUWg4c3hlUFNPd3VGRk15Y2xETEpLRkdva0twWWdoSkRKc2J0NXdrcmMyVS93Qkkvd0RFUlN6TGt5MFN5cnZKcUFTQUNRQXRCWWEzSUdXZ01GKzFSLzRTZC9zK1lqdU1uc1VsWlNDTHBkTHRvNDNveEhhTGFjMmF0U1VUVlVpekFrQitoY1FyU2Qwd0pkRmJzeElwUTUxS2lPaE1DTnI0WS9teUd1cGFDT2hwZzNzdkRyUm1za1hzNHNkMyttQ2t1V0NRU0hQRXNUNnRDWklMcHN0Q1Q3b29kclgvQU5QeElHcU5PQVdraytnSmowbVNOMFhld3Z4NXhqTVlVOXpNclNGSm9VVkpJQkNnQVhCRDNCallZU1pVZ0hrSUVhdWhjdDBUUms5c0I4WmFpcWxRQVVrT2YwMzhXYkF0L2RHdGdYdERZY3VjdXBhRUhxZ0U1Tm1jL1NMdU5FVXp3NlpJUGVzQWJtUmtDU1BFWFlhQzd0eDFpLzJwN2JyVVFKY3BFbzBNb3NBc2xQQlhzcEJGdGRlRWVwN1c3TXlUSldsS0VPVWxJZEVzQUVncENuQ0hjTzhlSmRydXpjMlVwTXhRZElDYTFJSVZ2bXB4TXNHTlFJSWJRMzRUY1UzVEtPVjdSbk1maXlydkZrMHJYY1hKTjNMUG0yWHBGalk4akVKU1Z5MVZMc1ZCVHBEQzlLU2MxZFBwRmpzOWhrS0pVVkIxYVVqd2dzY3hibEZrYklueVZxUkxYK21YVUVrZXlvbG1VYkZXVjllVHdzOGkzRFg1RWF2WlZsU1p0U2xNa0ZTQUdGZ2xTbTNqeXNUd3Vid2JOa0JNNFZGbVZjYnhET2wxRG14dFozaVpFdExxSUNsS0Z5eFNBNDNpTDMwZTJXY1pqYmN4VXFlRkVoa0VsZ3RTazNJTzRUZDJTTEVrRGp4akg5NlZHZnAyRHUxRXRsbWhKcFFBa2tnM3pwTlJ6c000bTJCdE1TeW1XVWxOalU3dWJLeUJzSHE0WkRuQjdHeTVVOU5aS2dGSkthU29Nb2xpRlp1K3ZtWUY0cVNFZ2lla0JPUW1CcmduaFlaSkhVUjB3eUtVT0VsL2YrUlgvSTdFQlJCSVNsckYxVWhkSnp1Q0NRMTJQQWNHaGJQa29VRFcvd0MyNUlaN3NRZWQyNXhNdVNrck15V0hwS1F0S2trS0lDUnZCckhvMlJONGo3UVNpSlZTQXhjS1VSd0NUcHBiTnM0VlN1bzlXQUs0ckF5RmtBaEtsVWpkenRrNFBBa3ZsYjNuc3FVSmFDRUpwVG1LZWwzR1p5elBHTTNnTnNvWlFLRXBzQUZPMWh4T2hmWG0wWDA3V1F1U3hKQnBZYjVxSkxPQStiQU1EeWhKWVpyVHVodVNORGg1eUVBR1h1Mk4yOFZnNFpyT2RHRVJ6SjZsajlRbFRaQm5zYVRaK1h5Z2JnWjlhZ2hKQ1JhNUJDV0ZMT3puT3g1dkZqYUJLRFNWRXZZMGtFZUVYQ2habjU4ZWNUVUduUVU3SlY0MVJKS1ZMU0hPNkRTQmZJRFFRb0gvQUo5ZWxaR2x6bDVCbzVGcW1IWmorK0kwY2MzYUdCUUpESkk0NnZIVk1BK1o2L0tHaVlXTE9QbEhvVVJKMUtIaEFEODRycUp5dTNYT0VoVjczUEY0bVRTZXVsdmxHNkNScG5IUWZmUGpGaVVLaUxXNUdPR1drQTVQWThzK28rekhNTXRzZ0lWOWFBR1U3TENrSlV2UndLZW9ZbmhkL1dJcE8xTzd3eGxqTXFVQU9DVGNuM3hLbkV0SXFxZHQxclpsU3MzNURNUm4xcWN4S0VPZXBlekhVbkhvMy80ZmtIRHpBNmc4MTNTMW1RalU5VDdvOXM3RDQ5Q3BIZGhncERraHJrRTJKMEp6OGdJOFMvRHovcDFuL3VxLy9DSTllN0NGSWx1NDNpbzlXWk92U0o1cDhiS3hqeVJkN1ZySUlhdXlUNFV1TmN6U1dqQVlHYVNrazFPVkU3d1kraEErRWJQOFFlMHd3a3NJQ1ZLV3NPV3lTT0tqbzk3Y2pHUHdlT1JQbENhaml5aHdQTWFIK0lTSzBaQlhCWXBLN3BVU2J1NEkvYmsrbWNQbmJTVktJM2Frbm5jZElHYkdWbjk4SXM0OVhoOC9sRTV5dDJXakd0QnpCNDZYT1NRQzdnZ3BPYkcxeEdsMkppU1JTVGxsYVBNUVNDRkpMRWF4cDlnYlpLamNNb2VpdUxRc1cxdUlaeHRVemV1ZVB3aFg0bjNmU0k1RTBLU0ZESXhKSFVza24xWngwSy9FKzc2UjVIK0tXQ2FjM2VsSUlxS0tpQXVxb0VzbExQdW5lTCtJY285Y2FQSy94aVRKM1ZLc3BCU1ZIallzQndMYzJ6dENaSExYWTBEeUtWZ1ZwV29BbWdoZ0FXVWNuQVl0bzNTOGFudVpvVFVxd3NGT21weXJKbGFHd3pEbmxybnRxVFVrR1loZjdTZzJZK0pLdk9yVGlJazJQdHlnRVRYU0Zra2FwQTNRMnBCSmU4VHl4bk9La2tDMG1MRVlxbWJ2S2FhN09sTnFHY0NyTUtKelBNOElPeU83VUNpY0NwMFdkTGhSdWZUZE4rTFJVeE9HRTRGS0dXdG5ERnd6RWdtMm9QdjZ3TndlSlYzNVRQSkN3QUFrS1lCMnVHeitGb1J4NXgxMnY4L2dQUVJuWUtWS1lwcmNBbk11SGRPN2NBRnVHbXVjRHRvQk9JazdzMTJLWEwrMWx2Y0xlK0RuNVVacEpCS1J2UFU0TjJJZjN3SG1iTVJVWmN4U2dxYVFvQUkzU1FMYndGam1lWEtCaW1ydHQyaFdnWnNoYzJTbFpJZVdwUUMxWEp6dXJtekFrOVlMN0t4Nlp5VEtzVXJCUXF3c0tjNnZQTmhsQXpCN1MvTHRKS1NhSENuVFVMR3pBTm5yMDFjd3paT0c3eWFKd0NVaW9sZzk3azhiYS9TT25KRlNUbEpmWmdUSXRtNEdkS1dVZ2dHNEFzN20zTUIyQjVpQ1AraUZZWlJTRnRtM2hKWWtoTFhzVGtiZFlrL0txUk5DQWlwQ2c2bGtpcElCc29LTEZ3NEYzeWlkVXd5d0ZLQTltb2pkdVd1bC9FT2phd3M4a203VFZtb2h3c3RjbFpxV0NLaWJEUGV1YWJzNTV4T21ZcS82WnFCZXgwdlp4N0wzOGhlelJiU3NLbUFBRUVKVlp3WElCYXhET1NSbHh5TFJaR0RDellzRFlnaG5Mc2VkN1dmMnRZajhUZTBPa0N1N2ttNjFMcUxQdkdGQnc5bEp1Z1EyamhSOTd3b3ArU2xNOG1LekhVckl5aDBqRHFXb0lRSFVvc0JHdDdNZGdadUttclFwVkNVKzFaVGx5R3RiVHJkMmowcFNqRmJPZEpzeU5WbWFKSkV0UkxEUHFQbkIzYTNaQ1pKbW1WM2lGcVNBUzFRWUYrSVo3ZStHOXIrelJ3UzBJcnJLcFNGcWROTEZWNlIwaGVjWHBQc05BNlpneWtPVkYyeTVtSGJFbm9UT2xDWWtLUVZwQ25JRzZTQVE2aUVnY3pwRVdGbktXVW9jWnBTTEI3cUErY01tNFYxbEl2ZFF0d0QvQUNFWkwya1pJMlA0aDlsL3lqS2xJVUpLamMyb0QzU3dlb1prRW16a05tMFlpWTRKQkRIaGxIdXVJMnpOVU1FSjBwSVhPbFV6RXpHQmNDbFhlUzFGMkxWQ3hZS0x0bkhtUGFmQjE3Um5nQ3lpWmo1T0N4SkhxWWpoeWV6SGxEZWgyQnhhNVd6SzVhaWxSbkVPRzFMYTlJOVI3UDdXQUtaYWxVeTVhU1ZoemRTMWJvRERqU1l3dXpwTXRHRk1zcGNiNmdGQUtEbHlQdG90N0V4WDZ5U3MycVNWOENBc1pqVm1IbTBSeXlVbGFMUmk0dW1lamRzRkNhaFJZbW9NUzFyQllVSDhpSXdIWmtpVk1ueXcxQ2lHRlFjRUE1UGZoNlFmN1E3VXFTd2RsMXFMNTd4bW5US3grTVpiQnQzeHRsL0VKRnRiTWxlalQ3RVZZL2ZDTFdPWGw1eFEyTWJHTEdPVmNSS1hSUmRrWlZGckJySUFJemQ0b0tWRm5DcTNmV05qN0RrNk4xMloyc0R1bkkrNVgwTUh0c3BmRHpya0h1MWtGS2lrZ2hKSUlVQzZUemp6UEM0b29VRkR6SEtOeEkyeExtWWVZbXNWR1dzQmlIOEowNHgwWTN4bFQ2T2VjYjJqeTNaRzFjWCtha0ovTnpsbzcrUWx1L1VRcEpXZ0tjRTNzN2pyQjc4WXV6aTFvTTlLMUZyQkxGVnk5U2pva05ZZE9jQWpoU25HWVlFS1MwL0NrSlZveXBUMmV3dUdHalI2bDJ4bElWS3BXN0V0WlZJdmJlNWUrRmxMMDM5VFA1ajVpeGhCbGhTalNFN29RQnF3ZFRqUndmVGhBZnZBcGJrbGpucVc1YVBIcEhiZllNa1ljcVRZeW5DYWJKTHFEa2hydmYxanpWU0dqc3hmS1JrcVp0T3pvdzYxQVlkUzBMU0FTb2xScU9URklZSE8zdWU0aWJGMG9yVWhmL0VBaFNxZ01oWmdRSEFlOXVJdkEvc2pzc3BtektodkpTQVV1R0lVSHR4NnVHanUzTVBOQk02WW9CZ0UyTDd0Z1FRQmR5b1A1Unh6eC91MWV2N29Qc0haYXdGQ3F6Z2VITmJFdmxxNUpZUjJaTnJRVTBPeENrMUVWK2JFN3pBTllQQURaKzBVM1FxYURjQkJ1eDNNM0p0YzNpZ05vckN3dEhlTFFVa0ozV0l6dHdMSFVaL0NmL3pOczNJMDg5VXBCNzN1d3NxU0NWSmNrRU80VU1yQTVqcEFmWjIyNWZlRkNnSmFjdytiNmdrbG16YkozZ3JzbmFBbmhTbHNsendzcFdWK2JOZm9PRUNkdDltVnVacUJ1cUpLZ3pCSThuSk9aTm8yUGltNFpOTTIrdzNNMm1oQVNtb1hJdU5YSmY1YTZDRzdSQVZLVXlYQ0dxTlZWU1ZKTlc2MjZBNC90TVpLZVZURkUxSnFUWU1HZXdMaFBNdjhZMEd3TVRpRXl5b2lwS1NwSmZNWldJMVR2RTY1UTAvSDRMbEhzTmxpVFlwcUNEdW1oVjdoUmRuRmlYT2Y5UmkwdEtsVGdRa2dVNkM2am1PdWVsK3NWdGtvVXFwS1VFSWNraDNaTEJ5azhpY3hkakI3WnVJZmRXaXFrcUZJTFpLQUZ3YjdvWVJHV25iQ2lXWDJmc0htelhZUHV0ZHJoaVhGNFVla1lOakxRWEpkSXVjOHRlY0tMcHVoOW55N3NsWUUxSkxzQ2NzOGpyR3J3bTNjUWdOSm1pVW52TzgwSksyU0xraTQzQnVsd2JndUNZeXN1UlRjRUVuaEU2U1k3NXhVaUtiUWJRZ2Q1M2lweG1MVVhXNElTUTcwbFNpTFdHUXlzSVcwMGllb3FtTFdYYmVzQUFBQUFIY25MaEFsRVN2MTlZUjQvZXhpYkQ0WER5bG9tQXpTVXFTcHQxblNRUTlyK3NIK3ltSndxSnhXdERKQVVhbHBDaWxaMUJPVDNzSXpvbkFId2p6Yy9PRk14SlZtYmNNZ09nRm9Wd2svY0MwYWp0VjJ0NzVVdnVwc3gwQXVxN1BaZ3hzZGJsNHkrenNWTU04S1dhaXlrM0lGaWxtdmFJMkVJOUkwWXFLRGJZVFZ0QnBTQXp1blBMemdyc1NjeTBubWs1NlYzKytrWkNZU1RjVzVaNWVrYXJCN1VsaWpldUtMWjJTb1doSlkxV2lrY213emlabFFmTWIzL3NpcmhSdnFKMDE0NVJETTJqTHB6dXhmUEkxOE9zV3RuS1N0SlZlNmlCMERST1ViMGhvNjdDdXpaeVVwTG1Jc1p0TkQzVmtEOVlxemJKTklMdGF6aTcrc1pQOEFVVVNBRG0xd2JlV2NUK0czMk01cGJSclY3VFJiZUYvbi9pTHVGeDZBQUtnNy9IbkhuczlTMDZLR2hmUStST2tXTm00MXFRUXF4emI3NVFmZ3RiUVBpY3RNOUlFOUp5VVBVUlI3NHBXU05EYlg0eFJrQUtBSU9jUzl5b2ErK0ViazBQRlJOakoyUExtcFJqQ3RZVTZGcTRBeXlOM0t3WkFFUWRwTzEzZmtKb0tVcEw1dTU0NUNCV3dkdUdVOHRkNVpjVXUyYjM5VEZMR0NVQ3ZlQkZtYlI3OFh0bEVuelgyR1NpL3VWZTBHSlRPa0xscERGUTF5MHY3b3dHSTdQem1Oa20yaWh3NXRHd1hNRVFMWEhURE5KQ1N4UllVd1pRbEtXS2FtQk53N201SHJGUGIwaXVRc0FPV2NkZkw3T1VEMVRJaFZNamNtM2JCOE5WUVAycHNyOUFGUUFtcGNxQ1IrN2lHNWVzRE5tN1FteVVxWXFBSUxETklVejVGdzhhM1o2eFdncUZ5Zk5oZDM0V0ZtNFFCN1JOVW9KTEFMY0FBaXhEa256TVVoazUraVNPZVVhREV1VExTa1Q1WUFVUUFRNFVFc2oyQ0hCZFFIeGkzczZjc1RhRk1TSlNTVTN6SnNHZG5ZOE5SempQN0F4Y3NZZVloWnVWT3daN0FDNGF3c0FPWlBHRHY0ZWhDc1ROSzBsUVhTbElzMWdRWGU5aUJsODRuTEhxVit4bHNJbzJZanhKdzc3aEhlWmVIVjdod3c4L1FFOW1ZTlNrcDNTVXFON2czRGdLTFc0K1JHYlcxMjZ6TVc0TjhvZ2xybG9zSFNCL1NwaDFMV2puYXZiWlRpWmpzTHNkYWdKdFJDU3FjZ2dON0tsSXlMM3Q3eEd2dy9aeEtaeG12WlMxTFlCbUtpNDh1VVpuczV0UVllVXRCM2xHYk5XaVdueEs3eVlWQnliQzEraGpiN0h4eG15Z3RTQ2czQlNiczF1QXRGUFMyQlVYQTBjaGVrS0tCUGxFQXhJaWFvYW1IVVJOSXdhbEFxeVFNMUhMaGJqSGZaRkVnbWo3K0VQRXlJWm9GZ2wyR1Q2dm1XMGhJakdaTWt3OFEwSzVEMCtzT1FJV3pEd05YRU9BamdURXFVUXJDY1NrUklFZmYzbEhVSmpvRUFJaWg5WW1rVEZJOEtpQS9rL1NJa25XT2xYRFA3MWhHRWYzc3h5b0xWdlo1Tlo4b1lpdDZndFFQSXQvRU5Nd2dPVDZDR3FWcThBd3lmaHlwVlJXcXJpN1IxV0hjTXBhajFQMGhzeWRUZlBpMFdwQ2tsOTBsdWIra0hZRHVIV1VOU28yeXZsRnRPMTVvYzFPRzFHWFRuOUloNzZUWWl1cmszTElrOHhGS2NzS0NtZHhaaTF6MWVGNGpXWHY4QVVGRnhueDYvZndpTDh5K2tEY0lWSmJPTlpzdFlXaTZSZmtPUDBpZVNmdzEwQlRiQUg1NWkxNGJOMm1XczVqVTRuWlNGQUFvRG5KZ3hnWE43T3BjbEt6eUhMNXdpOGlEN00zSXo1eEtnWEJOK01kL1BrNlJvWjJ4RXMyZGdCYjd2ZUJPTjdQcUhndmZNaXdIbHppa00yT1dnWElMWUlwbmlVaEs2WmlVdnhwOWx5L0E2ZElxWXZEbWFnSlVwSU5hbllBcTNTb1dlN1g5REhPeUV2dThZVXpEa2xRNGczU1EzVVhqWjdXbFlkUS9UUUFTVXJTUW00ZDNOWG0vbVlsT3NiMTl3OGJqWjVtY0lBcVlFZ3FvWWxRdFNBcW5lNnVJMFBaL2JDcEtVbE10R1NyczUzaWY0NVFTVmhONWJqTkJRU0M1SXFCU1M0Wnh2ZXVzUlRjRkxYdWxCSlFsSVQ3TGdhdUdEMzkwR1dkU2pzRDBHNUhhaWFzT1JTZjhBYVcra1ZNUmpacXF2MVdleDNpUmNHeEJPN0ZJU1dWU0JUYnk2NU56ejlZblNpeElHVFdzeXJDMXpwN281bTM3QzhtTW1CWVR1QkwyQVBPM0RsYUMrdzlyekpSVWtoVkpzRFVWRzFnNEphemVmSFNCYzA1Y3JuNDM5OFdCWU1IUEhJOGc3OU9lc0kyNk1td29lMWt6K3IrMHdvRUZYRlB1UHloUnJmMU55WjV3a1hFRWRwaHFRTEN4WVdEMEpMdENoUjdRRVVoRHlmaENoUXdSLzFpekpGdjhBeUVLRkFNeWZGcEFXVzQvS0h5a2p1eWRhaGZ5TUtGQ01JMlhwNXgxR3NLRkFRVGljdlA2UXpReDJGQU1SVExtL0V3MmFrQVd0bkNoUW9Db3M3cDhvSVlYd1RmOEFhUG5DaFF6NkdoMExIQmxKYmg4eEZqQ0RkOHZuQ2hRcGlsTjhYbWZoQm5ZeWpISVVRemZJVDl6VXl6WWRmb1lqbDZ3b1VlWi9KUjlIVUpCZDlDbHVXV1hySEVlSDErSmhRb3F1aDBPa3l4K1lsMkdaMDZSWXhRM2h6bUlCNlh0SFlVYVB5b2VQeWcvYWlSVXF3MDk0aExTS1UyMFB1ZUZDZ3YySXo3SHBHZm44UkRKaVJRQzNENEdGQ2hWMkw3RVNMb3ZkNVpmbnVqUGpFYzRNUzF0MGZDRkNncnNETGN0UmJNd29VS0VmWk5uLzJRPT1cIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8yd0NFQUFrR0J4TVRFaFVURXhNVkZoVVdGeFlYR0JjWUZ4Z1pHQmdZRnhnWUdCMFlGeGNZSFNnZ0dCb2xIUllhSVRFaEpTa3JMaTR1Rng4ek9ETXROeWd0TGlzQkNnb0tEZzBPR3hBUUd5OGxIeVV0TFMwdExTOHZMUzB0TFM4dExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExmL0FBQkVJQU1JQkF3TUJJZ0FDRVFFREVRSC94QUFjQUFBQkJRRUJBUUFBQUFBQUFBQUFBQUFGQUFJREJBWUJCd2oveEFCQUVBQUJBZ1FEQlFVR0JRTUNCZ01BQUFBQkFoRUFBeEloQkRGQkJTSlJZWEVHRXpLQmtVS2hzY0hSOEFjVUkxTGhZcEx4RlhJa016Umpnc05Eb3JML3hBQWFBUUFEQVFFQkFRQUFBQUFBQUFBQUFBQUJBZ01BQkFVRy84UUFMaEVBQWdJQ0FnRUNCUVFCQlFFQUFBQUFBQUVDRVFNaEVqRUVJa0VUTW1GeGdRVWpVZkNSUXFIQjRmRVUvOW9BREFNQkFBSVJBeEVBUHdEemFidEJJU1NrN3prZE9iNnZGWFo3cEtWRWJxbE1IOEowT1JETS93QWVFVmNJdEFYdmdoUFJ5NHVMZFEzUXhjd2toYTVnQ2tLb2ZKTmlBWGJUbWZVeHowbzZDZWg3T3d0S0FIMGM4WE9ibUppaStVQ3RpWXhFdE5LaXFvbkkrSzVzRkY4NzVNTW9NU1NUdkczTG54ajBjSGt4blNYL0FJVGxDaHBrOG9qS1l0Q2JIQ0JIWW15ZEZZaUhDSkZ0RWJReGprY0loN1FtZ2dHVXgybUh0Q2FNWVlFd3FZZTBKb3dSbE1LbUh0Q2FNQVpUSGFZZTBKb3hpT21GVEVqUnhvd1JsTUttSkdoTkFNUjB3Z21KR2luajVyV2NBYXZrMmVjUThqTjhPTmpSalpZS2s2a0J0ZlBXRWxRc09wSE9Ca25Fb2NBRjZ0NFdHZGxaUGQ4L1RMS0hvbXFTNUZ3N0h5ekwyR3Z1anlvK2UwMWZSVjR3aVVSeW1Ib0lJdHdCanJSN0VKcVVVMFJhb2pwamxNU3RIR2hyQlJIVEhLWWxhT05Cc3hIVENpUm9VRUZHTG5GQ1poSVNncXBERmdVbTcydmM2Y282aWZVV1FVaEtUdktTYVNYZndsVjNPV1JnUnM3Rk5ORGtNUVE5bWUxeVlzWXVRRVZJUWxTKzhaU2RBR09kUEI4dUlBNXg4MDRVNloxV1hjTmpWOThKYVhVcDJmeEJLUDNYMXVieHRrNGhLYVVqZUxEL0FER0cyVHN4Y3M5NG9WRmxNbHhkcmE1amx6alE3THhGYWt1RlZPSEJHUkFkczdmejBqb3daWXdrb3dXMzJ4WkxXdytlUWlNeElNNGV1Vkh0clJFcm1PQVJKVENwaGhSalFtaDlNZHBnbUdOQ2FKS1lWTVl4SFRIV2g3UjFveGlPbUZURWxNSm94aU9tTzB3OW83VEdNUk5DYUpLWTdUQU1SdEhHaVdtRlRBQ1JXZ1hqWlJOU0ZDcEo1Z1dPZzRuMGk5aTFzNC9kWjcydHVzRzRnNjZjb0N5cHEzVlVsZ2xWaVdVQW5tZk84ZUY1dmtySXVOYlRPakhHdGxPVGgxeXpTRmJnekQwa0d3dnd5YStvaTkzd0FLbE8xVFczZDVnUURlN2pod2dMdENiTlI0VTdyUFVvZ1VnTlkzZHdkTllVbWZrb2wwckFmTWxOZ3o5V1BtSTRuQnlWajNScGNMaWVJMFpQMHQ1Um9OaDdQTTVZU0E0QWRUSFRyeE9VWXZCWXFwWEVYemNOcmEydkQ3UHBQNFpZcVRXcENsRUxLUlpXcXIyVGF6QzdkT2NVeDU4bVAwcC85RzR4N1lFeG1Ib1dwUDdWRWZiUkJUR203WjRJSm1pWWtic3dadG1wTEIvUnZTTTgwZTlneWM4YWtRbXFkRVRSeG9sYU9VeFlRamFGRDJoUVFIbW13c0N4S3B5U0VweVNRem5rL1RoQnVaTnJRVmlXRXU1RGk5blVHcUxnWk1XTVZOcXo2QVVGU1JWNGFXSlpydWRDNTQ4bWdWZ0prNVphbXBJRFVsUlRZZ3NSekRGdUVmTnRPZnJaMGx2SFkwSzhOYkZPK1J3VUxCMnNISSt5WXZka0p4NzVLU29qdkxwSllnc0RZaHpwYk8wRDhIc2lZYWd1WUVpV1F5UzRKY1dBSkQ1S05tYS9PSnFTWjdJTlV3R3BZTjBnQmlQTmpwd3p1MFd4VGpDU3IyTTBlanpKTFJ4Q3RJWmhKaWlnTy9DNEQrNkprb2VQY2k3Vm5PeGlwWjRSeW1KV0k0d3FqREppa1ZNSm9rYUVFd3dCalFtaVNtR3FVQVFEbWN2S05aaHJSMW9mVEhhWXhpTm9WTVNVd3FZeGlPbU90RWxNS21NWWlhT3RFbE1jSkFoSnpqRlhKME5HTGZReG9WTWNtVFFQNXkrc1ZQekR1TkRrVWtNUzJRT1pMTWVGNDgvTitwNDRhanN2SHhwZStnUjJuN3lXcEswRWtHeWdTOVBRWmdINHR5WVluRmxTMW9YdXBXQUFvWEtnb2dNTDN1RHE4YUdZcE15V3RLbUdoQnRrQmZwZlBKNHgvd0NaZWVKYXFkd3FDVk1BQUNscmh3Y3dPUGs3eDVjOG54MjUxVExPQ2l0TXVLcVNwU1ZsVXlrQ2swc0dMbnlaaGJRbmpGSVNRWmRxVkJTaXBURUFwRGtrQzQvcHpqUlRjTTZBa2tGUlNMWGQyMVpWMkxhUUF3K0ZwQ2xUU251MXJKcEF1U2FidWNuWTI1eExITlAvQUdGYUpzRlM3TUFsUkJHUnVMVlcwSVZ3emVOWnNYRWpEeTFLQ1htcklTeUVoeUE3Z0V1ZkpoazcyalBZV1VsSkFBQVNDd0NnV05oNGkxOHpac3lCcEJuWjJGRTZZbEt5cEtWVExLU09KOFlBZTNpOUJvSVdjdlVNamZZVENxbTdQVXBZWFdDVnBxS2l3UzRwRlZ3QUhIbDBqTUtVT0lqMHpEZmx3a1NFcUUyamNVU1Fxa2l4ZW83c1lIYUdFTXFZdVdmWkpIbHA3bWoyUDArZEp3L0pISXZjSDFjQVQ1TjhXamwrQTh6OUlzVXh5bVBUSWxlbFhFZjJuNndvbnBoUmpIamtxYTVjcEsxR3pOWnlDRGxxOTdRZjJmcytaS0pVcFNBUURZcVRtMlJCT2Q4akVNaWVnVG1XUWxURWtzRW5nMW52NXZ4aXB0YWZMUVJMa3FyM25VV0pMc0xwSkFhd0licDVmUFNibStLT2hCS2JqeXRSbHpGZ0pkd3RHVDU1c0RkbVpvczRCWUtpaVhTaFNpeWxGbk9sMUMvRXR4SFdCTWpaQ3lFa01FS0NYUzdLWGUyVGtGenB4YmpIZHI0c1M5eVVGSlZjRkp1UXcwSkdSOWM3eG9RZzVKTG96dWowckNzMU4yVFp6cTNCOCtzV0tCb1l6ZlpqSG51NWFDSEpEcUljaFBCeGtDYitrYVVKajNzY3VVVXptZW1JS01jYUhORWMyY2xMT2M0YVUxRld3VTJQQ1k3VERoSFFJYXdEUW1JWnN2ZlJtTEswRnhiay9wQlRadUJNMllsQXMrWjRKR1orOVdqVmJVMlZLbWdTZ0VCYUVnb0NWRHZVRElGU1Q0aysrOXM0NC9KOHVPRnBkbGNlUGxzdzlNS21KVjRTZExKRTVGQkFGbkJHdDNHblZvNFNPSWpvaG54emp5VEZsamtuVkRHaFV3ak1HbDRhVkhpM1NPZko1K0tIVy9zVmg0MDVmUWNSRWFwbzB2OEFEMWlOU3NqZTdaODc2eHdLamh5L3FXUjZpcU9pSGlSWGV4eEpPZnA5WTdpRVhCTCtGT3AwQUh5aHBNU1RTQ2xCemRQTSsyditJOCtVNVNkeWRuU29wZEZWU0JjSHB4NXhuTVhpQkpVcEtsQUtVUVJZWkU1Qmh4dmJKOVkweVFjemMrN1dLRzBjQWhmNmhRbXNhcXM5aEVuWGJGeVJ0V0QxbFlROW5JWjJmTFE1ZXZBY29HVE1JS2xURGRMQU1sNmdwVFVxWmpvQ1BNRGhFUjJrWlNqMzRVbE9TUUxrbCt1VE1QOEFFUzFHY2xTWmRTbElTU3E3SkJCZGkrWXpBdmZwREtNby9iK1RudXkrVnBtTXBKb0tDa0txVW9WZUhKbVoyeUhPMENaektJUGZWTXBZUzI2UXR5ZkU0SkFha2RZZ1JpNWhVQXBCQlNDb2szSkJVRWtock8rclptQ016Q3l4THJVQWJKS3MzTjA4R1kzSmYxNXNsOE5pOWpKOHgwVkxLZ0hxSjRseURZWmtPUFNDV3lzU3B1OHc2bUtBazFLSUxQYld3YjQ5SUd5WjRtSHV5dFZaU0dRVXNsS2RRVkU4QnFJN2haVTBCTXRZQ1VrTUZGS2xKNmthdVg5SDVrY2IrNXJQUmZ3NGtUak9Ld3hscGNVbFRLTCswTHRtb3FJSDdpSE40Tzl0OEkweE13RFBkUFVYSHVmMGdiK0hPQW5CUU15WW1sS2xFSUZDbFhjQTJkazN5NVpXamFkcE1JSnNwU1ExUTNnTlhGL2hiempyOGFmQ1NsOVRTVnFqellwampSS1JIQ0k5NnpsSXFZVVNVd294anl6QUh1a3JtZ3BaMlNraHdlYlpuaDZtSUU3UmtWaFpscGNoeUV1QzlzdEd6SEcyY1U1dTBEU2tBSllGNlhkSnVkRGwvaUtpSklXb3NhYjJERXVUeHZiaFo0OE5ZN3R5TGhxVmpETlVvcFNrbEtYQ2FxUUtUYWthbTV0MDR3T3hFdGF5Vk1ibG1PWUx0VFlaMjRES0x5ZGlrM1NlN0RFRnpkdFEzdERMWDFnbGcxaVVRaytKSkdSWUx6WlJ6dU9mRGpDODR4K1VOQlBzbGhWb1UzZW5JQ2hzdmFVQWVBSlBxOGJRQ01ac3pGeWt2Tm5MVFNseUFYS3lUU3pzSHpZWDRDTkRzSGFZeEZhd1NCWUJKYXc0bHRTWGowZkRuTGo2KzJSbjNvS05HYTJ6ak44N3BJQkF0Zkk4dVlqUVk2YlFncWJLTWhPTHF1WEp5R1l0bmM2WitjUS9Vc21vdy9JK0Jkc0p5Tm9MQ3hva0FPNE5uSUJmcDllYmFPVVhBSXlNWXVXaVdTeWkyU2k1VXpXTEpUcVNRTStCalk3TW5CYUFwSU5Od0hzUzJyYVJYd01uN2FUWU15MmFQc2hLVVo0SUJwQU5YQmlMUDVnZWtiVXlRTWtodzVIVWpOK01RYkx3Q1pTRUpBWWdCK2FtRGt4Y01jWGs1RmxseXI2RHhWS2p6YnRoS21JeFJtS05sb1N3eWFsK0daNDhtZ09pZUZGZ3A5TC9BRnpqYjl2c0hWSkMvd0JoNTVLdHB6Q1k4eWtsVlFCRFh6dXh2eEJqa08zRzdpZ3dRd3lQbGY4QWxvWk1VeFpuTFBrdzRad3AwOElEczVPUUdwYkp6YjFpdEtydis1Vnp3VHdBYmgvTUlVSFlaTERUUFF2a1dpVWtRMUVrQURXRVZpTTJhaU9mTVlQOEx4SEtVVFo3QjJEY1NTZlVreEhQeHNwUGltSkhubGJRUlFuOXA1S2JKSkovenhqYk0wSEFnNS9mbEVXUGxKVW1raHRBYkFoK0JPUjVpQW1FN1FLbXFvUWdBSDJsTFlDeHVlT1FzRHAxaGszOHlVcXFuSlRNYzBzQVdHZEt0Um1RTFd0NUkzVHBnY2t1d2ZNd2lwQ3U4SVVVaXFyTmRuU2tPd082QW85SGZXS0pCVmlGSlJaRkJXc3BPYk9BUTVES1lnY2JIckYxQzUwc2dyV1ZHd1lxWUg5d0RscWh1dGtMdEFQYndXa2hnRWtwS1ZnV0ZzaHlaejYrY2RHUDFTT1NiWHNhbVFaZGxQVlFuamttcDJZNjI2MmdGaTltL3dETUNsa0FNYlBleHZTUzF5TXZmckFYQjdTN3NrZ09TbWtoeU1nenZjNWZ3MFhaKzEyRXVjQ2txVlVsYU0yU0ZFcHYwTGVrTkhET0QwLzcySnlzS0ZXK2tkMms5MlNDYnV0SVl1czZraTc4MmpkOWtNUkxtVFdtcGNwU1ppeXBpTW51aHc2VUZSM1E3OFJIbStCeDROS2xLQUlJQ2pjRWlteEdZZDFFRnhvSUt6c1NFQlJja3R2Sk5pMlRwYklVL0RXSnlUaTBncG0vMmZ0ZEtWVENtYkxYS1NWQkl0S3VrTFprZ1pFbHJNWFBOelBoOXZMWE9WT2xsalFBVXNWN29BcVZ4QTB6MTFqemFXWENjdjNKRHBlbmlDUFBLTjMrSDJCUlBucFNGS1pMckpCWnlMVTUrZVhIcUZiZkpJTmhMRnlpQzdGbGJ3czJmS0s1RWJmdFhnS3BZV0xsUHcxK3NZMm1QZThiTHpoVDdXam5uR25vaHBqc1BhRkhUWWxIejZxWS9ud3Q3aEJUQTdKbWhhU1hUdTFnNU53ZDhpOFNmbFpTRmkrWEVQbHJ6TC80aXZQeDZnc2xKSWMrZjM5SThoeWN0UkxoenZKcVhyU2lrQ29GZ041d05BV0xFOGZLS09JbWlncUFMbTVjZ1ppd0ExR3VRTm81TzJxNkdGeUV1ZlZ2bEZFTGU1SUo0TmtPZWtTakI5dEdDT0IyZE1tMFBTbVdSVTU1R2s4NnVYQnVzZXA3THdrdVVnUzBESUI3WE5zeVJhUEpFWStaVWhDVktzMU43QzlnQWJBUEhxMnc4TDNNbE5TdDVRYzFLMU4yZVBRd05XVG1WdHE3VVN5NVZ3bzJCWXNxOXc0OEpBMGpMNG1lcmVDVWhSTGxuYTJoMHl0ZUxtT20xVDFocnRjblE1aG1QM3l5aTVzN1lDNWlhbHJNdVNCZGY3cjNvU015VHJIbmVWazVaZGxzVWRBL1oyelY0aGRFc1ZLLytvZW8zNEM0MTBqMGZzanM4Q2RMbFZDYXBKSldRQUpVc0l6U2hJOGFuc1ZISitOZ0dHS1RMUjNVaElseXVUVnIwZFN2UElldWtTYkFDMXpDZzRneVJZSVRJU1N0ZGk0cTB5NUNJeHlTK1c5Ri9ocEt6MWpGNCtWS0R6SmlFRCtwUUh4Z0JpTzNHSGNwa0ptNGhYL2JRYWY3emFLT0M3S3l3WC9MS1dyOStJbUFuclNLdmxCMUd6MXBUdlRVUzBqU1doS1FQL0taVVI1TkRjaWRJeGZhN2JPUG1TUytIVEtscWExVlN6ZkpSQUlBMXRxMFkzRFltY2wzbG01ekJCOTJjZW5kb2RueTNSZFMxRzlTbHFYcG81WWVVQ3BHRGxCWUN5QUR4SStkb1Z1TkZZMnVqQzRuR3FTcnZDQ0JrQXhjQzFxU3pBNXY4V3RGUDdRVzNVQzM5Vi9RUjZOMm83TDB5KzlrZ3FwRzhFc0MzN2dBR0xkSTg4eFhkcXpBUCs1SVB2RVNiUldNckJVL2JrMDJDbVBBSi9rL0NLeTF6MSt5cFhVcUE5Q3dqU1MwcEFzdzZNSXE0aFNldnFZeWtoclpuRHM5Zjdrb2YrcC9jSVgrbThWS1BSUHpMUVZtNGtESWZMNFJXNzRxSURaL2VaaCtaTjJOdzZVUzBrcFNFcUdyaHlDWGN0ZHg4Tklzakh2THFVZ24ycTZXSkFKQmZpWDV4UXg2VnBOelpuZlJ1dld6eFJPS0llc2xhRlg0MGtGd1J5ZlNOd1U5a1pxdGgvWldJQkZUdW9LREFJRmcxUUxseHJiazJSdEQ1cktTNVNONjE5NUtUZTdGbTkyVVVjQk9Ta29tcFNvR1lEY28vVFRTa2lxbDgyQTlCbEUwemF0YWxXU0JjcUxKcFRNeXYxRDJiVVJKd2ZKMEpZQzdRWUVNS1dxZHdsQ2JNU2JidnRYR2JPM0dCZUcyZlVpb2tBdmtTeXIyRzZwcW5JekI0eHV0bnRTVkw3c0ZDbnl5QUYwam5DeCtEckpYUWhTRHUzVDdJSVpnclhJKzdyZVBsT1BwZitRT0pnWmN3b1NGT3gwRFpPOTcyMHQ5dnBNT0pobzd5Z3E4UVc0QVdDR0FGbkpaN1FUbllKUUZVbE10ayt6dTc1TGtsU0czWDRKYTl0V2dSaU5qcktqVWxLVUVNVFU3S0k5Z0FtOVhIcGFIZVdPVDZBcWl4Tm5GSzFTMUlBVGtsWXp1QUF4MUFjeHEreFcxUHl5MHJLUXNPZGJpOXlPYk1OREFIYWdRaElTUzRDUUFCZXpNU0FOTFA1SGdJZHMzRktTVGtRd0xwYTlJZTdGeGtIRWMwbTVSdEI5ejNGSGFuRHprTlVBVFlwVUNEMGJYeWpOWXlUUXRTUmNBMjZHNDkwWkREWW9ZaWJMVDNkS1FVZ2hDUUNxb3VTNmk5UTBHVitjYWZFYkk3c1ZTc1hZWDdxY2hTVkVETUlxWW55ZU96eGZJY0piOXpUZ3BMUnhRUEtGRXdoUjdObktmT3M1SkJOM3VYenoxaDZKWlYxaDZabzFTNWV4dkRqTGU5VzliU1BQYkxDa1M2WEp0WTJiT0prVGlxNVpqWXMxWGx3aXQzNUxBWjhlTHgyZExDY2pVK280NmlBMWZZU2ZCSi9VVG5iUjI5OGF4SVNVdjgrdVVaQ1hQWUUzZlRseisrTVhkbUxKVldic2ZNOGdmbEFiYVFBN2dzV2hOUzVxMUVDd1FrVktiTE5qU1ByRXVKN2JoSUNFUzFNa01rS3NBT1R1ZldLZXl5QXRhZzlKUzdFNU1kUFgzZXFtNDlGSklJOFhMUzdPOS9QbEhLNmN0cXlzWjEwUlRlMG1KWGtRa2NtSHhnLzhBaHVaaTlwNFVyVVZiNU55VGtoZkdNZmhTU1ZCT1F5MFBtQkc4L0NWSi93QlJscElTNVRNWWtPVUVJSnFTSHpZRk45RkdLVGlrdElkU2JXejA3dHh0NmZoRlM1cVM2S3dnU3dQR2JrdmJnQ1BTQzNiQ1dsV0dVb2tzbEpXa0IzS2dIRmhuL01aMzhVbHFsL2xWSk8rWndaZVNrMGxQaHUxMzlIalU5b3BRUmhaeFJVQ0VFZzFGd2VJYzV4eHVMNHV3cHExUmdleiswUVVJU3Rkd1ZVak0wNXNlRjN0QVh0RmlKbjVvNWxPN1FFN3hwQUR1QmNYcWdsMk5sZ0pWem1Menp5RUM5ci85WXM1YjZQZ2tRczFVRWkwZm1aNm9uR21YZ1ZMbEFxVWhHNkdKTDVCMDVzSHk0Q1BLRnpCTkJDcVNTNWNNQzU2UnZNWGlFeXNEUFU5RktmRUhCRGtBM0hXRHV5dXp1SFFsSDZTQ1VwRzhVZ2xSYTZpNDlCL0RUbEZ5YVFxa29XLzVQSUpPRE5JSEtJc2RnVnBEbVd0aTk2ZDBBWmtrNURuSHZrckRwVDRVcEhRQWZDQWZhUU91V0xNeXFnV1lnZ2hpL1dMUXhiMks4OTlJOEY3OUpVRWdvS2lRQUFxb2trc3pBY2Vlc2JFZGhKeVFETVZKUVNtcGxMekRPV3NYL2lNeGhKQ1VUSmJKL3dEa2ttMU9UcTFCUDIwZTI3YWtDZmgxSmxxQ1psQ1VoVlNSN09WUWRzN2hudVJxOFVuU2pvMG0wenhYYXBSTEpST3NwS2lrNTFkR1VMQVd0d2dWSjJiZFM2ZThVcFZTUStWMzF5TVNkb3NTdVlzMW8vVVNkOEZ3b215WFZ2RzVLYW1IRTZRL1pncHBXRXFKeUtVZ3FZYVhCc2JHSnVMaEhUSlM3TE4wL3ByL0FPV2ZZWWtseFloSU45VzZqbERNVmhwSXc1TXNLUUVna1hkMG05enhaOVJsRjQ0dXNLVHUwa0pVZjNQdkRqWnVXdWVrVWhzdVdsRzZsWnVCdkVrQnI2NWEzaVVaVjNvREFtRXg2bHFsQkNBV0FxS2trZ2xOZ3djdWJock83Q0RlTDJ3c3lWR2dwSXo5bmdTYVNOelBUckdleFdMVEltQklwVUU3eVdmZFVSbVdBZFFjdGRtT3NFRmJibVRKWVdnT3BGenVqMmtoMjZFR09xZVBrMCtPaFV3ckxuS21TMExVYXF3cHlCNFNBYVRZQWtOU05ZSDRQYklYS0tWMlVFT2tHenNsbUQzVnFMWkdPYlBuS0RwSUtHRlljRDJya2xyVTI4UGxGZ1QwcHJXa2dqd2trT3hXR3RWWWh5YkRqRXVLVGFyN0JzR0ZLeE0vVUozeWRCL1VXQUl5c2NtTG5WNG5STG1WbEpBWUFYRGlwM0Q3dG1JZlRoQkRaK0VsRWd6VklCVUJNTHJCQUpTNUpZT0dJeURzd2lUWXM5RTRxSzFGa3FZTWx3b0hVbTVCRmkzWGpGSnRwWFFLTmQyUjJQTmx5MHpMbEJJQ3FRbXNONGdvc29Ca3FPZWo1TkYzSDRsWW1tVFkxSXFGM0xPUTRaUkQ2RXM5b2c3SDQrWDNyR2NxVWxTY3drWmczQ25jY1RVUVdGblp3VDNhUmNnWWlUTFhOUTRTQVpoU0F3S244WnM3TGZQWG5DNDVwTG1QVjZzQUJPSisxSSthSVVCWnUzcHIyV20xdE5MUG5IWTlENDhQNVpIZ3p5aWt0Wmg5ODRZRkVYaXlxZW9CeXg1WFlqcEVhcG9LYmNYcGJUSndkSXlzeFRxSU1jQml3dEFVemVqUTBTakZMUmg4a1pFaTJyUWN3K0xsVWQwZ0ZPcEpJYzhSQVNSTEpMY3RJc1lkUDNsRXA3TWFUQlNXU1ZxREZRWUN6czd0OTJnQnRXUUFwU2trQU94QXRmcXdHc0c1K0pFeGtzbDJMQU83TWJoV1JEc09FRDhYZ0JRSmlmQVhBSTlrZ3NRZk1SSEF2VnQwMzBQOWpaZmc3c0NSUGxZdWJQQklRWklTeGE1N3duUi8yNVI2RjJYMkxoa2JSVXVRZ2dJQUNUdm01UW9LY2trYWozZWVML0MvSDA0S2VndHZUa0RQMlFoOHN4ZVBTT3d1RkZNeWNsRExKS0ZHb2tLcFlnaEpESnNidDV3a3JjMlUvd0JJL3dERVJTekxreTBTeXJ2SnFBU0FDUUF0QllhM0lHV2dNRisxUi80U2QvcytZanVNbnNVbFpTQ0xwZEx0bzQzb3hIYUxhYzJhdFNVVFZVaXpBa0IraGNRclNkMHdKZEZic3hJcFE1MUtpT2hNQ05yNFkvbXlHdXBhQ09ocGczc3ZEclJtc2tYczRzZDMrbUNrdVdDUVNIUEVzVDZ0Q1pJTHBzdENUN29vZHJYL0FOUHhJR3FOT0FXa2srZ0pqMG1TTjBYZXd2eDV4ak1ZVTl6TXJTRkpvVVZKSUJDZ0FYQkQzQmpZWVNaVWdIa0lFYXVoY3QwVFJrOXNCOFphaXFsUUFVa09mMDM4V2JBdC9kR3RnWHREWWN1Y3VwYUVIcWdFNU5tYy9TTHVORVV6dzZaSVBlc0FibVJrQ1NQRVhZYUM3dHgxaS8ycDdiclVRSmNwRW8wTW9zQXNsUEJYc3BCRnRkZUVlcDdXN015VEpXbEtFT1VsSWRFc0FFZ3BDbkNIY084ZUpkcnV6YzJVcE14UWRJQ2ExSUlWdm1weE1zR05RSUliUTM0VGNVM1RLT1Y3Um5NZml5cnZGazByWGNYSk4zTFBtMlhwRmpZOGpFSlNWeTFWTHNWQlRwREM5S1NjMWRQcEZqczloa0tKVVZCMWFVandnc2N4YmxGa2JJbnlWcVJMWCttWFVFa2V5b2xtVWJGV1Y5ZVR3czhpM0RYNUVhdlpWbFNadFNsTWtGU0FHRmdsU20zanlzVHd1YndiTmtCTTRWRm1WY2J4RE9sMURteHRaM2laRXRMcUlDbEtGeXhTQTQzaUwzMGUyV2NaamJjeFVxZUZFaGtFbGd0U2szSU80VGQyU0xFa0RqeGpIOTZWR2ZwMkR1MUV0bG1oSnBRQWtrZzN6cE5SenNNNG0yQnRNU3ltV1VsTmpVN3ViS3lCc0hxNFpEbkI3R3k1VTlOWktnRkpLYVNvTW9saUZadSt2bVlGNHFTRWdpZWtCT1FtQnJnbmhZWkpIVVIwd3lLVU9FbC9mK1JYL0k3RUJSQklTbHJGMVVoZEp6dUNDUTEyUEFjR2hiUGtvVURXL3dDMjVJWjdzUWVkMjV4TXVTa3JNeVdIcEtRdEtra0tJQ1J2QnJIbzJSTjRqN1FTaUpWU0F4Y0tVUndDVHBwYk5zNFZTdW85V0FLNHJBeUZrQWhLbFVqZHp0azRQQWt2bGIzbnNxVUphQ0VKcFRtS2VsM0daeXpQR00zZ05zb1pRS0Vwc0FGTzFoeE9oZlhtMFgwN1dRdVN4SkJwWWI1cUpMT0ErYkFNRHloSllaclR1aHVTTkRoNXlFQUdYdTJOMjhWZzRack9kR0VSeko2bGo5UWxUWkJuc2FUWitYeWdiZ1o5YWdoSkNSYTVCQ1dGTE96bk94NXZGamFCS0RTVkV2WTBrRWVFWENoWm41OGVjVFVHblFVN0pWNDFSSktWTFNITzZEU0JmSURRUW9IL0FKOWVsWkdsemw1Qm81RnFtSFpqKytJMGNjM2FHQlFKREpJNDZ2SFZNQStaNi9LR2lZV0xPUGxIb1VSSjFLSGhBRDg0cnFKeXUzWE9FaFY3M1BGNG1UU2V1bHZsRzZDUnBuSFFmZlBqRmlVS2lMVzVHT0dXa0E1UFk4cytvK3pITU10c2dJVjlhQUdVN0xDa0pVdlJ3S2VvWW5oZC9XSXBPMU83d3hsak1xVUFPQ1RjbjN4S25FdElxcWR0MXJabFNzMzVETVJuMXFjeEtFT2VwZXpIVW5IbzMvNGZrSER6QTZnODEzUzFtUWpVOVQ3bzlzN0Q0OUNwSGRoZ3BEa2hya0UySjBKejhnSThTL0R6L3Axbi91cS8vQ0k5ZTdDRklsdTQzaW85V1pPdlNKNXA4Ykt4anlSZDdWcklJYXV5VDRVdU5jelNXakFZR2FTa2sxT1ZFN3dZK2hBK0ViUDhRZTB3d2tzSUNWS1dzT1d5U09Lam85N2NqR1B3ZU9SUGxDYWppeWh3UE1hSCtJU0swWkJYQllwSzdwVVNidTRJL2JrK21jUG5iU1ZLSTNha25uY2RJR2JHVm45OElzNDlYaDgvbEU1eXQyV2pHdEJ6QjQ2WE9TUUM3Z2dwT2JHMXhHbDJKaVNSU1RsbGFQTVFTQ0ZKTEVheHA5Z2JaS2pjTW9laXVMUXNXMXVJWnh0VXpldWVQd2hYNG4zZlNJNUUwS1NGREl4SkhVc2tuMVp4MEsvRSs3NlI1SCtLV0NhYzNlbElJcUtLaUF1cW9Fc2xMUHVuZUwrSWNvOWNhUEsveGlUSjNWS3NwQlNWSGpZc0J3TGMyenRDWkhMWFkwRHlLVmdWcFdvQW1naGdBV1VjbkFZdG8zUzhhbnVab1RVcXdzRk9tcHlySmxhR3d6RG5scm50cVRVa0dZaGY3U2cyWStKS3ZPclRpSWsyUHR5Z0VUWFNGa2thcEEzUTJwQkplOFR5eG5PS2trQzBtTEVZcW1idkthYTdPbE5xR2NDck1LSnpQTThJT3lPN1VDaWNDcDBXZExoUnVmVGROK0xSVXhPR0U0RktHV3RuREZ3ekVnbTJvUHY2d053ZUpWMzVUUEpDd0FBa0tZQjJ1R3orRm9SeDV4MTJ2OC9nUFFSbllLVktZcHJjQW5NdUhkTzdjQUZ1R211Y0R0b0JPSWs3czEyS1hMKzFsdmNMZStEbjVVWnBKQktSdlBVNE4ySWYzd0htYk1SVVpjeFNncWFRb0FJM1NRTGJ3RmptZVhLQmltcnR0MmhXZ1pzaGMyU2xaSWVXcFFDMVhKenVybXpBazlZTDdLeDZaeVRLc1VyQlFxd3NLYzZ2UE5obEF6QjdTL0x0SktTYUhDblRVTEd6QU5ucjAxY3d6Wk9HN3lhSndDVWlvbGc5N2s4YmEvU09uSkZTVGxKZlpnVEl0bTRHZEtXVWdnRzRBczdtM01CMkI1aUNQK2lGWVpSU0Z0bTNoSllraExYc1RrYmRZay9LcVJOQ0FpcENnNmxraXBJQnNvS0xGdzRGM3lpZFV3eXdGS0E5bW9qZHVXdWwvRU9qYXdzOGttN1RWbW9od3N0Y2xacVdDS2liRFBldWFiczU1eE9tWXEvNlpxQmV4MHZaeDdMMzhoZXpSYlNzS21BQUVFSlZad1hJQmF4RE9TUmx4eUxSWkdEQ3pZc0RZZ2huTHNlZDdXZjJ0WWo4VGUwT2tDdTdrbTYxTHFMUHZHRkJ3OWxKdWdRMmpoUjk3d29wK1NsTThtS3pIVXJJeWgwakRxV29JUUhVb3NCR3Q3TWRnWnVLbXJRcFZDVSsxWlRseUd0YlRyZDJqMHBTakZiT2RKc3lOVm1hSkpFdFJMRFBxUG5CM2EzWkNaSm1tVjNpRnFTQVMxUVlGK0laN2UrRzlyK3pSd1MwSXJyS3BTRnFkTkxGVjZSMGhlY1hwUHNOQTZaZ3lrT1ZGMnk1bUhiRW5vVE9sQ1lrS1FWcENuSUc2U0FRNmlFZ2N6cEVXRm5LV1VvY1pwU0xCN3FBK2NNbTRWMWxJdmRRdHdEL0FDRVpMMmtaSTJQNGg5bC95aktsSVVKS2pjMm9EM1N3ZW9aa0VtemtObTBZaVk0SkJESGhsSHV1STJ6TlVNRUowcElYT2xVekV6R0JjQ2xYZVMxRjJMVkN4WUtMdG5IbVBhZkIxN1JuZ0N5aVpqNU9DeEpIcVlqaHllekhsRGVoMkJ4YTVXeks1YWlsUm5FT0cxTGE5STlSN1A3V0FLWmFsVXk1YVNWaHpkUzFib0REalNZd3V6cE10R0ZNc3BjYjZnRkFLRGx5UHRvdDdFeFg2eVNzMnFTVjhDQXNaalZtSG0wUnl5VWxhTFJpNHVtZWpkc0ZDYWhSWW1vTVMxckJZVUg4aUl3SFpraVZNbnl3MUNpR0ZRY0VBNVBmaDZRZjdRN1VxU3dkbDFxTDU3eG1uVEt4K01aYkJ0M3h0bC9FSkZ0Yk1sZWpUN0VWWS9mQ0xXT1hsNXhRMk1iR0xHT1ZjUktYUlJka1pWRnJCcklBSXpkNG9LVkZuQ3EzZldOajdEazZOMTJaMnNEdW5JKzVYME1IdHNwZkR6cmtIdTFrRktpa2doSklJVUM2VHpqelBDNG9vVUZEekhLTnhJMnhMbVllWW1zVkdXc0JpSDhKMDR4MFkzeGxUNk9lY2IyankzWkcxY1grYWtKL056bG83K1FsdS9VUXBKV2dLY0UzczdqckI3OFl1emkxb005SzFGckJMRlZ5OVNqb2tOWWRPY0FqaFNuR1lZRUtTMC9Da0pWb3lwVDJld3VHR2pSNmwyeGxJVktwVzdFdFpWSXZiZTVlK0ZsTDAzOVRQNWo1aXhoQmxoU2pTRTdvUUJxd2RUalJ3ZlRoQWZ2QXBia2xqbnFXNWFQSHBIYmZZTWtZY3FUWXluQ2FiSkxxRGtocnZmMWp6VlNHanN4ZktSa3FadE96b3c2MUFZZFMwTFNBU29sUnFPVEZJWUhPM3VlNGliRjBvclVoZi9FQWhTcWdNaFpnUUhBZTl1SXZBL3Nqc3NwbXpLaHZKU0FVdUdJVUh0eDZ1R2p1M01QTkJNNllvQmdFMkw3dGdRUUJkeW9QNVJ4engvdTFldjdvUHNIWmF3RkNxemdlSE5iRXZscTVKWVIyWk5yUVUwT3hDazFFVitiRTd6QU5ZUEFEWiswVTNRcWFEY0JCdXgzTTNKdGMzaWdOb3JDd3RIZUxRVWtKM1dJenR3TEhVWi9DZi96TnMzSTA4OVVwQjczdXdzcVNDVkpja0VPNFVNckE1anBBZloyMjVmZUZDZ0phY3crYjZna2xtemJKM2dyc25hQW5oU2xzbHp3c3BXVitiTmZvT0VDZHQ5bVZ1WnFCdXFKS2d6Qkk4bkpPWk5vMlBpbTRaTk0yK3czTTJtaEFTbW9YSXVOWEpmNWE2Q0c3UkFWS1V5WENHcU5WVlNWSk5XNjI2QTQvdE1aS2VWVEZFMUpxVFlNR2V3TGhQTXY4WTBHd01UaUV5eW9pcEtTcEpmTVpXSTFUdkU2NVEwL0g0TGxIc05saVRZcHFDRHVtaFY3aFJkbkZpWE9mOVJpMHRLbFRnUWtnVTZDNmptT3VlbCtzVnRrb1VxcEtVRUlja2gzWkxCeWs4aWN4ZGpCN1p1SWZkV2lxa3FGSUxaS0FGd2I3b1lSR1duYkNpV1gyZnNIbXpYWVB1dGRyaGlYRjRVZWtZTmpMUVhKZEl1Yzh0ZWNLTHB1aDlueTdzbFlFMUpMc0Njczhqckdyd20zY1FnTkptaVVudk84MEpLMlNMa2k0M0J1bHdiZ3VDWXlzdVJUY0VFbmhFNlNZNzV4VWlLYlFiUWdkNTNpcHhtTFVYVzRJU1E3MGxTaUxXR1F5c0lXMDBpZW9xbUxXWGJlc0FBQUFBSGNuTGhBbEVTdjE5WVI0L2V4aWJENFhEeWxvbUF6U1VxU3B0MW5TUVE5citzSCt5bUp3cUp4V3RESkFVYWxwQ2lsWjFCT1Qzc0l6b25BSHdqemMvT0ZNeEpWbWJjTWdPZ0ZvVndrL2NDMGFqdFYydDc1VXZ1cHN4MEF1cTdQWmd4c2RibDR5K3pzVk1NOEtXYWl5azNJRmlsbXZhSTJFSTlJMFlxS0RiWVRWdEJwU0F6dW5QTHpncnNTY3kwbm1rNTZWMysra1pDWVNUY1c1WjVla2FyQjdVbGlqZXVLTFoyU29XaEpZMVdpa2Ntd3ppWmxRZk1iMy9zaXJoUnZxSjAxNDVSRE0yakxwenV4ZlBJMThPc1d0bktTdEpWZTZpQjBEUk9VYjBobzY3Q3V6WnlVcExtSXNadE5EM1ZrRDlZcXpiSk5JTHRhemk3K3NaUDhBVVVTQURtMXdiZVdjVCtHMzJNNXBiUnJWN1RSYmVGL24vaUx1Rng2QUFLZzcvSG5IbnM5UzA2S0doZlErUk9rV05tNDFxUVFxeHpiNzVRZmd0YlFQaWN0TTlJRTlKeVVQVVJSNzRwV1NORGJYNHhSa0FLQUlPY1M5eW9hKytFYmswUEZSTmpKMlBMbXBSakN0WVU2RnE0QXl5TjNLd1pBRVFkcE8xM2ZrSm9LVXBMNXU1NDVDQld3ZHVHVTh0ZDVaY1V1MmIzOVRGTEdDVUN2ZUJGbWJSNzhYdGxFbnpYMkdTaS91VmUwR0pUT2tMbHBERlExeTB2N293R0k3UHptTmttMmlodzV0R3dYTUVRTFhIVEROSkNTeFJZVXdaUWxLV0thbUJOdzdtNUhyRlBiMGl1UXNBT1djZGZMN09VRDFUSWhWTWpjbTNiQjhOVlFQMnBzcjlBRlFBbXBjcUNSKzdpRzVlc0RObTdRbXlVcVlxQUlMRE5JVXo1Rnc4YTNaNnhXZ3FGeWZOaGQzNFdGbTRRQjdSTlVvSkxBTGNBQWl4RGtuek1VaGs1K2lTT2VVYURFdVRMU2tUNVlBVVFBUTRVRXNqMkNIQmRRSHhpM3M2Y3NUYUZNU0pTU1UzekpzR2RuWThOUnpqUDdBeGNzWWVZaFp1Vk93WjdBQzRhd3NBT1pQR0R2NGVoQ3NUTkswbFFYU2xJczFnUVhlOWlCbDg0bkxIcVYreGxzSW8yWWp4Snc3N2hIZVplSFY3aHd3OC9RRTltWU5Ta3AzU1VxTjdnM0RnS0xXNCtSR2JXMTI2ek1XNE44b2dscmxvc0hTQi9TcGgxTFdqbmF2YlpUaVpqc0xzZGFnSnRSQ1NxY2dnTjdLbEl5TDN0N3hHdncvWnhLWnhtdlpTMUxZQm1LaTQ4dVVabnM1dFFZZVV0QjNsR2JOV2lXbnhLN3lZVkJ5YkMxK2hqYjdIeHhteWd0U0NnM0JTYnMxdUF0RlBTMkJVWEEwY2hla0tLQlBsRUF4SWlhb2FtSFVSTkl3YWxBcXlRTTFITGhiakhmWkZFZ21qNytFUEV5SVpvRmdsMkdUNnZtVzBoSWpHWk1rdzhRMEs1RDArc09RSVd6RHdOWEVPQWpnVEVxVVFyQ2NTa1JJRWZmM2xIVUpqb0VBSWloOVlta1RGSThLaUEvay9TSWtuV09sWERQNzFoR0VmM3N4eW9MVnZaNU5aOG9ZaXQ2Z3RRUEl0L0VOTXdnT1Q2Q0dxVnE4QXd5Zmh5cFZSV3FyaTdSMVdIY01wYWoxUDBoc3lkVGZQaTBXcENrbDkwbHViK2tIWUR1SFdVTlNvMnl2bEZ0TzE1b2MxT0cxR1hUbjlJaDc2VFlpdXJrM0xJazh4Rktjc0tDbWR4WmkxejFlRjRqV1h2OEFVRkZ4bng2L2Z3aUw4eStrRGNJVkpiT05ac3RZV2k2UmZrT1AwaWVTZncxMEJUYkFINTVpMTRiTjJtV3M1alU0blpTRkFBb0RuSmd4Z1hON09wY2xLenlITDV3aThpRDdNM0l6NXhLZ1hCTitNZC9QazZSb1oyeEVzMmRnQmI3dmVCT043UHFIZ3ZmTWl3SGx6aWtNMk9XZ1hJTFlJcG5pVWhLNlppVXZ4cDlseS9BNmRJcVl2RG1hZ0pVcElOYW5ZQXEzU29XZTdYOURIT3lFdnU4WVV6RGtsUTRnM1NRM1VYalo3V2xZZFEvVFFBU1VyU1FtNGQzTlhtL21ZbE9zYjE5dzhialo1bWNJQXFZRWdxb1lsUXRTQXFuZTZ1STBQWi9iQ3BLVWxNdEdTcnM1M2lmNDVRU1ZoTjViak5CUVNDNUlxQlNTNFp4dmV1c1JUY0ZMWHVsQkpRbElUN0xnYXVHRDM5MEdXZFNqc0QwRzVIYWlhc09SU2Y4QWFXK2tWTVJqWnFxdjFXZXgzaVJjR3hCTzdGSVNXVlNCVGJ5NjVOeno5WW5TaXhJR1RXc3lyQzF6cDdvNW0zN0M4bU1tQllUdUJMMkFQTzNEbGFDK3c5cnpKUlVraFZKc0RVVkcxZzRKYXplZkhTQmMwNWNybjQzOThXQllNSFBISThnNzlPZXNJMjZNbXdvZTFreityKzB3b0VGWEZQdVB5aFJyZjFOeVo1d2tYRUVkcGhxUUxDeFlXRDBKTHRDaFI3UUVVaER5ZmhDaFF3Ui8xaXpKRnY4QXlFS0ZBTXlmRnBBV1c0L0tIeWtqdXlkYWhmeU1LRkNNSTJYcDV4MUdzS0ZBUVRpY3ZQNlF6UXgyRkFNUlRMbS9FdzJha0FXdG5DaFFvQ29zN3A4b0lZWHdUZjhBYVBuQ2hRejZHaDBMSEJsSmJoOHhGakNEZDh2bkNoUXBpbE44WG1maEJuWXlqSElVUXpmSVQ5elV5ellkZm9Zamw2d29VZVovSlI5SFVKQmQ5Q2x1V1dYckhFZUgxK0poUW9xdWgwT2t5eCtZbDJHWjA2Ull4UTNoem1JQjZYdEhZVWFQeW9lUHlnL2FpUlVxdzA5NGhMU0tVMjBQdWVGQ2d2Mkl6N0hwR2ZuOFJESmlSUUMzRDRHRkNoVjJMN0VTTG92ZDVaZm51alBqRWM0TVMxdDBmQ0ZDZ3JzRExjdFJiTXdvVUtFZlpObi8yUT09XCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogXCJCYXJ1cmlcIixcclxuICAgICAgICBjbGFzczogXCJiYXJ1cmlcIixcclxuICAgICAgICBpdGVtczogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJFbmdsaXNoIENsdWJcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIkJhciBlbmdsZXplc2NcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL1wiLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvYmFyMS5qcGdcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCIvaW1hZ2VzL3BhcnRlbmVyaS9iYXIxLmpwZ1wiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJTY3VsxINyaWVcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIkJhclwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9iYXIyLmpwZ1wiLFxyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsOiBcIi9pbWFnZXMvcGFydGVuZXJpL2JhcjIuanBnXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkRlYW5lJ3NcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIklyaXNoIEJhclwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9iYXIzLmpwZ1wiLFxyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsOiBcIi9pbWFnZXMvcGFydGVuZXJpL2JhcjMuanBnXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkphbWFpY2FcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIlJhc3RhIEJhclwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9iYXI0LmpwZ1wiLFxyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsOiBcIi9pbWFnZXMvcGFydGVuZXJpL2JhcjQuanBnXCIsXHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkNhZmUxM1wiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiQ2FmZW5lYVwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9iYXI1LmpwZ1wiLFxyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsOiBcIi9pbWFnZXMvcGFydGVuZXJpL2JhcjUuanBnXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgIH0sXHJcbiAgICBcclxuXHJcblxyXG5cclxuXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogXCJDbHVidXJpXCIsXHJcbiAgICAgICAgY2xhc3M6IFwiY2x1YnVyaVwiLFxyXG4gICAgICAgIGl0ZW1zOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkZvdXIgUm9vbXNcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIkNsdWJcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL1wiLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvY2x1YjEuanBnXCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvY2x1YjEuanBnXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIk1PVmVcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIkNsdWJcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL1wiLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvY2x1YjIuanBnXCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvY2x1YjIuanBnXCIsXHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkFydGFcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIlNwb3J0IENsdWJcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL1wiLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvY2x1YjMuanBnXCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvY2x1YjMuanBnXCIsXHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIlphbyBQbGFuZXRcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIkNoaWxkcmVuIENsdWJcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL1wiLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvY2x1YjQuanBnXCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvY2x1YjQuanBnXCIsXHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIk1hbGlidSBCcmHImW92XCIsXHJcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZTogXCJHZW50bGVtZW4gQ2x1YlwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9jbHViNS5qcGdcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCIvaW1hZ2VzL3BhcnRlbmVyaS9jbHViNS5qcGdcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuXHJcblxyXG5cclxuXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogXCJGaXRuZXNzXCIsXHJcbiAgICAgICAgY2xhc3M6IFwiZml0bmVzc1wiLFxyXG4gICAgICAgIGl0ZW1zOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIjE4Z2ltXCIsXHJcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZTogXCJGaXRuZXNzIENsdWJcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL1wiLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvZml0bmVzczEuanBnXCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvZml0bmVzczEuanBnXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkd5bSBwdWxzIEJyYXNvdlwiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiRml0bmVzc1wiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCJodHRwczovL3VwZml0LndvcmxkL2RhdGFfZmlsZXMvY2x1YnMtZ2FsbGVyeS83NTIvZ3ltLXB1bHMtYnJhc292Xzc1Mi5qcGc/Y2FjaGU9MTUzMjMzODUxOVwiLFxyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsOiBcImh0dHBzOi8vdXBmaXQud29ybGQvZGF0YV9maWxlcy9jbHVicy1nYWxsZXJ5Lzc1Mi9neW0tcHVscy1icmFzb3ZfNzUyLmpwZz9jYWNoZT0xNTMyMzM4NTE5XCIsXHJcbiAgICAgICAgICAgIH0se1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiVVJTVVwiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiR2VudGxlbWVuIGZpdG5lc3NcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL1wiLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiaHR0cHM6Ly91cGZpdC53b3JsZC9kYXRhX2ZpbGVzL2NsdWJzLWdhbGxlcnkvNjcyL3NhbGEtZml0bmVzcy1icmFzb3ZfNjcyLmpwZz9jYWNoZT0xNTMxNzQ4MTYyXCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiaHR0cHM6Ly91cGZpdC53b3JsZC9kYXRhX2ZpbGVzL2NsdWJzLWdhbGxlcnkvNjcyL3NhbGEtZml0bmVzcy1icmFzb3ZfNjcyLmpwZz9jYWNoZT0xNTMxNzQ4MTYyXCIsXHJcbiAgICAgICAgICAgIH0se1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiSXJvbiBXaWxsXCIsXHJcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZTogXCJmaXRuZXNzXCIsXHJcbiAgICAgICAgICAgICAgICBsaW5rOiBcIi9cIixcclxuICAgICAgICAgICAgICAgIGltYWdlOiBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFELzJ3Q0VBQWtHQnhNVEVoVVRFeE1WRlJVWEZ4VVlGeGNZRnhjVkZ4Y1hGUllXRnhnVkZSY1lIU2dnR2gwbEhSY1hJVEVoSlNrckxpNHVHQjh6T0RNdE55Z3RMaXNCQ2dvS0RRME5GUThQRlNzWkZSa3JLeXN0TFMwckt5MHJMU3NyS3lzckt5MHJLemN0S3pjM0xTMHJLemMzS3lzdExTMHRLeXNyS3lzckxTMHJLeXNySy8vQUFCRUlBTGNCRXdNQklnQUNFUUVERVFIL3hBQWNBQUFDQWdNQkFRQUFBQUFBQUFBQUFBQUVCUU1HQUFJSEFRai94QUJKRUFBQ0FRSURBd2dGQ0FnRkJBSURBQUFCQWhFQUF3UVNJUVV4UVFZVElsRmhjWUd4QnpLUm9jRVVJMEpTWW5LeTBTUXpZM09Da3FMd0ZVT3p3dUVsVThQU1JQRTBnNVAveEFBWEFRRUJBUUVBQUFBQUFBQUFBQUFBQUFBQUFRSUQvOFFBR1JFQkFRRUFBd0FBQUFBQUFBQUFBQUFBQUJFQklURkIvOW9BREFNQkFBSVJBeEVBUHdEbWJtb1dOTnNSc1M0RDZ5KzhmQ2hUc201OW4ybjhxNklDelY1bm9vN011L1ZCL2lIeHJUL0RidjFEN1YvT2dCdkhXdkZxVEcyR1FnTU12ZldpVUhvcllWZ0ZiUlVIZ2F2YzFlUlhsQjdOWk5ZS3lLRENhOVUxNFJXQ2dsVnFLdFlpUDcvNW9LdGxhZ1lOaWVQWjVuMzYwSGR1RThleit6WGhidzhmTTFHOUI0ejFvV3IwaXRZb1BDMWIyN2tHYTBJckFLQ3liSzJuazFCajJhbjJSRzd0OXBvbmEyMW1jU2RaMDdCeE1uV080VldWdXhCSHhOU3ZkbisvR2dneEQwUmdqb0tEdVViZ3gwUlZDMHR2ckExZU52UGZYZ29KVWFwVmVvRXFaYUNVWEsyVjZqRmJnVUJ1R3ZWWTltNGlDTmZHcXRaTWYzclIxckVSL3dEZTd0MHFDNS80aDJqK1kvQVZsVmhNWVkvT1Q4YXlpbjIwck9wcFl5VSt4eXpTdTVib0F3bFQyck5icGJvdTBsQTQ1TGNqMnhuT0ZieHRaTWdnVHJPZlhROWxhOHF1UlQ0UzJIZTl6Z080UWVzRFdlK3JoNkxQL2tEOXovNWZ5b24wb3BPR0hZZjl5Vkx5T0xYTm5ha0RXQ2ZvcWZoVVoyWU96LzhBbXY1VjFUMFYybE43RWhsQjZOc2lRRHhicjc2dDczTFFmWERpQVNQVVRYaFNqNTF1N0tIMmZaSGxTckg0Zkl5aUJyUFh3anQ3YStuZVVPekxQeWRtRnBGYVUxQ3FDSmRaRWpzSkZmTm0yVm02ZzdEN1NkZklWYzBEV3NNQ08zVDR6OEtsWEJBOWRHdGh5cXoyanlQNVZ2WXRGam9LSTh3V3dPY0JnWEdpSkt3WW1kK25aV1lqazhWNFhCM3FQekZkWjlDWWdZci9BUFIvNXFrOUtkdVh0bjd3L29GU3E0eC9oZjMvQU9RZisxUnZzNk9KOFZJOHBydUhKL2tGaHIrR3RYV053TTZLeGdpSk8rTktsMmg2Tk1NcU13dVhkQVRFcnc4S1VjQXVJQVluM04rVll1SFp2VkU5My9OTXR0NGNERUcyQjZ1WWVBWWdlVkZiS3c1a3dPSUg0b3FvUi9KSCtxYW1HekxrQTVSSDNrOHBtclNjRmNHYVVnQXhKSU05VUNhdjJONU9ZZGRrMnI2MmdMcHc5cGkyczVqYmtuZkcrbFZ4VTdPdWZVWTl3SjhxMU9CZjZqaitFajRWMUhZSElGOFpiYTZqV2xBZGxoZ1o2TWRRN2EwMjk2Tjd1SHROZGRyUlZRU2N1YWRBVHhBNnFWSEwrWUkzajJnMW1VOFA3N3FKdDI1WjQzQm1BN3BOTmJHRG1KWFNCcUFwTzdxSkhuVkZldVdqMitORjRWT2lQNzRtbUczOW1YTU9MZWRWWG5NeEE2SmFGeTZrRGQ2d2lsV2RsQWd3SW4za2ZDZ0JhM3FhMUsxZmJYbzYyaGNQUndSeW5VTTE2MG9JTzV2V25VYTBicy8wVVlwOFFMRjE3Vm9sT2NKVm11d3ViTHFJVVRQYlVvNXZhV3B3dGRidGVoak1yTmJ4ZW9aMWg3Y1NVWXJ2VnRBU0ozR0o0MHV2ZWlESHFkQmgzSFdMekEreHJRODZYQnpsVnFXMmxXVEZja0hzM2VidXZsWUhwQUFOR3U0Tk1IdmlvOEp5ZHZrbkpMNVFDU3RnWFBhSlB2RkFoQ1JXNG92YTJCdldpQmNJV2R3Tm5teWU3b1Z0c2JZV0x4UklzSWJoV0pobFNNMDVkWEtqWEtmWlFRaGY3bXZhYlB5VTJnaHl0WnVBamhuWGpyd2FPTlpUZ1dERU5RVncwUmRhaFdxSzlRVk1McXJ2SUhlWXFGSzAyZ3VnN3o1VlIwbjBWM1ZMWWpLUWRMTzd2dTAxOUk2emhqM0g4U1ZWZlEwQ01SaXdlTnZEbjJHNnZ3cTQ4dmxuRE4zTjVUOEt6NksxNkw5TVJlSFhhdG44UDUxMHF1YWVqYlRGM1Ird1gzYzErZGRMcG9CMjJzMlgvaDl6TFh6RHRwSXYyLzR2eEN2cUhhZythYnc4eFh6VHlpc3hmdDk3L2lGWEFadERvV3MwR0N5ZysvVXpYdUF3NzNGWjBDNUVIU0xQYlhlckVSTGFtRWJkT283YVlZdkhXcmVHdWh3WHoyOGd5RlN5UHpsdGxlQ2VCWGRWeFhIV01ac241YWJOa1hWVjF1RUlpTm5RTU11WUNRQ2NwOFJWRHIwYWJDdjRWc1FMNkJNNHNsWVpXbkticytxVDFpb1BTWmJrMisvelZ2eXF3Y2w4Vmhia3RobFZRMXUyV0NybDR0RWpkOWJkU2Ywa0orcFAyeDVQV2ZROTVGZi9BSU9IKzU4VFRQYUErYWY3cmVScFh5SlA2RFkrNmZjN1UyeGcrYmY3cmVScUQ1bjI1Yi82Z3crMC93RHFQVEZMV1FnZ1QwMW5oQXl2clFuS0FmOEFVVysvYy8xR3EwWWJBSTlweWYxZ2EzeldwQXpFWEMwamowVk8vdnJZU1luRzNDekhtbnloRmFUSUdsa1BCMDA2dStyNXNmYnd4dXczSXQ1RFpCc2xjMmFlYnRDR21CdkJHbE92a2xwc050QmJUQmc2M0VuT0hFRERybE9uZWZHdWUraXU2VHM3YVZ2Z0NIL210T3AvQUtnNlA2THgraTNQMzl6eVNtSEx4WndWNzdqL0FJR29IMFpqOUd1L3YzL0JicG55eldjSGUvZHYrQnFubytjOWlXY3h1RDdiZVpwMGl1bW9VTkdXQm1BSjBHb2tkZmJRUEplM0wzZnZ0K0kxMFhhdXk3U1lXMWZHSFc2UllabldXVXNFVnVydzlsYUhPZVhXMFRlTmdsV1VxdHdFTUk0b05DTkQ2dkNxL2Y4QVZUN2gvRzlOK1Z1TEZ4Y09SWnQydExwK2JaMkRCamJJQlZ5Y3BYWFVIV2R3aWsrSmJvcCs3LzN2VkhlZlNOeWl2WVhBV0h3dDRJOG9yUUxia0EyaWRRNE1iaHc0MUp5SzVTMjJ3NXhtSnVnM09ac3E1anBFMnJlZTQyVkJwTE9Ub0kzVlFOdmJDdnBnY1JldUVLb3VvRnQ1RkJiUERjNmJtODZFQ0pPOG5TYXJDYlZhM2hMSzIzSUw4L3p1Wm5Oc0FESXFpMkRsekVJTlRPOWVxc3dkKzVFN2J0WDB2RlNZRDg1bUlJQlc3SkRDZFlsV0hnYWI3TzI3aDc4YzFlUjgyYUJNRTVRck1NcDEwRHFUM2l2bVd6eWl4SlZiQ01nWG0xU09iU2NxdG5FdkdmMWlkekRmVnQ1RlllOWlNWGF0MjhWaUxRNXZNeHR1UG15U3lFS3JTdTYzYkdvbUk3S1FXemIyeXIxL0YzYmxxMnpvSEtsaEVBcVlaWjZ3YXRISlhBbTFjVldRSTN5VzNuR2s1aGN1U1RHODY3Nm01RzRaN1ZpOWJ1TzF4bHhHSUJkb3pQMHlRelJwSkJCMHBwYlg5SkovWkQvVWFvT2NlbVhBWjcyRkkrcTQ5NEkrTkplVGUyUDhOdytNeEJWR2NDd3FJMzAzWnJnRUdRUUJKSmpXQlZ2OUpkcWNSaEQ5bTkvc3FxYmV3YW15USt2emxzNWROWUZ6V0kxM3h2OEFwVmM2Rkh4M3BGMmpjZG5PSUN6d1cxYXlpQkVETXBNZDVOWlFPTTJFd2RvQWpzM2RvSFpXVm9XK2VpTzRWR1RXMTA2VVB6bFFUaHdBU2RBTlQ0VUZ0RGFGdGd1VjBPcDNPazd1MXFNdE5XbTFEMFY3L2hRWGIwUTNGT0l2RlFRRGFVYTZ6a2ZyQkkrbnVtZmFLdS9MUkp3NS9pLzAzcWgraUc2VGlyZ0pKK1piZVovekxkZEM1VkxOZy94ZjZiMW5leFZlUStFRnZFaTRXL1dvYlFYcUtoV251aTJSM3hYUXFvbkpGdzE5Rkk5VldZZDhSOFRWN3BvSDJoK3JidThxK2Z0dllXY1paWHJ1TVA2MXI2Qng0K2JmN3JlVmNUMjNhakhXVDFYTHgvbEdiNFV3Yy8ycWh1WXg4b2tsMzRFL1dPNEFtcjl5TnduNkZpc0k3RU15TGlJR1laUUNGT1pDUWRSeloxRzZlb1R6cDd6Qzg3S3hVaWVrT0FaZ3BQOEFWWFRkaFlCTERKZFFETmxLblU5TlhYS1E1K2tUTzh6cldoWVBRcGlTVXVvWWhGU04wak05M01DUUpQU0JPc3hPbFA4QTBnVzh3c2o3YSsrUlZaOUR0MzlKeGE2VGx0czBmV1o3aEk5L3ZxMjh0VWtXL3ZMNW1wNkR1U05zSmgxdENUemNnRS9TREV0UHRKSDhNOGFhNHIxRys2M2thVmNrbm5ESXg5WTVwOEhZQ211STFSdnV0NUdzamdXMTlsbytPdU8ySnMyU3QyNkFqODRXYnBreW9SVHBySGhUSEZYZWFDaGJ5SHBCcFZiNEp5cGNVaFMxb0FkRzR4a25oU3psalpqYVE3WHVmaXFmYjVLb3BCajE1N3NoMzFzSnZSWWJneDExN2RrM1J6RjFYZ2xNaXREWml3KzVFSGZKNDE1eUsyMjJGdTRyRGl5MTA0aUxRQVlMREEzTlRJT2taajJRYWZlaFd5M040NjViWkVjaEV6WEp5aUZZeG9kQ1MvYjZ1NmdlUUZ0ZjhWeEtzQVR6R0lkRHZodWpETC9BN2p1TlFkTzVIWDhSYnRGYmVFQnpNWEpOOVIwc3RzR09pZUdYMzBYeWx4ZUxiRFhRMkZSVktQSkY4TVFNalNRTW9uVGhOSGNqQjh5ODhILzhkdWp1VWF6aDdvK3hjLzAycUQ1KzVOb1JjdTVBV09kcHpBTEJrNkFoak5Xekc4dmhZRnF5OXRITnRDcktwekdHa1pYRFFBWTFnRTZFZFlwRnlZdFJldmo5bzM0alZmNWJZWUxpRGNVYUV3NSszTFFQNUFQWUswSWRvMzhQY0NabnVyRTdyU0daajlycHU5OUQzcmVHS3JOMjk2cEErWlU2Wm0vYTk5TGJ4MEhqV1hEb083NG1xam8rM09WSHl2Q1hMQ3FSemZTWXhFbTJ1WDZ4Z2RFOEtvdUJzRzhxV29JQUxRVmhpU1czWlNWNGtjYXNQSjY1bStXckJINkxlTzhHV1VrNWhvSTBnUnJ1bWRZQWZJakNjNHpTeFZVTDVvTUZzeW9GUW5lQk1uVGZxS2lwYmRxemJBVnJ6akxLajlIVW5lZnBDL3JNOVFwdHljeGlZTzl6bG02NWM1VnkzTU5BUDB3Tk1RdThmM05KOXM0RkxUZ3FJQU9hT0hIaDc2bjVWT1h1Smx5QWhFekVrZ2xnR2pjT3B2S2d1VzFPVUdQU0xvZklMalh3cXJaWEpjdVBhREVOR0tKbFZFcWRJSk01dHc2WnNMRk5kRnE0MFpudzl0bWpjQ3hKSUhqWEVMbU91dUxGaTNhUmlnNXhybk9MZlFDNm1YU1ZCUnBSZzBkY2R0UGR1OHQ3OXF5RnN2YnRFVzB0RXJMWEFBU1N5bjFWNnR4cVFXNzBtWXRMVnpEdGNZS29XNlNUMlpOM0U5d3JsbTMrV1hPQXBaU0YrczJyR0NDQ0FOQnFCeE5JY1h0Ym5uRFhybHk2MjdOY2RuSWs4TXhNRHNvbTNoY3JLM055QVFZTzRqcXF3QU50TzZUSlkrd2ZsV1U5VEUybzF3K3Y4UDhBNjFsQkJnOXN2ZXpUYnRJQkhxS3dKSm5lV1kxczF3elFPeTBDcVJJa2t0b1FkTkJHaDg2Sm5XZ1k0WnE5MnEvUlh2OEFoVlYydGo3cVhZVnlvZ1FCdTNhbjJ6WGxyYlYvL3VlMEtmaFFkVTlEOTM5T0k2N0Z6M1BhTmRUNVFrYzFxUUJKM2tENkRkZGNZOURPUGU1dE1aMkorWXVqY0ZHOUQ2bzQ2YjZ0bktqMFZKaUxqWFd4TGRLNWNicFcxY2puWFo4dVpqNm9tQUttOWhqeWJ4VmxNUXBOMjJPZ3dQVFh0N2FzMkk1VDRKSnpZM0RMMzNyUTgycm1Hei9ROWgyY0srSXV3Wm5LbHBUcE82VmJxcXcyZlEzZ1YvemNVZjQ3WS9EYkZUZ1djY3FjRmVXNmxyRjJISVJpY3R4U0lqZk13ZkN1WWNvc1ZaTjhzdDIwNVVZazlGMVk2cEEzSHJOWGl4Nk5ObjJzN2xIdXlwQVc2L09JQ05jd0IrbDIxenZsdHlac1dHdk9scFZYTE51SkFVbDBCQTRjZE93MWNIUExRQlcvOVloQUJ4TTNGWSs1YWI3QTJ6ZVI3YTNIYm1WUEdEQUFNYXhtanNvVForRnpZVEZYSWxoY3c2cVFKSTFjdEhFVEltZ3NNNXQzRlp3d3ltWWlEdTAwUGhXa2RMOUdXM3NOaGNYaXJsMjZ4VzZCbE9TNDVKRnhpQUFxa2dCU045WEhsQnkyd3R3REt1SmZVSFREM1J1SitzQlNiMFZFZjRqZks3bnd0dCt3a3VGSi9wOTlkSzJzTlBBZWRZM3RWSDJOeTBSTGR0VndPMHJoQk9xWVFsZFdKOVlzQnhwdmM1WTNXVmd1eXRvYmo2eVdrOGRibE44SGRWUW8xNkpPNk8zclBiUkY3YUl5a1FkWjNrRGZRY1Q1UU5pYitPRERBM1F3VzYvTkYwREVTb3pTTk5HZEpHOHo0MG0yN3RxOFZlMWN3eHRGY3dKemhpRHFwQkFBcStjb01TL3k4TlphRytTNG1TT2xFdmg0UHRBOWhxcTh2N1FGcHJrOU5tS250MWtrOXU2dEJQeUk1VFlqQjIzV3h6WTU1NVlzcU9ZUUJRT2xjUUx2YmVUUFVPTyt6THR5MWpNMXRtVEV0YklFODNsWkd0aVFvQzNBVGtFK0JxdDRMRzgwcW5NTTB6bEtoeEI2d2Y3N3Q5T05qYmVEYlN3TjdLRUNQaDdiRWtLQ1AxYlAxSUliZEppTjlFWGZraDZXTGVHVzRtTDV5NlN3S0cyMkdhQUZnZ21iZlVOSVBIWGhUbkhlbWpBWEVaQlp4TWtNUC9qY1ZJLzcvYlRwK1VXRkU1bnNIcitkdzc2eDlseWFVN1M1VDdQalU0YnhTNjM0YkJIdnJLdWViTDVUMmJkMjYrUzZRN2xoSE5TQVRPdnptK2svS0RIRy9jWW9HQ0Y4OE5rbWNvWGdUd0hYVVhLMDJUZkRXblIwWnBKUkNpckxIbzVUdmdSckEzMG1SVm5WUkhkVzBGMzdMUU5EcFF6M3VIeEg1MTQ5dFFZZ2Irb1RCQTBtdlNCRzRVRGJZMjJicU94dFdjK2EzY1J3b3VQSzNKbGlGRzhBOTJnclRZKzFYc0M2VWdnbFFRZU01am9lQjZJOTlOTFdNdzlucDJyakkzTmxXRGcvclRiaVZJRXh2RzQ2a0h0cXQydGM0RzdvbjJTUGpRUDl2NHJQWlI5MmF5cDd1akJIdU5DNE5ycjIxWXNTWWd5TTBoUUZVbVFkd1VhMW9Cbnd5S0Q2b3VJVDFFM0hjRDJNS2cybmRKdDRjWmVrdHUydXZIcFBFSHEwandpb3E1N1N4YjJzSGgxQVBPM2JTRm9ra0Fqb29za2tEVW1PMmtsalo5M21yM09KTHVGeWFna1FTVEo0Y1BaVnh4UVU0cGdkOXEyaXIyYVFmTDMwdnUzZW13MGdHSTR4bG5OUFZPbEJXdGkzTGFkQjFWWDNFbEFXOXAvS211RngvUmdsTk5CTzh4cDhQZlNmbFdBR1JsMFl5UFpCL09vZHVyME1NMi81dFo3ZDlCWlBscS9zL2QrZFpWSnlkY1QyR3ZLb05Sb09ocG5oN1pOVjdudGFzV3pjV010RVM0dkFDNGhROVdoNGc4RFZXYTFsVEtkR2tranRCeWdUL043YXVJQ3Z4SThZcE50WFluRktLc0hvWGJKdE8yV0lFcGRHL1gxQzJvNGVyWDBCak1VQ3VnSmdnNkNkM2RYeXpzbmFsekRzV3RzVlpKS3NyTXBHWllJa1FlUG5SZC9sbGpIMzNuUGZjdXQ1dldkd2QvOEFsYkEvcXI0N2VhdUQzNVlyTHUyUVBXa2ZldTIwL0c0cjV3dmJZdk5xV0U5d1A0cHFQL0VydjF6NEJSNUNrSDBKZTIvYVAwN1BqZnN0K0JtcWw4djlvaDhLK1Y3VERNZ2hHZG9uTWRjeUtPSEFtdVdOanJwMzNIL21iODZZVzc1K1JQSkpMWGdOVFBxV3dlUDM2UU4rU2VKVzNncjBzdWMzc3dVeUpWRVVSTVJKMXB0aGNUYnZLd2RjdlJBS3NCQUlUS3d0ek9ra2FlODhPZmJPQUxheEVOcWU0MTBIQzlEQ204ZFV0Mnk2VHFKR283eUxnZ2RpUnViV2dMa2Z5MFhBc2ppMmJuelQybUJ1RlNnNXlWT2lHZEZIQWI2ZjdROUxvY1FNT3ZpOTArUlN1VFpwSmdrZ1pRSkFFZGtEVFNUNTZUV1RTSTZCYzlKOXo2Tm0yTy9uVy9IZkk5MUEzL1NQaVQ2cVdWN3JOaWZhMXNuMzFUS3dDVEFCSk1BQWFrazdnQnhOSUxLL0x2R2traTVsTGJ5b1ZDWTNUellXb05xN1h2WDhJR3ZYR2M4OHdCWm1iUUloK2tUeEpxREY3S3QyclV1N3RkZ3VVUlJsVkFRdVptUDBjeHk1bzFQcWhoRG1MYUdtRnNDQ0o1eG9JZzZzUUQzUUJRQ0pZS3JueXAwWUpKYlZnMEFBQTlYZHg0NlZwZVluSzBFTG1FSFdQb25Rbjg2a3Yzd0k1dFY2aG1BZTVQM1cwSFlRdmpVTjFMamhyakZteTVRU3hKak1HSVhYN3AwN0tvOGU0eDNzVDNrbW9pSzJZMW9hRGE0ZWg0L2xXdHR0MWJCSlZ1eUQ3Sm1vN1c3eG9Dci9BSzNnSzNUUldlQWNvRUE3aXpHQlBYeE1jY3NWcGZFd1J3RUhzMTQ5VlRPc1dCcHE5dyt5Mm9BOTkxdlpRSGNuTm1XN2w5RnVrdEpFaVlKNkxHQ2QvQWJvMzFCaGNHR3hMMjFLb1BuTlRPVUJEUGt2bFJlRTVRR3lvRm9Td0lKTUxHYUFOV0lrOXdwWmhMeDU4TXcxT2VScW9obGFSMThkTzJLQ1hCNTdia01PaXh5dDlsbElFeHYwTFFlK20yelNEZnQyMlVIT0xkbmRNTU1TTGdZUXdqUXdUcngwTTBMaVFJSU1uT0U2WFZvQ0o3VEd2ZDF6SkhKTy9ueG1GQkVrTUNkRC9sMjJhZS9vMUF4NVQ3VmEzakhkZXNnamdSTzczVVRaeDl1NEFSZnRLU05WWXZLbnFhRUk5azBqMms0dVlweWRRUzN1TmVoUU4yNmlwZHBZUXNTUzlwK3JJWElBNHptVWRsTDN3OXd3R3VTQUlBTTZBVWNuSHVyVW1pQWZrVGZXRlpSMDE1UVZyUFJkckVSUTR0elJWbkFFMVFaaGNhUnhwM2hjVUdFR2tnd0JvbXhiSzFCSnRUQmdLeEcrUENOWitIdnF2aXJrcTUwSVBVYXFlTHM1SElvcUtzRmVUV1RSSHMweXhXbUR0ZmFlNjN2Q2Y3S1dUVEhheGl4aDEvWmsvd0E3dTMrNFVBdXl4THFJelNEcEpFOUU4UlY1dktUc3U3cVZDbTJNZzFrQzdhVmlEdjBDTUk0ek5VTEFrNXhsRW5XQUJKSmc2QWNhdXR2YVRqWjExU2pJeWhNelJwUE9Xd29ZY0RyNWZXb3FuWWhBRjBWeHJ2WVFQRFNoWnBsYVM3aUdGcGRTVHhNS0lCSkpKM0FDYWEzc1Boc01oVUhucnBFWjRnS1Qvd0J0ZUhmUkZkNWgvcU4vS2Z5bzdaVjFzUGVXNndobHpGUVNvWUVxUUdLSHBhVE9vNENnTHFhenJVVUFEUVZRZnRqYlZ5OWZ1TUhLSytSUW85VUxiWEtnQSt5TjNVU1NLTjVXNG9PMXNoVlZjZ0txdWlxdjBWQTZnQUtRVzdjbU5jeElqU1FaUEV6cDc2dEdJMkEySWptcmlNNnFxbTFNWEFGVWFxRG8vZ1o3S0NxbVNKM2RVRGpUYkZzQmhiWUFqbmJyUDRXN2FJQi9NMXlncitBWkdDdUN1dnJIUmREcncwUFlSUFpSRzJJVTI3WTNXN1NEeGVicC93QlFleWdDTmFtc3J5Z253bjBoOWsrWC9OYjNNTTJWWUIrY1pndW0rTklIc1B0cmJBWGtWV20yV1lrUTB0Q2dha1pWM3oxazZScFd5WXE1TnNBa2kxblpSd1dZTE5RQVhvekVEUUNRUEQ0MU1TZWJFa2tEZDN0dzl4b2ZQRFNZT3BQdG96SDRwblZWT1VaQXE2QUQxUVJyMW50TkJtQnZvSCtjTUxFNWhxUnhqU2k5cU9wdlF1aWhRQndKNk9reHVPb29IQW1XVUFkS1JIR0RPOGpxcVhQbWU0ZDhrOXVtYVI1Q2diWWpHRjdGcFFQb2tidGN3TXlUMUVNUi9EdzFwdHlKd29uNVJPdHNYNEduQ3lBRDE3M0k4RFNtd3JOaHkwQ0V1UTJtdVY5WW5oeDc1anFvemtnR055NmZvaXkyblZMSWZOUlVBSCtlZTQwVlFWdHB2bnVhakNhRGRPUGRXaHIxRHY3cTFKb05xeXNGWlFBYlB3SEUwMFdCWGk2Q0sxWnFDWFBYb3FETlVxVUJHSHV3YVFiYk12Tk9UUU9Pd21mY3k5dVpsUUR4Y2lmQ2FLUlRUN0FiTVg1SGR4SkN1d1lLcXRteXFOUVhPVWlUT2dtUjQ3bGQvQmhRZm5yVEVmUlhuV0o3bTV2Si9WVHpGYlFaTm5JamxjOXdya1FBQWl5aXdydkhGanFPSjNtaUsyeDRqMmRScGh0MVNPYlQ2dHEwUFpiV2FXV3J1WGVBdzRnekI4UnFEMmltMjBvZkVMSklWbVFTTlNGTURUd3FoZFlnTnFZR3V2U0h3cTJiSmZDcGgrWmE0bHpNVkpSWHlqb3RuVU9TUVNRWjBIV1lOTE5vNGZEZ3hieno5L01CM21OVDJDZ0RoUWVQdEFOQVp0TVhSY054RmRWblJRckJBSWlBTnhIc3BiWWRpU1dHbkVtYThiQmlkSTc0aU8wbWRLaXQ0VE1XaGdTb25jZGRRTko3NkFpN2VSanZDaU4rclQyd0tIaFBybndVa3gxdzBEMzB3dDdKVkZEWDJaWjlXMkk1eHU4UjBSMzBEZWEycGJvRVFHMG1TREJ5NWkzYkVnY0ozR2c5dDRoRUlLaG1NTU5TRjNxUklVQnQwenY0VjdjeHJGK2NBeXR2QkU2ZFJFbXJHY0dsdkRDMnFxOTV3YzI4azNBbk90dTNKWlJsWEt2cjNHMW5LQVVGOE1VNlhyMjJaRzdDQ2Y4QWtlRkJKZXg5L0ZNbHU3ZGU1bVpWRW1kNUN6QUcrT08vU3RiMkh1WWkvY05wR2VYYUlHZ0U5RVR1SFJqZlcyeG5oaStnNXRIYnhDNVYvcVlHZ2JiUXBFNkhlTlA3TkJac0Q2TzlvWEJtRnBFSFcxMjMvc0xIMjFIdEhrRmpiSWx4Wmo5L2JYMzNDb3BKWjJqY1FFVzNaSitxeFh5cVRadTI3OW5PYmR4bFo0elBQVE1idWtkZmZVNUV1SDJWakZKRnRMd2thbTBXWldBQjBMMlNWUEhTZVBiVU56Wmx6bkNDalc0VW1TckxFQXpFNzlOSXA1aGVWV05DSE5mekxwTHNVdXNDWmdRWmFUMWJ0S1NiVTJqY1k5Szh6c2ZXR1VKSFVEbGdUMWdTQjExUUpnOE1XdUtyQ0pNbVJIUlVGbTl3TlJ2QkpKa1NUcnZIOTc2TjJjZExyblhMYVllTnhsVHlacURzb0puUGxQajUwQld6VkN0bTN3R2FmdXFTUGVCVVdGSkFKRytSdTBPN1RYMjFOaDdZQXVzR3pkQ04wYXN5ajg2Z2NFSXNEZlBpZC9rd29IR3pYWnJWMVJ1SlROSkpFRmJxeWZFcjRnVTY1SGlMT0xZL1V0RHdKYlQrbXF6c3ZVT3JFaVVKRUg2YW5vOTI5dGUyckxzQi93QkR4TGRib3ZmQ2srYlZCWDhNZm5qM05SeE5MOEgrc1BjYVBvTmxPL3VyUW10bDQ5MWFHZ2tCcktqcktDZlBVRHZYaGFvYmhvSW14Qkowb3pCM1RTKzFiTTAyczJnQlZFek5RZU5PbFRNOUI0eDlLZ1VQeG8zYVdLNTlrTzVzbHRJM0FsRkNDTytCUWVRbmdhbHcxZzUxMUE2UzhaNGpxcWlmQllkYmQxZWVBaUNZT29PK0pqZUpHN2pSRzJtRGdYRjNIdTBnOWxNY1R5ZHZYYmlzd051MlVEQm1IQ1R1QklQYk83ZEpFaW9NWmhMUzIydDIzTDVUSmJlTlFOQVk3UGZRQ3F3eWh1c1RXanNlbzl3RXNmeUhhYUV0WWtLSU15TnhpWTdoVVQ0Z25mSjd5VFFUMzJZakxBVWI0a2UvV1RXMnkyeVhWWU5Hc2FUeDBuWHFNSHdvTnJoN3U2dkRtUFdhQXk5ZFlNeFlrdE9wSjFQdDE5bEx3MnV1NGtFOXNIalRESEptWUg2d0I4U05SN1pxRjhDNFU5Q1FZT2Jpc1RPbmJQdW9DN2UxemFjWEVVTXdWOGhZazgyN3ZtRjFRQ0FXWGVzNkF3WU1DaE5tdE9aVDlJVDRpaHltb0xTRm1NMGFkc0d0c0VyRzZCYkJZem9BTlltSlBWUUVvY3RxNzFzVVh3RXNmSmEwVEJzZUZUMlN5M2hsS3FTWWwxUjFFOFNyZ3JWb3RYTVZHZ3dWMzcxaEY5OXVLQ3MydGxNZDgxNXN2QlozZFQ5R1BpUGhWcytVNGpqZ2NPLzd1NDZlNHVCU2paOXU1WXUzYmo0YThRNUp5cUp5ak1TT2tBMHhNYnFpcE1Sc1kyMWxWQVZMYjNTUWVNTEJJN0ZZKytxZzVPODhkZmJUVGFXUGN0Y0hTVUVNTXBtWUxFZ0dRT0RkUXBYY2FZN2dQWnBWUVhjc01xb3NFYzRRd2tSSzdsNzk4K05RNGplUU53cGhkMmlXdldXTUVXMVVLT0F5S0FvaitGZlpTbzc1UEVtZ2t6d0lVbnBBU1B0QWtBZVI4YWRzeUM2UVVPUlRsZ2FrQmRCR20rbEd6a205YkErdXZzREFuM0ExZE1UZ3JUNnNnSjYvalFlL0k3UE5GMU1BbzJ1NGlRZUZRN0tmL3A5dy9Xdk43a1NveWd0aktrWlo5VTd1dldwK2JDWUFBY2JqbnlGUlZkd1IrY1BjYVlVQmdBTXg2NDArTkhVUjZwOHExcjBmQ3RhQnRnc05oeWdMdVEyc2pNbzRtTkRydXJLazJkamNNdHRSY3RabUV5Y29NNm5qUFZXVUNETlVUTlVhM0sxWnFvblM1VXB4VkE1NjFMMEJwdjE2UklvRldwdnM1a0JCdVRsRytBRDdqdm9GV1VUdW52OEErS3NPeThNbUd5NGk4VkREcEpiaFNkUm9XRERmclBZWU9zUlh0L0VXUTUrUzJXWnp1SlU1VSs2R0pqdkpxZkJiT3ZBbDNTemRZNytkVG5CNFNkUENvcGZ0WGxBMThrc1dnbWNvSmx1MTIzbis0aWwyRXVYQzRrUXBCRURjSjNlK0t2R0hRcUlPQXc3RHFVK1MzUVFQQ2lCZHd2OEFtN092VysyM21iOExGUi9MUWN5K1RsbnlqZnJFQ2QzZFJRMmFSdjA3OVBPcGNVd3RZbFhFNVZ1QTZqcFpNMnNneHJsNGFWMURCVzhNM3EzMFBmeC9sekNxT1oydGxIcW91MXNxdW1yc3JERTY4elBYMFZQdDBORXJ5U3c3NmpNTzFiaGIzTklxVWNnMjFoemJ5TU9Id00wZmlVZGw2SWhHQU1nQW1EcnZOWFRsN3lTRnZCdGNSaTNObFRCVVRERUtkVmdhU0R1NFV0NUNiTmZFNFFNdVFtMnpXMkJZaHRJWmRNc2VxeThlRktLWW16N3FpRmRnTmROUU5ld1Z0YU9KdCtxVjhOS3YyUDJXeUhWWVAzazhnMCs2bGVJdzRBMWducTExOGFDa1lpNHlYRnVFUXdPWWpodjFIY2RhcytFeE51NE5iUUI3REZKTnMyYjF3NldsRWRUNWpIZVk4cUsyYVhGdFFRUVJwSGR1UHNpcWg2bGdmUloxOTlSdmZ1QXhuQjc2V3ZpajFtaEh1bWQ5Uld2S0habHk0M09ES1RBQkFNWmdOeDE0L2tLcjE3Q1hGM29SL2ZYVmliRXQxMExkdk1TQ2VCQmpTRDJHcWhYaXJZUzR5NjlIb3oxTUk4eUNQR2gxYmdkMnZoUEdqYnRza3NTWnpFa3oxbW96WUZCdnN5OEZ1aCtBQmllN0tOM0dLY3R0S2VOSklOZUNhQnpqUWNxc1NkUkpIM2ljZzlpbHZFVVRadkU0T0R3ZDQ4ZGFVUGV6S0pPNERUdVZWLzIrK25Gd0g1SWpINlJZK0FNRHlxQlZnRDBqMXhSMUFZUDF2QTBkUWVpdENhOW10Q2FCL3N5NWZGcGNsa011c0VrQ2VrWjQ5ZFpVT0E1N20xeTNRcThCbG1KSjR4WHRCMUxhM0lQWnFSS0twUFVXOGdmaFZPNVk4a3NMYnRsckNQUEE3bDkrdnVyb1hLQ0pYWGpTemIxck5aYmpwOEtpdUFzYTFtcDhVa093NmlmT29hcUpMSTFwdGhMWVloVHVOSzdPK20rQjlkTzhlZEJkc05zZTZxQXFGY1J1TWcrZEdZYTViSDZ4V3RudXpEMmlyanNEQkx6UzhkQlJ1SjJiYkk5VVZLcXVZTzNaZjFiaXQ0aWp4czBkbmhTamFPeUxXWTlBVDE3dktnTWlvWW00bmM3UlFWRDBxN001dkVLNEdseEFmNGw2SjkyWDIxWk9SK3lNSGk4Rlp1UGg3WmZMa2RnTWpGclp5a2twQmt3RDQwdTVkMk9jdzRmbkMvTnR4M2dQMFRyMzVhcG13OXM0NjJyWWZDTXdETVhJVlFXQmdLVG1JNkkwRlVkVHhQSXZDcXNyZnY0Y0RpTDNSOGVkQjg2cVcxY1Zac0g1cmFndW42dk1jNGZHNGpBQ2wrSDVINHpGSE5pY1FGbjY3bTh3L2huTDc2dHV5dlJ2Z1UxdUc1ZVAybXlyL0trSDJrMEZleFhLTm1zdGJGOHVYQlZnY3lDRG9SbFpqNTBYc0hKYXNsRXVaYzVsd3I1Wk83V0ROWFc5eVV3RExIeVd5TklsVnlIK1pZUHZwTmpQUjNoRDZodlcvdTNBdy9yQlB2b0VkNW9CeXU0L2pZaitva1ZYOFJ0MGFqblo3MG4zaUtpMm5zTG1zYXVGdjNTdHNrWmJtbnF0T1FrRXdOUmxQYURUekdmNFpaQVZMSzNHSFptbnZMYi9BSDBGWlhhOTF6bHRvR2FDWWd6QUV6RTlXdGFiSXdqNGk2YmIzbXQ2RnRRU0RCRWdDUUJ2cWJidU1acnlZaFU1a2dBQ1NCT1hTWVBZWTNib3AzczZ4a2dzMlpqcVNQTHVxaGdlVHRxRkMzTGdnQWIxTzRScnBVRjdrMFFPamRIY1VqM2cvQ21sbUt6RVhpQlVGVnhtemJpZlZidUorSUZLN2hZYjFQbjVWWThaaTZUWDcwOEtJV1BjN0tqTFVZN0d0c05oMVk2MVFCbXJ5ajhSaEVEUUswK1NEZ2FnQ3ExYlMwd2VHSDdPZmFTYVFIQkhoRldEYkNaY0xoZ2Q0dExRVi9DZXY0R2pTYUR3cW5OUENEUlpvTUJyV2E5RmFVQjJHUzNsR1ppRHJJRFJ4Nm9yS2pzTW1VU2hKMTFqdHJLQnR0SGxmaXJobm9pRDIxT3ZMZTZVS3V2RGVETlpXVllLZmkyek16ZFptaFNheXNvSnNQdnB2WkVFSHRGWldWQjNYa3pjbXl2Y0tPeFdKZ1ZsWldWVm5IWENXb0RFMjgyK3NyS29BeCtDRDIzdC9XVWp4alErMnVkY21NUnpXTXQ5VGsyMjduMEg5V1gyVmxaVkhVZmtRUEQzeFdOaEdVRWk0UUI0MWxaVUNMRjhzbHRObERGNCt6QTkrdFF2eXZ2WHVqYWhPczlYbjdoV1ZsVVZibE1yc3dMdWJqN3AzUnVJQW5YaWVxZ2ZsVGdkR0Y3UUFEN2Q5WldWVWFBdGNJRG1STTA5c3Z1ckt5Z2RZRnBGRVhySklyeXNxS1U0ckNVQmR3OVpXVUFqMjZpeVZsWlJHWmEzeVZsWlFiS0tiOG92MUZqOTB2bFdWbEFtd2grYlBmOEFsWGhyS3lnOEZhMWxaUUhKZmFCMFR1RzV5b2dEVFFHc3JLeWcvOWs9XCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndDRUFBa0dCeE1URWhVVEV4TVZGUlVYRnhVWUZ4Y1lGeGNWRnhjWEZSWVdGeGdWRlJjWUhTZ2dHaDBsSFJjWElURWhKU2tyTGk0dUdCOHpPRE10TnlndExpc0JDZ29LRFEwTkZROFBGU3NaRlJrckt5c3RMUzByS3kwckxTc3JLeXNyS3kwckt6Y3RLemMzTFMwckt6YzNLeXN0TFMwdEt5c3JLeXNyTFMwckt5c3JLLy9BQUJFSUFMY0JFd01CSWdBQ0VRRURFUUgveEFBY0FBQUNBZ01CQVFBQUFBQUFBQUFBQUFBRUJRTUdBQUlIQVFqL3hBQkpFQUFDQVFJREF3Z0ZDQWdGQkFJREFBQUJBaEVBQXdRU0lRVXhRUVlUSWxGaGNZR3hCektSb2NFVUkwSlNZbkt5MFNRelkzT0NrcUx3RlVPend1RWxVOFBTUlBFMGc1UC94QUFYQVFFQkFRRUFBQUFBQUFBQUFBQUFBQUFBQVFJRC84UUFHUkVCQVFFQUF3QUFBQUFBQUFBQUFBQUFBQkVCSVRGQi85b0FEQU1CQUFJUkF4RUFQd0RtYm1vV05Oc1JzUzRENnkrOGZDaFRzbTU5bjJuOHE2SUN6VjVub283TXUvVkIvaUh4clQvRGJ2MUQ3Vi9PZ0J2SFd2RnFURzJHUWdNTXZmV2lVSG9yWVZnRmJSVUhnYXZjMWVSWGxCN05aTllLeUtEQ2E5VTE0UldDZ2xWcUt0WWlQNy81b0t0bGFnWU5pZVBaNW4zNjBIZHVFOGV6K3pYaGJ3OGZNMUc5QjR6MW9XcjBpdFlvUEMxYjI3a0dhMElyQUtDeWJLMm5rMUJqMmFuMlJHN3Q5cG9uYTIxbWNTZFowN0J4TW5XTzRWV1Z1eEJIeE5TdmRuKy9HZ2d4RDBSZ2pvS0R1VWJneDBSVkMwdHZyQTFlTnZQZlhnb0pVYXBWZW9FcVphQ1VYSzJWNmpGYmdVQnVHdlZZOW00aUNOZkdxdFpNZjNyUjFyRVIvd0RlN3QwcUM1LzRoMmorWS9BVmxWaE1ZWS9PVDhheWluMjByT3BwWXlVK3h5elN1NWJvQXdsVDJyTmJwYm91MGxBNDVMY2oyeG5PRmJ4dFpNZ2dUck9mWFE5bGE4cXVSVDRTMkhlOXpnTzRRZXNEV2Urcmg2TFAva0Q5ei81ZnlvbjBvcE9HSFlmOXlWTHlPTFhObmFrRFdDZm9xZmhVWjJZT3ovOEFtdjVWMVQwVjJsTjdFaGxCNk5zaVFEeGJyNzZ0NzNMUWZYRGlBU1BVVFhoU2o1MXU3S0gyZlpIbFNySDRmSXlpQnJQWHdqdDdhK25lVU96TFB5ZG1GcEZhVTFDcUNKZFpFanNKRmZObTJWbTZnN0Q3U2RmSVZjMERXc01DTzNUNHo4S2xYQkE5ZEd0aHlxejJqeVA1VnZZdEZqb0tJOHdXd09jQmdYR2lKS3dZbWQrblpXWWprOFY0WEIzcVB6RmRaOUNZZ1lyL0FQUi81cWs5S2R1WHRuN3cvb0ZTcTR4L2hmMy9BT1FmKzFSdnM2T0o4Vkk4cHJ1SEova0ZocitHdFhXTndNNkt4Z2lKTytOS2wyaDZOTU1xTXd1WGRBVEVydzhLVWNBdUlBWW4zTitWWXVIWnZWRTkzL05NdHQ0Y0RFRzJCNnVZZUFZZ2VWRmJLdzVrd09JSDRvcW9SL0pIK3FhbUd6TGtBNVJIM2s4cG1yU2NGY0dhVWdBeEpJTTlVQ2F2Mk41T1lkZGsycjYyZ0xwdzlwaTJzNWpia25mRytsVnhVN091ZlVZOXdKOHExT0JmNmpqK0VqNFYxSFlISUY4WmJhNmpXbEFkbGhnWjZNZFE3YTAyOTZON3VIdE5kZHJSVlFTY3VhZEFUeEE2cVZITCtZSTNqMmcxbVU4UDc3cUp0MjVaNDNCbUE3cE5OYkdEbUpYU0JxQXBPN3FKSG5WRmV1V2oyK05GNFZPaVA3NG1tRzM5bVhNT0xlZFZYbk14QTZKYUZ5NmtEZDZ3aWxXZGxBZ3dJbjNrZkNnQmEzcWExSzFmYlhvNjJoY1BSd1J5blVNMTYwb0lPNXZXblVhMGJzLzBVWXA4UUxGMTdWb2xPY0pWbXV3dWJMcUlVVFBiVW81dmFXcHd0ZGJ0ZWhqTXJOYnhlb1oxaDdjU1VZcnZWdEFTSjNHSjQwdXZlaURIcWRCaDNIV0x6QSt4clE4NlhCemxWcVcybFdURmNrSHMzZWJ1dmxZSHBBQU5HdTROTUh2aW84SnlkdmtuSkw1UUNTdGdYUGFKUHZGQWhDUlc0b3ZhMkJ2V2lCY0lXZHdObm15ZTdvVnRzYllXTHhSSXNJYmhXSmhsU00wNWRYS2pYS2ZaUVFoZjdtdmFiUHlVMmdoeXRadUFqaG5YanJ3YU9OWlRnV0RFTlFWdzBSZGFoV3FLOVFWTUxxcnZJSGVZcUZLMDJndWc3ejVWUjBuMFYzVkxZaktRZExPN3Z1MDE5STZ6aGozSDhTVlZmUTBDTVJpd2VOdkRuMkc2dndxNDh2bG5ETjNONVQ4S3o2SzE2TDlNUmVIWGF0bjhQNTEwcXVhZWpiVEYzUit3WDNjMStkZExwb0IyMnMyWC9oOXpMWHpEdHBJdjIvNHZ4Q3ZxSGFnK2Fidzh4WHpUeWlzeGZ0OTcvaUZYQVp0RG9XczBHQ3lnKy9Velh1QXc3M0ZaMEM1RUhTTFBiWGVyRVJMYW1FYmRPbzdhWVl2SFdyZUd1aHdYejI4Z3lGU3lQemx0bGVDZUJYZFZ4WEhXTVpzbjVhYk5rWFZWMXVFSWlOblFNTXVZQ1FDY3A4UlZEcjBhYkN2NFZzUUw2Qk00c2xZWlduS2JzK3FUMWlvUFNaYmsyKy96VnZ5cXdjbDhWaGJrdGhsVlExdTJXQ3JsNHRFamQ5YmRTZjBrSitwUDJ4NVBXZlE5NUZmL0FJT0grNThUVFBhQSthZjdyZVJwWHlKUDZEWSs2ZmM3VTJ4ZytiZjdyZVJxRDVuMjViLzZndyswL3dEcVBURkxXUWdnVDAxbmhBeXZyUW5LQWY4QVVXKy9jLzFHcTBZYkFJOXB5ZjFnYTN6V3BBekVYQzBqajBWTy92cllTWW5HM0N6SG1ueWhGYVRJR2xrUEIwMDZ1K3I1c2Zid3h1dzNJdDVEWkJzbGMyYWVidENHbUJ2QkdsT3ZrbHBzTnRCYlRCZzYzRW5PSEVERHJsT25lZkd1ZStpdTZUczdhVnZnQ0gvbXRPcC9BS2c2UDZMeCtpM1AzOXp5U21ITHhad1Y3N2ovQUlHb0gwWmo5R3UvdjMvQmJwbnl6V2NIZS9kditCcW5vK2M5aVdjeHVEN2JlWnAwaXVtb1VOR1dCbUFKMEdva2RmYlFQSmUzTDNmdnQrSTEwWGF1eTdTWVcxZkdIVzZSWVpuV1dVc0VWdXJ3OWxhSE9lWFcwVGVOZ2xXVXF0d0VNSTRvTkNORDZ2Q3EvZjhBVlQ3aC9HOU4rVnVMRnhjT1JadDJ0THArYloyREJqYklCVnljcFhYVUhXZHdpaytKYm9wKzcvM3ZWSGVmU055aXZZWEFXSHd0NEk4b3JRTGJrQTJpZFE0TWJodzQxSnlLNVMyMnc1eG1KdWczT1pzcTVqcEUycmVlNDJWQnBMT1RvSTNWUU52YkN2cGdjUmV1RUtvdW9GdDVGQmJQRGM2Ym04NkVDSk84blNhckNiVmEzaExLMjNJTDgvenVabk5zQURJcWkyRGx6RUlOVE85ZXFzd2QrNUU3YnRYMHZGU1lEODVtSUlCVzdKRENkWWxXSGdhYjdPMjdoNzhjMWVSODJhQk1FNVFyTU1wMTBEcVQzaXZtV3p5aXhKVmJDTWdYbTFTT2JTY3F0bkV2R2YxaWR6RGZWdDVGWWU5aU1YYXQyOFZpTFE1dk14dHVQbXlTeUVLclN1NjNiR29tSTdLUVd6YjJ5cjEvRjNibHEyem9IS2xoRUFxWVpaNndhdEhKWEFtMWNWV1FJM3lXM25HazVoY3VTVEc4Njc2bTVHNFo3Vmk5YnVPMXhseEdJQmRvelAweVF6UnBKQkIwcHBiWDlKSi9aRC9VYW9PY2VtWEFaNzJGSStxNDk0SStOSmVUZTJQOE53K014QlZHY0N3cUkzMDNacmdFR1FRQkpKaldCVnY5SmRxY1JoRDltOS9zcXFiZXdhbXlRK3Z6bHM1ZE5ZRnpXSTEzeHY4QXBWYzZGSHgzcEYyamNkbk9JQ3p3VzFheWlCRURNcE1kNU5aUU9NMkV3ZG9BanMzZG9IWldWb1crZWlPNFZHVFcxMDZVUHpsUVRod0FTZEFOVDRVRnREYUZ0Z3VWME9wM09rN3UxcU10TldtMUQwVjcvaFFYYjBRM0ZPSXZGUVFEYVVhNnprZnJCSStudW1mYUt1L0xSSnc1L2kvMDNxaCtpRzZUaXJnSkorWmJlWi96TGRkQzVWTE5nL3hmNmIxbmV4VmVRK0VGdkVpNFcvV29iUVhxS2hXbnVpMlIzeFhRcW9uSkZ3MTlGSTlWV1lkOFI4VFY3cG9IMmgrcmJ1OHErZnR2WVdjWlpYcnVNUDYxcjZCeDQrYmY3cmVWY1QyM2FqSFdUMVhMeC9sR2I0VXdjLzJxaHVZeDhva2wzNEUvV080QW1yOXlOd242RmlzSTdFTXlMaUlHWVpRQ0ZPWkNRZFJ6WjFHNmVvVHpwN3pDODdLeFVpZWtPQVpncFA4QVZYVGRoWUJMREpkUURObEtuVTlOWFhLUTUra1RPOHpyV2hZUFFwaVNVdW9ZaEZTTjBqTTkzTUNRSlBTQk9zeE9sUDhBMGdXOHdzajdhKytSVlo5RHQzOUp4YTZUbHRzMGZXWjdoSTkvdnEyOHRVa1cvdkw1bXA2RHVTTnNKaDF0Q1R6Y2dFL1NERXRQdEpIOE04YWE0cjFHKzYza2FWY2tubkRJeDlZNXA4SFlDbXVJMVJ2dXQ1R3NqZ1cxOWxvK091TzJKczJTdDI2QWo4NFdicGt5b1JUcHJIaFRIRlhlYUNoYnlIcEJwVmI0SnlwY1VoUzFvQWRHNHhrbmhTemxqWmphUTdYdWZpcWZiNUtvcEJqMTU3c2gzMXNKdlJZYmd4MTE3ZGszUnpGMVhnbE1pdERaaXcrNUVIZko0MTV5SzIyMkZ1NHJEaXkxMDRpTFFBWUxEQTNOVElPa1pqMlFhZmVoV3kzTjQ2NWJaRWNoRXpYSnlpRll4b2RDUy9iNnU2Z2VRRnRmOFZ4S3NBVHpHSWREdmh1akRML0E3anVOUWRPNUhYOFJidEZiZUVCek1YSk45UjBzdHNHT2llR1gzMFh5bHhlTGJEWFEyRlJWS1BKRjhNUU1qU1FNb25UaE5IY2pCOHk4OEgvOGR1anVVYXpoN28reGMvMDJxRDUrNU5vUmN1NUFXT2RwekFMQms2QWhqTld6Rzh2aFlGcXk5dEhOdENyS3B6R0drWlhEUUFZMWdFNkVkWXBGeVl0UmV2ajlvMzRqVmY1YllZTGlEY1VhRXc1KzNMUVA1QVBZSzBJZG8zOFBjQ1pudXJFN3JTR1pqOXJwdTk5RDNyZUdLck4yOTZwQStaVTZabS9hOTlMYngwSGpXWERvTzc0bXFqbyszT1ZIeXZDWExDcVJ6ZlNZeEVtMnVYNnhnZEU4S291QnNHOHFXb0lBTFFWaGlTVzNaU1Y0a2Nhc1BKNjVtK1dyQkg2TGVPOEdXVWs1aG9JMGdScnVtZFlBZklqQ2M0elN4VlVMNW9NRnN5b0ZRbmVCTW5UZnFLaXBiZHF6YkFWcnpqTEtqOUhVbmVmcEMvck05UXB0eWN4aVlPOXpsbTY1YzVWeTNNTkFQMHdOTVF1OGYzTko5czRGTFRncUlBT2FPSEhoNzZuNVZPWHVKbHlBaEV6RWtnbGdHamNPcHZLZ3VXMU9VR1BTTG9mSUxqWHdxclpYSmN1UGFERU5HS0psVkVxZElKTTV0dzZac0xGTmRGcTQwWm53OXRtamNDeEpJSGpYRUxtT3V1TEZpM2FSaWc1eHJuT0xmUUM2bVhTVkJScFJnMGRjZHRQZHU4dDc5cXlGc3ZidEVXMHRFckxYQUFTU3luMVY2dHhxUVc3MG1ZdExWekR0Y1lLb1c2U1QyWk4zRTl3cmxtMytXWE9BcFpTRitzMnJHQ0NDQU5CcUJ4TkljWHRibm5EWHJseTYyN05jZG5JazhNeE1Ec29tM2hjckszTnlBUVlPNGpxcXdBTnRPNlRKWSt3ZmxXVTlURTJvMXcrdjhQOEE2MWxCQmc5c3ZlelRidElCSHFLd0pKbmVXWTFzMXd6UU95MENxUklra3RvUWROQkdoODZKbldnWTRacTkycS9SWHY4QWhWVjJ0ajdxWFlWeW9nUUJ1M2FuMnpYbHJiVi8vdWUwS2ZoUWRVOUQ5MzlPSTY3RnozUGFOZFQ1UWtjMXFRQkoza0Q2RGRkY1k5RE9QZTV0TVoySitZdWpjRkc5RDZvNDZiNnRuS2owVkppTGpYV3hMZEs1Y2JwVzFjam5YWjh1Wmo2b21BS205aGp5YnhWbE1RcE4yMk9nd1BUWHQ3YXMySTVUNEpKelkzREwzM3JRODJybUd6L1E5aDJjSytJdXdabktscFRwTzZWYnFxdzJmUTNnVi96Y1VmNDdZL0RiRlRnV2NjcWNGZVc2bHJGMkhJUmljdHhTSWpmTXdmQ3VZY29zVlpOOHN0MjA1VVlrOUYxWTZwQTNIck5YaXg2Tk5uMnM3bEh1eXBBVzYvT0lDTmN3QitsMjF6dmx0eVpzV0d2T2xwVlhMTnVKQVVsMEJBNGNkT3cxY0hQTFFCVy85WWhBQnhNM0ZZKzVhYjdBMnplUjdhM0hibVZQR0RBQU1heG1qc29UWitGellURlhJbGhjdzZxUUpJMWN0SEVUSW1nc001dDNGWnd3eW1ZaUR1MDBQaFdrZEw5R1czc05oY1hpcmwyNnhXNkJsT1M0NUpGeGlBQXFrZ0JTTjlYSGxCeTJ3dHdES3VKZlVIVEQzUnVKK3NCU2IwVkVmNGpmSzdud3R0K3drdUZKL3A5OWRLMnNOUEFlZFkzdFZIMk55MFJMZHRWd08wcmhCT3FZUWxkV0o5WXNCeHB2YzVZM1dWZ3V5dG9iajZ5V2s4ZGJsTjhIZFZRbzE2Sk82TzNyUGJSRjdhSXlrUWRaM2tEZlFjVDVRTmliK09EREEzUXdXNi9ORjBERVNvelNOTkdkSkc4ejQwbTI3dHE4VmUxY3d4dEZjd0p6aGlEcXBCQUFxK2NvTVMveThOWmFHK1M0bVNPbEV2aDRQdEE5aHFxOHY3UUZwcms5Tm1LbnQxa2s5dTZ0QlB5STVUWWpCMjNXeHpZNTU1WXNxT1lRQlFPbGNRTHZiZVRQVU9PK3pMdHkxak0xdG1URXRiSUU4M2xaR3RpUW9DM0FUa0UrQnF0NExHODBxbk1NMHpsS2h4QjZ3Zjc3dDlPTmpiZURiU3dON0tFQ1BoN2JFa0tDUDFiUDFJSWJkSmlOOUVYZmtoNldMZUdXNG1MNXk2U3dLRzIyR2FBRmdnbWJmVU5JUEhYaFRuSGVtakFYRVpCWnhNa01QL2pjVkkvNy9iVHArVVdGRTVuc0hyK2R3NzZ4OWx5YVU3UzVUN1BqVTRieFM2MzRiQkh2ckt1ZWJMNVQyYmQyNitTNlE3bGhITlNBVE92em0ray9LREhHL2NZb0dDRjg4TmttY29YZ1R3SFhVWEswMlRmRFduUjBacEpSQ2lyTEhvNVR2Z1JyQTMwbVJWblZSSGRXMEYzN0xRTkRwUXozdUh4SDUxNDl0UVlnYitvVEJBMG12U0JHNFVEYlkyMmJxT3h0V2MrYTNjUndvdVBLM0psaUZHOEE5MmdyVFkrMVhzQzZVZ2dsUVFlTTVqb2VCNkk5OU5MV013OW5wMnJqSTNObFdEZy9yVGJpVklFeHZHNDZrSHRxdDJ0YzRHN29uMlNQalFQOXY0clBaUjkyYXlwN3VqQkh1TkM0TnJyMjFZc1NZZ3lNMGhRRlVtUWR3VWExb0Jud3lLRDZvdUlUMUUzSGNEMk1LZzJuZEp0NGNaZWt0dTJ1dkhwUEVIcTBqd2lvcTU3U3hiMnNIaDFBUE8zYlNGb2trQWpvb3Nra0RVbU8ya2xqWjkzbXIzT0pMdUZ5YWdrUVNUSjRjUFpWeHhRVTRwZ2Q5cTJpcjJhUWZMMzB2dTNlbXcwZ0dJNHhsbk5QVk9sQld0aTNMYWRCMVZYM0VsQVc5cC9LbXVGeC9SZ2xOTkJPOHhwOFBmU2ZsV0FHUmwwWXlQWkIvT29kdXIwTU0yLzV0WjdkOUJaUGxxL3MvZCtkWlZKeWRjVDJHdktvTlJvT2hwbmg3Wk5WN250YXNXemNXTXRFUzR2QUM0aFE5V2g0ZzhEVldhMWxUS2RHa2tqdEJ5Z1QvTjdhdUlDdnhJOFlwTnRYWW5GS0tzSG9YYkp0TzJXSUVwZEcvWDFDMm80ZXJYMEJqTVVDdWdKZ2c2Q2QzZFh5enNuYWx6RHNXdHNWWkpLc3JNcEdaWUlrUWVQblJkL2xsakgzM25QZmN1dDV2V2R3ZC84QWxiQS9xcjQ3ZWF1RDM1WXJMdTJRUFdrZmV1MjAvRzRyNXd2Yll2TnFXRTl3UDRwcVAvRXJ2MXo0QlI1Q2tIMEplMi9hUDA3UGpmc3QrQm1xbDh2OW9oOEsrVjdURE1naEdkb25NZGN5S09IQW11V05qcnAzM0gvbWI4NllXNzUrUlBKSkxYZ05UUHFXd2VQMzZRTitTZUpXM2dyMHN1YzNzd1V5SlZFVVJNUkoxcHRoY1Ridkt3ZGN2UkFLc0JBSVRLd3R6T2trYWU4OE9mYk9BTGF4RU5xZTQxMEhDOURDbThkVXQyeTZUcUpHbzd5TGdnZGlSdWJXZ0xrZnkwWEFzamkyYm56VDJtQnVGU2c1eVZPaUdkRkhBYjZmN1E5TG9jUU1Pdmk5MCtSU3VUWnBKZ2tnWlFKQUVka0RUU1Q1NlRXVFNJNkJjOUo5ejZObTJPL25XL0hmSTkxQTMvU1BpVDZxV1Y3ck5pZmExc24zMVRLd0NUQUJKTUFBYWtrN2dCeE5JTEsvTHZHa2tpNWxMYnlvVkNZM1R6WVdvTnE3WHZYOElHdlhHYzg4d0JabWJRSWgra1R4SnFERjdLdDJyVXU3dGRndVVSUmxWQVF1Wm1QMGN4eTVvMVBxaGhEbUxhR21Gc0NDSjV4b0lnNnNRRDNRQlFDSllLcm55cDBZSkpiVmcwQUFBOVhkeDQ2VnBlWW5LMEVMbUVIV1BvblFuODZrdjN3STV0VjZobUFlNVAzVzBIWVF2alVOMUxqaHJqRm15NVFTeEpqTUdJWFg3cDA3S284ZTR4M3NUM2ttb2lLMlkxb2FEYTRlaDQvbFd0dHQxYkJKVnV5RDdKbW83Vzd4b0NyL0FLM2dLM1RSV2VBY29FQTdpekdCUFh4TWNjc1ZwZkV3UndFSHMxNDlWVE9zV0JwcTl3K3kyb0E5OTF2WlFIY25ObVc3bDlGdWt0SkVpWUo2TEdDZC9BYm8zMUJoY0dHeEwyMUtvUG5OVE9VQkRQa3ZsUmVFNVFHeW9Gb1N3SUpNTEdhQU5XSWs5d3BaaEx4NThNdzFPZVJxb2hsYVIxOGRPMktDWEI1N2JrTU9peHl0OWxsSUV4djBMUWUrbTJ6U0RmdDIyVUhPTGRuZE1NTVNMZ1lRd2pRd1RyeDBNMExpUUlJTW5PRTZYVm9DSjdUR3ZkMXpKSEpPL254bUZCRWtNQ2REL2wyMmFlL28xQXg1VDdWYTNqSGRlc2dqZ1JPNzNVVFp4OXU0QVJmdEtTTlZZdktucWFFSTlrMGoyazR1WXB5ZFFTM3VOZWhRTjI2aXBkcFlRc1NTOXArcklYSUE0em1VZGxMM3c5d3dHdVNBSUFNNkFVY25IdXJVbWlBZmtUZldGWlIwMTVRVnJQUmRyRVJRNHR6UlZuQUUxUVpoY2FSeHAzaGNVR0VHa2d3Qm9teGJLMUJKdFRCZ0t4RytQQ05aK0h2cXZpcmtxNTBJUFVhcWVMczVISW9xS3NGZVRXVFJIczB5eFdtRHRmYWU2M3ZDZjdLV1RUSGF4aXhoMS9aay93QTd1Mys0VUF1eXhMcUl6U0RwSkU5RThSVjV2S1RzdTdxVkNtMk1nMWtDN2FWaUR2MENNSTR6TlVMQWs1eGxFbldBQkpKZzZBY2F1dHZhVGpaMTFTakl5aE16UnBQT1d3b1ljRHI1ZldvcW5ZaEFGMFZ4cnZZUVBEU2hacGxhUzdpR0ZwZFNUeE1LSUJKSkozQUNhYTNzUGhzTWhVSG5ycEVaNGdLVC93QnRlSGZSRmQ1aC9xTi9LZnlvN1pWMXNQZVc2d2hsekZRU29ZRXFRR0tIcGFUT280Q2dMcWF6clVVQURRVlFmdGpiVnk5ZnVNSEtLK1JRbzlVTGJYS2dBK3lOM1VTU0tONVc0b08xc2hWVmNnS3F1aXF2MFZBNmdBS1FXN2NtTmN4SWpTUVpQRXpwNzZ0R0kyQTJJam1yaU02cXFtMU1YQUZVYXFEby9nWjdLQ3FtU0ozZFVEalRiRnNCaGJZQWpuYnJQNFc3YUlCL00xeWdyK0FaR0N1Q3V2ckhSZERydzBQWVJQWlJHMklVMjdZM1c3U0R4ZWJwL3dCUWV5Z0NOYW1zcnlnbnduMGg5aytYL05iM01NMlZZQitjWmd1bStOSUhzUHRyYkFYa1ZXbTJXWWtRMHRDZ2FrWlYzejFrNlJwV3lZcTVOc0FraTFuWlJ3V1lMTlFBWG96RURRQ1FQRDQxTVNlYkVra0RkM3R3OXhvZlBEU1lPcFB0b3pINHBuVlZPVVpBcTZBRDFRUnIxbnROQm1Cdm9IK2NNTEU1aHFSeGpTaTlxT3B2UXVpaFFCd0o2T2t4dU9vb0hBbVdVQWRLUkhHRE84anFxWFBtZTRkOGs5dW1hUjVDZ2JZakdGN0ZwUVBva2J0Y3dNeVQxRU1SL0R3MXB0eUp3b241Uk90c1g0R25DeUFEMTczSThEU213ck5oeTBDRXVRMm11VjlZbmh4NzVqcW96a2dHTnk2Zm9peTJuVkxJZk5SVUFIK2VlNDBWUVZ0cHZudWFqQ2FEZE9QZFdocjFEdjdxMUpvTnF5c0ZaUUFiUHdIRTAwV0JYaTZDSzFacUNYUFhvcUROVXFVQkdIdXdhUWJiTXZOT1RRT093bWZjeTl1WmxRRHhjaWZDYUtSVFQ3QWJNWDVIZHhKQ3V3WUtxdG15cU5RWE9VaVRPZ21SNDdsZC9CaFFmbnJURWZSWG5XSjdtNXZKL1ZUekZiUVpObklqbGM5d3JrUUFBaXlpd3J2SEZqcU9KM21pSzJ4NGoyZFJwaHQxU09iVDZ0cTBQWmJXYVdXcnVYZUF3NGd6QjhScUQyaW0yMG9mRUxKSVZtUVNOU0ZNRFR3cWhkWWdOcVlHdXZTSHdxMmJKZkNwaCtaYTRsek1WSlJYeWpvdG5VT1NRU1FaMEhXWU5MTm80ZkRneGJ6ejkvTUIzbU5UMkNnRGhRZVB0QU5BWnRNWFJjTnhGZFZuUlFyQkFJaUFOeEhzcGJZZGlTV0duRW1hOGJCaWRJNzRpTzBtZEtpdDRUTVdoZ1NvbmNkZFFOSjc2QWk3ZVJqdkNpTityVDJ3S0hoUHJud1VreDF3MEQzMHd0N0pWRkRYMlpaOVcySTV4dThSMFIzMERlYTJwYm9FUUcwbVNEQnk1aTNiRWdjSjNHZzl0NGhFSUtobU1NTlNGM3FSSVVCdDB6djRWN2N4ckYrY0F5dHZCRTZkUkVtckdjR2x2REMycXE5NXdjMjhrM0FuT3R1M0paUmxYS3ZyM0cxbktBVUY4TVU2WHIyMlpHN0NDZjhBa2VGQkpleDkvRk1sdTdkZTVtWlZFbWQ1Q3pBRytPTy9TdGIySHVZaS9jTnBHZVhhSUdnRTlFVHVIUmpmVzJ4bmhpK2c1dEhieEM1Vi9xWUdnYmJRcEU2SGVOUDdOQlpzRDZPOW9YQm1GcEVIVzEyMy9zTEgyMUh0SGtGamJJbHhaajkvYlgzM0NvcEpaMmpjUUVXM1pKK3F4WHlxVFp1Mjc5bk9iZHhsWjR6UFBUTWJ1a2RmZlU1RXVIMlZqRkpGdEx3a2FtMFdaV0FCMEwyU1ZQSFNlUGJVTnpabHpuQ0NqVzRVbVNyTEVBekU3OU5JcDVoZVZXTkNITmZ6THBMc1V1c0NaZ1FaYVQxYnRLU2JVMmpjWTlLOHpzZldHVUpIVURsZ1QxZ1NCMTFRSmc4TVd1S3JDSk1tUkhSVUZtOXdOUnZCSkprU1Rydkg5NzZOMmNkTHJuWExhWWVOeGxUeVpxRHNvSm5QbFBqNTBCV3pWQ3RtM3dHYWZ1cVNQZUJVV0ZKQUpHK1J1ME83VFgyMU5oN1lBdXNHemRDTjBhc3lqODZnY0VJc0RmUGlkL2t3b0hHelhaclYxUnVKVE5KSkVGYnF5ZkVyNGdVNjVIaUxPTFkvVXREd0piVCttcXpzdlVPckVpVUpFSDZhbm85Mjl0ZTJyTHNCL3dCRHhMZGJvdmZDaytiVkJYOE1mbmozTlJ4Tkw4SCtzUGNhUG9ObE8vdXJRbXRsNDkxYUdna0JyS2pyS0NmUFVEdlhoYW9iaG9JbXhCSjBvekIzVFMrMWJNMDJzMmdCVkV6TlFlTk9sVE05QjR4OUtnVVB4bzNhV0s1OWtPNXNsdEkzQWxGQ0NPK0JRZVFuZ2FsdzFnNTExQTZTOFo0anFxaWZCWWRiZDFlZUFpQ1lPb08rSmplSkc3alJHMm1EZ1hGM0h1MGc5bE1jVHlkdlhiaXN3TnUyVURCbUhDVHVCSVBiTzdkSkVpb01aaExTMjJ0MjNMNVRKYmVOUU5BWTdQZlFDcXd5aHVzVFdqc2VvOXdFc2Z5SGFhRXRZa0tJTXlOeGlZN2hVVDRnbmZKN3lUUVQzMllqTEFVYjRrZS9XVFcyeTJ5WFZZTkdzYVR4MG5YcU1Id29Ocmg3dTZ2RG1QV2FBeTlkWU14WWt0T3BKMVB0MTlsTHcydXU0a0U5c0hqVERISm1ZSDZ3QjhTTlI3WnFGOEM0VTlDUVlPYmlzVE9uYlB1b0M3ZTF6YWNYRVVNd1Y4aFlrODI3dm1GMVFDQVdYZXM2QXdZTUNoTm10T1pUOUlUNGloeW1vTFNGbU0wYWRzR3RzRXJHNkJiQll6b0FOWW1KUFZRRW9jdHE3MXNVWHdFc2ZKYTBUQnNlRlQyU3kzaGxLcVNZbDFSMUU4U3JnclZvdFhNVkdnd1YzNzFoRjk5dUtDczJ0bE1kODE1c3ZCWjNkVDlHUGlQaFZzK1U0ampnY08vN3U0NmU0dUJTalo5dTVZdTNiajRhOFE1SnlxSnlqTVNPa0EweE1icWlwTVJzWTIxbFZBVkxiM1NRZU1MQkk3RlkrK3FnNU84OGRmYlRUYVdQY3RjSFNVRU1NcG1ZTEVnR1FPRGRRcFhjYVk3Z1BacFZRWGNzTXFvc0VjNFF3a1JLN2w3OTgrTlE0amVRTndwaGQyaVd2V1dNRVcxVUtPQXlLQW9qK0ZmWlNvNzVQRW1na3p3SVVucEFTUHRBa0FlUjhhZHN5QzZRVU9SVGxnYWtCZEJHbStsR3prbTliQSt1dnNEQW4zQTFkTVRnclQ2c2dKNi9qUWUvSTdQTkYxTUFvMnU0aVFlRlE3S2YvcDl3L1d2TjdrU295Z3RqS2taWjlVN3V2V3ArYkNZQUFjYmpueUZSVmR3UitjUGNhWVVCZ0FNeDY0MCtOSFVSNnA4cTFyMGZDdGFCdGdzTmh5Z0x1UTJzak1vNG1ORHJ1cktrMmRqY010dFJjdFptRXljb002bmpQVldVQ0ROVVROVWEzSzFacW9uUzVVcHhWQTU2MUwwQnB2MTZSSW9GV3B2czVrQkJ1VGxHK0FEN2p2b0ZXVVR1bnY4QStLc095OE1tR3k0aThWRERwSmJoU2RSb1dERGZyUFlZT3NSWHQvRVdRNStTMldaenVKVTVVKzZHSmp2SnFmQmJPdkFsM1N6ZFk3K2RUbkI0U2RQQ29wZnRYbEExOGtzV2dtY29KbHUxMjNuKzRpbDJFdVhDNGtRcEJFRGNKM2UrS3ZHSFFxSU9BdzdEcVUrUzNRUVBDaUJkd3Y4QW03T3ZXKzIzbWI4TEZSL0xRY3krVGxueWpmckVDZDNkUlEyYVJ2MDc5UE9wY1V3dFlsWEU1VnVBNmpwWk0yc2d4cmw0YVYxREJXOE0zcTMwUGZ4L2x6Q3FPWjJ0bEhxb3Uxc3F1bXJzckRFNjh6UFgwVlB0ME5FcnlTdzc2ak1PMWJoYjNOSXFVY2cyMWh6YnlNT0h3TTBmaVVkbDZJaEdBTWdBbURydk5YVGw3eVNGdkJ0Y1JpM05sVEJVVERFS2RWZ2FTRHU0VXQ1Q2JOZkU0UU11UW0yelcyQllodElaZE1zZXF5OGVGS0tZbXo3cWlGZGdOZE5RTmV3VnRhT0p0K3FWOE5LdjJQMld5SFZZUDNrOGcwKzZsZUl3NEExZ25xMTE4YUNrWWk0eVhGdUVRd09Zamh2MUhjZGFzK0V4TnU0TmJRQjdERkpOczJiMXc2V2xFZFQ1akhlWThxSzJhWEZ0UVFRUnBIZHVQc2lxaDZsZ2ZSWjE5OVJ2ZnVBeG5CNzZXdmlqMW1oSHVtZDlSV3ZLSFpseTQzT0RLVEFCQU1aZ054MTQva0tyMTdDWEYzb1IvZlhWaWJFdDEwTGR2TVNDZUJCalNEMkdxaFhpcllTNHk2OUhvejFNSTh5Q1BHaDFiZ2QydmhQR2pidHNrc1NaekVrejFtb3pZRkJ2c3k4RnVoK0FCaWU3S04zR0tjdHRLZU5KSU5lQ2FCempRY3FzU2RSSkgzaWNnOWlsdkVVVFp2RTRPRHdkNDhkYVVQZXpLSk80RFR1VlYvMisrbkZ3SDVJakg2UlkrQU1EeXFCVmdEMGoxeFIxQVlQMXZBMGRRZWl0Q2E5bXRDYUIvc3k1ZkZwY2xrTXVzRWtDZWtaNDlkWlVPQTU3bTF5M1FxOEJsbUpKNHhYdEIxTGEzSVBacVJLS3BQVVc4Z2ZoVk81WThrc0xidGxyQ1BQQTdsOSt2dXJvWEtDSlhYalN6YjFyTlpianA4S2l1QXNhMW1wOFVrT3c2aWZPb2FxSkxJMXB0aExZWWhUdU5LN08rbStCOWRPOGVkQmRzTnNlNnFBcUZjUnVNZytkR1lhNWJINnhXdG51ekQyaXJqc0RCTHpTOGRCUnVKMmJiSTlVVktxdVlPM1pmMWJpdDRpanhzMGRuaFNqYU95TFdZOUFUMTd2S2dNaW9ZbTRuYzdSUVZEMHE3TTV2RUs0R2x4QWY0bDZKOTJYMjFaT1IreU1IaThGWnVQaDdaZkxrZGdNakZyWnlra3BCa3dENDB1NWQyT2N3NGZuQy9OdHgzZ1AwVHIzNWFwbXc5czQ2MnJZZkNNd0RNWElWUVdCZ0tUbUk2STBGVWRUeFBJdkNxc3JmdjRjRGlMM1I4ZWRCODZxVzFjVlpzSDVyYWd1bjZ2TWM0Zkc0akFDbCtINUg0ekZITmljUUZuNjdtOHcvaG5MNzZ0dXl2UnZnVTF1RzVlUDJteXIvS2tIMmswRmV4WEtObXN0YkY4dVhCVmdjeUNEb1JsWmo1MFhzSEphc2xFdVpjNWx3cjVaTzdXRE5YVzl5VXdETEh5V3lOSWxWeUgrWllQdnBOalBSM2hENmh2Vy91M0F3L3JCUHZvRWQ1b0J5dTQvallqK29rVlg4UnQwYWpuWjcwbjNpS2kybnNMbXNhdUZ2M1N0c2taYm1ucXRPUWtFd05SbFBhRFR6R2Y0WlpBVkxLM0dIWm1udkxiL0FIMEZaWGE5MXpsdG9HYUNZZ3pBRXpFOVd0YWJJd2o0aTZiYjNtdDZGdFFTREJFZ0NRQnZxYmJ1TVpyeVloVTVrZ0FDU0JPWFNZUFlZM2JvcDNzNnhrZ3MyWmpxU1BMdXFoZ2VUdHFGQzNMZ2dBYjFPNFJycFVGN2swUU9qZEhjVWozZy9DbWxtS3pFWGlCVUZWeG16YmlmVmJ1SitJRks3aFliMVBuNVZZOFppNlRYNzA4S0lXUGM3S2pMVVk3R3RzTmgxWTYxUUJtcnlqOFJoRURRSzArU0RnYWdDcTFiUzB3ZUdIN09mYVNhUUhCSGhGV0RiQ1pjTGhnZDR0TFFWL0NldjRHalNhRHdxbk5QQ0RSWm9NQnJXYTlGYVVCMkdTM2xHWmlEcklEUng2b3JLanNNbVVTaEoxMWp0cktCdHRIbGZpcmhub2lEMjFPdkxlNlVLdXZEZUROWldWWUtmaTJ6TXpkWm1oU2F5c29Kc1B2cHZaRUVIdEZaV1ZCM1hremNteXZjS094V0pnVmxaV1ZWbkhYQ1dvREUyODIrc3JLb0F4K0NEMjN0L1dVanhqUSsydWRjbU1SeldNdDlUazIyN24wSDlXWDJWbFpWSFVma1FQRDN4V05oR1VFaTRRQjQxbFpVQ0xGOHNsdE5sREY0K3pBOSt0UXZ5dnZYdWphaE9zOVhuN2hXVmxVVmJsTXJzd0x1Ymo3cDNSdUlBblhpZXFnZmxUZ2RHRjdRQUQ3ZDlaV1ZVYUF0Y0lEbVJNMDlzdnVyS3lnZFlGcEZFWHJKSXJ5c3FLVTRyQ1VCZHc5WldVQWoyNml5VmxaUkdaYTN5VmxaUWJLS2I4b3YxRmo5MHZsV1ZsQW13aCtiUGY4QWxYaHJLeWc4RmExbFpRSEpmYUIwVHVHNXlvZ0RUUUdzckt5Zy85az1cIixcclxuICAgICAgICAgICAgfSx7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJCZWxhcXZhXCIsXHJcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZTogXCJHZW50bGVtZW4gZml0bmVzc1wiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCJodHRwczovL3d3dy5iZWxhcXZhLmNvbS9kYXRhX2ZpbGVzL2dhbGxlcnkvZ3JvdXAtZml0bmVzcy85L2dyb3VwLWZpdG5lc3MtaW1hZ2UtY2xhc2UtcmVhbHJ5ZGVyLWJlbGFxdmEuanBnP2NhY2hlPTE1NjQ2NDgyOTBcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCJodHRwczovL3d3dy5iZWxhcXZhLmNvbS9kYXRhX2ZpbGVzL2dhbGxlcnkvZ3JvdXAtZml0bmVzcy85L2dyb3VwLWZpdG5lc3MtaW1hZ2UtY2xhc2UtcmVhbHJ5ZGVyLWJlbGFxdmEuanBnP2NhY2hlPTE1NjQ2NDgyOTBcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgfSwsXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogXCJDaXJjdWl0ZSB0dXJpc3RpY2VcIixcclxuICAgICAgICBjbGFzczogXCJjaXJjdWl0ZVwiLFxyXG4gICAgICAgIGl0ZW1zOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIlR1ciBQcml2YXQgQnJhyJlvdlwiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiVHJhbnNmZXIgQnVjdXJlyJl0aSBCcmHImW92XCIsXHJcbiAgICAgICAgICAgICAgICBsaW5rOiBcIi9cIixcclxuICAgICAgICAgICAgICAgIGltYWdlOiBcImh0dHBzOi8vd3d3LnJlbnRjYXJ3aXRoZHJpdmVyLnJvL3dwLWNvbnRlbnQvZ2FsbGVyeS9icmFzb3Z2dnYvQ2lyY3VpdC1UdXJpc3RpYy1CcmFzb3YuanBnXCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiaHR0cHM6Ly93d3cucmVudGNhcndpdGhkcml2ZXIucm8vd3AtY29udGVudC9nYWxsZXJ5L2JyYXNvdnZ2di9DaXJjdWl0LVR1cmlzdGljLUJyYXNvdi5qcGdcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgXHJcbiAgICAgICAgXSxcclxuICAgIH0sXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgIHtcclxuICAgICAgICBuYW1lOiBcIkJlbnppbmFyaVwiLFxyXG4gICAgICAgIGNsYXNzOiBcImJlbnppbmFyaVwiLFxyXG4gICAgICAgIGl0ZW1zOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIlNvY2FyIEJyYciZb3ZcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIkJlbnppbmFyaWVcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL1wiLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiaHR0cHM6Ly9zdG9yYWdlMC5kbXMubXBpbnRlcmFjdGl2LnJvL21lZGlhLzEvMTQ4MS8yMTMzMC8xNjk0NTgzOS8xL3BvemEtMi5qcGdcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCJodHRwczovL3N0b3JhZ2UwLmRtcy5tcGludGVyYWN0aXYucm8vbWVkaWEvMS8xNDgxLzIxMzMwLzE2OTQ1ODM5LzEvcG96YS0yLmpwZ1wiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICBcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuXHJcblxyXG5cclxuICAgIFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6IFwiQ3VsdHVyxIMgyJlpIGRpdmVydGlzbWVudFwiLFxyXG4gICAgICAgIGNsYXNzOiBcImN1bHR1cmFcIixcclxuICAgICAgICBpdGVtczogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJNdXpldWwgQ2l2aWxpemF0aWVpIFVyYmFuZVwiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiTXV6ZXVcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL1wiLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndDRUFBa0dCeE1TRWhVU0V4TVdGaFVXRnhvWUdCY1ZGeGNiR3hnWUdCb1lHQmtkRnhnWUhTZ2dHQm9sR3gwWElqRWhKU2t0TGk0dUdCOHpPRE10TnlndExpc0JDZ29LRGcwT0doQVFHaTBsSUNVdExTMHRMUzh0TFMwdExTMHRMUzB0TFMwckt5MHRMUzB0TFMwdExTMHRMUzByTFMwdExTMHRMUzB0TFMwdExTMHRMZi9BQUJFSUFLSUJPQU1CSWdBQ0VRRURFUUgveEFBY0FBQUJCUUVCQVFBQUFBQUFBQUFBQUFBQUFRSURCQVVHQndqL3hBQkZFQUFCQWdNRkJRVUdBd1lFQlFVQUFBQUJBaEVBQXlFRUJSSXhRU0pSWVhHQkJoT1JvY0V5UXJIUjRmQWpVbklIRkdLQ292RXprckxDRlJaVDB1SWtORU5Fay8vRUFCa0JBUUVCQVFFQkFBQUFBQUFBQUFBQUFBQUJBZ01FQmYvRUFDWVJBUUVBQWdJQ0FnSUNBZ01BQUFBQUFBQUJBaEVTSVFNeFFWRVRZU0xCY1lFRUZETC8yZ0FNQXdFQUFoRURFUUEvQU8rUW1Ka3BoRUppZENZOURrUktZbFNtRlNtSkVwaUJBbUhCTVBDWWNFeEEwQ0hnUW9FT0FnRUFoNEVLQkRnSWlrQWh3RUtCQ3RBSTBMQ3dSRkVMQkN4QWtMQkJBRUVFRVJSQkJCQUVFRUVBUVFRUUJCQkJBRUVFRUFRUVFRQkJCQkFFRUVFQVFRUVFCQkJCQWNYWWUwRm5tZXpNSFVHTmVUTlNvT0ZBamdSSGdLWjZrbHdwUU85OXpmU0xVbThwd3lXb0JtejRORDhzYS9HOTdRUTdPSGlWS1k4V3VxLzFKVU84R0pOWFlsNjZ1K2J0NFIwVXJ0TkxVMzRzMUg2aVNCVU0yRjZlMTVSZWNUaFhwWUVLQkhtcy90Wk5EcGxyQzZCbEVxQnFBVHF4WTBxMGRIZFhhRmFVQXpzSkRPNHpablVkY1RPM0dKZkxqUGF6eFpWMUlFUEFpS3gybEUxSVdoVHBQM1VhR0xBRWJjOUVBaHdFS0JDeEFrTEJCQlJCQ3dSQVFRUVJGRUVFRUFRUVFRQkJCQkFFRUVFQVFRUVFCQkJCQUVFRUVBUVFRUUJCREphM0tzcUZxYVVCcnhyRDRBZ2dnZ0NDQ0NBSUlaTm5KUUhVb0pEZ09vZ0J5V0FycVRTRWdQbVF1Mm05NEpRaUt6a29lV29WUWNQRnN3ZkQ0UmJVb2FOWEtrY1BUMGUwc3BEMWkzTGxlUDNxSXIyYm5YUHBGcENzS3N1T3BIUWI0emJXcEZ1VktMZmROT2thZGlWUUE2VSsvR001RXl0Q0dmTi91c2FkbVd6T1BySExLdXVNYnR6WDJxUTRDWHE1NnR1em9CNHgzVjAzckxucEJTYTZnL2RZOHZRTkJ4ZUo3QmJGSUl3a2hRTkkzNC9KY1dQSjQ1azlaZ2ptN3E3U1l0bVovbUhxSTZLWE1DZzZTQ09FZW5IT1plbmx5d3VQczZDQ0NOTUNDQ0F3VWlWUGw5dEN4aldIdEZaRkxXaE5xUXBXTTBVcElHUW9nMENrOGF4c0pJSWNWRzhRTExQWllJSWpUT0JXcEZYU0VrMExNckV6SEkreWNzcWI0Q1NDQ0NBSUlJSUFnZ2dnQ0d5eTRmaWZJa1JVdnE4VTJhUk1ucXlRa2x0NXlTT3BZZFk4S3NsOFdpV3RVeEUrYWhaVVZLd3FvU3FwZEoyVFVuTVJMZE5ZNDdmUVVFZVJXRDlwVnNsVW5TNWM5TzhmaHE4UTZUL2xFZFRkbjdUTEZNWVRDdVFvL3dEVVM2Zjg2WEE2dENXSmNiSFl6VnMxSGNnZU1QamplMnZhUUNSTEZsbkpLcGluQzVha3F3cFF4ZlVaNFF4NHh5OWcvYWhhSktzRnFrcG1nZS9MMkZOdlk3S3VqUTVUZWw0WFczclVFYzVjbmJleFdsZ21iM2F6N2s3WVBJRTdKNkV4c1h0ZUtMUEpYUG1Ga0lTVmM5d0hNc09zVm5UbXV4ZDg5OWFyd2wxcFB4cGZjd2tsdVhkcC93QTBkaEhoUFpYdFlpeVdvVGxsMExCVE5aeVFsWnhGUUF6WWgraEVlNXlab1dsSzBsMHFBVUR2QkRnK0VTWGJXY2t2UjhFRUVWa1FRUlZ2VzNDUkptVGxBa1MwbFJBWnlCVXM5SURpL3dCcWx1Q3JDaERmNDB6TCtGT0kvd0RiNHdSd3ZiYnRaTG55N0VBUnNTV1VrS0NtVml3S2NqZ2grc0Vjc3U2N1k2MDVlZE1Mb25ObXlDUnIrVW5jZER6aWRhaHU4OHZsRzFiTHNTdVU0QUdOSVNTTXNRWmxBYUVGaHdjUmlXTWxRMnN4c2tGMnhDbW5qeWpudVdiYmtzNlBRcXU2THNpMEFGamx2aUZObHhCd2VtWStjVGQwek9Ib0RUUGNhYzk4UzJWdVNyc21Zbk1GczhzenppOUtEYXVNeHVEUmxCVzBDY3NtSVl4cDJSUWJaTEd1ZXUrT2VVYnhXQk00OVdvWUZUZDdmZkdGTTBHaFR4ZlRkVGhFMGxDTXpTdXRSa3pjbmVNeTZXeTFOWnJXUVkxN0hlcTBGMHFJQnFRRGwwakFuVEs0Z3pNd2JLb2ZMbTVpeFo3UUN6NkNqZXNiL2NaL1ZkcEk3VW4za1B5cEhRV0MySm1veHA1TnVNZWJLbTZ1OVByRExaMnVtV1IweTAvaUtBSUV6MkNEa3VocjVWZU9tSGx5MzI1WmVLWDA5QnY2L3BGamw5NVBYaEh1cEZWTE81Q2N5ZklhdEhrUGFMdG5hTHdWM1lCbFdjNXlrbmFVTjgxUTlwL3lEWnJYRlF4aFd1Zk10RTN2Wjh3ekpxeXdmZzlFcEZBa1ZvS2ZHSk1HR21lOHh2UFA2YThYaWs3cTVMa2drREM1SkFBQXE1b0FBQS9JUnFoTm9zaThLVnpKU21CWUtJekZLWkg2R05EOW1KbGQ1TUNoK09Fa29VU1RzYWhJUHNrVVBFSGhHdjJvay84QXBWcW1IdkZJbWdTMWxzUVNzSlVRU0djWmpvRG1JNWNMcmUzWDgwNThkS2xnN2JXcERCZUNhUDRneXZGTGZBeFd2Sy9wa3hSbXlKa3l6VDgzU1F1V3NhQ2FoUVlqUUZpUnB1akI3NEFmWitzZERjbHdLbUlNMmVlNFFUaFFGamJLalJKVU1rSkpJenFYYWtNYzgvaGZKNC9GTzcwYmQvN1VwOGtoRnRzd1ZSKzhrS0FjY0VLSkJQOEFNT1VkbmMvYmV3MmxnaWVsQ2o3azM4TlQ3dHFpdWhNZVkzN2QrRmZkVHhoWXNTTkh5VU40eVBFY2NzQzlidFZabGlYT0FxSFNRWENrNU9JNjQrUzZlYlB4U1hwOUhqZkJIaHZaSmM4S0FsV2hja1ZJRHF3TFlPd0JPQlNpeHBubkhZWEQydG55cDB5UmFVR2J0a0tYS1NNUVVOa3VFZ0JZWlBPbXVVZEptNWZqdnc5Q2hxMWhJSkpZQU9TY2dCbVRFUXRhVlN6TlFvS1RoSkJCcFI2SGRXaDNSaDNwZjhxWEluS1V0aXNoTXBKTGxTcGtxV1U0VTVzNnE3cW1OTVNPVC9hcmZtS1lteHBVeVVNdVl4elVYd3A2Q3ZVYm84N25UU0NlQjlhK1Rud2hiYmE1aTVreGFxclVwUldTemxUMW9CbFNHWG9oUW5MR2o3bnpUWFhjL2dZeGU2N1RxYVhWQ2hCekcrS1V5U054OWZBdzY4Snk1YzFhVXRtK3VvSHFZbW5UR21xU1JVUzhWTlJnQ3VsSXliWmMxTFZUUlFxRzRjbzA1YXhQUUNmYUVWaXBDa2xRMElIaTdSQ0Y5MHBLaGtvZXBIcEN4WlZwSURNb1Y0KzhNdkVSS3VhdFV2dUZMVVpUaFFRVkVwQkRnTUhwUW5LR1dnNUVNRkRSOTNEVVEyVXNISmh2RDVRaG82ejJKQVVtbnZENC9VNXg3TDJEdFE3aWNxWk9Lc0V6YVZNbUZXRkFRaG5LanNpaXZBNnZIanE3VWxHMG9zeDZua05ZeTd3dlpjMHFxVXBVQUNrRXNRRGlHUDhBTldzV1h0bktSNmxmMzdYa1M1aFJacEltcEZPOFdvcEJQOEtRSEtlTkhqbkxYKzE2M0s5aEVoSDhxbEgrcFVlZktNUktWR3RzNmpxYmIrMFc4cG1kcVVuOUNVcDh3SGptN2RlMCtjWG16cGt6OWExSHlKaXFveEVxQWptS2hZWXFDQTlibEtCbG1Va2c0S0hJQXFLTVFxS0pCeE0rOFBwSE5LeEluQnd4bWUxdUttRFU0aHpEYkRhSnB4eWtyVGkxd3BLZ3RLVVlTU1EyOU5XYmFlaEVUWHZaTFF0SVhqbHJZaG1HRm1ZaW9CR2ZySGx3bXBxMTZjcnU3a1daNmk1MldiMTFFV0FzTVM1eGIzWmhuOEk1M3Y1eWs0amhKTzRzM0E1VmY3M1dMRE9tdUJnT1JPSUtUUnFaTzVyOEl0OGZTenlkdGFTbmF3amFjTzdrVXJuRTVra0FVYW12aEZWU1VsUVVsUlNhQlFJYXV1WHJHcDNpUWtPQVdhdTRjTjBZeXJjaEJNRE1YRk9GUHVrWE8rWTVhMVB6R1JFVVpFN0ZpbzQzQlB1OHhGMnlXUmMwRVNrNGlTQ0dZTlhVNURYV0p4MmN0Uk9VZzBBRmFQVFRSdkN1Y1FUV2xrVkRINHhad0psRk12dlJNbXFXRTBBVWdLb0dVVkpPTm5HeUdqTXRsclJobkl0VXJDdkVnb1FoUXhZMlc3bXJKQUl6M2pPa2RKaFl4YzVXcXV4cW1TbGpFRURCTG1TNXRRR0lVVkJaeU5BQTM4VDZSVXQ5N2Q1SmxXYVVoTXlaM2FBdGVFSEN5VWdoQUlwem8ybGNxS1V6cHlFUzVxOEVsS1VnSTFWaHljTTVMMTZqYzhkRmR0M0ZLV1FuQW5mbXMvSStZamRzeGMrNno3bzdPaEdMdnBoQm1BQlFTWGV1eTlDN0YybzFUR292c2pLTlVURy9WcDVpTml3MlJLYXRYZVM1Nm1Ob29CNE5tNCtjYytWdFh1ZXE0Yi9sU2NnNDVVeGxESlNTeEhJZ0Q0dzI4SlY0S2xtVk5LbG9KQnFBUzR5T0lBbnpqdUUyVUdvQTUvVk1PTWdqVTlTRDVHTmJKbFhrdG9zYS9aVWs1Ym5QbEhZWEIyaFIrN0d6V2xZQ2hzcFVRcXFXMmNUQjNGS3R1MWVPb1hJSkcwQWYxSitWSXBUcm5sTG9aUS9sTGVWSVM2OUdXZkxxeHhQYTZlbVphcHFrcXhKVmh3a096WUVpblY0d3I3dHBWSmxoWkpTZ2lWTUFEa3lpZGtnYndNU2N2eTc0OUJ0SFphU2NzU2VZY2YweGtXL3Nsc2tZZ1ExUTR5L1NXK01XZTJzczVaSjlDK2J1a3lyRXVXa0JTRU1vTEM5dkVGSVR0SENRQ3g0MERNTktOMVhaM2Rubkx4bE0wQlFRdkRpUVVnRXFUTUl4QlFVbHdRek1NakZXN3V6azJZQlowVEVwd3BYaG1GSkNzS0ZvU0VxS0RrWDBMRUEwb1kzSlBabTNva3FsZDlLV0RpY09vQldJTUFYUTZXY2paVUtOSFhqZnB3M1BXMURzL2JMYTFvbklWUlNWcldrZ0ZFMHJyc0FFYlpEa01BY2djMml2ZGRuRnNWTG1xS1N1VWhJSlZzZ0JCWUVwU0hmQ00zRDRUUXhzV0tUYjVFa1MxV1lLQ1RoR0ZibkRocVFvS1VWYWpDVWpTc1oxeVd2OTFrNFp5Rm9DaXloTWxxQVV5QUJqRGxTS2dWTk5vMU9rc3ErMHlMbWxCaVZwZFRzQUVWWnhRckJLbUdvMzZQRWRwc3Nzb21sQ2xxU3hZNGluSk81SkF6ZUNlbnZDSjZFZ3k5a0JTV0tVbkVLQ3JwekdZRVg3MW5KVUpwU1gyRG9meUFheHl1MWpOWElsbVkySTF5QlV6c0E0Q1RwcmxDVHJtUXBhc0NnZnd5N3BhbUFnOGNtejZOREw5VUYyeENob0pma0R2cjR4c1d5ZEtWTURqWXdNdkVObWdCeXFHeXAxMWVOSTRxZDJkVUpVMElCYlpVNFlzMkxRczNMaEdYZWQwekV5NVlhb0NuZW1hbkhMWHdqcnJvUmlzOHgxRWxKVmhybjdWS210UElSTGVLajNVcVlvc2phY0VBTmlMMTRONjV2RzVhamg3ZEtVSnltQkxHaEZmWFBsNVExVnBDVTdRT002RFQ5UWFqN2g1UkplMTVvV2NNdElZZStSVTUreURVQ01sSWY3KzNpaDB5WXBaMUpEWkRmeWhreEtrcXdxQkJaMklZMWZTSFM1ekltSUFQNG1FRWdzUUVIRUdOYzRrdENsVENGRkpvbEtLQWx3a01IT3BnZGFWSGdzOG5IamRXRUlUaUpJSllDaG9NNHRTN3VuS3lscVBTSnBkeldrWklVbDZPU0JUakRaR2RhSlFDWmEwcXhKWGlZc1I3SkFMZzhZckxSWGRHM011SzBLYkVVMC9OTWRvZU96U3ZlbUlUMEo5SWNwOXJ4dDlSenhTMEVkSU96eVJuTlA4bytjRU9jWGhsOU9pdXl6SVJPMlZKb1V5aUFVdVZZSFlWYXBBY2FrQVZhTm0wcHhJSjdwS2x1MjB6dlE0VHMwVUFRR0IzMGpuYjA3SmxJSzVTaVV1K0EwSUZEUlQxSUl6WjJHK0hXWHRPVUJwb1hpRHFUTURQa3pURXFZS0pLbWZPc2NjZFdibGF6M0wzRzVZTHVsTURNa3kwazV1SHpjMUFGU3o2MStPVDJqdFlUTUVxV0VqdXdwOEl3KzNoSURVSUxEd1VJanQzYWNwUyswRjU0bDRIQ3NLVTdDQTZRUlN1b0JEUmtybUxtSjd3eXlrQnRvdVZPYWtrNmc1dVhQTEtPa24yeHY2TlRlQkRnNWNRRHhpMGkxTzJUY1BscEdZdW5FR0w5aHNDcHFrSWxKSzFuUkdiYXVTR0RiOG92Q0V5cnFrckV1UWxhVHRLMnlWVVNtV0VGUkoycTZFazZSVVYybW16cENVcElseTYvNGFPN3hES29xd1ByV0wxL0tFdVVKY3dwU28wN3R3UzdWNE1tZ0I0QnVOT3czU1pnY2wwaW5DbEhPOCtBR2dpU1NMdTVlMDAyMWdGY3V5ZXdabVB2bGdNbFZQOElOd0ZjeXdpUzdMbUNUaUFKVm1WcnFwem13T1JKMVZXc2FOa3N5VXBCek9FbndiTGRucFNMS3lYV05NTXo0SmFtdXNadmJSTFBZa0JZMVVDSEpxV0lWcjhvMUxCTWRPUURFaGh3TVp0bU8xL0xMK0NvdlhjZ3BTeERiUitNWnMvbzJtdVJaTXNPU1RpVm1YUHRHTiswajhOZjZGZjZUR0hkc2dvUUVrdVhKMTFQR042WXhCU1NBNElxUnFHaVgvd0JId3diblEwMUd5eE9McDdRYklmWmk5ZlU1YVZJd0tVbWxXeU9idUdOV2lXeDNjbENrcVNUc3ZTbFhmZHppYTMyTXJJSUxNR3IxK2NkYlp5YzlYaUpGcFYrN2lZN3F3NWtOcVJVQm9aZE50TTF3b0pvQWRrblhtUzBTeTdPb1NSTHpJR21YdEUvQ0dYWFpsSUtzUUFkS1JUaDFqUFdxdmU0bXQ4OU10SVVvRXVXb0hhaEw1aWxJeXI5U0psbVdwTCt5VFdoMlM1K0VhTjlTc1NFaGlkc0dqNU1yZEZLY2tpeXFHZ1F0d29FblU1dkdkVGp0ZC95MHcreVpUMzVDVkZzQ2hoTGIwa0ZJVFJpTkhpSyt1MGN6dnlpV2NLVVlnNEkybUthL0dHZGs1aWphWmJxZE9HYXpIS3N1aERCdm5paExEY1luV2NLd3BFeGF5dkVhSERqQUxIVUZEbHNuYm5IcXh2OEFGejEyMnJCMmxRY1dPakJ3ZC9BN2xlVWFGMTNtbWVLVUxPVThENlJ6MHk3VXBuU3hJVGh3WWdweWE3TGdrdFZWVDQ4b3B5a3piUGFrbFRzVFU1dUt2bHB6NXhkcndkZmFMcGtMQlNxVWhqbXd3dlVHcFN4ekFQUVJRbmRuSlJCQ1ZMRGdqUEZvM3ZWUGpHNFREQ3FGeGw5c2JzY0pmMXdLbGtUKzhTUWtwQkJHRTEyUXdCSXpJMTBNUTJ1YUIzZThLTHUyUndoMmJLbkhLTlh0M2FtbEJJUHZKOGxmVVJ5OTVUR3dyQXlPN05sQTUra2NjOFpMMDNLdFhTQVZ6UWFnVHByTXhCOXBtY2NtaUc4YkVpY3FTRmpHSnFVcFNrS1VnT0VyVzV5QkdiT2FQNFJXWEEweVdrZ3BWTXdBMG9DaHptR28vREtzWTF6cG56TFdpYXFzdVc0RzBHWVN5Z0VCMnJRMDNtSTFQYnAwOWo1WU9IOTNRK2JLV0NXM3RpaVpQWmhLQ0VpVkpRVlpCczI1Q09sdFNnYlNNaThzL0ZVUlhpZng1UDZsZjdmbkhQWFh0MzYzSnFlbUxLdUxhVWdHVUNsZ1FFbWoxSHVoNGp0VjNDV1dWTkljT3lVa2hxalZRM0dOMnkvKzRuRGlqL1RHWGY4QVZhY05kak1WOTVXNkhHYTJ1TjNueCtORW1kbjBnT1ppam5rQU1nK3NVTEhZSk14UlQrSlFQVlNkNEc3akhUV21jQUFLbkU0b0NXcHJ1RVlOenkxSldTVXFBd0hNSGVtTGNZemhsbGNjclVONlhiS2xKY0l4VkFxVHFDZE9VTXZleXk1T0hETFRVbDhUbkp1TVhyOFNWeTJTa3ZpQnkwd3ErY1Y3K1JqQ2NOV0plb0c3ZkVzbStsd3l0azNUNWxqbHBka0lvZHc0K2NKRWs2Mm9ydERQZU9QR0ZqcDA4LzhBTm1KdkZLcFVwUjJUT0RKR2JuQ1ZONEF4VHRjbVd0Q0JNQ1M0U2x6bU1SQUZjeFdNR1pPT0N4RDhpMUgrdFBvVENXVzFvQkFuWWlqdkZrNFQrVXBXbnpKanpZWWZUMTVaZmJTRnp5VUVFS1NPT0VHaDBmRTRpeFlWSmt5c1BleTFTbm9Da0ErMlJVNHo1Z0RqRU42Vyt5cFQrR1ZmbEw0aWtaTjdRZDQ1K1ZiVWxKUXQwb0txS1ZsbStibWo4ZFIwN3liM05PR1Y5VnVTT3ozZmttU1VxUUZWSk5CcXpKNWthWkRmR3pLdkg5MFIzZGprcWNnWTUwMU8wdGg3b1d6cEZXYW00VmN6M1JiWmNwQVNtbEVrNGFoOXJDZW9PVVpGc3Q2WjR4eXlsYVVNQ0hLRGpvS2xhUlNvNFZPc2F1MlduZkE3eVJMV3lUTUtUakpBeERFbkVYWWIzcG84V0xwa0ZNb3BkMmZMZWNKUHJISTJtOHBrbVdnTGxuRE9Dc0FDMHV3REtKYkVLRTVibXFHTVZwZDlUMEtzb1JNV2xFeGUybWhDZ0pyRVZEcExVNkNOZkREME9US09BT1dkSjRaZ2IrVVBBUTVMdVMrUUp6WitHa1p5YmNrYklTNUFyU3Babnp6ejN3KzBYaTJNQVZTbFpyazZBZzZGMk9NZUJqanpkZUswbThVS21kMGd1cEtoaVQrV2hJY2FVYUhkbkxRdFVoSmVycXFhazdhczNqbnhhWm9NeGVNdWtLS0hKSUd3Q0hTVGhOWDBpYnM5YVZoTmxBVXlWTG5oWVlNcGdzalJ3eEdrYXkzTWIvcit6R3l1M2txT3BlTnN5d2N3RHpqbUxITUpXdHlXRE5IVGd4dzN0dldpQ1VnNko4b2tUWjA2RHdKankzdEJaa2Z2Tm9KU2x6TU5TbitFYXgxZCt6QUxIWnFrT1pZR0hNbnVsTUJVZllqZU9PN0l6YjA2YWJMWUdxc2o3eDNjNDV2c1E2aE0ybE1BamQvSHdpTzBxVW03YlJoV3ZFSFpSZEtoN0hFa2JzNHEvczhuRXpKaWNSSUVzVWVqOTR2VGUzeGowVEhqNDgvOHhuNWp0U2hYNXZFRDBhTTYrU29TbGc0U01DdENORHJWakhPOXZMOW1JVjNVc3FTRWdGYWtGbEVxcUE3Z2dNeG9hdkZMc3BmNjVvWEltS1dvRkNpZ3Jxb0ZMdWtra2tobk5jbThQSFBKT1duVytPNjJXNWJRVUpsbFEydG9LS1gzS0p3OE5jOU5ZNmFSYWtzakMyRlNSaGJMZUFPa2VkcnZIOGRNc0V1bFJyWFZCVTQ2Tkd6YWJXc2hCREdYamFZS3VrWnVubWRkQ2VNZlN3eDNoMDhmS1M5dW5BY2Q0b05nV1E3bW9QdFpaaDI4SXlyMWxFcWw0U1ZZQVMrWk9ROG56K0x4TlpyZXdFbzZGWVVWRjhURUYyT2hBUGpHTGZ0OGhLbUJJcUtqVnQyNERkeDV4ZURwaG4yZExuakNDSmlBYVp1Tk40ekx3NUZxbXZTZUNOM2VINEdNdkd3RzBrQ252OE4ybndpdXEwRUt6SGtZOGR2VDdmNDlyWGFLWXRVcFNsS0tsSlduTGlRK1Fya1B2S3BiWmoyZFljQWhTZWRWWnhRdlRhVUUwcW11TExNNXZ5aXBiWmFFMmRUaEpVNlNjalRFa1pqcS93QlkzTzVIeXY4QWthbWRrYVlVcEtnbHlTd0l6ZXBPWEJxYWFSUFlGaEUyWTFFZ3FZTUN4QUxiSno1UnpobVNnRUhDRW5nTXhpSmpWc3R0QUpSaUJRY1lLV0ZNaXFwYXRjbm80M3hkVytuR1diN2RpdTNMek15b0RQM1NQaVZSQXUzcS93Q29xbjhLQjZ4Rlo1aVpoREZ3dzBBQjRrZ25Randndkd5R1Vzb1dVdlFnb3FHVmlZSEtvd25MZkhDYitZOS84TnlGTnVWWGJtZENCNlFodHAvTk4vOEEwLzhBR0tnclJKZFJVbEl4QU1NV3VyL1dFOW5FbVlRVklWZ0pRQXhaS0ZPMm50TjBpcHZIbHhQbld3RE5VenF2NUppR3pXdE0wa0pxd2ZhVVJSbjNDdkQ2UlBObEtDZThDazRRckNVTUhLV0Rrbk9yK2NWNWlFYlFZbkNGSFN1RUV0bHF6ZFkxTE5mdEpaYi9BSVVyUmVFc1BRYS9uT1hJd3o5OVFja2p3bWVwaXRkVnVWTlhNUXNJMlVrN0FVa2hpQTIwUzRyenBGeFJUdVArWWY4QWJHc3VQcVJNYkwyaU04RVVTbndQcVlXTHhzaVRqL0VDU2dzRXZtQ1NCc3N4eTEzVmdqTG5mTGp2MDVLMDJpa29BRXNUNEVndjQvQ0lKOVVpbFhVYyttN2dJbHZJdE5RUDRRZjZsZktFc2RrWE1DY0EwWW5ka3haNjZ4WmhIRzUycXN5YXJ6NHU3YnRkWWVMdklDMUtDeFFLWmxEMlFhQjh6eWpwTERkS0pPMFJpVWMxSGp1M0NJNWlpdFJ6M2RLNjlENVIxa2tadHRjelpiNnRBRG9VcGtwU29oZ2RuRW9VM2hpbGdmeTZETkxIYTVrcFNVcW16Rm1Za0VNU3dCT2U4cVlQbDFqcFpWeklDQ2dlOUxFdXA5MFlteTFxWVdUY1JRVUxsbmFscG1CSVVTUTZ4UVBtbElQUFdOSTVxM3o1czBTa3BLaVpRd0JpTWtza0hBbXFTeExrczc4SW10dDIycVhJbFRGU3Bnd0tWdGtMOW9xQlNTVkpGWEdZSkhHclEzczVZVnk3ZUU0VjRYV2wxZ2pFR0lCY2lycUFNZHhaNzNtV2hjNnlxbGdKa2tiVGs0OFZSaUJwdVBTRmhLNWk1ci9uRzBoSzJVaFRweVp0bkVrOHd3SFdOMitMZDNkb2twQXhKbUNjcVp3UUphYURjNVNLOE9NV0pseXBPU1FPSStVVkxmMmZLMkxZbEpCd3VTL0ozeWVNZmp4WGxVUFp1ODAyb2JRWWtrRVBtTUl5TERRdEhXV2F5eXdVWVEyQWtwQW9IVUNDYVp1NWprTHQ3UDJpVVFVb3FsNmFGeDk2eHZ5ZjNuV1IvVTN6aVplT1pmSmpseG5wdTJKTFRaaW5PMWgxM1BsdWpyVE1BcVN3M21PRnM0bXVDWkpmOVNmVWlORzlGekowdGN2dWxERUdmRWlsUWZ6UnluaC9iZDhqVm0zRFpaeWxUQ25FVkVrbE14YkVqWlBzcWJSdWtYNTEzUzF5MHlsQTRFTmhEbW1FWVJYTTBqa3V4bGx0RmtzcVpLMGhhZ3BhaXBTeTV4cktxc0ZWcldzYm90YzhrVWxBYWpFb3Z5T0VONXhxZVA4QWFjLzB2LzhBQ3BYY3FrTWU3WG1IUERYUFFSSGRGeFNMTVZLbEpJS2d4ZFJOSGZXSURPbkgzcFkvbFVmVVJSc04yekphOFl0TXd1UzZWRlNrMTRLV1diVGRGNFhXdHB6L0FFNW50NU5INzFNQkIvOEFqTk1MK3lsbWNIV00zc3BPSGZKYjhzNy9BRUxqMEswV05Td1FxWWE1bEtFQXR6SUppc0xxU0U0TzhtbE5mZVM5YzY0WGpqLzErL2Z6dDEvUDFyWHhwNTNhclVrS1JOQURrdStITVlUUlIzMUE2eHMzUGF6TU9PV2dsQWNGeWtPQTRabjUxamVIWSt5L2tXZWN4Zmt4RFJiczNaeVJMVGhRaFNVblFUSmpWZjhBaTRueGoyNCtUTEdhankzR1Z5RjYzNmtMSlNpWTB1aXFKTEVBSTJpQ3pPTmVFWTEyMjVFNjBvTEFnRU1sZFFTN1ZHdkg2eDZUTDdQV1lZbWxJMndRdDY0d2FIRy90UHhlRmwzQlowK3pJbERsTFI4b2ZreVdSekZndjBDMHpaSmxvQkJ3RWxRU0NRQW9IQ0VGaXhqTS93Q1lCYVVURllVb1VnVVFGWXNSZG1mQ1BoSG9Zc0NBS0lTQndTQjZRdmNEN2FNN3JmS3ZIck1pWlBtbEV5WE5sZ2dzVXBWb1hHMFV0Vmg0eG8yeTVaa21UTndJQ3NzSlhWUnFNamlBRlR1OTNuSHB4c3dpTmRrVHFQSVE3U3ZLcG5aSkRBSzd6WkJxa3FjN2dRQ3pEZ0JFZ3VYdW1NdkdyL0VmR2xSTzJsQWRKYlpPeUs4NDlOVlkwblFlVVFxdTlKMEk1RXdsMVV2YmxidHNZWEpVa3F3RlNDajlPeUE5YTA1dyt4M1dKU0Y0NTVtT3luT0lrQklMZ1lsS05jMmZONDZCZDNON3g2eFhuV0J3Umlkd3pQNnhMSldwbmxOZHNBeWtXaVNydVorRnlsbHRrUXluU0hHK0gzZGRCbG9LVlRqTUpXVllpS2wwb1N4ZFJmMlkwcE4wSmxwWkNNS1hmWkFBZkxKTklWY2dhcEhUQ0Q4SWNJdjVNdDcyeEx3dXhsS25HY1FrTW9wT01oa3BBT3lGTTlOM2pEVlhwWmlWRVRxa0xvVUw5NUpHN2pHdGJiQWliTFZMVUZNYzJ3dUs2Rm96bGRtTFB2WDFod2hQSmxITjluNXFKYzFSbUxTa0tRb095cUUxcTRqVFZhWkgvV0hnWWxuZGo1S2xPRnFEWmpFR09mWCswTVYyUmxEM2o1L01ST0VXZVN6MGtGc2xySndGSkxrOFdKNWNZSWJZYmpFbFpVaFJMaG1yb1h6QmZkNFFScVl4enRJTGhTb2hTMU9RR29HMUozOFkwcE4xcEZBVlV5cnVpeElFWHBmci9mNVJuUzdVUCtHZzZxOFlCZENBWHIxSkhEVHBHa0YwNkUvS0hGQWVvR2U0YS9XTG8ycjJld3BITHFZbW5TTUJiQzQwT2grL3ZSNTBEeDlmckZtektIc3FEalE3dnI5N3dSdGsvdXlWckNseWdjSTJTcGpoTGdoaHZ6ckZ1ejJWQ0ZMV2xDUXFZMk0xcVVoZzRkc3FSb3JsQkdnNEZoOS9lb2g2VlJxM2Z0SjBySkowSGdJWEFzNkh3SHlpM0JHUlRGblh4OFI4NGVpekszdDErVVdva1NZcHRDaVVyZW56OUJFNkplL3loenhJRUhjWWdhSmNLcW1iQ0hGSkgySWZoSXFmbjhJQnFla09oUk00K1h6aFNSdTlQS0FTRnhjVEFHM2ZmUXc4SU9ZSGw4L25BTXhRcVFkMFBTU05XNU42UWlpRG1RZVFQMGdFWS9aQStNSXRHOER3ZjRRS3c3ajQvd0I0UXFBMDhmb1lvWXlSdThQckE0UDBjZWtMaUpvNGhGaFdSZnJTQVJhVHFQRWlHRWN2Qi9NUTB5UU0vSXFoaWluUi9MNndBdFkzbndQemlKYWh6NWsvS0htWnU5Zm42Ukd1ZXI4MWVIMEVBaWtuOG9IR25yRWFrOFFPWC9qQVFvNlB5YUVFZzZqcVMza0FUQVJyYlZ6MDlTVEVXTURUeGY1Q0ZtRkl6SkowWVlhZGMvQ0UvZUJvTVA4QVVmT0Fhd1Zra0hsVDRORWN5ekRVdDFId1ltSHJtUDd4NjVlRVFxUEVlWHlnS2srUU5GRWo5SWl0TWtFWlY4QjhTSXZLQkpvQVR3UHlNTi9kaWFxMlJ6cjBFVVppOGFmemRDUG5DUmFuejBTd1R0RnRTU3c2RFNDRzBRU1ZmSWMvdjFpNmxiUHdIbjl0R2ZLbUo0bHVVYUFDUWtrZzVJVlU2clV3Rk56UkJQdkhENXhKbnJtUHY0eFdsV2gxRmdNaG9kNnQ4U3liU1dRWGJKMkFHWTRjV2dxM0xTK1dvOENQdnlpVkVzbk1ONkhKdytueDZ4VTd4UkpTN21oRmZEekJpZENTV09Fc1JXbmcvbVBDQ0wwbGRNS3ZJaW03a00yT2xlTUlxWGh6UGtYNC93QnVYQ0t3UVhiWmNiMUNvNGdWK29pNUxXa2pDVkJXN01kSFZRRVpCK1VGTVNvY1M0b3dGZVRueU1KUG1oSW9oUzMzS0htOWVrS3RBVHFTL0JnZDdQVUVHaEJZdjBNSW1ZTXh5ZFJQbUtSQkVpMkxQLzErWks0dnk1dzFBOEsrZWZPSVVyUDVRQzJWSC9sS3ZXSENhclNnNFU4V3FubkFXaWxXYVNTUEQ3RU5LVHF3NXFEK1ppQXJPOHZ6K3dmakU4dWU0WlcwT3IvTWZkWUJjSTFJOC92ckRrcVNEUW5vRzgzckRqWmd6cGNEY1VueStuakNHenNLbElIVXYwSDFnaDNlRFVEbS93QWdIaDZWalFOekQvSEtHRENQZUo1RDFKcDVRb1duOHI3Z1QvWUhvOEEvYTBML0FLUzNsU0VDQ2RENFEwV2c1QUFjQUsrTGZLSG90Q2hxVDRHQVh1Q002Y3lCNVp3QkllcS9BRS9GaEFGSk9hZW8rV3NJVUE1S3J1VlJvb0ZxVG9EMXA1Q0VNd2FBRG8veGhGeWxEM1g1R0ZGbVVSazNPalFEQ3RSOTdvN1JHVW5kNWZLSlZTVWlpbC81US9ucEREYUVKT3lsL3dCU3ZpQnBCVUFmVHlpUVdkV1pZRCtOaENLdGhkM0hRZlppTmN3SE5QbVFmV0FjcENCbXAvMGcvRlJieWlBekVqUWRhd3hXRjZFOGlIOFdNTlVoOGxBOVcrUHpnQ1pPSjk4OG1ZZVVWbHl0eEI2L09CVXRRRlIxYUl5NTF6NGZDa0E1U0ZqSjI0RXQ0aUlUTlA4QWNBK2tXSlZpb1ZLVXczdU0vZ2s4Q1FZYk50S0VCazRsY3lTUE92Z0FlTUF5WEtVcjNCekxqd1l3VFpjdFB0S2M3a21uVS9aaUJkdVdYeEdoMFAzWHFURUM1NC9LM0pYOXhBVHJ0WVprN0E0QUVucTcrVVVKcHI3VGsvbWQ0Y1ZKcm1QUDFpQ1lCbGlISXVJb2l0Q1NVcUdJTXhCWlducENRMmRJTEZtUDZXUGtLd1FSVVJrZXZ3amF0U2l5djFwLzBBd1FSQkRJOXM4ay93QzZOaTc1U1NnT2tIbUJvYVFzRUF0b1dRb0FFZ01janhFVnlzbENuSlB0K1JMUWtFQlptZTcxK0VPczN2Yy85b2dnZ05XYU5oZjZaS3VwSkJQTWlqeFZQdGRQV0NDSUVWN0t1RHR3Ykp0MFBtRmxKYmpCQkFYTHZRQ1NDQVE0b2VrWGJac3AyYVpaVTE0UVFSUlJLaVYxclRXTkd4VkFlcmtndnFBS1BCQkVHZGFhSHI2dzRlMEJ2ZUZnZ0NXS3JHN0xobkN5aitHK3UvWFhXQ0NBblRwOTc0SlNRVmdhYm9JSURSbUpBQ21BSEtJclVObmttQ0NLTW0wMHdnYTV4R3NiYVJvMlhoQkJBTUEyb1ljMWNvSUlLcnpqbHloUU5wdVB5Z2dnSUpTamlOZFQ2eGZXZGxCMUpZOFJTaDN3UVFGRzh2OEFFVU56QWNBd29OMFptbldDQ0NJaDdJZ1g3TDhJSUlLcnI5a2NuaUQ1UVFSUlJ0S2pnSjFiMUVFRUVCLy8yUT09XCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndDRUFBa0dCeE1TRWhVU0V4TVdGaFVXRnhvWUdCY1ZGeGNiR3hnWUdCb1lHQmtkRnhnWUhTZ2dHQm9sR3gwWElqRWhKU2t0TGk0dUdCOHpPRE10TnlndExpc0JDZ29LRGcwT0doQVFHaTBsSUNVdExTMHRMUzh0TFMwdExTMHRMUzB0TFMwckt5MHRMUzB0TFMwdExTMHRMUzByTFMwdExTMHRMUzB0TFMwdExTMHRMZi9BQUJFSUFLSUJPQU1CSWdBQ0VRRURFUUgveEFBY0FBQUJCUUVCQVFBQUFBQUFBQUFBQUFBQUFRSURCQVVHQndqL3hBQkZFQUFCQWdNRkJRVUdBd1lFQlFVQUFBQUJBaEVBQXlFRUJSSXhRU0pSWVhHQkJoT1JvY0V5UXJIUjRmQWpVbklIRkdLQ292RXprckxDRlJaVDB1SWtORU5Fay8vRUFCa0JBUUVCQVFFQkFBQUFBQUFBQUFBQUFBQUJBZ01FQmYvRUFDWVJBUUVBQWdJQ0FnSUNBZ01BQUFBQUFBQUJBaEVTSVFNeFFWRVRZU0xCY1lFRUZETC8yZ0FNQXdFQUFoRURFUUEvQU8rUW1Ka3BoRUppZENZOURrUktZbFNtRlNtSkVwaUJBbUhCTVBDWWNFeEEwQ0hnUW9FT0FnRUFoNEVLQkRnSWlrQWh3RUtCQ3RBSTBMQ3dSRkVMQkN4QWtMQkJBRUVFRVJSQkJCQUVFRUVBUVFRUUJCQkJBRUVFRUFRUVFRQkJCQkFFRUVFQVFRUVFCQkJCQWNYWWUwRm5tZXpNSFVHTmVUTlNvT0ZBamdSSGdLWjZrbHdwUU85OXpmU0xVbThwd3lXb0JtejRORDhzYS9HOTdRUTdPSGlWS1k4V3VxLzFKVU84R0pOWFlsNjZ1K2J0NFIwVXJ0TkxVMzRzMUg2aVNCVU0yRjZlMTVSZWNUaFhwWUVLQkhtcy90Wk5EcGxyQzZCbEVxQnFBVHF4WTBxMGRIZFhhRmFVQXpzSkRPNHpablVkY1RPM0dKZkxqUGF6eFpWMUlFUEFpS3gybEUxSVdoVHBQM1VhR0xBRWJjOUVBaHdFS0JDeEFrTEJCQlJCQ3dSQVFRUVJGRUVFRUFRUVFRQkJCQkFFRUVFQVFRUVFCQkJCQUVFRUVBUVFRUUJCREphM0tzcUZxYVVCcnhyRDRBZ2dnZ0NDQ0NBSUlaTm5KUUhVb0pEZ09vZ0J5V0FycVRTRWdQbVF1Mm05NEpRaUt6a29lV29WUWNQRnN3ZkQ0UmJVb2FOWEtrY1BUMGUwc3BEMWkzTGxlUDNxSXIyYm5YUHBGcENzS3N1T3BIUWI0emJXcEZ1VktMZmROT2thZGlWUUE2VSsvR001RXl0Q0dmTi91c2FkbVd6T1BySExLdXVNYnR6WDJxUTRDWHE1NnR1em9CNHgzVjAzckxucEJTYTZnL2RZOHZRTkJ4ZUo3QmJGSUl3a2hRTkkzNC9KY1dQSjQ1azlaZ2ptN3E3U1l0bVovbUhxSTZLWE1DZzZTQ09FZW5IT1plbmx5d3VQczZDQ0NOTUNDQ0F3VWlWUGw5dEN4aldIdEZaRkxXaE5xUXBXTTBVcElHUW9nMENrOGF4c0pJSWNWRzhRTExQWllJSWpUT0JXcEZYU0VrMExNckV6SEkreWNzcWI0Q1NDQ0NBSUlJSUFnZ2dnQ0d5eTRmaWZJa1JVdnE4VTJhUk1ucXlRa2x0NXlTT3BZZFk4S3NsOFdpV3RVeEUrYWhaVVZLd3FvU3FwZEoyVFVuTVJMZE5ZNDdmUVVFZVJXRDlwVnNsVW5TNWM5TzhmaHE4UTZUL2xFZFRkbjdUTEZNWVRDdVFvL3dEVVM2Zjg2WEE2dENXSmNiSFl6VnMxSGNnZU1QamplMnZhUUNSTEZsbkpLcGluQzVha3F3cFF4ZlVaNFF4NHh5OWcvYWhhSktzRnFrcG1nZS9MMkZOdlk3S3VqUTVUZWw0WFczclVFYzVjbmJleFdsZ21iM2F6N2s3WVBJRTdKNkV4c1h0ZUtMUEpYUG1Ga0lTVmM5d0hNc09zVm5UbXV4ZDg5OWFyd2wxcFB4cGZjd2tsdVhkcC93QTBkaEhoUFpYdFlpeVdvVGxsMExCVE5aeVFsWnhGUUF6WWgraEVlNXlab1dsSzBsMHFBVUR2QkRnK0VTWGJXY2t2UjhFRUVWa1FRUlZ2VzNDUkptVGxBa1MwbFJBWnlCVXM5SURpL3dCcWx1Q3JDaERmNDB6TCtGT0kvd0RiNHdSd3ZiYnRaTG55N0VBUnNTV1VrS0NtVml3S2NqZ2grc0Vjc3U2N1k2MDVlZE1Mb25ObXlDUnIrVW5jZER6aWRhaHU4OHZsRzFiTHNTdVU0QUdOSVNTTXNRWmxBYUVGaHdjUmlXTWxRMnN4c2tGMnhDbW5qeWpudVdiYmtzNlBRcXU2THNpMEFGamx2aUZObHhCd2VtWStjVGQwek9Ib0RUUGNhYzk4UzJWdVNyc21Zbk1GczhzenppOUtEYXVNeHVEUmxCVzBDY3NtSVl4cDJSUWJaTEd1ZXUrT2VVYnhXQk00OVdvWUZUZDdmZkdGTTBHaFR4ZlRkVGhFMGxDTXpTdXRSa3pjbmVNeTZXeTFOWnJXUVkxN0hlcTBGMHFJQnFRRGwwakFuVEs0Z3pNd2JLb2ZMbTVpeFo3UUN6NkNqZXNiL2NaL1ZkcEk3VW4za1B5cEhRV0MySm1veHA1TnVNZWJLbTZ1OVByRExaMnVtV1IweTAvaUtBSUV6MkNEa3VocjVWZU9tSGx5MzI1WmVLWDA5QnY2L3BGamw5NVBYaEh1cEZWTE81Q2N5ZklhdEhrUGFMdG5hTHdWM1lCbFdjNXlrbmFVTjgxUTlwL3lEWnJYRlF4aFd1Zk10RTN2Wjh3ekpxeXdmZzlFcEZBa1ZvS2ZHSk1HR21lOHh2UFA2YThYaWs3cTVMa2drREM1SkFBQXE1b0FBQS9JUnFoTm9zaThLVnpKU21CWUtJekZLWkg2R05EOW1KbGQ1TUNoK09Fa29VU1RzYWhJUHNrVVBFSGhHdjJvay84QXBWcW1IdkZJbWdTMWxzUVNzSlVRU0djWmpvRG1JNWNMcmUzWDgwNThkS2xnN2JXcERCZUNhUDRneXZGTGZBeFd2Sy9wa3hSbXlKa3l6VDgzU1F1V3NhQ2FoUVlqUUZpUnB1akI3NEFmWitzZERjbHdLbUlNMmVlNFFUaFFGamJLalJKVU1rSkpJenFYYWtNYzgvaGZKNC9GTzcwYmQvN1VwOGtoRnRzd1ZSKzhrS0FjY0VLSkJQOEFNT1VkbmMvYmV3MmxnaWVsQ2o3azM4TlQ3dHFpdWhNZVkzN2QrRmZkVHhoWXNTTkh5VU40eVBFY2NzQzlidFZabGlYT0FxSFNRWENrNU9JNjQrUzZlYlB4U1hwOUhqZkJIaHZaSmM4S0FsV2hja1ZJRHF3TFlPd0JPQlNpeHBubkhZWEQydG55cDB5UmFVR2J0a0tYS1NNUVVOa3VFZ0JZWlBPbXVVZEptNWZqdnc5Q2hxMWhJSkpZQU9TY2dCbVRFUXRhVlN6TlFvS1RoSkJCcFI2SGRXaDNSaDNwZjhxWEluS1V0aXNoTXBKTGxTcGtxV1U0VTVzNnE3cW1OTVNPVC9hcmZtS1lteHBVeVVNdVl4elVYd3A2Q3ZVYm84N25UU0NlQjlhK1Rud2hiYmE1aTVreGFxclVwUldTemxUMW9CbFNHWG9oUW5MR2o3bnpUWFhjL2dZeGU2N1RxYVhWQ2hCekcrS1V5U054OWZBdzY4Snk1YzFhVXRtK3VvSHFZbW5UR21xU1JVUzhWTlJnQ3VsSXliWmMxTFZUUlFxRzRjbzA1YXhQUUNmYUVWaXBDa2xRMElIaTdSQ0Y5MHBLaGtvZXBIcEN4WlZwSURNb1Y0KzhNdkVSS3VhdFV2dUZMVVpUaFFRVkVwQkRnTUhwUW5LR1dnNUVNRkRSOTNEVVEyVXNISmh2RDVRaG82ejJKQVVtbnZENC9VNXg3TDJEdFE3aWNxWk9Lc0V6YVZNbUZXRkFRaG5LanNpaXZBNnZIanE3VWxHMG9zeDZua05ZeTd3dlpjMHFxVXBVQUNrRXNRRGlHUDhBTldzV1h0bktSNmxmMzdYa1M1aFJacEltcEZPOFdvcEJQOEtRSEtlTkhqbkxYKzE2M0s5aEVoSDhxbEgrcFVlZktNUktWR3RzNmpxYmIrMFc4cG1kcVVuOUNVcDh3SGptN2RlMCtjWG16cGt6OWExSHlKaXFveEVxQWptS2hZWXFDQTlibEtCbG1Va2c0S0hJQXFLTVFxS0pCeE0rOFBwSE5LeEluQnd4bWUxdUttRFU0aHpEYkRhSnB4eWtyVGkxd3BLZ3RLVVlTU1EyOU5XYmFlaEVUWHZaTFF0SVhqbHJZaG1HRm1ZaW9CR2ZySGx3bXBxMTZjcnU3a1daNmk1MldiMTFFV0FzTVM1eGIzWmhuOEk1M3Y1eWs0amhKTzRzM0E1VmY3M1dMRE9tdUJnT1JPSUtUUnFaTzVyOEl0OGZTenlkdGFTbmF3amFjTzdrVXJuRTVra0FVYW12aEZWU1VsUVVsUlNhQlFJYXV1WHJHcDNpUWtPQVdhdTRjTjBZeXJjaEJNRE1YRk9GUHVrWE8rWTVhMVB6R1JFVVpFN0ZpbzQzQlB1OHhGMnlXUmMwRVNrNGlTQ0dZTlhVNURYV0p4MmN0Uk9VZzBBRmFQVFRSdkN1Y1FUV2xrVkRINHhad0psRk12dlJNbXFXRTBBVWdLb0dVVkpPTm5HeUdqTXRsclJobkl0VXJDdkVnb1FoUXhZMlc3bXJKQUl6M2pPa2RKaFl4YzVXcXV4cW1TbGpFRURCTG1TNXRRR0lVVkJaeU5BQTM4VDZSVXQ5N2Q1SmxXYVVoTXlaM2FBdGVFSEN5VWdoQUlwem8ybGNxS1V6cHlFUzVxOEVsS1VnSTFWaHljTTVMMTZqYzhkRmR0M0ZLV1FuQW5mbXMvSStZamRzeGMrNno3bzdPaEdMdnBoQm1BQlFTWGV1eTlDN0YybzFUR292c2pLTlVURy9WcDVpTml3MlJLYXRYZVM1Nm1Ob29CNE5tNCtjYytWdFh1ZXE0Yi9sU2NnNDVVeGxESlNTeEhJZ0Q0dzI4SlY0S2xtVk5LbG9KQnFBUzR5T0lBbnpqdUUyVUdvQTUvVk1PTWdqVTlTRDVHTmJKbFhrdG9zYS9aVWs1Ym5QbEhZWEIyaFIrN0d6V2xZQ2hzcFVRcXFXMmNUQjNGS3R1MWVPb1hJSkcwQWYxSitWSXBUcm5sTG9aUS9sTGVWSVM2OUdXZkxxeHhQYTZlbVphcHFrcXhKVmh3a096WUVpblY0d3I3dHBWSmxoWkpTZ2lWTUFEa3lpZGtnYndNU2N2eTc0OUJ0SFphU2NzU2VZY2YweGtXL3Nsc2tZZ1ExUTR5L1NXK01XZTJzczVaSjlDK2J1a3lyRXVXa0JTRU1vTEM5dkVGSVR0SENRQ3g0MERNTktOMVhaM2Rubkx4bE0wQlFRdkRpUVVnRXFUTUl4QlFVbHdRek1NakZXN3V6azJZQlowVEVwd3BYaG1GSkNzS0ZvU0VxS0RrWDBMRUEwb1kzSlBabTNva3FsZDlLV0RpY09vQldJTUFYUTZXY2paVUtOSFhqZnB3M1BXMURzL2JMYTFvbklWUlNWcldrZ0ZFMHJyc0FFYlpEa01BY2djMml2ZGRuRnNWTG1xS1N1VWhJSlZzZ0JCWUVwU0hmQ00zRDRUUXhzV0tUYjVFa1MxV1lLQ1RoR0ZibkRocVFvS1VWYWpDVWpTc1oxeVd2OTFrNFp5Rm9DaXloTWxxQVV5QUJqRGxTS2dWTk5vMU9rc3ErMHlMbWxCaVZwZFRzQUVWWnhRckJLbUdvMzZQRWRwc3Nzb21sQ2xxU3hZNGluSk81SkF6ZUNlbnZDSjZFZ3k5a0JTV0tVbkVLQ3JwekdZRVg3MW5KVUpwU1gyRG9meUFheHl1MWpOWElsbVkySTF5QlV6c0E0Q1RwcmxDVHJtUXBhc0NnZnd5N3BhbUFnOGNtejZOREw5VUYyeENob0pma0R2cjR4c1d5ZEtWTURqWXdNdkVObWdCeXFHeXAxMWVOSTRxZDJkVUpVMElCYlpVNFlzMkxRczNMaEdYZWQwekV5NVlhb0NuZW1hbkhMWHdqcnJvUmlzOHgxRWxKVmhybjdWS210UElSTGVLajNVcVlvc2phY0VBTmlMMTRONjV2RzVhamg3ZEtVSnltQkxHaEZmWFBsNVExVnBDVTdRT002RFQ5UWFqN2g1UkplMTVvV2NNdElZZStSVTUreURVQ01sSWY3KzNpaDB5WXBaMUpEWkRmeWhreEtrcXdxQkJaMklZMWZTSFM1ekltSUFQNG1FRWdzUUVIRUdOYzRrdENsVENGRkpvbEtLQWx3a01IT3BnZGFWSGdzOG5IamRXRUlUaUpJSllDaG9NNHRTN3VuS3lscVBTSnBkeldrWklVbDZPU0JUakRaR2RhSlFDWmEwcXhKWGlZc1I3SkFMZzhZckxSWGRHM011SzBLYkVVMC9OTWRvZU96U3ZlbUlUMEo5SWNwOXJ4dDlSenhTMEVkSU96eVJuTlA4bytjRU9jWGhsOU9pdXl6SVJPMlZKb1V5aUFVdVZZSFlWYXBBY2FrQVZhTm0wcHhJSjdwS2x1MjB6dlE0VHMwVUFRR0IzMGpuYjA3SmxJSzVTaVV1K0EwSUZEUlQxSUl6WjJHK0hXWHRPVUJwb1hpRHFUTURQa3pURXFZS0pLbWZPc2NjZFdibGF6M0wzRzVZTHVsTURNa3kwazV1SHpjMUFGU3o2MStPVDJqdFlUTUVxV0VqdXdwOEl3KzNoSURVSUxEd1VJanQzYWNwUyswRjU0bDRIQ3NLVTdDQTZRUlN1b0JEUmtybUxtSjd3eXlrQnRvdVZPYWtrNmc1dVhQTEtPa24yeHY2TlRlQkRnNWNRRHhpMGkxTzJUY1BscEdZdW5FR0w5aHNDcHFrSWxKSzFuUkdiYXVTR0RiOG92Q0V5cnFrckV1UWxhVHRLMnlWVVNtV0VGUkoycTZFazZSVVYybW16cENVcElseTYvNGFPN3hES29xd1ByV0wxL0tFdVVKY3dwU28wN3R3UzdWNE1tZ0I0QnVOT3czU1pnY2wwaW5DbEhPOCtBR2dpU1NMdTVlMDAyMWdGY3V5ZXdabVB2bGdNbFZQOElOd0ZjeXdpUzdMbUNUaUFKVm1WcnFwem13T1JKMVZXc2FOa3N5VXBCek9FbndiTGRucFNMS3lYV05NTXo0SmFtdXNadmJSTFBZa0JZMVVDSEpxV0lWcjhvMUxCTWRPUURFaGh3TVp0bU8xL0xMK0NvdlhjZ3BTeERiUitNWnMvbzJtdVJaTXNPU1RpVm1YUHRHTiswajhOZjZGZjZUR0hkc2dvUUVrdVhKMTFQR042WXhCU1NBNElxUnFHaVgvd0JId3diblEwMUd5eE9McDdRYklmWmk5ZlU1YVZJd0tVbWxXeU9idUdOV2lXeDNjbENrcVNUc3ZTbFhmZHppYTMyTXJJSUxNR3IxK2NkYlp5YzlYaUpGcFYrN2lZN3F3NWtOcVJVQm9aZE50TTF3b0pvQWRrblhtUzBTeTdPb1NSTHpJR21YdEUvQ0dYWFpsSUtzUUFkS1JUaDFqUFdxdmU0bXQ4OU10SVVvRXVXb0hhaEw1aWxJeXI5U0psbVdwTCt5VFdoMlM1K0VhTjlTc1NFaGlkc0dqNU1yZEZLY2tpeXFHZ1F0d29FblU1dkdkVGp0ZC95MHcreVpUMzVDVkZzQ2hoTGIwa0ZJVFJpTkhpSyt1MGN6dnlpV2NLVVlnNEkybUthL0dHZGs1aWphWmJxZE9HYXpIS3N1aERCdm5paExEY1luV2NLd3BFeGF5dkVhSERqQUxIVUZEbHNuYm5IcXh2OEFGejEyMnJCMmxRY1dPakJ3ZC9BN2xlVWFGMTNtbWVLVUxPVThENlJ6MHk3VXBuU3hJVGh3WWdweWE3TGdrdFZWVDQ4b3B5a3piUGFrbFRzVFU1dUt2bHB6NXhkcndkZmFMcGtMQlNxVWhqbXd3dlVHcFN4ekFQUVJRbmRuSlJCQ1ZMRGdqUEZvM3ZWUGpHNFREQ3FGeGw5c2JzY0pmMXdLbGtUKzhTUWtwQkJHRTEyUXdCSXpJMTBNUTJ1YUIzZThLTHUyUndoMmJLbkhLTlh0M2FtbEJJUHZKOGxmVVJ5OTVUR3dyQXlPN05sQTUra2NjOFpMMDNLdFhTQVZ6UWFnVHByTXhCOXBtY2NtaUc4YkVpY3FTRmpHSnFVcFNrS1VnT0VyVzV5QkdiT2FQNFJXWEEweVdrZ3BWTXdBMG9DaHptR28vREtzWTF6cG56TFdpYXFzdVc0RzBHWVN5Z0VCMnJRMDNtSTFQYnAwOWo1WU9IOTNRK2JLV0NXM3RpaVpQWmhLQ0VpVkpRVlpCczI1Q09sdFNnYlNNaThzL0ZVUlhpZng1UDZsZjdmbkhQWFh0MzYzSnFlbUxLdUxhVWdHVUNsZ1FFbWoxSHVoNGp0VjNDV1dWTkljT3lVa2hxalZRM0dOMnkvKzRuRGlqL1RHWGY4QVZhY05kak1WOTVXNkhHYTJ1TjNueCtORW1kbjBnT1ppam5rQU1nK3NVTEhZSk14UlQrSlFQVlNkNEc3akhUV21jQUFLbkU0b0NXcHJ1RVlOenkxSldTVXFBd0hNSGVtTGNZemhsbGNjclVONlhiS2xKY0l4VkFxVHFDZE9VTXZleXk1T0hETFRVbDhUbkp1TVhyOFNWeTJTa3ZpQnkwd3ErY1Y3K1JqQ2NOV0plb0c3ZkVzbStsd3l0azNUNWxqbHBka0lvZHc0K2NKRWs2Mm9ydERQZU9QR0ZqcDA4LzhBTm1KdkZLcFVwUjJUT0RKR2JuQ1ZONEF4VHRjbVd0Q0JNQ1M0U2x6bU1SQUZjeFdNR1pPT0N4RDhpMUgrdFBvVENXVzFvQkFuWWlqdkZrNFQrVXBXbnpKanpZWWZUMTVaZmJTRnp5VUVFS1NPT0VHaDBmRTRpeFlWSmt5c1BleTFTbm9Da0ErMlJVNHo1Z0RqRU42Vyt5cFQrR1ZmbEw0aWtaTjdRZDQ1K1ZiVWxKUXQwb0txS1ZsbStibWo4ZFIwN3liM05PR1Y5VnVTT3ozZmttU1VxUUZWSk5CcXpKNWthWkRmR3pLdkg5MFIzZGprcWNnWTUwMU8wdGg3b1d6cEZXYW00VmN6M1JiWmNwQVNtbEVrNGFoOXJDZW9PVVpGc3Q2WjR4eXlsYVVNQ0hLRGpvS2xhUlNvNFZPc2F1MlduZkE3eVJMV3lUTUtUakpBeERFbkVYWWIzcG84V0xwa0ZNb3BkMmZMZWNKUHJISTJtOHBrbVdnTGxuRE9Dc0FDMHV3REtKYkVLRTVibXFHTVZwZDlUMEtzb1JNV2xFeGUybWhDZ0pyRVZEcExVNkNOZkREME9US09BT1dkSjRaZ2IrVVBBUTVMdVMrUUp6WitHa1p5YmNrYklTNUFyU3Babnp6ejN3KzBYaTJNQVZTbFpyazZBZzZGMk9NZUJqanpkZUswbThVS21kMGd1cEtoaVQrV2hJY2FVYUhkbkxRdFVoSmVycXFhazdhczNqbnhhWm9NeGVNdWtLS0hKSUd3Q0hTVGhOWDBpYnM5YVZoTmxBVXlWTG5oWVlNcGdzalJ3eEdrYXkzTWIvcit6R3l1M2txT3BlTnN5d2N3RHpqbUxITUpXdHlXRE5IVGd4dzN0dldpQ1VnNko4b2tUWjA2RHdKankzdEJaa2Z2Tm9KU2x6TU5TbitFYXgxZCt6QUxIWnFrT1pZR0hNbnVsTUJVZllqZU9PN0l6YjA2YWJMWUdxc2o3eDNjNDV2c1E2aE0ybE1BamQvSHdpTzBxVW03YlJoV3ZFSFpSZEtoN0hFa2JzNHEvczhuRXpKaWNSSUVzVWVqOTR2VGUzeGowVEhqNDgvOHhuNWp0U2hYNXZFRDBhTTYrU29TbGc0U01DdENORHJWakhPOXZMOW1JVjNVc3FTRWdGYWtGbEVxcUE3Z2dNeG9hdkZMc3BmNjVvWEltS1dvRkNpZ3Jxb0ZMdWtra2tobk5jbThQSFBKT1duVytPNjJXNWJRVUpsbFEydG9LS1gzS0p3OE5jOU5ZNmFSYWtzakMyRlNSaGJMZUFPa2VkcnZIOGRNc0V1bFJyWFZCVTQ2Tkd6YWJXc2hCREdYamFZS3VrWnVubWRkQ2VNZlN3eDNoMDhmS1M5dW5BY2Q0b05nV1E3bW9QdFpaaDI4SXlyMWxFcWw0U1ZZQVMrWk9ROG56K0x4TlpyZXdFbzZGWVVWRjhURUYyT2hBUGpHTGZ0OGhLbUJJcUtqVnQyNERkeDV4ZURwaG4yZExuakNDSmlBYVp1Tk40ekx3NUZxbXZTZUNOM2VINEdNdkd3RzBrQ252OE4ybndpdXEwRUt6SGtZOGR2VDdmNDlyWGFLWXRVcFNsS0tsSlduTGlRK1Fya1B2S3BiWmoyZFljQWhTZWRWWnhRdlRhVUUwcW11TExNNXZ5aXBiWmFFMmRUaEpVNlNjalRFa1pqcS93QlkzTzVIeXY4QWthbWRrYVlVcEtnbHlTd0l6ZXBPWEJxYWFSUFlGaEUyWTFFZ3FZTUN4QUxiSno1UnpobVNnRUhDRW5nTXhpSmpWc3R0QUpSaUJRY1lLV0ZNaXFwYXRjbm80M3hkVytuR1diN2RpdTNMek15b0RQM1NQaVZSQXUzcS93Q29xbjhLQjZ4Rlo1aVpoREZ3dzBBQjRrZ25Randndkd5R1Vzb1dVdlFnb3FHVmlZSEtvd25MZkhDYitZOS84TnlGTnVWWGJtZENCNlFodHAvTk4vOEEwLzhBR0tnclJKZFJVbEl4QU1NV3VyL1dFOW5FbVlRVklWZ0pRQXhaS0ZPMm50TjBpcHZIbHhQbld3RE5VenF2NUppR3pXdE0wa0pxd2ZhVVJSbjNDdkQ2UlBObEtDZThDazRRckNVTUhLV0Rrbk9yK2NWNWlFYlFZbkNGSFN1RUV0bHF6ZFkxTE5mdEpaYi9BSVVyUmVFc1BRYS9uT1hJd3o5OVFja2p3bWVwaXRkVnVWTlhNUXNJMlVrN0FVa2hpQTIwUzRyenBGeFJUdVArWWY4QWJHc3VQcVJNYkwyaU04RVVTbndQcVlXTHhzaVRqL0VDU2dzRXZtQ1NCc3N4eTEzVmdqTG5mTGp2MDVLMDJpa29BRXNUNEVndjQvQ0lKOVVpbFhVYyttN2dJbHZJdE5RUDRRZjZsZktFc2RrWE1DY0EwWW5ka3haNjZ4WmhIRzUycXN5YXJ6NHU3YnRkWWVMdklDMUtDeFFLWmxEMlFhQjh6eWpwTERkS0pPMFJpVWMxSGp1M0NJNWlpdFJ6M2RLNjlENVIxa2tadHRjelpiNnRBRG9VcGtwU29oZ2RuRW9VM2hpbGdmeTZETkxIYTVrcFNVcW16Rm1Za0VNU3dCT2U4cVlQbDFqcFpWeklDQ2dlOUxFdXA5MFlteTFxWVdUY1JRVUxsbmFscG1CSVVTUTZ4UVBtbElQUFdOSTVxM3o1czBTa3BLaVpRd0JpTWtza0hBbXFTeExrczc4SW10dDIycVhJbFRGU3Bnd0tWdGtMOW9xQlNTVkpGWEdZSkhHclEzczVZVnk3ZUU0VjRYV2wxZ2pFR0lCY2lycUFNZHhaNzNtV2hjNnlxbGdKa2tiVGs0OFZSaUJwdVBTRmhLNWk1ci9uRzBoSzJVaFRweVp0bkVrOHd3SFdOMitMZDNkb2twQXhKbUNjcVp3UUphYURjNVNLOE9NV0pseXBPU1FPSStVVkxmMmZLMkxZbEpCd3VTL0ozeWVNZmp4WGxVUFp1ODAyb2JRWWtrRVBtTUl5TERRdEhXV2F5eXdVWVEyQWtwQW9IVUNDYVp1NWprTHQ3UDJpVVFVb3FsNmFGeDk2eHZ5ZjNuV1IvVTN6aVplT1pmSmpseG5wdTJKTFRaaW5PMWgxM1BsdWpyVE1BcVN3M21PRnM0bXVDWkpmOVNmVWlORzlGekowdGN2dWxERUdmRWlsUWZ6UnluaC9iZDhqVm0zRFpaeWxUQ25FVkVrbE14YkVqWlBzcWJSdWtYNTEzUzF5MHlsQTRFTmhEbW1FWVJYTTBqa3V4bGx0RmtzcVpLMGhhZ3BhaXBTeTV4cktxc0ZWcldzYm90YzhrVWxBYWpFb3Z5T0VONXhxZVA4QWFjLzB2LzhBQ3BYY3FrTWU3WG1IUERYUFFSSGRGeFNMTVZLbEpJS2d4ZFJOSGZXSURPbkgzcFkvbFVmVVJSc04yekphOFl0TXd1UzZWRlNrMTRLV1diVGRGNFhXdHB6L0FFNW50NU5INzFNQkIvOEFqTk1MK3lsbWNIV00zc3BPSGZKYjhzNy9BRUxqMEswV05Td1FxWWE1bEtFQXR6SUppc0xxU0U0TzhtbE5mZVM5YzY0WGpqLzErL2Z6dDEvUDFyWHhwNTNhclVrS1JOQURrdStITVlUUlIzMUE2eHMzUGF6TU9PV2dsQWNGeWtPQTRabjUxamVIWSt5L2tXZWN4Zmt4RFJiczNaeVJMVGhRaFNVblFUSmpWZjhBaTRueGoyNCtUTEdhankzR1Z5RjYzNmtMSlNpWTB1aXFKTEVBSTJpQ3pPTmVFWTEyMjVFNjBvTEFnRU1sZFFTN1ZHdkg2eDZUTDdQV1lZbWxJMndRdDY0d2FIRy90UHhlRmwzQlowK3pJbERsTFI4b2ZreVdSekZndjBDMHpaSmxvQkJ3RWxRU0NRQW9IQ0VGaXhqTS93Q1lCYVVURllVb1VnVVFGWXNSZG1mQ1BoSG9Zc0NBS0lTQndTQjZRdmNEN2FNN3JmS3ZIck1pWlBtbEV5WE5sZ2dzVXBWb1hHMFV0Vmg0eG8yeTVaa21UTndJQ3NzSlhWUnFNamlBRlR1OTNuSHB4c3dpTmRrVHFQSVE3U3ZLcG5aSkRBSzd6WkJxa3FjN2dRQ3pEZ0JFZ3VYdW1NdkdyL0VmR2xSTzJsQWRKYlpPeUs4NDlOVlkwblFlVVFxdTlKMEk1RXdsMVV2YmxidHNZWEpVa3F3RlNDajlPeUE5YTA1dyt4M1dKU0Y0NTVtT3luT0lrQklMZ1lsS05jMmZONDZCZDNON3g2eFhuV0J3Umlkd3pQNnhMSldwbmxOZHNBeWtXaVNydVorRnlsbHRrUXluU0hHK0gzZGRCbG9LVlRqTUpXVllpS2wwb1N4ZFJmMlkwcE4wSmxwWkNNS1hmWkFBZkxKTklWY2dhcEhUQ0Q4SWNJdjVNdDcyeEx3dXhsS25HY1FrTW9wT01oa3BBT3lGTTlOM2pEVlhwWmlWRVRxa0xvVUw5NUpHN2pHdGJiQWliTFZMVUZNYzJ3dUs2Rm96bGRtTFB2WDFod2hQSmxITjluNXFKYzFSbUxTa0tRb095cUUxcTRqVFZhWkgvV0hnWWxuZGo1S2xPRnFEWmpFR09mWCswTVYyUmxEM2o1L01ST0VXZVN6MGtGc2xySndGSkxrOFdKNWNZSWJZYmpFbFpVaFJMaG1yb1h6QmZkNFFScVl4enRJTGhTb2hTMU9RR29HMUozOFkwcE4xcEZBVlV5cnVpeElFWHBmci9mNVJuUzdVUCtHZzZxOFlCZENBWHIxSkhEVHBHa0YwNkUvS0hGQWVvR2U0YS9XTG8ycjJld3BITHFZbW5TTUJiQzQwT2grL3ZSNTBEeDlmckZtektIc3FEalE3dnI5N3dSdGsvdXlWckNseWdjSTJTcGpoTGdoaHZ6ckZ1ejJWQ0ZMV2xDUXFZMk0xcVVoZzRkc3FSb3JsQkdnNEZoOS9lb2g2VlJxM2Z0SjBySkowSGdJWEFzNkh3SHlpM0JHUlRGblh4OFI4NGVpekszdDErVVdva1NZcHRDaVVyZW56OUJFNkplL3loenhJRUhjWWdhSmNLcW1iQ0hGSkgySWZoSXFmbjhJQnFla09oUk00K1h6aFNSdTlQS0FTRnhjVEFHM2ZmUXc4SU9ZSGw4L25BTXhRcVFkMFBTU05XNU42UWlpRG1RZVFQMGdFWS9aQStNSXRHOER3ZjRRS3c3ajQvd0I0UXFBMDhmb1lvWXlSdThQckE0UDBjZWtMaUpvNGhGaFdSZnJTQVJhVHFQRWlHRWN2Qi9NUTB5UU0vSXFoaWluUi9MNndBdFkzbndQemlKYWh6NWsvS0htWnU5Zm42Ukd1ZXI4MWVIMEVBaWtuOG9IR25yRWFrOFFPWC9qQVFvNlB5YUVFZzZqcVMza0FUQVJyYlZ6MDlTVEVXTURUeGY1Q0ZtRkl6SkowWVlhZGMvQ0UvZUJvTVA4QVVmT0Fhd1Zra0hsVDRORWN5ekRVdDFId1ltSHJtUDd4NjVlRVFxUEVlWHlnS2srUU5GRWo5SWl0TWtFWlY4QjhTSXZLQkpvQVR3UHlNTi9kaWFxMlJ6cjBFVVppOGFmemRDUG5DUmFuejBTd1R0RnRTU3c2RFNDRzBRU1ZmSWMvdjFpNmxiUHdIbjl0R2ZLbUo0bHVVYUFDUWtrZzVJVlU2clV3Rk56UkJQdkhENXhKbnJtUHY0eFdsV2gxRmdNaG9kNnQ4U3liU1dRWGJKMkFHWTRjV2dxM0xTK1dvOENQdnlpVkVzbk1ONkhKdytueDZ4VTd4UkpTN21oRmZEekJpZENTV09Fc1JXbmcvbVBDQ0wwbGRNS3ZJaW03a00yT2xlTUlxWGh6UGtYNC93QnVYQ0t3UVhiWmNiMUNvNGdWK29pNUxXa2pDVkJXN01kSFZRRVpCK1VGTVNvY1M0b3dGZVRueU1KUG1oSW9oUzMzS0htOWVrS3RBVHFTL0JnZDdQVUVHaEJZdjBNSW1ZTXh5ZFJQbUtSQkVpMkxQLzErWks0dnk1dzFBOEsrZWZPSVVyUDVRQzJWSC9sS3ZXSENhclNnNFU4V3FubkFXaWxXYVNTUEQ3RU5LVHF3NXFEK1ppQXJPOHZ6K3dmakU4dWU0WlcwT3IvTWZkWUJjSTFJOC92ckRrcVNEUW5vRzgzckRqWmd6cGNEY1VueStuakNHenNLbElIVXYwSDFnaDNlRFVEbS93QWdIaDZWalFOekQvSEtHRENQZUo1RDFKcDVRb1duOHI3Z1QvWUhvOEEvYTBML0FLUzNsU0VDQ2RENFEwV2c1QUFjQUsrTGZLSG90Q2hxVDRHQVh1Q002Y3lCNVp3QkllcS9BRS9GaEFGSk9hZW8rV3NJVUE1S3J1VlJvb0ZxVG9EMXA1Q0VNd2FBRG8veGhGeWxEM1g1R0ZGbVVSazNPalFEQ3RSOTdvN1JHVW5kNWZLSlZTVWlpbC81US9ucEREYUVKT3lsL3dCU3ZpQnBCVUFmVHlpUVdkV1pZRCtOaENLdGhkM0hRZlppTmN3SE5QbVFmV0FjcENCbXAvMGcvRlJieWlBekVqUWRhd3hXRjZFOGlIOFdNTlVoOGxBOVcrUHpnQ1pPSjk4OG1ZZVVWbHl0eEI2L09CVXRRRlIxYUl5NTF6NGZDa0E1U0ZqSjI0RXQ0aUlUTlA4QWNBK2tXSlZpb1ZLVXczdU0vZ2s4Q1FZYk50S0VCazRsY3lTUE92Z0FlTUF5WEtVcjNCekxqd1l3VFpjdFB0S2M3a21uVS9aaUJkdVdYeEdoMFAzWHFURUM1NC9LM0pYOXhBVHJ0WVprN0E0QUVucTcrVVVKcHI3VGsvbWQ0Y1ZKcm1QUDFpQ1lCbGlISXVJb2l0Q1NVcUdJTXhCWlducENRMmRJTEZtUDZXUGtLd1FSVVJrZXZ3amF0U2l5djFwLzBBd1FSQkRJOXM4ay93QzZOaTc1U1NnT2tIbUJvYVFzRUF0b1dRb0FFZ01janhFVnlzbENuSlB0K1JMUWtFQlptZTcxK0VPczN2Yy85b2dnZ05XYU5oZjZaS3VwSkJQTWlqeFZQdGRQV0NDSUVWN0t1RHR3Ykp0MFBtRmxKYmpCQkFYTHZRQ1NDQVE0b2VrWGJac3AyYVpaVTE0UVFSUlJLaVYxclRXTkd4VkFlcmtndnFBS1BCQkVHZGFhSHI2dzRlMEJ2ZUZnZ0NXS3JHN0xobkN5aitHK3UvWFhXQ0NBblRwOTc0SlNRVmdhYm9JSURSbUpBQ21BSEtJclVObmttQ0NLTW0wMHdnYTV4R3NiYVJvMlhoQkJBTUEyb1ljMWNvSUlLcnpqbHloUU5wdVB5Z2dnSUpTamlOZFQ2eGZXZGxCMUpZOFJTaDN3UVFGRzh2OEFFVU56QWNBd29OMFptbldDQ0NJaDdJZ1g3TDhJSUlLcnI5a2NuaUQ1UVFSUlJ0S2pnSjFiMUVFRUVCLy8yUT09XCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIlByaW1hIMiYY29hbMSDIFJvbcOibmVhc2PEg1wiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiTXV6ZXVcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL1wiLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndDRUFBa0dCeE1URWhVVEV4TVZGaFVXRnhZWEdCY1lGeGdaR0JnWUZ4Z1lHQjBZRnhjWUhTZ2dHQm9sSFJZYUlURWhKU2tyTGk0dUZ4OHpPRE10TnlndExpc0JDZ29LRGcwT0d4QVFHeThsSHlVdExTMHRMUzh2TFMwdExTOHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMZi9BQUJFSUFNSUJBd01CSWdBQ0VRRURFUUgveEFBY0FBQUJCUUVCQVFBQUFBQUFBQUFBQUFBRkFBSURCQVlCQndqL3hBQkFFQUFCQWdRREJRVUdCUU1DQmdNQUFBQUJBaEVBQXhJaEJERkJCU0pSWVhFR0V6S0JrVUtoc2NIUjhBY1VJMUxoWXBMeEZYSWtNelJqZ3NORG9yTC94QUFhQVFBREFRRUJBUUFBQUFBQUFBQUFBQUFCQWdNQUJBVUcvOFFBTGhFQUFnSUNBZ0VDQlFRQkJRRUFBQUFBQUFFQ0VRTWhFakVFSWtFVE1tRnhnUVVqVWZDUlFxSEI0ZkVVLzlvQURBTUJBQUlSQXhFQVB3RHphYnRCSVNTazd6a2RPYjZ2RlhaN3BLVkVicWxNSDhKME9SRE0vd0FlRVZjSXRBWHZnaFBSeTR1TGRRM1F4Y3draGE1Z0NrS29mSk5pQVhiVG1mVXh6MG82Q2VoN093dEtBSDBjOFhPYm1KaWkrVUN0aVl4RXROS2lxb25JK0s1c0ZGODc1TU1vTVNTVHZHM0xueGowY0hreG5TWC9BSVRsQ2hwazhvaktZdENiSENCSFlteWRGWWlIQ0pGdEViUXhqa2NJaDdRbWdnR1V4Mm1IdENhTVlZRXdxWWUwSm93UmxNS21IdENhTUFaVEhhWWUwSm94aU9tRlRFalJ4b3dSbE1LbUpHaE5BTVIwd2dtSkdpbmo1cldjQWF2azJlY1E4ak44T05qUmpaWUtrNmtCdGZQV0VsUXNPcEhPQmtuRW9jQUY2dDRXR2RsWlBkOC9UTEtIb21xUzVGdzdIeXpMMkd2dWp5bytlMDFmUlY0d2lVUnltSG9JSXR3QmpyUjdFSnFVVTBSYW9qcGpsTVN0SEdockJSSFRIS1lsYU9OQnN4SFRDaVJvVUVGR0xuRkNaaElTZ3FwREZnVW03MnZjNmNvNmlmVVdRVWhLVHZLU2FTWGZ3bFYzT1dSZ1JzN0ZOTkRrTVFROW1lMXlZc1l1UUVWSVFsUys4WlNkQUdPZFBCOHVJQTV4ODA0VTZaMVdYY05qVjk4SmFYVXAyZnhCS1AzWDF1Ynh0azRoS2FVamVMRC9BREdHMlRzeGNzOTRvVkZsTWx4ZHJhNWpsempRN0x4RmFrdUZWT0hCR1JBZHM3Znowam93Wll3a293VzMyeFpMV3crZVFpTXhJTTRldVZIdHJSRXJtT0FSSlRDcGhoUmpRbWg5TWRwZ21HTkNhSktZVk1ZeEhUSFdoN1Ixb3hpT21GVEVsTUpveGlPbU8wdzlvN1RHTVJOQ2FKS1k3VEFNUnRIR2lXbUZUQUNSV2dYalpSTlNGQ3BKNWdXT2c0bjBpOWkxczQvZFo3MnR1c0c0ZzY2Y29DeXBxM1ZVbGdsVmlXVUFubWZPOGVGNXZrckl1TmJUT2pIR3RsT1RoMXl6U0ZiZ3pEMGtHd3Z3eWErb2k5M3dBS2xPMVRXM2Q1Z1FEZTdqaHdnTHRDYk5SNFU3clBVb2dVZ05ZM2R3ZE5ZVW1ma29sMHJBZk1sTmd6OVdQbUk0bkJ5VmozUnBjTGllSTBaUDB0NVJvTmg3UE01WVNBNEFkVEhUcnhPVVl2QllxcFhFWHpjTnJhMnZEN1BwUDRaWXFUV3BDbEVMS1JaV3FyMlRhekM3ZE9jVXg1OG1QMHAvOUc0eDdZRXhtSG9XcFA3VkVmYlJCVEdtN1o0SUptaVlrYnN3WnRtcExCL1J2U004MGU5Z3ljOGFrUW1xZEVUUnhvbGFPVXhZUWphRkQyaFFRSG1td3NDeEtweVNFcHlTUXpuay9UaEJ1Wk5yUVZpV0V1NURpOW5VR3FMZ1pNV01WTnF6NkFVRlNSVjRhV0pacnVkQzU0OG1nVmdKazVaYW1wSURVbFJUWWdzUnpERnVFZk50T2ZyWjBsdkhZMEs4TmJGTytSd1VMQjJzSEkreVl2ZGtKeDc1S1NvanZMcEpZZ3NEWWh6cGJPMEQ4SHNpWWFndVlFaVdReVM0SmNXQUpENUtObWEvT0pxU1o3SU5Vd0dwWU4wZ0JpUE5qcHd6dTBXeFRqQ1NyMk0wZWp6SkxSeEN0SVpoSmlpZ08vQzREKzZKa29lUGNpN1ZuT3hpcFo0UnltSldJNHdxakRKaWtWTUpva2FFRXd3QmpRbWlTbUdxVUFRRG1jdktOWmhyUjFvZlRIYVl4aU5vVk1TVXdxWXhpT21PdEVsTUttTVlpYU90RWxNY0pBaEp6akZYSjBOR0xmUXhvVk1jbVRRUDV5K3NWUHpEdU5Ea1VrTVMyUU9aTE1lRjQ4L04rcDQ0YWpzdkh4cGUrZ1Iybjd5V3BLMEVrR3lnUzlQUVpnSDR0eVlZbkZsUzFvWHVwV0FBb1hLZ29nTUwzdURxOGFHWXBNeVd0S21HaEJ0a0JmcGZQSjR4L3dDWmVlSmFxZHdxQ1ZNQUFDbHJod2N3T1BrN3g1YzhueDI1MVRMT0NpdE11S3FTcFNWbFV5a0NrMHNHTG55WmhiUW5qRklTUVpkcVZCU2lwVEVBcERra0M0L3B6alJUY002QWtrRlJTTFhkMjFaVjJMYVFBdytGcENsVFNudTFySnBBdVNhYnVjblkyNXhMSE5QL0FHRmFKc0ZTN01BbFJCR1J1TFZXMElWd3plTlpzWEVqRHkxS0NYbXJJU3lFaHlBN2dFdWZKaGs3MmpQWVdVbEpBQUFTQ3dDZ1dOaDRpMTh6WnN5QnBCbloyRkU2WWxLeXBLVlRMS1NPSjhZQWUzaTlCb0lXY3ZVTWpmWVRDcW03UFVwWVhXQ1ZwcUtpd1M0cEZWd0FISGwwak1LVU9JajB6RGZsd2tTRXFFMmpjVVNRcWtpeGVvN3NZSGFHRU1xWXVXZlpKSGxwN21qMlAwK2RKdy9KSEl2Y0gxY0FUNU44V2psK0E4ejlJc1V4eW1QVElsZWxYRWYybjZ3b25waFJqSGprcWE1Y3BLMUd6Tlp5Q0RscTk3UWYyZnMrWktKVXBTQVFEWXFUbTJSQk9kOGpFTWllZ1RtV1FsVEVrc0VuZzFudjV2eGlwdGFmTFFSTGtxcjNuVVdKTHNMcEpBYXdJYnA1ZlBTYm0rS09oQktianl0Umx6RmdKZHd0R1Q1NXNEZG1ab3M0QllLaWlYU2hTaXlsRm5PbDFDL0V0eEhXQk1qWkN5RWtNRUtDWFM3S1hlMlRrRnpweGJqSGRyNHNTOXlVRkpWY0ZKdVF3MEpHUjljN3hvUWc1SkxvenVqMHJDczFOMlRaenEzQjgrc1dLQm9ZemZaakhudTVhQ0hKRHFJY2hQQnhrQ2Ira2FVSmozc2N1VVV6bWVtSUtNY2FITkVjMmNsTE9jNGFVMUZXd1UyUENZN1REaEhRSWF3RFFtSVpzdmZSbUxLMEZ4YmsvcEJUWnVCTTJZbEFzK1o0SkdaKzlXalZiVTJWS21nU2dFQmFFZ29DVkR2VURJRlNUNGsrKzlzNDQvSjh1T0ZwZGxjZVBsc3c5TUttSlY0U2RMSkU1RkJBRm5CR3QzR25WbzRTT0lqb2hueHpqeVRGbGprblZER2hVd2pNR2w0YVZIaTNTT2ZKNStLSFcvc1ZoNDA1ZlFjUkVhcG8wdjhBRDFpTlNzamU3Wjg3Nnh3S2poeS9xV1I2aXFPaUhpUlhleHhKT2ZwOVk3aUVYQkwrRk9wMEFIeWhwTVNUU0NsQnpkUE0rMnYrSTgrVTVTZHlkblNvcGRGVlNCY0hweDV4bk1YaUJKVXBLbEFLVVFSWVpFNUJoeHZiSjlZMHlRY3pjKzdXS0cwY0FoZjZoUW1zYXFzOWhFblhiRnlSdFdEMWxZUTluSVoyZkxRNWV2QWNvR1RNSUtsVERkTEFNbDZncFRVcVpqb0NQTURoRVIya1pTajM0VWxPU1FMa2wrdVRNUDhBRVMxR2NsU1pkU2xJU1NxN0pCQmRpK1l6QXZmcERLTW8vYitUbnV5K1ZwbU1wSm9LQ2tLcVVvVmVISm1aMnlITzBDWnpLSVBmVk1wWVMyNlF0eWZFNEpBYWtkWWdSaTVoVUFwQkJTQ29rM0pCVUVraHJPK3JabUNNekN5eExyVUFiSktzM04wOEdZM0pmMTVzbDhOaTlqSjh4MFZMS2dIcUo0bHlEWVprT1BTQ1d5c1NwdTh3Nm1LQWsxS0lMUGJXd2I0OUlHeVo0bUh1eXRWWlNHUVVzbEtkUVZFOEJxSTdoWlUwQk10WUNVa01GRktsSjZrYXVYOUg1a2NiKzVyUFJmdzRrVGpPS3d4bHBjVWxUS0wrMEx0bW9xSUg3aUhONE85dDhJMHhNd0RQZFBVWEh1ZjBnYitIT0FuQlFNeVltbEtsRUlGQ2xYY0EyZGszeTVaV2phZHBNSUpzcFNRMVEzZ05YRi9oYnpqcjhhZkNTbDlUU1ZxanpZcGpqUktSSENJOTZ6bElxWVVTVXdveGp5ekFIdWtybWdwWjJTa2h3ZWJabmg2bUlFN1JrVmhabHBjaHlFdUM5c3RHekhHMmNVNXUwRFNrQUpZRjZYZEp1ZERsL2lLaUpJV29zYWIyREV1VHh2YmhaNDhOWTd0eUxocVZqRE5Vb3BTa2xLWENhcVFLVGFrYW01dDA0d094RXRheVZNYmxtT1lMdFRZWjI0REtMeWRpazNTZTdERUZ6ZHRRM3RETFgxZ2xnMWlVUWsrSkpHUllMelpSenVPZkRqQzg0eCtVTkJQc2xoVm9VM2VuSUNoc3ZhVUFlQUpQcThiUUNNWnN6Rnlrdk5uTFRTbHlBWEt5VFN6c0h6WVg0Q05Ec0hhWXhGYXdTQllCSmF3NGx0U1hqMGZEbkxqNisyUm4zb0tOR2EyempOODdwSUJBdGZJOHVZalFZNmJRZ3FiS01oT0xxdVhKeUdZdG5jNlorY1EvVXNtb3cvSStCZHNKeU5vTEN4b2tBTzRObklCZnA5ZWJhT1VYQUl5TVl1V2lXU3lpMlNpNVV6V0xKVHFTUU0rQmpZN01uQmFBcElOTndIc1MycmFSWHdNbjdhVFlNeTJhUHNoS1VaNElCcEFOWEJpTFA1Z2VrYlV5UU1raHc1SFVqTitNUWJMd0NaU0VKQVlnQithbURreGNNY1hrNUZsbHlyNkR4VktqemJ0aEttSXhSbUtObG9Td3lhbCtHWjQ4bWdPaWVGRmdwOUwvQUZ6amI5dnNIVkpDL3dCaDU1S3RwekNZOHlrbFZRQkRYenV4dnhCamtPM0c3aWd3UXd5UGxmOEFsb1pNVXhabkxQa3c0WndwMDhJRHM1T1FHcGJKemIxaXRLcnYrNVZ6d1R3QWJoL01JVUhZWkxEVFBRdmtXaVVrUTFFa0FEV0VWaU0yYWlPZk1ZUDhMeEhLVVRaN0IyRGNTU2ZVa3hIUHhzcFBpbUpIbmxiUVJRbjlwNUtiSkpKL3p4amJNMEhBZzUvZmxFV1BsSlVta2h0QWJBaCtCT1I1aUFtRTdRS21xb1FnQUgybExZQ3h1ZU9Rc0RwMWhrMzh5VXFxbkpUTWMwc0FXR2RLdFJtUUxXdDVJM1RwZ2NrdXdmTXdpcEN1OElVVWlxck5kblNrT3dPNkFvOUhmV0tKQlZpRkpSWkZCV3NwT2JPQVE1REtZZ2NiSHJGMUM1MHNncldWR3dZcVlIOXdEbHFodXRrTHRBUGJ3V2toZ0VrcEtWZ1dGc2h5Wno2K2NkR1AxU09TYlhzYW1RWmRsUFZRbmprbXAyWTYyNjJnRmk5bS93RE1DbGtBTWJQZXh2U1MxeU12ZnJBWEI3Uzdza2dPU21raHlNZ3p2YzVmdzBYWisxMkV1Y0NrcVZVbGFNMlNGRXB2MExla05IRE9EMC83Mkp5c0tGVytrZDJrOTJTQ2J1dElZdXM2a2k3ODJqZDlrTVJMbVRXbXBjcFNaaXlwaU1udWh3NlVGUjNRNzhSSG0rQng0TktsS0FJSUNqY0VpbXhHWWQxRUZ4b0lLenNTRUJSY2t0dkpOaTJUcGJJVS9EV0p5VGkwZ3BtLzJmdGRLVlRDbWJMWEtTVkJJdEt1a0xaa2daRWxyTVhQTnpQaDl2TFhPVk9sbGpRQVVzVjdvQXFWeEEwejExanphV1hDY3YzSkRwZW5pQ1BQS04zK0gyQlJQbnBTRktaTHJKQlp5TFU1K2VYSHFGYmZKSU5oTEZ5aUM3Rmxid3MyZktLNUViZnRYZ0twWVdMbFB3MStzWTJtUGU4Ykx6aFQ3V2pubkdub2hwanNQYUZIVFlsSHo2cVkvbnd0N2hCVEE3Sm1oYVNYVHUxZzVOd2Q4aThTZmxaU0ZpK1hFUGxyekwvNGl2UHg2Z3NsSkljK2YzOUk4aHljdFJMaHp2SnFYclNpa0NvRmdONXdOQVdMRThmS0tPSW1pZ3FBTG01Y2daaXdBMUd1UU5vNU8ycTZHRnlFdWZWdmxGRUxlNUlKNE5rT2VrU2pCOXRHQ09CMmRNbTBQU21XUlU1NUdrODZ1WEJ1c2VwN0x3a3VVZ1MwRElCN1hOc3lSYVBKRVkrWlVoQ1ZLczFON0M5Z0FiQVBIcTJ3OEwzTWxOU3Q1UWMxSzFOMmVQUXdOV1RtVnRxN1VTeTVWd28yQllzcTl3NDhKQTBqTDRtZXJlQ1VoUkxsbmEyaDB5dGVMbU9tMVQxaHJ0Y25RNWhtUDN5eWk1czdZQzVpYWxyTXVTQmRmN3Izb1NNeVRySG5lVms1WmRsc1VkQS9aMnpWNGhkRXNWSy8rb2VvMzRDNDEwajBmc2pzOENkTGxWQ2FwSkpXUUFKVXNJelNoSThhbnNWSEorTmdHR0tUTFIzVWhJbHl1VFZyMGRTdlBJZXVrU2JBQzF6Q2c0Z3lSWUlUSVNTdGRpNHEweTVDSXh5UytXOUYvaHBLejFqRjQrVktEekppRUQrcFFIeGdCaU8zR0hjcGtKbTRoWC9iUWFmN3phS09DN0t5d1gvTEtXcjkrSW1BbnJTS3ZsQjFHejFwVHZUVVMwalNXaEtRUC9LWlVSNU5EY2lkSXhmYTdiT1BtU1MrSFRLbHFhMVZTemZKUkFJQTF0cTBZM0RZbWNsM2xtNXpCQjkyY2VuZG9kbnkzUmRTMUc5U2xxWHBvNVllVUNwR0RsQllDeUFEeEkrZG9WdU5GWTJ1akM0bkdxU3J2Q0NCa0F4Y0MxcVN6QTV2OFd0RlA3UVczVUMzOVYvUVI2TjJvN0wweSs5a2dxcEc4RXNDMzdnQUdMZEk4OHhYZHF6QVArNUlQdkVTYlJXTXJCVS9iazAyQ21QQUovay9DS3kxejEreXBYVXFBOUN3alNTMHBBc3c2TUlxNGhTZXZxWXlraHJabkRzOWY3a29mK3AvY0lYK204VktQUlB6TFFWbTRrRElmTDRSVzc0cUlEWi9lWmgrWk4yTnc2VVMwa3BTRXFHcmh5Q1hjdGR4OE5Jc2pIdkxxVWduMnE2V0pBSkJmaVg1eFF4NlZwTnpabmZSdXZXenhST0tJZXNsYUZYNDBrRndSeWZTTndVOWtacXRoL1pXSUJGVHVvS0RBSUZnMVFMbHhyYmsyUnRENXJLUzVTTjYxOTVLVGU3Rm05MlVVY0JPU2tvbXBTb0dZRGNvL1RUU2tpcWw4MkE5QmxFMHphdGFsV1NCY3FMSnBUTXl2MUQyYlVSSndmSjBKWUM3UVlFTUtXcWR3bENiTVNiYnZ0WEdiTzNHQmVHMmZVaW9rQXZrU3lyMkc2cHFuSXpCNHh1dG50U1ZMN3NGQ255eUFGMGpuQ3grRHJKWFFoU0R1M1Q3SUlaZ3JYSSs3cmVQbE9QcGYrUU9KZ1pjd29TRk94MERaTzk3MjB0OXZwTU9KaG83eWdxOFFXNEFXQ0dBRm5KWjdRVG5ZSlFGVWxNdGsrenU3NUxrbFNHM1g0SmE5dFdnUmlOanJLalVsS1VFTVRVN0tJOWdBbTlYSHBhSGVXT1Q2QXFpeE5uRksxUzFJQVRrbFl6dUFBeDFBY3hxK3hXMVB5eTByS1FzT2RiaTl5T2JNTkRBSGFnUWhJU1M0Q1FBQmV6TVNBTkxQNUhnSWRzM0ZLU1RrUXdMcGE5SWU3RnhrSEVjMG01UnRCOXozRkhhbkR6a05VQVRZcFVDRDBiWHlqTll5VFF0U1JjQTI2RzQ5MFpERFlvWWliTFQzZEtRVWdoQ1FDcW91UzZpOVEwR1YrY2FmRWJJN3NWU3NYWVg3cWNoU1ZFRE1JcVlueWVPenhmSWNKYjl6VGdwTFJ4UVBLRkV3aFI3Tm5LZk9zNUpCTjN1WHp6MWg2SlpWMWg2Wm8xUzVleHZEakxlOVc5YlNQUGJMQ2tTNlhKdFkyYk9Ka1RpcTVaallzMVhsd2l0MzVMQVo4ZUx4MmRMQ2NqVStvNDZpQTFmWVNmQkovVVRuYlIyOThheElTVXY4K3VVWkNYUFlFM2ZUbHorK01YZG1MSlZXYnNmTThnZmxBYmFRQTdnc1doTlM1cTFFQ3dRa1ZLYkxOalNQckV1SjdiaElDRVMxTWtNa0tzQU9UdWZXS2V5eUF0YWc5SlM3RTVNZFBYM2VxbTQ5RkpJSThYTFM3TzkvUGxISzZjdHF5c1oxMFJUZTBtSlhrUWtjbUh4Zy84QWh1Wmk5cDRVclVWYjVOeVRraGZHTWZoU1NWQk9ReTBQbUJHOC9DVkovd0JSbHBJUzVUTVlrT1VFSUpxU0h6WUZOOUZHS1Rpa3RJZFNiV3owN3R4dDZmaEZTNXFTNkt3Z1N3UEdia3ZiZ0NQU0MzYkNXbFdHVW9rc2xKV2tCM0tnSEZobi9NWjM4VWxxbC9sVkpPK1p3WmVTazBsUGh1MTM5SGpVOW9wUVJoWnhSVUNFRWcxRndlSWM1eHh1TDR1d3BxMVJnZXorMFFVSVN0ZHdWVWpNMDVzZUYzdEFYdEZpSm41bzVsTzdRRTd4cEFEdUJjWHFnbDJObGdKVnptTHp6eUVDOXIvOVlzNWI2UGdrUXMxVUVpMGZtWjZvbkdtWGdWTGxBcVVoRzZHSkw1QjA1c0h5NENQS0Z6Qk5CQ3FTUzVjTUM1NlJ2TVhpRXlzRFBVOUZLZkVIQkRrQTNIV0R1eXV6dUhRbEg2U0NVcEc4VWdsUmE2aTQ5Qi9EVGxGeWFRcWtvVy81UElKT0ROSUhLSXNkZ1ZwRG1XdGk5NmQwQVprazVEbkh2a3JEcFQ0VXBIUUFmQ0FmYVFPdVdMTXlxZ1dZZ2doaS9XTFF4YjJLODk5SThGNzlKVUVnb0tpUUFBcW9ra3N6QWNlZXNiRWRoSnlRRE1WSlFTbXBsTHpET1dzWC9pTXhoSkNVVEpiSi93RGtrbTFPVHExQlAyMGUyN2FrQ2ZoMUpscUNabENVaFZTUjdPVlFkczdobnVScThVblNqbzBtMHp4WGFwUkxKUk9zcEtpazUxZEdVTEFXdHdnVkoyYmRTNmU4VXBWU1ErVjMxeU1TZG9zU3VZczFvL1VTZDhGd29teVhWdkc1S2FtSEU2US9aZ3BwV0VxSnlLVWdxWWFYQnNiR0p1TGhIVEpTN0xOMC9wci9BT1dmWVlrbHhZaElOOVc2amxETVZocEl3NU1zS1FFZ2tYZDBtOXp4WjlSbEY0NHVzS1R1MGtKVWYzUHZEalp1V3Vla1Voc3VXbEc2bFp1QnZFa0JyNjVhM2lVWlYzb0RBbUV4NmxxbEJDQVdBcUtra2dsTmd3Y3ViaHJPN0NEZUwyd3N5VkdncEl6OW5nU2FTTnpQVHJHZXhXTFRJbUJJcFVFN3lXZmRVUm1XQWRRY3RkbU9zRUZiYm1USllXZ09wRnp1ajJraDI2RUdPcWVQazArT2hVd3JMbkttUzBMVWFxd3B5QjRTQWFUWUFrTlNOWUg0UGJJWEtLVjJVRU9rR3pzbG1EM1ZxTFpHT2JQbktEcElLR0ZZY0QycmtsclUyOFBsRmdUMHByV2tnandra094V0d0VlloeWJEakV1S1RhcjdCc0dGS3hNL1VKM3lkQi9VV0FJeXNjbUxuVjRuUkxtVmxKQVlBWERpcDNEN3RtSWZUaEJEWitFbEVnelZJQlVCTUxyQkFKUzVKWU9HSXlEc3dpVFlzOUU0cUsxRmtxWU1sd29IVW01QkZpM1hqRkp0cFhRS05kMlIyUE5seTB6TGxCSUNxUW1zTjRnb3NvQmtxT2VqNU5GM0g0bFltbVRZMUlxRjNMT1E0WlJENkVzOW9nN0g0K1gzckdjcVVsU2N3a1pnM0NuY2NUVVFXRm5ad1QzYVJjZ1lpVExYTlE0U0FaaFNBd0tuOFpzN0xmUFhuQzQ1cExtUFY2c0FCT0orMUkrYUlVQlp1M3ByMldtMXROTFBuSFk5RDQ4UDVaSGd6eWlrdFpoOTg0WUZFWGl5cWVvQnl4NVhZanBFYXBvS2JjWHBiVEp3ZEl5c3hUcUlNY0Jpd3RBVXplalEwU2pGTFJoOGtaRWkyclFjdytMbFVkMGdGT3BKSWM4UkFTUkxKTGN0SXNZZFAzbEVwN01hVEJTV1NWcURGUVlDenM3dDkyZ0J0V1FBcFNra0FPeEF0ZnF3R3NHNStKRXhrc2wyTEFPN01iaFdSRHNPRUQ4WGdCUUppZkFYQUk5a2dzUWZNUkhBdlZ0MDMwUDlqWmZnN3NDUlBsWXViUEJJUVpJU3hhNTd3blIvMjVSNkYyWDJMaGtiUlV1UWdnSUFDVHZtNVFvS2Nra2FqM2VlTC9DL0gwNEtlZ3R2VGtEUDJRaDhzeGVQU093dUZGTXljbERMSktGR29rS3BZZ2hKREpzYnQ1d2tyYzJVL3dCSS93REVSU3pMa3kwU3lydkpxQVNBQ1FBdEJZYTNJR1dnTUYrMVIvNFNkL3MrWWp1TW5zVWxaU0NMcGRMdG80M294SGFMYWMyYXRTVVRWVWl6QWtCK2hjUXJTZDB3SmRGYnN4SXBRNTFLaU9oTUNOcjRZL215R3VwYUNPaHBnM3N2RHJSbXNrWHM0c2QzK21Da3VXQ1FTSFBFc1Q2dENaSUxwc3RDVDdvb2RyWC9BTlB4SUdxTk9BV2trK2dKajBtU04wWGV3dng1eGpNWVU5ek1yU0ZKb1VWSklCQ2dBWEJEM0JqWVlTWlVnSGtJRWF1aGN0MFRSazlzQjhaYWlxbFFBVWtPZjAzOFdiQXQvZEd0Z1h0RFljdWN1cGFFSHFnRTVObWMvU0x1TkVVenc2WklQZXNBYm1Sa0NTUEVYWWFDN3R4MWkvMnA3YnJVUUpjcEVvME1vc0FzbFBCWHNwQkZ0ZGVFZXA3VzdNeVRKV2xLRU9VbElkRXNBRWdwQ25DSGNPOGVKZHJ1emMyVXBNeFFkSUNhMUlJVnZtcHhNc0dOUUlJYlEzNFRjVTNUS09WN1JuTWZpeXJ2RmswclhjWEpOM0xQbTJYcEZqWThqRUpTVnkxVkxzVkJUcERDOUtTYzFkUHBGanM5aGtLSlVWQjFhVWp3Z3NjeGJsRmtiSW55VnFSTFgrbVhVRWtleW9sbVViRldWOWVUd3M4aTNEWDVFYXZaVmxTWnRTbE1rRlNBR0ZnbFNtM2p5c1R3dWJ3Yk5rQk00VkZtVmNieERPbDFEbXh0WjNpWkV0THFJQ2xLRnl4U0E0M2lMMzBlMldjWmpiY3hVcWVGRWhrRWxndFNrM0lPNFRkMlNMRWtEanhqSDk2VkdmcDJEdTFFdGxtaEpwUUFra2czenBOUnpzTTRtMkJ0TVN5bVdVbE5qVTd1Ykt5QnNIcTRaRG5CN0d5NVU5TlpLZ0ZKS2FTb01vbGlGWnUrdm1ZRjRxU0VnaWVrQk9RbUJyZ25oWVpKSFVSMHd5S1VPRWwvZitSWC9JN0VCUkJJU2xyRjFVaGRKenVDQ1ExMlBBY0doYlBrb1VEVy93QzI1SVo3c1FlZDI1eE11U2tyTXlXSHBLUXRLa2tLSUNSdkJySG8yUk40ajdRU2lKVlNBeGNLVVJ3Q1RwcGJOczRWU3VvOVdBSzRyQXlGa0FoS2xVamR6dGs0UEFrdmxiM25zcVVKYUNFSnBUbUtlbDNHWnl6UEdNM2dOc29aUUtFcHNBRk8xaHhPaGZYbTBYMDdXUXVTeEpCcFliNXFKTE9BK2JBTUR5aEpZWnJUdWh1U05EaDV5RUFHWHUyTjI4Vmc0WnJPZEdFUnpKNmxqOVFsVFpCbnNhVForWHlnYmdaOWFnaEpDUmE1QkNXRkxPem5PeDV2RmphQktEU1ZFdlkwa0VlRVhDaFpuNThlY1RVR25RVTdKVjQxUkpLVkxTSE82RFNCZklEUVFvSC9BSjllbFpHbHpsNUJvNUZxbUhaaisrSTBjYzNhR0JRSkRKSTQ2dkhWTUErWjYvS0dpWVdMT1BsSG9VUkoxS0hoQUQ4NHJxSnl1M1hPRWhWNzNQRjRtVFNldWx2bEc2Q1JwbkhRZmZQakZpVUtpTFc1R09HV2tBNVBZOHMrbyt6SE1NdHNnSVY5YUFHVTdMQ2tKVXZSd0tlb1luaGQvV0lwTzFPN3d4bGpNcVVBT0NUY24zeEtuRXRJcXFkdDFyWmxTczM1RE1SbjFxY3hLRU9lcGV6SFVuSG8zLzRma0hEekE2ZzgxM1MxbVFqVTlUN285czdENDlDcEhkaGdwRGtocmtFMkowSno4Z0k4Uy9Eei9wMW4vdXEvL0NJOWU3Q0ZJbHU0M2lvOVdaT3ZTSjVwOGJLeGp5UmQ3VnJJSWF1eVQ0VXVOY3pTV2pBWUdhU2trMU9WRTd3WStoQStFYlA4UWUwd3drc0lDVktXc09XeVNPS2pvOTdjakdQd2VPUlBsQ2FqaXlod1BNYUgrSVNLMFpCWEJZcEs3cFVTYnU0SS9iayttY1BuYlNWS0kzYWtubmNkSUdiR1ZuOThJczQ5WGg4L2xFNXl0MldqR3RCekI0NlhPU1FDN2dncE9iRzF4R2wySmlTUlNUbGxhUE1RU0NGSkxFYXhwOWdiWktqY01vZWl1TFFzVzF1SVp4dFV6ZXVlUHdoWDRuM2ZTSTVFMEtTRkRJeEpIVXNrbjFaeDBLL0UrNzZSNUgrS1dDYWMzZWxJSXFLS2lBdXFvRXNsTFB1bmVMK0ljbzljYVBLL3hpVEozVktzcEJTVkhqWXNCd0xjMnp0Q1pITFhZMER5S1ZnVnBXb0FtZ2hnQVdVY25BWXRvM1M4YW51Wm9UVXF3c0ZPbXB5ckpsYUd3ekRubHJudHFUVWtHWWhmN1NnMlkrSkt2T3JUaUlrMlB0eWdFVFhTRmtrYXBBM1EycEJKZThUeXhuT0tra0MwbUxFWXFtYnZLYWE3T2xOcUdjQ3JNS0p6UE04SU95TzdVQ2ljQ3AwV2RMaFJ1ZlRkTitMUlV4T0dFNEZLR1d0bkRGd3pFZ20yb1B2NndOd2VKVjM1VFBKQ3dBQWtLWUIydUd6K0ZvUng1eDEydjgvZ1BRUm5ZS1ZLWXByY0FuTXVIZE83Y0FGdUdtdWNEdG9CT0lrN3MxMktYTCsxbHZjTGUrRG41VVpwSkJLUnZQVTROMklmM3dIbWJNUlVaY3hTZ3FhUW9BSTNTUUxid0ZqbWVYS0JpbXJ0dDJoV2dac2hjMlNsWkllV3BRQzFYSnp1cm16QWs5WUw3S3g2WnlUS3NVckJRcXdzS2M2dlBOaGxBekI3Uy9MdEpLU2FIQ25UVUxHekFObnIwMWN3elpPRzd5YUp3Q1Vpb2xnOTdrOGJhL1NPbkpGU1RsSmZaZ1RJdG00R2RLV1VnZ0c0QXM3bTNNQjJCNWlDUCtpRllaUlNGdG0zaEpZa2hMWHNUa2JkWWsvS3FSTkNBaXBDZzZsa2lwSUJzb0tMRnc0RjN5aWRVd3l3RktBOW1vamR1V3VsL0VPamF3czhrbTdUVm1vaHdzdGNsWnFXQ0tpYkRQZXVhYnM1NXhPbVlxLzZacUJleDB2Wng3TDM4aGV6UmJTc0ttQUFFRUpWWndYSUJheERPU1JseHlMUlpHREN6WXNEWWdobkxzZWQ3V2YydFlqOFRlME9rQ3U3a202MUxxTFB2R0ZCdzlsSnVnUTJqaFI5N3dvcCtTbE04bUt6SFVySXloMGpEcVdvSVFIVW9zQkd0N01kZ1p1S21yUXBWQ1UrMVpUbHlHdGJUcmQyajBwU2pGYk9kSnN5TlZtYUpKRXRSTERQcVBuQjNhM1pDWkptbVYzaUZxU0FTMVFZRitJWjdlK0c5cit6UndTMElycktwU0ZxZE5MRlY2UjBoZWNYcFBzTkE2Wmd5a09WRjJ5NW1IYkVub1RPbENZa0tRVnBDbklHNlNBUTZpRWdjenBFV0ZuS1dVb2NacFNMQjdxQStjTW00VjFsSXZkUXR3RC9BQ0VaTDJrWkkyUDRoOWwveWpLbElVSktqYzJvRDNTd2VvWmtFbXprTm0wWWlZNEpCREhobEh1dUkyek5VTUVKMHBJWE9sVXpFekdCY0NsWGVTMUYyTFZDeFlLTHRuSG1QYWZCMTdSbmdDeWlaajVPQ3hKSHFZamh5ZXpIbERlaDJCeGE1V3pLNWFpbFJuRU9HMUxhOUk5UjdQN1dBS1phbFV5NWFTVmh6ZFMxYm9ERGpTWXd1enBNdEdGTXNwY2I2Z0ZBS0RseVB0b3Q3RXhYNnlTczJxU1Y4Q0FzWmpWbUhtMFJ5eVVsYUxSaTR1bWVqZHNGQ2FoUlltb01TMXJCWVVIOGlJd0haa2lWTW55dzFDaUdGUWNFQTVQZmg2UWY3UTdVcVN3ZGwxcUw1N3htblRLeCtNWmJCdDN4dGwvRUpGdGJNbGVqVDdFVlkvZkNMV09YbDV4UTJNYkdMR09WY1JLWFJSZGtaVkZyQnJJQUl6ZDRvS1ZGbkNxM2ZXTmo3RGs2TjEyWjJzRHVuSSs1WDBNSHRzcGZEenJrSHUxa0ZLaWtnaEpJSVVDNlR6anpQQzRvb1VGRHpIS054STJ4TG1ZZVltc1ZHV3NCaUg4SjA0eDBZM3hsVDZPZWNiMmp5M1pHMWNYK2FrSi9OemxvNytRbHUvVVFwSldnS2NFM3M3anJCNzhZdXppMW9NOUsxRnJCTEZWeTlTam9rTllkT2NBamhTbkdZWUVLUzAvQ2tKVm95cFQyZXd1R0dqUjZsMnhsSVZLcFc3RXRaVkl2YmU1ZStGbEwwMzlUUDVqNWl4aEJsaFNqU0U3b1FCcXdkVGpSd2ZUaEFmdkFwYmtsam5xVzVhUEhwSGJmWU1rWWNxVFl5bkNhYkpMcURraHJ2ZjFqelZTR2pzeGZLUmtxWnRPem93NjFBWWRTMExTQVNvbFJxT1RGSVlITzN1ZTRpYkYwb3JVaGYvRUFoU3FnTWhaZ1FIQWU5dUl2QS9zanNzcG16S2h2SlNBVXVHSVVIdHg2dUdqdTNNUE5CTTZZb0JnRTJMN3RnUVFCZHlvUDVSeHp4L3UxZXY3b1BzSFphd0ZDcXpnZUhOYkV2bHE1SllSMlpOclFVME94Q2sxRVYrYkU3ekFOWVBBRForMFUzUXFhRGNCQnV4M00zSnRjM2lnTm9yQ3d0SGVMUVVrSjNXSXp0d0xIVVovQ2Yvek5zM0kwODlVcEI3M3V3c3FTQ1ZKY2tFTzRVTXJBNWpwQWZaMjI1ZmVGQ2dKYWN3K2I2Z2tsbXpiSjNncnNuYUFuaFNsc2x6d3NwV1YrYk5mb09FQ2R0OW1WdVpxQnVxSktnekJJOG5KT1pObzJQaW00Wk5NMit3M00ybWhBU21vWEl1TlhKZjVhNkNHN1JBVktVeVhDR3FOVlZTVkpOVzYyNkE0L3RNWktlVlRGRTFKcVRZTUdld0xoUE12OFkwR3dNVGlFeXlvaXBLU3BKZk1aV0kxVHZFNjVRMC9INExsSHNObGlUWXBxQ0R1bWhWN2hSZG5GaVhPZjlSaTB0S2xUZ1FrZ1U2QzZqbU91ZWwrc1Z0a29VcXBLVUVJY2toM1pMQnlrOGljeGRqQjdadUlmZFdpcWtxRklMWktBRndiN29ZUkdXbmJDaVdYMmZzSG16WFlQdXRkcmhpWEY0VWVrWU5qTFFYSmRJdWM4dGVjS0xwdWg5bnk3c2xZRTFKTHNDY3M4anJHcndtM2NRZ05KbWlVbnZPODBKSzJTTGtpNDNCdWx3Ymd1Q1l5c3VSVGNFRW5oRTZTWTc1eFVpS2JRYlFnZDUzaXB4bUxVWFc0SVNRNzBsU2lMV0dReXNJVzAwaWVvcW1MV1hiZXNBQUFBQUhjbkxoQWxFU3YxOVlSNC9leGliRDRYRHlsb21BelNVcVNwdDFuU1FROXIrc0greW1Kd3FKeFd0REpBVWFscENpbFoxQk9UM3NJem9uQUh3anpjL09GTXhKVm1iY01nT2dGb1Z3ay9jQzBhanRWMnQ3NVV2dXBzeDBBdXE3UFpneHNkYmw0eSt6c1ZNTThLV2FpeWszSUZpbG12YUkyRUk5STBZcUtEYllUVnRCcFNBenVuUEx6Z3JzU2N5MG5tazU2VjMrK2taQ1lTVGNXNVo1ZWthckI3VWxpamV1S0xaMlNvV2hKWTFXaWtjbXd6aVpsUWZNYjMvc2lyaFJ2cUowMTQ1UkRNMmpMcHp1eGZQSTE4T3NXdG5LU3RKVmU2aUIwRFJPVWIwaG82N0N1elp5VXBMbUlzWnRORDNWa0Q5WXF6YkpOSUx0YXppNytzWlA4QVVVU0FEbTF3YmVXY1QrRzMyTTVwYlJyVjdUUmJlRi9uL2lMdUZ4NkFBS2c3L0huSG5zOVMwNktHaGZRK1JPa1dObTQxcVFRcXh6Yjc1UWZndGJRUGljdE05SUU5SnlVUFVSUjc0cFdTTkRiWDR4UmtBS0FJT2NTOXlvYSsrRWJrMFBGUk5qSjJQTG1wUmpDdFlVNkZxNEF5eU4zS3daQUVRZHBPMTNma0pvS1VwTDV1NTQ1Q0JXd2R1R1U4dGQ1WmNVdTJiMzlURkxHQ1VDdmVCRm1iUjc4WHRsRW56WDJHU2kvdVZlMEdKVE9rTGxwREZRMXkwdjdvd0dJN1B6bU5rbTJpaHc1dEd3WE1FUUxYSFRETkpDU3hSWVV3WlFsS1dLYW1CTnc3bTVIckZQYjBpdVFzQU9XY2RmTDdPVUQxVEloVk1qY20zYkI4TlZRUDJwc3I5QUZRQW1wY3FDUis3aUc1ZXNETm03UW15VXFZcUFJTEROSVV6NUZ3OGEzWjZ4V2dxRnlmTmhkMzRXRm00UUI3Uk5Vb0pMQUxjQUFpeERrbnpNVWhrNStpU09lVWFERXVUTFNrVDVZQVVRQVE0VUVzajJDSEJkUUh4aTNzNmNzVGFGTVNKU1NVM3pKc0dkblk4TlJ6alA3QXhjc1llWWhadVZPd1o3QUM0YXdzQU9aUEdEdjRlaENzVE5LMGxRWFNsSXMxZ1FYZTlpQmw4NG5MSHFWK3hsc0lvMllqeEp3NzdoSGVaZUhWN2h3dzgvUUU5bVlOU2twM1NVcU43ZzNEZ0tMVzQrUkdiVzEyNnpNVzROOG9nbHJsb3NIU0IvU3BoMUxXam5hdmJaVGlaanNMc2RhZ0p0UkNTcWNnZ043S2xJeUwzdDd4R3Z3L1p4S1p4bXZaUzFMWUJtS2k0OHVVWm5zNXRRWWVVdEIzbEdiTldpV254Szd5WVZCeWJDMStoamI3SHh4bXlndFNDZzNCU2JzMXVBdEZQUzJCVVhBMGNoZWtLS0JQbEVBeElpYW9hbUhVUk5Jd2FsQXF5UU0xSExoYmpIZlpGRWdtajcrRVBFeUlab0ZnbDJHVDZ2bVcwaElqR1pNa3c4UTBLNUQwK3NPUUlXekR3TlhFT0FqZ1RFcVVRckNjU2tSSUVmZjNsSFVKam9FQUlpaDlZbWtURkk4S2lBL2svU0lrbldPbFhEUDcxaEdFZjNzeHlvTFZ2WjVOWjhvWWl0Nmd0UVBJdC9FTk13Z09UNkNHcVZxOEF3eWZoeXBWUldxcmk3UjFXSGNNcGFqMVAwaHN5ZFRmUGkwV3BDa2w5MGx1YitrSFlEdUhXVU5TbzJ5dmxGdE8xNW9jMU9HMUdYVG45SWg3NlRZaXVyazNMSWs4eEZLY3NLQ21keFppMXoxZUY0aldYdjhBVUZGeG54Ni9md2lMOHkra0RjSVZKYk9OWnN0WVdpNlJma09QMGllU2Z3MTBCVGJBSDU1aTE0Yk4ybVdzNWpVNG5aU0ZBQW9EbkpneGdYTjdPcGNsS3p5SEw1d2k4aUQ3TTNJejV4S2dYQk4rTWQvUGs2Um9aMnhFczJkZ0JiN3ZlQk9ON1BxSGd2Zk1pd0hsemlrTTJPV2dYSUxZSXBuaVVoSzZaaVV2eHA5bHkvQTZkSXFZdkRtYWdKVXBJTmFuWUFxM1NvV2U3WDlESE95RXZ1OFlVekRrbFE0ZzNTUTNVWGpaN1dsWWRRL1RRQVNVclNRbTRkM05YbS9tWWxPc2IxOXc4YmpaNW1jSUFxWUVncW9ZbFF0U0FxbmU2dUkwUFovYkNwS1VsTXRHU3JzNTNpZjQ1UVNWaE41YmpOQlFTQzVJcUJTUzRaeHZldXNSVGNGTFh1bEJKUWxJVDdMZ2F1R0QzOTBHV2RTanNEMEc1SGFpYXNPUlNmOEFhVytrVk1SalpxcXYxV2V4M2lSY0d4Qk83RklTV1ZTQlRieTY1Tnp6OVluU2l4SUdUV3N5ckMxenA3bzVtMzdDOG1NbUJZVHVCTDJBUE8zRGxhQyt3OXJ6SlJVa2hWSnNEVVZHMWc0SmF6ZWZIU0JjMDVjcm40Mzk4V0JZTUhQSEk4Zzc5T2VzSTI2TW13b2Uxa3orciswd29FRlhGUHVQeWhScmYxTnlaNXdrWEVFZHBocVFMQ3hZV0QwSkx0Q2hSN1FFVWhEeWZoQ2hRd1IvMWl6SkZ2OEF5RUtGQU15ZkZwQVdXNC9LSHlranV5ZGFoZnlNS0ZDTUkyWHA1eDFHc0tGQVFUaWN2UDZRelF4MkZBTVJUTG0vRXcyYWtBV3RuQ2hRb0NvczdwOG9JWVh3VGY4QWFQbkNoUXo2R2gwTEhCbEpiaDh4RmpDRGQ4dm5DaFFwaWxOOFhtZmhCbll5akhJVVF6ZklUOXpVeXpZZGZvWWpsNndvVWVaL0pSOUhVSkJkOUNsdVdXWHJIRWVIMStKaFFvcXVoME9reXgrWWwyR1owNlJZeFEzaHptSUI2WHRIWVVhUHlvZVB5Zy9haVJVcXcwOTRoTFNLVTIwUHVlRkNndjJJejdIcEdmbjhSREppUlFDM0Q0R0ZDaFYyTDdFU0xvdmQ1WmZudWpQakVjNE1TMXQwZkNGQ2dyc0RMY3RSYk13b1VLRWZaTm4vMlE9PVwiLFxyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsOiBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFELzJ3Q0VBQWtHQnhNVEVoVVRFeE1WRmhVV0Z4WVhHQmNZRnhnWkdCZ1lGeGdZR0IwWUZ4Y1lIU2dnR0JvbEhSWWFJVEVoSlNrckxpNHVGeDh6T0RNdE55Z3RMaXNCQ2dvS0RnME9HeEFRR3k4bEh5VXRMUzB0TFM4dkxTMHRMUzh0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TGYvQUFCRUlBTUlCQXdNQklnQUNFUUVERVFIL3hBQWNBQUFCQlFFQkFRQUFBQUFBQUFBQUFBQUZBQUlEQkFZQkJ3ai94QUJBRUFBQkFnUURCUVVHQlFNQ0JnTUFBQUFCQWhFQUF4SWhCREZCQlNKUllYRUdFektCa1VLaHNjSFI4QWNVSTFMaFlwTHhGWElrTXpSamdzTkRvckwveEFBYUFRQURBUUVCQVFBQUFBQUFBQUFBQUFBQkFnTUFCQVVHLzhRQUxoRUFBZ0lDQWdFQ0JRUUJCUUVBQUFBQUFBRUNFUU1oRWpFRUlrRVRNbUZ4Z1FValVmQ1JRcUhCNGZFVS85b0FEQU1CQUFJUkF4RUFQd0R6YWJ0QklTU2s3emtkT2I2dkZYWjdwS1ZFYnFsTUg4SjBPUkRNL3dBZUVWY0l0QVh2Z2hQUnk0dUxkUTNReGN3a2hhNWdDa0tvZkpOaUFYYlRtZlV4ejBvNkNlaDdPd3RLQUgwYzhYT2JtSmlpK1VDdGlZeEV0TktpcW9uSStLNXNGRjg3NU1Nb01TU1R2RzNMbnhqMGNIa3huU1gvQUlUbENocGs4b2pLWXRDYkhDQkhZbXlkRllpSENKRnRFYlF4amtjSWg3UW1nZ0dVeDJtSHRDYU1ZWUV3cVllMEpvd1JsTUttSHRDYU1BWlRIYVllMEpveGlPbUZURWpSeG93UmxNS21KR2hOQU1SMHdnbUpHaW5qNXJXY0FhdmsyZWNROGpOOE9OalJqWllLazZrQnRmUFdFbFFzT3BIT0JrbkVvY0FGNnQ0V0dkbFpQZDgvVExLSG9tcVM1Rnc3SHl6TDJHdnVqeW8rZTAxZlJWNHdpVVJ5bUhvSUl0d0JqclI3RUpxVVUwUmFvanBqbE1TdEhHaHJCUkhUSEtZbGFPTkJzeEhUQ2lSb1VFRkdMbkZDWmhJU2dxcERGZ1VtNzJ2YzZjbzZpZlVXUVVoS1R2S1NhU1hmd2xWM09XUmdSczdGTk5Ea01RUTltZTF5WXNZdVFFVklRbFMrOFpTZEFHT2RQQjh1SUE1eDgwNFU2WjFXWGNOalY5OEphWFVwMmZ4QktQM1gxdWJ4dGs0aEthVWplTEQvQURHRzJUc3hjczk0b1ZGbE1seGRyYTVqbHpqUTdMeEZha3VGVk9IQkdSQWRzN2Z6MGpvd1pZd2tvd1czMnhaTFd3K2VRaU14SU00ZXVWSHRyUkVybU9BUkpUQ3BoaFJqUW1oOU1kcGdtR05DYUpLWVZNWXhIVEhXaDdSMW94aU9tRlRFbE1Kb3hpT21PMHc5bzdUR01STkNhSktZN1RBTVJ0SEdpV21GVEFDUldnWGpaUk5TRkNwSjVnV09nNG4waTlpMXM0L2RaNzJ0dXNHNGc2NmNvQ3lwcTNWVWxnbFZpV1VBbm1mTzhlRjV2a3JJdU5iVE9qSEd0bE9UaDF5elNGYmd6RDBrR3d2d3lhK29pOTN3QUtsTzFUVzNkNWdRRGU3amh3Z0x0Q2JOUjRVN3JQVW9nVWdOWTNkd2ROWVVtZmtvbDByQWZNbE5nejlXUG1JNG5CeVZqM1JwY0xpZUkwWlAwdDVSb05oN1BNNVlTQTRBZFRIVHJ4T1VZdkJZcXBYRVh6Y05yYTJ2RDdQcFA0WllxVFdwQ2xFTEtSWldxcjJUYXpDN2RPY1V4NThtUDBwLzlHNHg3WUV4bUhvV3BQN1ZFZmJSQlRHbTdaNElKbWlZa2Jzd1p0bXBMQi9SdlNNODBlOWd5Yzhha1FtcWRFVFJ4b2xhT1V4WVFqYUZEMmhRUUhtbXdzQ3hLcHlTRXB5U1F6bmsvVGhCdVpOclFWaVdFdTVEaTluVUdxTGdaTVdNVk5xejZBVUZTUlY0YVdKWnJ1ZEM1NDhtZ1ZnSms1WmFtcElEVWxSVFlnc1J6REZ1RWZOdE9mclowbHZIWTBLOE5iRk8rUndVTEIyc0hJK3lZdmRrSng3NUtTb2p2THBKWWdzRFloenBiTzBEOEhzaVlhZ3VZRWlXUXlTNEpjV0FKRDVLTm1hL09KcVNaN0lOVXdHcFlOMGdCaVBOanB3enUwV3hUakNTcjJNMGVqekpMUnhDdElaaEppaWdPL0M0RCs2SmtvZVBjaTdWbk94aXBaNFJ5bUpXSTR3cWpESmlrVk1Kb2thRUV3d0JqUW1pU21HcVVBUURtY3ZLTlpoclIxb2ZUSGFZeGlOb1ZNU1V3cVl4aU9tT3RFbE1LbU1ZaWFPdEVsTWNKQWhKempGWEowTkdMZlF4b1ZNY21UUVA1eStzVlB6RHVORGtVa01TMlFPWkxNZUY0OC9OK3A0NGFqc3ZIeHBlK2dSMm43eVdwSzBFa0d5Z1M5UFFaZ0g0dHlZWW5GbFMxb1h1cFdBQW9YS2dvZ01MM3VEcThhR1lwTXlXdEttR2hCdGtCZnBmUEo0eC93Q1plZUphcWR3cUNWTUFBQ2xyaHdjd09Qazd4NWM4bngyNTFUTE9DaXRNdUtxU3BTVmxVeWtDazBzR0xueVpoYlFuakZJU1FaZHFWQlNpcFRFQXBEa2tDNC9wempSVGNNNkFra0ZSU0xYZDIxWlYyTGFRQXcrRnBDbFRTbnUxckpwQXVTYWJ1Y25ZMjV4TEhOUC9BR0ZhSnNGUzdNQWxSQkdSdUxWVzBJVnd6ZU5ac1hFakR5MUtDWG1ySVN5RWh5QTdnRXVmSmhrNzJqUFlXVWxKQUFBU0N3Q2dXTmg0aTE4elpzeUJwQm5aMkZFNllsS3lwS1ZUTEtTT0o4WUFlM2k5Qm9JV2N2VU1qZllUQ3FtN1BVcFlYV0NWcHFLaXdTNHBGVndBSEhsMGpNS1VPSWowekRmbHdrU0VxRTJqY1VTUXFraXhlbzdzWUhhR0VNcVl1V2ZaSkhscDdtajJQMCtkSncvSkhJdmNIMWNBVDVOOFdqbCtBOHo5SXNVeHltUFRJbGVsWEVmMm42d29ucGhSakhqa3FhNWNwSzFHek5aeUNEbHE5N1FmMmZzK1pLSlVwU0FRRFlxVG0yUkJPZDhqRU1pZWdUbVdRbFRFa3NFbmcxbnY1dnhpcHRhZkxRUkxrcXIzblVXSkxzTHBKQWF3SWJwNWZQU2JtK0tPaEJLYmp5dFJsekZnSmR3dEdUNTVzRGRtWm9zNEJZS2lpWFNoU2l5bEZuT2wxQy9FdHhIV0JNalpDeUVrTUVLQ1hTN0tYZTJUa0Z6cHhiakhkcjRzUzl5VUZKVmNGSnVRdzBKR1I5Yzd4b1FnNUpMb3p1ajByQ3MxTjJUWnpxM0I4K3NXS0JvWXpmWmpIbnU1YUNISkRxSWNoUEJ4a0NiK2thVUpqM3NjdVVVem1lbUlLTWNhSE5FYzJjbExPYzRhVTFGV3dVMlBDWTdURGhIUUlhd0RRbUlac3ZmUm1MSzBGeGJrL3BCVFp1Qk0yWWxBcytaNEpHWis5V2pWYlUyVkttZ1NnRUJhRWdvQ1ZEdlVESUZTVDRrKys5czQ0L0o4dU9GcGRsY2VQbHN3OU1LbUpWNFNkTEpFNUZCQUZuQkd0M0duVm80U09Jam9obnh6anlURmxqa25WREdoVXdqTUdsNGFWSGkzU09mSjUrS0hXL3NWaDQwNWZRY1JFYXBvMHY4QUQxaU5Tc2plN1o4NzZ4d0tqaHkvcVdSNmlxT2lIaVJYZXh4Sk9mcDlZN2lFWEJMK0ZPcDBBSHlocE1TVFNDbEJ6ZFBNKzJ2K0k4K1U1U2R5ZG5Tb3BkRlZTQmNIcHg1eG5NWGlCSlVwS2xBS1VRUllaRTVCaHh2Yko5WTB5UWN6Yys3V0tHMGNBaGY2aFFtc2FxczloRW5YYkZ5UnRXRDFsWVE5bklaMmZMUTVldkFjb0dUTUlLbFREZExBTWw2Z3BUVXFaam9DUE1EaEVSMmtaU2ozNFVsT1NRTGtsK3VUTVA4QUVTMUdjbFNaZFNsSVNTcTdKQkJkaStZekF2ZnBES01vL2IrVG51eStWcG1NcEpvS0NrS3FVb1ZlSEptWjJ5SE8wQ1p6S0lQZlZNcFlTMjZRdHlmRTRKQWFrZFlnUmk1aFVBcEJCU0NvazNKQlVFa2hyTytyWm1DTXpDeXhMclVBYkpLczNOMDhHWTNKZjE1c2w4Tmk5ako4eDBWTEtnSHFKNGx5RFlaa09QU0NXeXNTcHU4dzZtS0FrMUtJTFBiV3diNDlJR3laNG1IdXl0VlpTR1FVc2xLZFFWRThCcUk3aFpVMEJNdFlDVWtNRkZLbEo2a2F1WDlINWtjYis1clBSZnc0a1RqT0t3eGxwY1VsVEtMKzBMdG1vcUlIN2lITjRPOXQ4STB4TXdEUGRQVVhIdWYwZ2IrSE9BbkJRTXlZbWxLbEVJRkNsWGNBMmRrM3k1WldqYWRwTUlKc3BTUTFRM2dOWEYvaGJ6anI4YWZDU2w5VFNWcWp6WXBqalJLUkhDSTk2emxJcVlVU1V3b3hqeXpBSHVrcm1ncFoyU2tod2ViWm5oNm1JRTdSa1ZoWmxwY2h5RXVDOXN0R3pIRzJjVTV1MERTa0FKWUY2WGRKdWREbC9pS2lKSVdvc2FiMkRFdVR4dmJoWjQ4Tlk3dHlMaHFWakROVW9wU2tsS1hDYXFRS1Rha2FtNXQwNHdPeEV0YXlWTWJsbU9ZTHRUWVoyNERLTHlkaWszU2U3REVGemR0UTN0RExYMWdsZzFpVVFrK0pKR1JZTHpaUnp1T2ZEakM4NHgrVU5CUHNsaFZvVTNlbklDaHN2YVVBZUFKUHE4YlFDTVpzekZ5a3ZObkxUU2x5QVhLeVRTenNIellYNENORHNIYVl4RmF3U0JZQkphdzRsdFNYajBmRG5MajYrMlJuM29LTkdhMnpqTjg3cElCQXRmSTh1WWpRWTZiUWdxYktNaE9McXVYSnlHWXRuYzZaK2NRL1VzbW93L0krQmRzSnlOb0xDeG9rQU80Tm5JQmZwOWViYU9VWEFJeU1ZdVdpV1N5aTJTaTVVeldMSlRxU1FNK0JqWTdNbkJhQXBJTk53SHNTMnJhUlh3TW43YVRZTXkyYVBzaEtVWjRJQnBBTlhCaUxQNWdla2JVeVFNa2h3NUhVak4rTVFiTHdDWlNFSkFZZ0IrYW1Ea3hjTWNYazVGbGx5cjZEeFZLanpidGhLbUl4Um1LTmxvU3d5YWwrR1o0OG1nT2llRkZncDlML0FGempiOXZzSFZKQy93Qmg1NUt0cHpDWTh5a2xWUUJEWHp1eHZ4QmprTzNHN2lnd1F3eVBsZjhBbG9aTVV4Wm5MUGt3NFp3cDA4SURzNU9RR3BiSnpiMWl0S3J2KzVWendUd0FiaC9NSVVIWVpMRFRQUXZrV2lVa1ExRWtBRFdFVmlNMmFpT2ZNWVA4THhIS1VUWjdCMkRjU1NmVWt4SFB4c3BQaW1KSG5sYlFSUW45cDVLYkpKSi96eGpiTTBIQWc1L2ZsRVdQbEpVbWtodEFiQWgrQk9SNWlBbUU3UUttcW9RZ0FIMmxMWUN4dWVPUXNEcDFoazM4eVVxcW5KVE1jMHNBV0dkS3RSbVFMV3Q1STNUcGdja3V3Zk13aXBDdThJVVVpcXJOZG5Ta093TzZBbzlIZldLSkJWaUZKUlpGQldzcE9iT0FRNURLWWdjYkhyRjFDNTBzZ3JXVkd3WXFZSDl3RGxxaHV0a0x0QVBid1draGdFa3BLVmdXRnNoeVp6NitjZEdQMVNPU2JYc2FtUVpkbFBWUW5qa21wMlk2MjYyZ0ZpOW0vd0RNQ2xrQU1iUGV4dlNTMXlNdmZyQVhCN1M3c2tnT1Nta2h5TWd6dmM1ZncwWForMTJFdWNDa3FWVWxhTTJTRkVwdjBMZWtOSERPRDAvNzJKeXNLRlcra2QyazkyU0NidXRJWXVzNmtpNzgyamQ5a01STG1UV21wY3BTWml5cGlNbnVodzZVRlIzUTc4UkhtK0J4NE5LbEtBSUlDamNFaW14R1lkMUVGeG9JS3pzU0VCUmNrdHZKTmkyVHBiSVUvRFdKeVRpMGdwbS8yZnRkS1ZUQ21iTFhLU1ZCSXRLdWtMWmtnWkVsck1YUE56UGg5dkxYT1ZPbGxqUUFVc1Y3b0FxVnhBMHoxMWp6YVdYQ2N2M0pEcGVuaUNQUEtOMytIMkJSUG5wU0ZLWkxySkJaeUxVNStlWEhxRmJmSklOaExGeWlDN0ZsYndzMmZLSzVFYmZ0WGdLcFlXTGxQdzErc1kybVBlOGJMemhUN1dqbm5Hbm9ocGpzUGFGSFRZbEh6NnFZL253dDdoQlRBN0ptaGFTWFR1MWc1TndkOGk4U2ZsWlNGaStYRVBscnpMLzRpdlB4NmdzbEpJYytmMzlJOGh5Y3RSTGh6dkpxWHJTaWtDb0ZnTjV3TkFXTEU4ZktLT0ltaWdxQUxtNWNnWml3QTFHdVFObzVPMnE2R0Z5RXVmVnZsRkVMZTVJSjROa09la1NqQjl0R0NPQjJkTW0wUFNtV1JVNTVHazg2dVhCdXNlcDdMd2t1VWdTMERJQjdYTnN5UmFQSkVZK1pVaENWS3MxTjdDOWdBYkFQSHEydzhMM01sTlN0NVFjMUsxTjJlUFF3TldUbVZ0cTdVU3k1VndvMkJZc3E5dzQ4SkEwakw0bWVyZUNVaFJMbG5hMmgweXRlTG1PbTFUMWhydGNuUTVobVAzeXlpNXM3WUM1aWFsck11U0JkZjdyM29TTXlUckhuZVZrNVpkbHNVZEEvWjJ6VjRoZEVzVksvK29lbzM0QzQxMGowZnNqczhDZExsVkNhcEpKV1FBSlVzSXpTaEk4YW5zVkhKK05nR0dLVExSM1VoSWx5dVRWcjBkU3ZQSWV1a1NiQUMxekNnNGd5UllJVElTU3RkaTRxMHk1Q0l4eVMrVzlGL2hwS3oxakY0K1ZLRHpKaUVEK3BRSHhnQmlPM0dIY3BrSm00aFgvYlFhZjd6YUtPQzdLeXdYL0xLV3I5K0ltQW5yU0t2bEIxR3oxcFR2VFVTMGpTV2hLUVAvS1pVUjVORGNpZEl4ZmE3Yk9QbVNTK0hUS2xxYTFWU3pmSlJBSUExdHEwWTNEWW1jbDNsbTV6QkI5MmNlbmRvZG55M1JkUzFHOVNscVhwbzVZZVVDcEdEbEJZQ3lBRHhJK2RvVnVORlkydWpDNG5HcVNydkNDQmtBeGNDMXFTekE1djhXdEZQN1FXM1VDMzlWL1FSNk4ybzdMMHkrOWtncXBHOEVzQzM3Z0FHTGRJODh4WGRxekFQKzVJUHZFU2JSV01yQlUvYmswMkNtUEFKL2svQ0t5MXoxK3lwWFVxQTlDd2pTUzBwQXN3Nk1JcTRoU2V2cVl5a2hyWm5EczlmN2tvZitwL2NJWCttOFZLUFJQekxRVm00a0RJZkw0Ulc3NHFJRFovZVpoK1pOMk53NlVTMGtwU0VxR3JoeUNYY3RkeDhOSXNqSHZMcVVnbjJxNldKQUpCZmlYNXhReDZWcE56Wm5mUnV2V3p4Uk9LSWVzbGFGWDQwa0Z3UnlmU053VTlrWnF0aC9aV0lCRlR1b0tEQUlGZzFRTGx4cmJrMlJ0RDVyS1M1U042MTk1S1RlN0ZtOTJVVWNCT1Nrb21wU29HWURjby9UVFNraXFsODJBOUJsRTB6YXRhbFdTQmNxTEpwVE15djFEMmJVUkp3ZkowSllDN1FZRU1LV3Fkd2xDYk1TYmJ2dFhHYk8zR0JlRzJmVWlva0F2a1N5cjJHNnBxbkl6QjR4dXRudFNWTDdzRkNueXlBRjBqbkN4K0RySlhRaFNEdTNUN0lJWmdyWEkrN3JlUGxPUHBmK1FPSmdaY3dvU0ZPeDBEWk85NzIwdDl2cE1PSmhvN3lncThRVzRBV0NHQUZuSlo3UVRuWUpRRlVsTXRrK3p1NzVMa2xTRzNYNEphOXRXZ1JpTmpyS2pVbEtVRU1UVTdLSTlnQW05WEhwYUhlV09UNkFxaXhObkZLMVMxSUFUa2xZenVBQXgxQWN4cSt4VzFQeXkwcktRc09kYmk5eU9iTU5EQUhhZ1FoSVNTNENRQUJlek1TQU5MUDVIZ0lkczNGS1NUa1F3THBhOUllN0Z4a0hFYzBtNVJ0Qjl6M0ZIYW5EemtOVUFUWXBVQ0QwYlh5ak5ZeVRRdFNSY0EyNkc0OTBaRERZb1lpYkxUM2RLUVVnaENRQ3FvdVM2aTlRMEdWK2NhZkViSTdzVlNzWFlYN3FjaFNWRURNSXFZbnllT3p4ZkljSmI5elRncExSeFFQS0ZFd2hSN05uS2ZPczVKQk4zdVh6ejFoNkpaVjFoNlpvMVM1ZXh2RGpMZTlXOWJTUFBiTENrUzZYSnRZMmJPSmtUaXE1WmpZczFYbHdpdDM1TEFaOGVMeDJkTENjalUrbzQ2aUExZllTZkJKL1VUbmJSMjk4YXhJU1V2OCt1VVpDWFBZRTNmVGx6KytNWGRtTEpWV2JzZk04Z2ZsQWJhUUE3Z3NXaE5TNXExRUN3UWtWS2JMTmpTUHJFdUo3YmhJQ0VTMU1rTWtLc0FPVHVmV0tleXlBdGFnOUpTN0U1TWRQWDNlcW00OUZKSUk4WExTN085L1BsSEs2Y3RxeXNaMTBSVGUwbUpYa1FrY21IeGcvOEFodVppOXA0VXJVVmI1TnlUa2hmR01maFNTVkJPUXkwUG1CRzgvQ1ZKL3dCUmxwSVM1VE1Za09VRUlKcVNIellGTjlGR0tUaWt0SWRTYld6MDd0eHQ2ZmhGUzVxUzZLd2dTd1BHYmt2YmdDUFNDM2JDV2xXR1Vva3NsSldrQjNLZ0hGaG4vTVozOFVscWwvbFZKTytad1plU2swbFBodTEzOUhqVTlvcFFSaFp4UlVDRUVnMUZ3ZUljNXh4dUw0dXdwcTFSZ2V6KzBRVUlTdGR3VlVqTTA1c2VGM3RBWHRGaUpuNW81bE83UUU3eHBBRHVCY1hxZ2wyTmxnSlZ6bUx6enlFQzlyLzlZczViNlBna1FzMVVFaTBmbVo2b25HbVhnVkxsQXFVaEc2R0pMNUIwNXNIeTRDUEtGekJOQkNxU1M1Y01DNTZSdk1YaUV5c0RQVTlGS2ZFSEJEa0EzSFdEdXl1enVIUWxINlNDVXBHOFVnbFJhNmk0OUIvRFRsRnlhUXFrb1cvNVBJSk9ETklIS0lzZGdWcERtV3RpOTZkMEFaa2s1RG5IdmtyRHBUNFVwSFFBZkNBZmFRT3VXTE15cWdXWWdnaGkvV0xReGIySzg5OUk4Rjc5SlVFZ29LaVFBQXFva2tzekFjZWVzYkVkaEp5UURNVkpRU21wbEx6RE9Xc1gvaU14aEpDVVRKYkovd0Rra20xT1RxMUJQMjBlMjdha0NmaDFKbHFDWmxDVWhWU1I3T1ZRZHM3aG51UnE4VW5Tam8wbTB6eFhhcFJMSlJPc3BLaWs1MWRHVUxBV3R3Z1ZKMmJkUzZlOFVwVlNRK1YzMXlNU2Rvc1N1WXMxby9VU2Q4RndvbXlYVnZHNUthbUhFNlEvWmdwcFdFcUp5S1VncVlhWEJzYkdKdUxoSFRKUzdMTjAvcHIvQU9XZllZa2x4WWhJTjlXNmpsRE1WaHBJdzVNc0tRRWdrWGQwbTl6eFo5UmxGNDR1c0tUdTBrSlVmM1B2RGpadVd1ZWtVaHN1V2xHNmxadUJ2RWtCcjY1YTNpVVpWM29EQW1FeDZscWxCQ0FXQXFLa2tnbE5nd2N1YmhyTzdDRGVMMndzeVZHZ3BJejluZ1NhU056UFRyR2V4V0xUSW1CSXBVRTd5V2ZkVVJtV0FkUWN0ZG1Pc0VGYmJtVEpZV2dPcEZ6dWoya2gyNkVHT3FlUGswK09oVXdyTG5LbVMwTFVhcXdweUI0U0FhVFlBa05TTllINFBiSVhLS1YyVUVPa0d6c2xtRDNWcUxaR09iUG5LRHBJS0dGWWNEMnJrbHJVMjhQbEZnVDBwcldrZ2p3a2tPeFdHdFZZaHliRGpFdUtUYXI3QnNHRkt4TS9VSjN5ZEIvVVdBSXlzY21MblY0blJMbVZsSkFZQVhEaXAzRDd0bUlmVGhCRForRWxFZ3pWSUJVQk1MckJBSlM1SllPR0l5RHN3aVRZczlFNHFLMUZrcVlNbHdvSFVtNUJGaTNYakZKdHBYUUtOZDJSMlBObHkwekxsQklDcVFtc040Z29zb0JrcU9lajVORjNINGxZbW1UWTFJcUYzTE9RNFpSRDZFczlvZzdINCtYM3JHY3FVbFNjd2taZzNDbmNjVFVRV0ZuWndUM2FSY2dZaVRMWE5RNFNBWmhTQXdLbjhaczdMZlBYbkM0NXBMbVBWNnNBQk9KKzFJK2FJVUJadTNwcjJXbTF0TkxQbkhZOUQ0OFA1Wkhnenlpa3RaaDk4NFlGRVhpeXFlb0J5eDVYWWpwRWFwb0tiY1hwYlRKd2RJeXN4VHFJTWNCaXd0QVV6ZWpRMFNqRkxSaDhrWkVpMnJRY3crTGxVZDBnRk9wSkljOFJBU1JMSkxjdElzWWRQM2xFcDdNYVRCU1dTVnFERlFZQ3pzN3Q5MmdCdFdRQXBTa2tBT3hBdGZxd0dzRzUrSkV4a3NsMkxBTzdNYmhXUkRzT0VEOFhnQlFKaWZBWEFJOWtnc1FmTVJIQXZWdDAzMFA5alpmZzdzQ1JQbFl1YlBCSVFaSVN4YTU3d25SLzI1UjZGMlgyTGhrYlJVdVFnZ0lBQ1R2bTVRb0tja2thajNlZUwvQy9IMDRLZWd0dlRrRFAyUWg4c3hlUFNPd3VGRk15Y2xETEpLRkdva0twWWdoSkRKc2J0NXdrcmMyVS93Qkkvd0RFUlN6TGt5MFN5cnZKcUFTQUNRQXRCWWEzSUdXZ01GKzFSLzRTZC9zK1lqdU1uc1VsWlNDTHBkTHRvNDNveEhhTGFjMmF0U1VUVlVpekFrQitoY1FyU2Qwd0pkRmJzeElwUTUxS2lPaE1DTnI0WS9teUd1cGFDT2hwZzNzdkRyUm1za1hzNHNkMyttQ2t1V0NRU0hQRXNUNnRDWklMcHN0Q1Q3b29kclgvQU5QeElHcU5PQVdraytnSmowbVNOMFhld3Z4NXhqTVlVOXpNclNGSm9VVkpJQkNnQVhCRDNCallZU1pVZ0hrSUVhdWhjdDBUUms5c0I4WmFpcWxRQVVrT2YwMzhXYkF0L2RHdGdYdERZY3VjdXBhRUhxZ0U1Tm1jL1NMdU5FVXp3NlpJUGVzQWJtUmtDU1BFWFlhQzd0eDFpLzJwN2JyVVFKY3BFbzBNb3NBc2xQQlhzcEJGdGRlRWVwN1c3TXlUSldsS0VPVWxJZEVzQUVncENuQ0hjTzhlSmRydXpjMlVwTXhRZElDYTFJSVZ2bXB4TXNHTlFJSWJRMzRUY1UzVEtPVjdSbk1maXlydkZrMHJYY1hKTjNMUG0yWHBGalk4akVKU1Z5MVZMc1ZCVHBEQzlLU2MxZFBwRmpzOWhrS0pVVkIxYVVqd2dzY3hibEZrYklueVZxUkxYK21YVUVrZXlvbG1VYkZXVjllVHdzOGkzRFg1RWF2WlZsU1p0U2xNa0ZTQUdGZ2xTbTNqeXNUd3Vid2JOa0JNNFZGbVZjYnhET2wxRG14dFozaVpFdExxSUNsS0Z5eFNBNDNpTDMwZTJXY1pqYmN4VXFlRkVoa0VsZ3RTazNJTzRUZDJTTEVrRGp4akg5NlZHZnAyRHUxRXRsbWhKcFFBa2tnM3pwTlJ6c000bTJCdE1TeW1XVWxOalU3dWJLeUJzSHE0WkRuQjdHeTVVOU5aS2dGSkthU29Nb2xpRlp1K3ZtWUY0cVNFZ2lla0JPUW1CcmduaFlaSkhVUjB3eUtVT0VsL2YrUlgvSTdFQlJCSVNsckYxVWhkSnp1Q0NRMTJQQWNHaGJQa29VRFcvd0MyNUlaN3NRZWQyNXhNdVNrck15V0hwS1F0S2trS0lDUnZCckhvMlJONGo3UVNpSlZTQXhjS1VSd0NUcHBiTnM0VlN1bzlXQUs0ckF5RmtBaEtsVWpkenRrNFBBa3ZsYjNuc3FVSmFDRUpwVG1LZWwzR1p5elBHTTNnTnNvWlFLRXBzQUZPMWh4T2hmWG0wWDA3V1F1U3hKQnBZYjVxSkxPQStiQU1EeWhKWVpyVHVodVNORGg1eUVBR1h1Mk4yOFZnNFpyT2RHRVJ6SjZsajlRbFRaQm5zYVRaK1h5Z2JnWjlhZ2hKQ1JhNUJDV0ZMT3puT3g1dkZqYUJLRFNWRXZZMGtFZUVYQ2habjU4ZWNUVUduUVU3SlY0MVJKS1ZMU0hPNkRTQmZJRFFRb0gvQUo5ZWxaR2x6bDVCbzVGcW1IWmorK0kwY2MzYUdCUUpESkk0NnZIVk1BK1o2L0tHaVlXTE9QbEhvVVJKMUtIaEFEODRycUp5dTNYT0VoVjczUEY0bVRTZXVsdmxHNkNScG5IUWZmUGpGaVVLaUxXNUdPR1drQTVQWThzK28rekhNTXRzZ0lWOWFBR1U3TENrSlV2UndLZW9ZbmhkL1dJcE8xTzd3eGxqTXFVQU9DVGNuM3hLbkV0SXFxZHQxclpsU3MzNURNUm4xcWN4S0VPZXBlekhVbkhvMy80ZmtIRHpBNmc4MTNTMW1RalU5VDdvOXM3RDQ5Q3BIZGhncERraHJrRTJKMEp6OGdJOFMvRHovcDFuL3VxLy9DSTllN0NGSWx1NDNpbzlXWk92U0o1cDhiS3hqeVJkN1ZySUlhdXlUNFV1TmN6U1dqQVlHYVNrazFPVkU3d1kraEErRWJQOFFlMHd3a3NJQ1ZLV3NPV3lTT0tqbzk3Y2pHUHdlT1JQbENhaml5aHdQTWFIK0lTSzBaQlhCWXBLN3BVU2J1NEkvYmsrbWNQbmJTVktJM2Frbm5jZElHYkdWbjk4SXM0OVhoOC9sRTV5dDJXakd0QnpCNDZYT1NRQzdnZ3BPYkcxeEdsMkppU1JTVGxsYVBNUVNDRkpMRWF4cDlnYlpLamNNb2VpdUxRc1cxdUlaeHRVemV1ZVB3aFg0bjNmU0k1RTBLU0ZESXhKSFVza24xWngwSy9FKzc2UjVIK0tXQ2FjM2VsSUlxS0tpQXVxb0VzbExQdW5lTCtJY285Y2FQSy94aVRKM1ZLc3BCU1ZIallzQndMYzJ6dENaSExYWTBEeUtWZ1ZwV29BbWdoZ0FXVWNuQVl0bzNTOGFudVpvVFVxd3NGT21weXJKbGFHd3pEbmxybnRxVFVrR1loZjdTZzJZK0pLdk9yVGlJazJQdHlnRVRYU0Zra2FwQTNRMnBCSmU4VHl4bk9La2tDMG1MRVlxbWJ2S2FhN09sTnFHY0NyTUtKelBNOElPeU83VUNpY0NwMFdkTGhSdWZUZE4rTFJVeE9HRTRGS0dXdG5ERnd6RWdtMm9QdjZ3TndlSlYzNVRQSkN3QUFrS1lCMnVHeitGb1J4NXgxMnY4L2dQUVJuWUtWS1lwcmNBbk11SGRPN2NBRnVHbXVjRHRvQk9JazdzMTJLWEwrMWx2Y0xlK0RuNVVacEpCS1J2UFU0TjJJZjN3SG1iTVJVWmN4U2dxYVFvQUkzU1FMYndGam1lWEtCaW1ydHQyaFdnWnNoYzJTbFpJZVdwUUMxWEp6dXJtekFrOVlMN0t4Nlp5VEtzVXJCUXF3c0tjNnZQTmhsQXpCN1MvTHRKS1NhSENuVFVMR3pBTm5yMDFjd3paT0c3eWFKd0NVaW9sZzk3azhiYS9TT25KRlNUbEpmWmdUSXRtNEdkS1dVZ2dHNEFzN20zTUIyQjVpQ1AraUZZWlJTRnRtM2hKWWtoTFhzVGtiZFlrL0txUk5DQWlwQ2c2bGtpcElCc29LTEZ3NEYzeWlkVXd5d0ZLQTltb2pkdVd1bC9FT2phd3M4a203VFZtb2h3c3RjbFpxV0NLaWJEUGV1YWJzNTV4T21ZcS82WnFCZXgwdlp4N0wzOGhlelJiU3NLbUFBRUVKVlp3WElCYXhET1NSbHh5TFJaR0RDellzRFlnaG5Mc2VkN1dmMnRZajhUZTBPa0N1N2ttNjFMcUxQdkdGQnc5bEp1Z1EyamhSOTd3b3ArU2xNOG1LekhVckl5aDBqRHFXb0lRSFVvc0JHdDdNZGdadUttclFwVkNVKzFaVGx5R3RiVHJkMmowcFNqRmJPZEpzeU5WbWFKSkV0UkxEUHFQbkIzYTNaQ1pKbW1WM2lGcVNBUzFRWUYrSVo3ZStHOXIrelJ3UzBJcnJLcFNGcWROTEZWNlIwaGVjWHBQc05BNlpneWtPVkYyeTVtSGJFbm9UT2xDWWtLUVZwQ25JRzZTQVE2aUVnY3pwRVdGbktXVW9jWnBTTEI3cUErY01tNFYxbEl2ZFF0d0QvQUNFWkwya1pJMlA0aDlsL3lqS2xJVUpLamMyb0QzU3dlb1prRW16a05tMFlpWTRKQkRIaGxIdXVJMnpOVU1FSjBwSVhPbFV6RXpHQmNDbFhlUzFGMkxWQ3hZS0x0bkhtUGFmQjE3Um5nQ3lpWmo1T0N4SkhxWWpoeWV6SGxEZWgyQnhhNVd6SzVhaWxSbkVPRzFMYTlJOVI3UDdXQUtaYWxVeTVhU1ZoemRTMWJvRERqU1l3dXpwTXRHRk1zcGNiNmdGQUtEbHlQdG90N0V4WDZ5U3MycVNWOENBc1pqVm1IbTBSeXlVbGFMUmk0dW1lamRzRkNhaFJZbW9NUzFyQllVSDhpSXdIWmtpVk1ueXcxQ2lHRlFjRUE1UGZoNlFmN1E3VXFTd2RsMXFMNTd4bW5US3grTVpiQnQzeHRsL0VKRnRiTWxlalQ3RVZZL2ZDTFdPWGw1eFEyTWJHTEdPVmNSS1hSUmRrWlZGckJySUFJemQ0b0tWRm5DcTNmV05qN0RrNk4xMloyc0R1bkkrNVgwTUh0c3BmRHpya0h1MWtGS2lrZ2hKSUlVQzZUemp6UEM0b29VRkR6SEtOeEkyeExtWWVZbXNWR1dzQmlIOEowNHgwWTN4bFQ2T2VjYjJqeTNaRzFjWCtha0ovTnpsbzcrUWx1L1VRcEpXZ0tjRTNzN2pyQjc4WXV6aTFvTTlLMUZyQkxGVnk5U2pva05ZZE9jQWpoU25HWVlFS1MwL0NrSlZveXBUMmV3dUdHalI2bDJ4bElWS3BXN0V0WlZJdmJlNWUrRmxMMDM5VFA1ajVpeGhCbGhTalNFN29RQnF3ZFRqUndmVGhBZnZBcGJrbGpucVc1YVBIcEhiZllNa1ljcVRZeW5DYWJKTHFEa2hydmYxanpWU0dqc3hmS1JrcVp0T3pvdzYxQVlkUzBMU0FTb2xScU9URklZSE8zdWU0aWJGMG9yVWhmL0VBaFNxZ01oWmdRSEFlOXVJdkEvc2pzc3BtektodkpTQVV1R0lVSHR4NnVHanUzTVBOQk02WW9CZ0UyTDd0Z1FRQmR5b1A1Unh6eC91MWV2N29Qc0haYXdGQ3F6Z2VITmJFdmxxNUpZUjJaTnJRVTBPeENrMUVWK2JFN3pBTllQQURaKzBVM1FxYURjQkJ1eDNNM0p0YzNpZ05vckN3dEhlTFFVa0ozV0l6dHdMSFVaL0NmL3pOczNJMDg5VXBCNzN1d3NxU0NWSmNrRU80VU1yQTVqcEFmWjIyNWZlRkNnSmFjdytiNmdrbG16YkozZ3JzbmFBbmhTbHNsendzcFdWK2JOZm9PRUNkdDltVnVacUJ1cUpLZ3pCSThuSk9aTm8yUGltNFpOTTIrdzNNMm1oQVNtb1hJdU5YSmY1YTZDRzdSQVZLVXlYQ0dxTlZWU1ZKTlc2MjZBNC90TVpLZVZURkUxSnFUWU1HZXdMaFBNdjhZMEd3TVRpRXl5b2lwS1NwSmZNWldJMVR2RTY1UTAvSDRMbEhzTmxpVFlwcUNEdW1oVjdoUmRuRmlYT2Y5UmkwdEtsVGdRa2dVNkM2am1PdWVsK3NWdGtvVXFwS1VFSWNraDNaTEJ5azhpY3hkakI3WnVJZmRXaXFrcUZJTFpLQUZ3YjdvWVJHV25iQ2lXWDJmc0htelhZUHV0ZHJoaVhGNFVla1lOakxRWEpkSXVjOHRlY0tMcHVoOW55N3NsWUUxSkxzQ2NzOGpyR3J3bTNjUWdOSm1pVW52TzgwSksyU0xraTQzQnVsd2JndUNZeXN1UlRjRUVuaEU2U1k3NXhVaUtiUWJRZ2Q1M2lweG1MVVhXNElTUTcwbFNpTFdHUXlzSVcwMGllb3FtTFdYYmVzQUFBQUFIY25MaEFsRVN2MTlZUjQvZXhpYkQ0WER5bG9tQXpTVXFTcHQxblNRUTlyK3NIK3ltSndxSnhXdERKQVVhbHBDaWxaMUJPVDNzSXpvbkFId2p6Yy9PRk14SlZtYmNNZ09nRm9Wd2svY0MwYWp0VjJ0NzVVdnVwc3gwQXVxN1BaZ3hzZGJsNHkrenNWTU04S1dhaXlrM0lGaWxtdmFJMkVJOUkwWXFLRGJZVFZ0QnBTQXp1blBMemdyc1NjeTBubWs1NlYzKytrWkNZU1RjVzVaNWVrYXJCN1VsaWpldUtMWjJTb1doSlkxV2lrY213emlabFFmTWIzL3NpcmhSdnFKMDE0NVJETTJqTHB6dXhmUEkxOE9zV3RuS1N0SlZlNmlCMERST1ViMGhvNjdDdXpaeVVwTG1Jc1p0TkQzVmtEOVlxemJKTklMdGF6aTcrc1pQOEFVVVNBRG0xd2JlV2NUK0czMk01cGJSclY3VFJiZUYvbi9pTHVGeDZBQUtnNy9IbkhuczlTMDZLR2hmUStST2tXTm00MXFRUXF4emI3NVFmZ3RiUVBpY3RNOUlFOUp5VVBVUlI3NHBXU05EYlg0eFJrQUtBSU9jUzl5b2ErK0ViazBQRlJOakoyUExtcFJqQ3RZVTZGcTRBeXlOM0t3WkFFUWRwTzEzZmtKb0tVcEw1dTU0NUNCV3dkdUdVOHRkNVpjVXUyYjM5VEZMR0NVQ3ZlQkZtYlI3OFh0bEVuelgyR1NpL3VWZTBHSlRPa0xscERGUTF5MHY3b3dHSTdQem1Oa20yaWh3NXRHd1hNRVFMWEhURE5KQ1N4UllVd1pRbEtXS2FtQk53N201SHJGUGIwaXVRc0FPV2NkZkw3T1VEMVRJaFZNamNtM2JCOE5WUVAycHNyOUFGUUFtcGNxQ1IrN2lHNWVzRE5tN1FteVVxWXFBSUxETklVejVGdzhhM1o2eFdncUZ5Zk5oZDM0V0ZtNFFCN1JOVW9KTEFMY0FBaXhEa256TVVoazUraVNPZVVhREV1VExTa1Q1WUFVUUFRNFVFc2oyQ0hCZFFIeGkzczZjc1RhRk1TSlNTVTN6SnNHZG5ZOE5SempQN0F4Y3NZZVloWnVWT3daN0FDNGF3c0FPWlBHRHY0ZWhDc1ROSzBsUVhTbElzMWdRWGU5aUJsODRuTEhxVit4bHNJbzJZanhKdzc3aEhlWmVIVjdod3c4L1FFOW1ZTlNrcDNTVXFON2czRGdLTFc0K1JHYlcxMjZ6TVc0TjhvZ2xybG9zSFNCL1NwaDFMV2puYXZiWlRpWmpzTHNkYWdKdFJDU3FjZ2dON0tsSXlMM3Q3eEd2dy9aeEtaeG12WlMxTFlCbUtpNDh1VVpuczV0UVllVXRCM2xHYk5XaVdueEs3eVlWQnliQzEraGpiN0h4eG15Z3RTQ2czQlNiczF1QXRGUFMyQlVYQTBjaGVrS0tCUGxFQXhJaWFvYW1IVVJOSXdhbEFxeVFNMUhMaGJqSGZaRkVnbWo3K0VQRXlJWm9GZ2wyR1Q2dm1XMGhJakdaTWt3OFEwSzVEMCtzT1FJV3pEd05YRU9BamdURXFVUXJDY1NrUklFZmYzbEhVSmpvRUFJaWg5WW1rVEZJOEtpQS9rL1NJa25XT2xYRFA3MWhHRWYzc3h5b0xWdlo1Tlo4b1lpdDZndFFQSXQvRU5Nd2dPVDZDR3FWcThBd3lmaHlwVlJXcXJpN1IxV0hjTXBhajFQMGhzeWRUZlBpMFdwQ2tsOTBsdWIra0hZRHVIV1VOU28yeXZsRnRPMTVvYzFPRzFHWFRuOUloNzZUWWl1cmszTElrOHhGS2NzS0NtZHhaaTF6MWVGNGpXWHY4QVVGRnhueDYvZndpTDh5K2tEY0lWSmJPTlpzdFlXaTZSZmtPUDBpZVNmdzEwQlRiQUg1NWkxNGJOMm1XczVqVTRuWlNGQUFvRG5KZ3hnWE43T3BjbEt6eUhMNXdpOGlEN00zSXo1eEtnWEJOK01kL1BrNlJvWjJ4RXMyZGdCYjd2ZUJPTjdQcUhndmZNaXdIbHppa00yT1dnWElMWUlwbmlVaEs2WmlVdnhwOWx5L0E2ZElxWXZEbWFnSlVwSU5hbllBcTNTb1dlN1g5REhPeUV2dThZVXpEa2xRNGczU1EzVVhqWjdXbFlkUS9UUUFTVXJTUW00ZDNOWG0vbVlsT3NiMTl3OGJqWjVtY0lBcVlFZ3FvWWxRdFNBcW5lNnVJMFBaL2JDcEtVbE10R1NyczUzaWY0NVFTVmhONWJqTkJRU0M1SXFCU1M0Wnh2ZXVzUlRjRkxYdWxCSlFsSVQ3TGdhdUdEMzkwR1dkU2pzRDBHNUhhaWFzT1JTZjhBYVcra1ZNUmpacXF2MVdleDNpUmNHeEJPN0ZJU1dWU0JUYnk2NU56ejlZblNpeElHVFdzeXJDMXpwN281bTM3QzhtTW1CWVR1QkwyQVBPM0RsYUMrdzlyekpSVWtoVkpzRFVWRzFnNEphemVmSFNCYzA1Y3JuNDM5OFdCWU1IUEhJOGc3OU9lc0kyNk1td29lMWt6K3IrMHdvRUZYRlB1UHloUnJmMU55WjV3a1hFRWRwaHFRTEN4WVdEMEpMdENoUjdRRVVoRHlmaENoUXdSLzFpekpGdjhBeUVLRkFNeWZGcEFXVzQvS0h5a2p1eWRhaGZ5TUtGQ01JMlhwNXgxR3NLRkFRVGljdlA2UXpReDJGQU1SVExtL0V3MmFrQVd0bkNoUW9Db3M3cDhvSVlYd1RmOEFhUG5DaFF6NkdoMExIQmxKYmg4eEZqQ0RkOHZuQ2hRcGlsTjhYbWZoQm5ZeWpISVVRemZJVDl6VXl6WWRmb1lqbDZ3b1VlWi9KUjlIVUpCZDlDbHVXV1hySEVlSDErSmhRb3F1aDBPa3l4K1lsMkdaMDZSWXhRM2h6bUlCNlh0SFlVYVB5b2VQeWcvYWlSVXF3MDk0aExTS1UyMFB1ZUZDZ3YySXo3SHBHZm44UkRKaVJRQzNENEdGQ2hWMkw3RVNMb3ZkNVpmbnVqUGpFYzRNUzF0MGZDRkNncnNETGN0UmJNd29VS0VmWk5uLzJRPT1cIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiRmlsYXJtb25pY2EgQnJhyJlvdlwiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiRmlsYXJtb25pY2FcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL1wiLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndDRUFBa0dCeE1TRWhVU0V4TVZGaFVYR0JjWEdCY1hHQmNXRnhnWEZSVVhGaGNWRlJjYUhpZ2dHQm9sSGhVVklURWhKU2tyTGk0dUZ4OHpPRE10TnlndExpc0JDZ29LRGcwT0doQVFHeTBtSHlVdEx5MHRMUzB2TFMwdExpMHRMUzB0S3kwdExTMHRMUzB0TFMwdExTMHJMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMZi9BQUJFSUFMY0JFd01CSWdBQ0VRRURFUUgveEFBYkFBQUJCUUVCQUFBQUFBQUFBQUFBQUFBRkFBSURCQVlCQi8vRUFFRVFBQUlCQWdRREJnTUZCZ1FHQXdFQUFBRUNFUUFEQkJJaE1RVkJVUVlUSW1GeGtUS0JvVUpTc2NIUkZCVWpZdUh3TTNLU29sT0NzdExpOFJaRHdnZi94QUFhQVFBREFRRUJBUUFBQUFBQUFBQUFBQUFBQVFJREJBVUcvOFFBS0JFQUFnSUNBZ0lDQVFRREFRQUFBQUFBQUFFQ0VRTWhFakVUVVNKQllSUXlnYkdSb2ZBRS85b0FEQU1CQUFJUkF4RUFQd0FTMWRGTmMwNVRYejdQcEVTTFhNUXhpQnVkSjZIa2E2dE5WNWIwL0UvMG4zcG9HV3J1Q2V5UWx4V1V3SURDREhJMUJkUU1JSUJCNjFOZXZzMFppVEFnVHJvT1ZSRGVodmVnUzFzcllEQkpZTEZKR2ZTQ1pnRGVQZXJpNjBGN1dkNmoyV3RxeENoZzBDZFRCSU1lUzAzRGNjVEpPWUFuKzVyU2NKTko5bWNaeGkydWd6Y2JsVEpvUCs5ays4UGNWejk3cDk5ZmNVS0RCelhzTGswMHRRbzhZdC9mWDNGTlBHTGYzMTl4Undmb09jZllUWnFhR29XT0xJVEFZRW56RkVzTXdPdEpwcnNha24wVG9uV3BLNERTcURRN1NBcnBBQWswNnkrWVNBWTg5UG42VlNpUzVIRzBFZ0VucFRFc3NTQ3gyMlViVDU5YXVXN0pQcFZxM2FBL1dyU0laWHRZWW5mVDhhdElnR3dwNEZQQzAwaVd5cThrd0JUN1dHNjFLMXdDbzh4UHBWcEV0bkxqQlRwOUtrYkVyeXE5eGRNT0V0OXlXTFI0ODIwNmJmWDZVSEswMmlVeDc0Z0dtbW95bGNCaWdCeEZjcHdOY0lvR2NwVW9yb0ZBaHNWMWJaTlMyMG83d1BpQ1djMFcwdU1kQklMUjZBVTBoTm1lN2sxMmp6NEc2eExkeWRkZVErbktsUUl3NHVUVXlOVU51M29LZDNSNVZ5VWRpTEttckdGUzEzUmtQM3BNZ3lNdVdObUVUbTIxbWh3VWtoV09VRWdFbWRCT3BxN2RoV0toMWVER1paZytZbURUNlF1MkltcDhJQVBFZmw2OHFyMjF6R0t0WERycHNOcVMxc3J2UXgwekFnODkrUjE4NnlPTDdJT0NjcmdDVEdhVG9ZaVkyNTlkaFcvNFRnczVMTjhJK3AvU29PSnJyV21PY29iUm5saEdlbWVmanNsZC93Q0luczFQUFpGLytLc2Y1VCt0YXVhUmFyL1VUOW1YNmJINk1wLzhSYlgrTUo1ZUUvWFdrdlpJODczc25QOEExVnFHYWtxenZSK29uN0d2L05qOUdhdDlrei94dXYySTE1ZmFxSzFqSHc5enVydnlia3c1RWYzNVZycXE4UXdLWGx5dU9zSG1wSWlSU1daeTFQb2J3S080YVp6Q1hjNGtWY3RSeTE1ZjBxbHd6aHh0MnhiSk9oM0drajhxTFlmQ0FDSWdkQlU4VjlGSnY3SUJZekVhVEhzS3VXOE9CdnFhbVZZMEZQQzlhcElUWTBDcEFuV21tNUcxUmxpYXBJaHNsYTZCdFVUT1RTQzA0TFZDSXdLY0ZwOU5MVUFjSXB1V2tYcDlxNXJvSk5BaXdlRlhPN0Z3b2NoTUJvMG1xVjYxRzliTGhIQzcxOUFIY3JiR3lqWDJuUVVNN1FjSXNvOEMrb2dhcUllNFdrekoxeWphcXJWa2N0MFpSN3NIVC8zVXR1NkQ2OUtKNHZzLzNTTGVLYVA4TE1aWS9wUXpKcU5LVFJTZGlaNnEzY2FxNkZoUFRjK3dxNDlzRUVIbnA3MUhoN0NXL2dRQTlkejcwaHNsNFBiTjU0S09GaWN4MEJPbWdIUG5XMXdON0M0WWVOMUI2RHhON0NUV0xlOHgwa3gwMkZSUlRzVFZvM2o5dHNPREF0M0NPc0wrYlVxd2NVcXJteVBGRXIyN05FOERncE90VmtxOWgzcmpPNG00aHc0RWJDZzJONGFGMm1qalhpS2d4VjBFR2VsS3gwQ01LdVZQTWsrMjFQRlFFd2ZLbkRFQVV1eDlCaTFqY3FnRGxWREYzWnFtK0s5YWllNlRWV1JROW1waGFveVRYVU5JWktxOWFrbW93YW1TMzFwZGo2T0tKcnR0aG15N25uMEhxZVZUSW5TcDdXSEFxMUVoc3A0UEhxYnIydnRMbCtZWlFmenE1Y3hsdGZpZFI4eFE3ajNCTy9BYTJRbDBhQnRRQ3N6bFlqM0g5YUhZWHNleW1Ydi9BQ1JmT2QyUDVWMFJqQnEyem5sS2FkSkJxM3h5eXh5cTZrK3UvcDFxeUwwODZFWGV5MWtxQUdjRWZhT1VrK29nVFE5dUVZeXhyYWZ2RjZmK0xma2Fxby9USjVTWGFOVWlhelB5NVZJQldXdy9hTmtPVzliWlQ2SDZxZFI5YU5ZUGk5dTU4TEErWE1lb3BPTFExTk1KQmFhd05FdUE0dG5KczJ3RG5JVnZEbmpYYy9kQTlSUkRqSEM3TnJRM2d6L2RFYWZJYmZPaXRXSEpYUmwzdVJURkhTZm1ab2hpdXo0UW8xd0ZsZnhMSmtSUEliRGVyOTVMVmk4Q244UkJCMUVUMUVIYWloMkJiUERMdDVnbHN3VDVTZmxPbEV1RThLVzFmeTNDVlluS3pPWmpYbjBGUHZjUmk4YnRzWk5aVURsVlhGWXRyakZtTWs2azA5QzJ5OXgzRXVIYTB0NHRiR2d5bktwK1EzK2MwR1VSVDIxcHNVbXdTQ2RnZDViYlBkVmNnOEt0TEUrU2pZVUlkYWttbjJySll4UUJWTk5Cb3RqK0dpMllEcStreWtuNWJUUVRGNGhFM1A4QWZwdlJRV1RFVnlLZ3NZbmFSb2RqK3RUczRwRE9SU3FzM0ViWU1GMWtlWXBVQ3N1cWxXN0sxZHZjTVpUQkJGTUZpS3dhT2xNZ3VpcVdJYlExZnZMVkMvVVVVVVhGUXNsV3lsT1d3VHlvQUhzSzdscTlmd1RTQUJxZVZUL3VhN0dZbzBUbDJPL1NtbFlyb0U1YTR5MWF2WVpsSkJFRWJnMUdiZEZEc2ZZU3JhV2V0TEREb0tJcGdtaVltcmpHeUpTb3FxdlNuQ3IxcTJnbk9yYkdJMGh1Uk9oa1ZXS2l0T05HZkt4a21wN3Q4RkZYSW9LejRoT1pwKzlyeXFJaW1rMHhDQzFhVEFYQ21jS2NzeE1hVEV4VlJTYU84RnhGaTNyZlptNklzbVQ1OHZjMElUZElBWXEycEVPb0k4d0NCNzdVS2ZDMk1QOEF4d0lERlFZTXJyTUhYbDg2MDNHc1ZhdlBLMlFvRzJiWGYrVWFmalZXemhCZFBkdGt5blNIZ0pwcnJPZzIvQ3FUK2hOWHNpd1BhL0RXUXl1NFpXVWpLaEk4UjJKeS9uUTdDY2VzM0RDdHIwYlErM091dDJldytjc3laajVra2V3MEk5WnJtTjdQWWU2UGdDSGt5ZUUrMngrWXF2aVI4K3dzdUtKalhiYXBzYmZWMmxVQ0NCb0NTUFhYV3NpM0M4WFkxczNCZFg3cmFOOHBNZlVlbFhlRmNVdVhKVnJUSXltQ0drZk1TTlJTYTlEVXQ3RGFXaWRnVDZVMWxJb2wyZTcwSHZMaDdxMXFyc0Q0b1AyWVVHWjZUVmppYllSeUZ0Qnp5ek5NZXVwbjZVcUh5M1FBYTRPdE1OM29LS1crQTJiZDRDNkhkTnc0a2s5R1hOeW11NGZFV2JZY01pdElJVWs2cWV2blJRV0JDMTBraGJaSUgycEFHM3Y5S084RzRZU2h2WFJLcWZGbGtnZEJyRld1QTRzT0dzcm1kR2pNRXlneU5SNGp0VXZFdUc0aXphSVZmQ1k4T2ZRK3V3cDBLOWsxL3ROYUNHM2F3MGdnZzVpQm9SR3kvclZYaGVCdFhiZHorRGxjQ1ZDQlZYenpGdGFDVzdONHRxVlVlV3AyOU90YTdnSERiZTl6eEhvVElwMjJ5YVNXakhZbkRSTWtDcWlsVHN3MDByMGJpL0NNTzUwdEF1Mmc1OG9nTHR5NVZpZUo0UkVZckNnamNEU0NPb3BOVVZHVmcwNFZQdUw3Q2xUaEEwQnJ0U005WnVZeTFjdUFsQVJWSitDSTV1UVlKMVFjaDYxbkxQRUlOV1c0d1JzZGF5ZVJ0N1JmZ2NmMk9nWHhXd0VnQmd6U1E2Z0VaU0RHL09kOUtGbFpxYkgzNWFlWnFLeHpxRzdOb3FqaTJLdllXeFVLbXJGdS9GU1dqdHh3TVJiOHNuL1ZXMWZqQ0FScHVEOHh6cnppN2VtN1BtUHBWaDhVYWFiWFJuUEhHZjdndDIxeDZYSGhGV0d5bGpBelpsblVIbE02K2dyTXF0VFhXbmVrb3FtMit3akZSVkltd3lhaXRIaFlyUDJCcVBVZmpSaTFjcTRFekxtS3NxUnBRQzlaMm8xY3VhVlF1ck1mM3lOYUdZTU5zejVVaUFLSWQzVXY3TUR5b29BZFpSU1JKZ1RxUUpnZFk1MG50aVRHbzVWWnY0UWNxcU9yQ2dCM2NuZURUVHBSUGgzRkxkcFNMZ056bUZMNVZCaUpJRzUrVkQ3OTFIYVFBSjVEV2dWa1F1RDFvN3cvQUxjdCtQdTdVR2M3dEJQOHNTQlZYRWNHdUl2ZUJTVTVOR1dma2RhZGdNSmFaR054MHR3ZmlKTEhVYUxsSHBUU0UzclFNNGpoMkRrVzdpRmVzRS9vUHJWSGkxaS9sRFdTTTZ6NFcyWUhsTWlENjZVU1prVnRITEwxVlluL0FGVVJ4dkdiVHJsRmhpeEdydmNKYmFOdjYwSUdZOWJ2RWhiSTcyMUJJSnRiQXg1eHY4Nks0QzNkZUJteW5ucE5kdFcwQU9nQjBnbGlZSE1hNzh2YXJBc09FTndFNVFjcEkwRWtURTBOMkNqUnJzTnc2eXRuK0s1dU45NXp0NUtPbFozRjhPdHRMcUZLcXdFNlFDZFIrRkNyOTBzY3pFc2Vwcml2SEtpd1VUUThPNG5idzRVanhTSmhZa1FZZ2o3TlQ4VTdVaGpsVlNWMGt6QjVTSWoxRkFNTGlMZXZlekdVeGxLanhjcG5sVkc1ZEhYOGFMMEhGWFlYL2VvVzduQ0FvRElWdHlPakVmbFZURmNUZG1KRGxRU2ZDcElBSFRTaHh1aW8yeEFIVDVtbFk2TDlqRkZXemhtRERZZ21mZXJkckNtNnR5NUsrSFZzekFNWjZBNmswRFhGQTdRZlRXdXRpVDFqMm9zS0xKUGxTcWdjVVB2ajNwVWhoNEhXbzVKTTEzTlRMZ2tBYTdqWWtiYTh1VllIUVJEclVsazZHbzNydHM2VWhrcGF1QjZaWEtBSXZ0VkxOUXJ2VXRNUXFldGNGT0ZBRTFuY2V0RVZORHJIeENyNHJXSFJsUHNtemFVMGpiKytWTm1uSGxXaEIwQ3BrTlFpcEFhQUpIQU5WcmxtUWFubXUwZ0JGN0NEV3FuY2xUb1NQU2psMnExeTBEVEVDYjRjNmxtYi9NU2Z4cUJjVGwzZ2ZLaVZ4S0Y0MUtRRjBZOWNoVXJMRWdodFFRQk1pTnRkUGFxcHZqcFFjc1pPcDk2cVc4Y0RkN3NxZFpNbitXbGRqNk5DY1VCMDk2NGVJYVJtSHkxb1JoN29KWVI4SmoxL1NwODFUWlhFdE5qZk0reHFNNHJ5UHppZ0dMNDNsTGlJeXNGR3huZVoxMG1QclUzRHVJWjFCNmFHWW5UbVlxM0dTVmtLVVc2QzV4QjZEMy9wVEd2dDVmWDlhclBpQUJtTEFBYjZiaW9yOThBaHAzOElFNk1UQi9DSStkSkpzcHRJdHM3SG45QlFYRzhNdU8wcTRWZlUvcFJRd0pHY01jeEVBYmFEYnFQT29ydUlDa0FoOWVpTWZxQkh1YUU1SjZGSlJhMlVjQnd0cmJaamNuUWlOZjFvbGtIU3JkN0NLcVoxekVzUVJ0cEkyUDFxc2xwajluOHFVbTI5amlrbFNPWmFWUy9zN2RQcVAxcFZCWm9nYVJOTm11azFtYWtOdzYxMU5xaXVySjUrOFUwV3ZOdjlSL1dnQ3hGS0tIWW5HTGJkVUphV0U3bmFZcXZnYlp0NGk0TlN0eitJcmE3ODFuYno5S3JpVFlTdGJtcHhWZXh6L3ZuVTRxUmpoVDZqcm9wZ1dNTjhRL3ZsVjZxR0YrS3J0YXc2TXA5a2xQcUp6QVBwV2Z4SEVidVpFYnUyRE1ScWs3SXpkZjVhcHVpS05OWGFFNFBIWEd1S2paWUlPd0lPZzlhS3pRbllOVVBXbkEwd0duVXdHT2RhaGNVM0Y0bFVrc3dIbHorUW9QaWVPaVNFSG9XMzloVEVYOFJRcTZjeGlobC9pVjEyaVdVOVcwVWdiQmN2T3FWdDdobGd6emxNNTRtWjFGdUJ2dHZSVEZ5UWRHQVRmWDNxRmVFV2crZURtRS9hUFBmU2hxWHJoRFExd0FRUm5qT2ZKTXVuTG4xcHJYTGh6QU02cU5SbitNNmZDcFV4eSt0VHdmc3J5UjlCcGNIYkVuTHVaT3AxUFhlbi9zeWZkRlo1YnJ2S0t6S1BpbDgwem9JekIvbkZTWVN6ZHZPTE5wYnZpKzltWWpuT1lPSUdnL3MwdkcvWWVWZWdvM0M3R3Y4QUJ0Nm1US2d5ZGRUMU9wOTZkYndscGRGdG92b3FqOEJWL2gzQUxWZ1RkWTNiaEVGYzdHMkQ1a25YMEdubWFoZkNXdzVJUUQwbU51UXFKUytyTkl4dmRHZDdUSXBGdGRKTEhRRGxsTS9sVkRGWVFkNWJTUENGWDZUK2dyWS9zeWZkSHRVZC9CV2pxMXREQTVxRG9OYWNjaVFwWTJ6QmNFRndZck13Y0E1OVNERy9VK2xiSHZRZVlxOXc3Q0plQ2kzYlV6eXlqU05KUElDaWpZTEQ0ZVFsdTI5NC9FK1JZWHFCcHFmNzhxZVRKemQwVGp4dUNxenpyaDVjWDdtZG1JQk9YTXhJZ21kSk9uS3RFdUlYN3c5NkhjWndBTjVpQW9CZy9BdTVHdE5YRGtBYXI3UjdBYlZjdm5zaUw0YUMzN1F2VVZ5aGdRYzIxOVAvQUNwVlBqUlhrWnF3YVJOUllhK3JxR1V5Q0pCcVJqV0IwMlFMenB4TmN0ODZwOFh3eHUybXRLWVp3QUkxNWc3YzlxRlgyTktUMUZXdzFhczRlL2JDNVZjZ2ZHRzFCMzFqbDg2Q2NRbEhsdkN0dHdGRXhta2hjMGRJTzFaaXp4NU1KM2xxem56bVFYSmpLeS9aZ2p5UHpORGJ2RXJseitKYy9peG9EY0piVWtFd1puMnJxOE9qbDgyNlBRTFRnQWtrQURja3dQZXErTDR4YlRJQk56TVNCM2VWZ0lna3NaQUc0b1pmNEJpOFZZVzVtdGkxcTRWaVF6THVERWJBVEhXYU9XdUcyVXc5cVZNb1F4QUl6dXhBSkdXZGlmbHB2V1hCTHRsODIzMW9zVTRWUXhQRmJkc00xMGhNcFdRTXhBemJEcVRvYXBIdFpoUi85aC8wUCtsU3NjbjBpbmtpdTJhUENmRjhxZTJPVVhoWmd5VnpUcEhQVGVaMDZVRTRueFJyZUdhOWFCekZWeXlwbnhzb25MMWdrd2FBNEx0STZnWHJpbHJrNVZud2pKOW9OQTJrNkdKbnlyV0VYeE01eVhLajBLOGZDM29md3JOWTF3dHkwU1FGQmNra3dCL0RZYSs5V3gybHc3V1MvZUFFNlpZWXNEOGhxUE9nbkVMQnh5QmJCREFnNnpBblNKNXhJK2xEanRXSlMwNjdEdkNjVWx5NHJXMlZoRGFnenlGSGdheDNaVHM5ZXdSZHJvQnpEVElaWFFhU1NCQjFQMG9seEc3aWJoUGRqSXAreUdHb01hRXp5b3BSdElPVGFUYUROL0dva3lkUUNZNTZVRnZkcFErWkZPUWlBZEJtQklud3RQUWpsUWJIMkxxZ2wwQTAxSlpQTFhYZWhTY0h4UmMzd2pHMllKbFpQd3dQQVJ0NTAwcmZZbTlhUWF2c1dtVG1KNXpKOTVxTExBMlllWkIvR3FEM1NnbDB5LzVrajhDS00ydXpneGRwQVN0dEdoaVJPWWpjUXBrRDVtcUpwdm9nV3cyLy9kOU5LYVVnaVNJNXptL1NuOFM3UFhjSW9JSWUxTUsreDExQWNjankwMDArVlZ2MmlDUnFCckI3d3pIS1FmNzFvWUZobVQ3NC93QjM2VTF3di9FQitaL1N1NGR5MEFkNXZ1TGdJMTBuUVRIdlJqaExHMjhna2tuN1lramZVU05EVXlseEtqRnlHNEhzK2ZpdkVvdTRBZzNHOUFSNFI1bjJvd0hWRnlXMUNMekEzYnpkdDIvQ211eE9wTW5xYXpQSE9MbGI5cFZaZ3F0L0V5L2EyME9uTFhuenJMNVRkR3RSZ3JEOXg2RVluRnNISUFCMi9DcFU0a0h1TWlxWUNocytrR1kwamNIWDZHcTE4K0tvYXJzMFRLdUw0a3daSTBneXduUXFaM21xL2FMSDNqaHU5dHFSYjd4Rk54U1J2TUErcEFCOWZPcjR3aVBxU3dNZ2VHTmdDZFpIbWFreHBQN0sySFRTMnJHNFFkUzdCODh0dHBvQUFOb0hQV3RvY1ZUTU1uSjJyQVhZTGlWOFg3NnE3QzFsSXl5U0ZKY1pjczdHQTJvNlZxY1ZpMVFRWUxSb0pIMTZWbWVEdjNXWjRVRmxWUUFrQ1p6Wm1LNnNkVHFaK0t1NGZHdTdPYmxzeXZUeEVpZWthUitkUFB0dVNKd2Fpa3k4MkpsaVhLa21OeE1SeTNwdC9IQWFBTE1iZ2Yxb2J3dTYxck9wUm1Ec3pqTC9BRGRSQk0xSmNSWEdWeGNZR1BDVURlNG1xVWZaTGw2S3QzaXNFeEREcklwVTl1SXBiSlJMWUNnNkJrQk91cG5UenJsYVYrRE96YThLNFMxcTBsc2tTcWdIMWpYNjFjT0JQWDZVVVZCVHdvcmxhdDJkYTBxUm04Qlo3MjJIUmhCNUZkUWRpRERVSFZiall3VzFZZkhsSklPaWlNNUFub0NhTThDeEZ1dytLdHV3QVc2ekNUdG1Qd2dkQW5kZTlaYmdIYUhQZWJMa1IyaURkQklKZDlRSVlRU1k2NzhxcDRtM3BhTHc1NHdpM0o3YXBJOVE0WndEQldtTjFiS202K3B1TjRtSk84VG9zeHlpc3oyNjdJMjdoL2FiQkVvQm5zRVF0d0JpU1ZLN01kUWV2bHpKY0w0b3pmd3JvVlgreVZQZ1loWktpZFEwUzBIZUQwSXFUR1lsRVA4QUVZS2pBL0VRSjVIek80cmEyam4wWjFlMHVIbkpmdDVkTlF5RFlqUWFUSytRMzJvSDJxN1cyamRqRFduVmlGWXMwTkJaUThMWkJDamZtZE9sQzA0VWwrNjFtMWVHZFc4QllrZ3dUR1p0VHFOSTNuNndZYmgxL0QzbkxXTzh1UkM1V01ET0hVdEs2bUkxK3U5T0dER3RzeG5tbSt2OGxuaUdJYkZNbGk5ZnQyMlh4Rml1WE96QVpSa0pFRVppTkpHKzFXK0c5aUpDTzkyUm9TdVNKRTdFNWp2VmUzaExmN1IzMkx1aDFCbExRYVlZeG82azVsWFFjdGRKT211dndlTUpzb0FCM2h5SkV5b1o5SkowMEdzalRWU0tjNU5Lb2loRlNkek5OZ3piVUFLcWd4dWZpUHYrVlE0eXpaZVNVR2ZyQU05Sm1zeGR0WGNwdWQ4OEFFaFl0NWN1K3ZoME1jK1huR3NWM2ladGxjd2s1b0pBaVFVTEswY3ZoSWpxRFdQRTZ1WnJzVGNWTFpQaEVLWTJHdzBvSndWeFp0TGJrYlp0QnVYOFV6ODZEOW44TmJGMjREYTB1K1B4aFdoaXpFRUhvd0krWTIxcTd4KzVsWUtoZzVDeGlQQ3FSb0J5SnpBYTh2U254M1NKVS90aGNjUk9zSDgvcFFuaUdHdDVXdUFrTElabFRReVRCeVJFQXlESHJRNU1HUkI3MjVtSkFQakpIaUlVd3AwMG1mbFYvQjhDdWxBVnZSQkkySTFVbFNRWjIwUHlOSnJRK1R1Z2Z3M0FXN1Z3WFNXY25LVUx3Vnl1RklZVHFHR3EvaFdwYmlHVHhFaGZQUVZrTWR4RzNadkl0NitqQU0yWUljNUJLbi9FeWlRSk5jVGkyRVppOTI5Ykk4V1ZUNG9HWWdBQ0oyQU8zMnZJUmZCdlpIa2l0Qm50RlovYUF1VmJiaVplQ3VkbDhPMnhtSkcvVFdydkNMdTVnaGQxa1I0ZVdoMkdocnpEalBGMWU1Y05sR0NzUU0zaUI4TTVZRXd1a0Q1VnB1RmNadDNMS0lIQXpaQTRKR1lFRVp3WjVHRDhqVlBGSkVSelJibzFPTzQ1WjBSL0dqWmdSbEpWaUFDc0VqS2RZT2hvT25GdUdPcFkyeWdCeWtrWllQVDRxcWNRTnk2Mkg3aTViem9DNTd4NEc2SE1EdG1rRWYyYXR2ZTRobVlOWlc1YkFKVXhiZk1laEFxWktpMUt5YTIzRDJJRnU4VUpFZ1Jta0VTQ0F5bjZWYzRmWXNBNWx4VnRoSTVLcDBucEZaNStLaGY0bDdod1ZnY3NpeVZZYWJobDVjcWh1NHZob1Bkdmh6Yk56S2ZBN2lkZFBReVRVdU42My9ZS1ZiMS9SdjB0SWY4QTdGUG9SK3RZampuWjY2MTI2N1g3WVRMY3VETG1KOEFCQ3NzQUFtQU5DWmlZcHI0UEEzWVZNVGZ0bEJFQXFZSDgyaEorZFNYZUVhbHJlTWxTRC9DK0NkTmdacFJxSlVtNUFQQmNjc2gxY013Z0FRUnRBZ2FqbFc4UEEyY0IwZENHQUkzR2hFamtldGVldDJYeGpCQWJZdVJDaUdIaFVUb1duYjByVDRYR2NTczI0TnBtQ2dBS0FqYUNCcGxqK3hXMlpSa2xSamhsSk4yVzJLVzM3dHJ0dk1OWURheEJIUG5WREY4V3RoQ3NqTVprYXpEYlJ5TlBidFJjQXozOExFR1BGYllIeUkzMDh4VXR2dGZZWkE3V3hsT2s1dk9ObUFpc2VOZlJyenY3QTFuRkJFSmtTRlV4Q3NUdU12bHlOUHcrS0tzekRYTkhpQkFFY2h5a2VWR3Yzbmc3Z2tXeDY1RVllNE5ERTRkaGd4SzRxQVRPUnJZeWpXWUFBQUZVK0V0U0ZHVTRPNGtlSXNvZFRlWHJCVng5UUNLckw0aEFZQVR1eklCUE1tV210UU1GZ24wbTNQazVYNlpxNDNabkROOEpjZWpUK00wSm9UVHN5V0s0cFp6SG1kSjA1d0pwVUE3UVdoWnhOMjNxUXJHRDVIVVQ1NjBxN0ZoVFJ4U3pTVGFQZDY0Ym5uVmJBNG9YTGFYTXBYTW9hRHVKRXdhbUwxNTlIcHBtVjQ3aHJQN1M5OTBRaGJMTS9nVmlTbVdUcUNDY3JLUHpySi92NnlsM3ZMYWVBTm1BeUlwM3RITDcyei9yNlZyTzAxcTRMZUpjSkllMjRHc2taMXRwQUc1L3c1K2RlWldHS3RwS3R1TndaMjA4ek1WMVlrbWppeXlhWVZ0OXI4VURtRHJta05PVWJxVEhxTlR2MW9meFhqVi9Fc0d2M1djcm9KZ0FBa0hRS0FOd1Bhb2JnS2tqS0FmTURueWcrdEdjQndVNVVaOGlLNjN2RU5TU3BDbEJHbWNTZFBJNzZtdHZpdG1QeWxxd1h3bkc1SGdRRk15T3NBeFB6cThPS05uS08yYTJUQkhJZENQU2x4N0RrWXhnR1ZqbEJKVVpSSXR3ZENkOUlJNjhoVkUydThjS3BKa2J4RUFic2ZJYSsxSnFMZC9nRTVMWDVMdU92V0xUWlVCWWpSc3htQ09nQVVmVTFjZTlmdjRjdmJIZGpETXR3OG0xK0ZsMEdnS0NCSFB5b1BqY1REUGxWUEVRd2FKYUdHYlFuYVF3cVhzK1h1M0h0bHpCczM0Qlk1WjdwbzBwMXF3dmRGbTMydHhRVHU1UmxJSTFUWFhlQ0k2bWxoT01YTHVKdDNicEJoaDRWbGRwMlZmRVkzam1kT2RHdXltRXRqQ3RldVc3YktGekUzQ2RJYTRkQkJHMlVlMVUreG1EbHJ1SlpOUXA3c2RTK2RXS2p5aUI2bXBiaXIwV2xKMXZzMi9BTGlPQ1YxR1N6b1JFRUpHeDFCa1Y1N3grOWR3K092c3JETXpFK0lTQ2pnTUFmSWFEL2xyWTluN3d0a284NWpiczZUTU1sc0J4NUhVSHprMEg3WllnTGljTmVVUVVJekhUTkJmd3dEdkhqNWM2eWhxYlJyazNCUDBDY1YyaXYzZ2xxMmlXM2FGbFNTek1mQUluUlpuK3RlcllOVnRXMFJkRlJRb25vb2o4cThyeDFudThVTXgvd1VXNmRwQmJFWjJWUXNabzcwMXVMM0VpMW9tMlZZc3Zoa0VxWkhQeXBaVXFWRHd0Mjc3UE04TmcyeFYxN2s1VmU2MnNUQmZQYzFrZ2FCVHVSdUs3aStDRkZaODZsQm1qVUJ6bGRVMVNUbE1zTkpOYWpzdGdudzhLNnJJWjdnWWEvWVZBRDAzYXFuYVJqY0NBSTV6UGN6WkpnanZnMm9Ha3dOQ1J5SFFWdDVQbFM2TVBGVWJmWm92L0FPZDJiZHZCRzQ0bk83dWY4cWVBRC9ZVDg2RjlyK0NKYXNJd0NCeUI0Z29VbHBRUVFGMUpMYmsrZEVlREtpNFZiU1pnQ0RJYlVqTVpZZmlLc2NUd1A3VGtWeWNvTW1ER2dralgvTUZySGxVN04rRndTL0JGdy9zdWlTclpneXFnbGZHRG9kVHozbllBVk4rNW9iK0hmVE4wTW8zNHo5S01XU1F4WW5jS1BhZC9lcDdoRENHQUk2RUFqNjFsTGJzMmlxVkFYdWNiYjJMSDBiTjlHcXBmNGhkSCtOWVJoL05iL01hVWMvWTBId0Y3ZitSaUIvcE1yOUthd3ZqWjB1RG82NVQvQUtsMC93QnRJWm0wZkJzV1A3UGtMQWhqYmJjSGVScFZkZUNZUEt5Mjc5MjFtajRnVGxJNkdOUGVqK0pkRC9qWVFqK1pJdUQxMGdqMnFvTUpnN253WHNoNkV4cjZOVFVtUzRvb0RzL2Y3dFJZeE50M0IrSW5ValhRNzlSN1Vydjcwc29wQ200MnVZQnBXSjBpYXZYT3pqN3E2c1BQOVJVQnM0dTBaQmVPaXRtSHNhRTE2QnArMk12OXFzUlpSR3UyeVpBekxrMVV4cnRHbE1idFRoYmlCcnRpMlZiU1NCOVJCNkdwdjMvZVdBNFU5YzZRZnBGTXhQRXNMYzB2WVpTT3F3ZjAvR2hVRGJHb09HM1VJVzJVUnRDVTBIKzArbktsaCtBNFFLeTJyNUFia3htTkkwbUtZY0J3KzViTnRYZTBwNWErdk9RTnFaaE95WVdUYXhQZUFqUUVobzh4QjBwOXA3SnFtdERMWFpHNnJCbHhJdUtQc2tlWDNnYW9ZL2h1TXNrdVZRcE82a3lCUDlhbHQ5bnNkYmNIT0hRSFdEckh6SDUwM2lQRXNaWVlaVXVGWTEwWXdmcjVWVzNLcVRKMG8zdGY5L0prOGRkejNHYnFlWjE2YTBxMWxqdFBkWlFTQUR6bFJPaGpYU2xXNnpTU3JpYzd3d2s3NWY2UFZCYUFwRlJVcEZNSzF4bm9FTG9QL2RadmoyZDdsdTNheUtmR3pNUk1MQ29jbzVraHlQbldwYTNOVWJ2REVMWi90UmxuWGFaamZyVFRvbVN0SG1mR3VBbHNRWUppNHhsanFBVDRvQTNBaFQxNVZadDhJdUEyMGtsVll5UkpNWlRvQnlVeDd0Vyt1Y0l0c3lzWmxUSTljcFhYcm94cWRMQ3JzQVBwV25rZFVaK0ZYWjU0M1l1NWV1RjJjSXZMVE1RQjh3UC9BSFJkT3h0dFV5QzdjOC9oQVByQW1QS2ExN1ZFMUo1Sk1heFJXekFYK3dUbHY4WlF1bjJTV2dBQ0ltT1hXckQ5azdWaTI1WE96c3BUTnZHZndrZ0RiZXRveTAwclI1WkM4TWZSaFc0WXk0WjhPQVdVdG1HYlFnaUkyMzJtclhDRGRGdTNBaUxhcnRCMDJKOTYxajI2aTdtazV0bExHbDBBT0Y0TzZqczd2SmVKK1FnYVZGeHJnb3ZzcElKNjY3QUJvQTU3bXRJYlZOTm1rcE5iRzRKcW1ZMi93Vmd4ZFZsOU5TVHNDcC8vQUNLbDRMWXhDTVZaSXRtWWdpRjVpTlpqeTlLMW5kVjBXNmZOMVRGNDBuYUtGdXllZFNKZ2xBaVA3T3RYTWxMTFUyVlJYdDRZTG9BQjZWS2x1cElwUlJZVWRVMDhQVEJYWm9HUHpVczFNbXVHZ1JMbnFERVlkTG54b3JlbzE5OTY3TmRtZ0FjM0IxVXphZTVhUDhyRWo1Zy9yVGMyTXQ3TWwwZENJYjh2eE5FczFJbWdBVzNIRjJ2MldUeklrZldLak5uQlhmdXFUL3lHaTJibFZQRThNc3Y4U0NlbzhQNFVCUVB2ZGxsT3FYRDVUcUtHWW5zL2lFK0dENWd3ZnJSSzd3UjFNMkx6S2VobVBkZjBwdjdiamJYeG9MZzZnVC8wd2ZjVXlXQmx4V01zL2F1ajE4WStzaXA3UGEyOE5IVkhIcGxQMDI5cUtXKzAxczZYRUtubnorbTlUbTVoTDNORDYrRS9Xbi9CTmVtQy93RDVXblBEZjdoLzIwcXZIc3hoenFBZmt4ajhhNVQrSWZJOUJOTk5LbFdac05OTU5LbFFBMWhVVENsU3BpT1JYQ3RLbFNHTUtVd3JTcFVBTVlVMktWS2dRaUs1RktsUU00QlhLVktnQmhya1VxVkFqc1VwcmxLZ0JHa0tWS2dEazBwcFVxQkNwVXFWTURzVndpbFNvQVlUVFNhVktnQnBhbTVxN1NwQVJYN0NYTkhSVzlRRDdIbFF1LzJldEg0Q3lIL1VQWTYvV3UwcWRnMG1ETG5aeTdPald5UCtZZlNLVktsVDVNamdqLy9aXCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndDRUFBa0dCeE1TRWhVU0V4TVZGaFVYR0JjWEdCY1hHQmNXRnhnWEZSVVhGaGNWRlJjYUhpZ2dHQm9sSGhVVklURWhKU2tyTGk0dUZ4OHpPRE10TnlndExpc0JDZ29LRGcwT0doQVFHeTBtSHlVdEx5MHRMUzB2TFMwdExpMHRMUzB0S3kwdExTMHRMUzB0TFMwdExTMHJMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMZi9BQUJFSUFMY0JFd01CSWdBQ0VRRURFUUgveEFBYkFBQUJCUUVCQUFBQUFBQUFBQUFBQUFBRkFBSURCQVlCQi8vRUFFRVFBQUlCQWdRREJnTUZCZ1FHQXdFQUFBRUNFUUFEQkJJaE1RVkJVUVlUSW1GeGtUS0JvVUpTc2NIUkZCVWpZdUh3TTNLU29sT0NzdExpOFJaRHdnZi94QUFhQVFBREFRRUJBUUFBQUFBQUFBQUFBQUFBQVFJREJBVUcvOFFBS0JFQUFnSUNBZ0lDQVFRREFRQUFBQUFBQUFFQ0VRTWhFakVUVVNKQllSUXlnYkdSb2ZBRS85b0FEQU1CQUFJUkF4RUFQd0FTMWRGTmMwNVRYejdQcEVTTFhNUXhpQnVkSjZIa2E2dE5WNWIwL0UvMG4zcG9HV3J1Q2V5UWx4V1V3SURDREhJMUJkUU1JSUJCNjFOZXZzMFppVEFnVHJvT1ZSRGVodmVnUzFzcllEQkpZTEZKR2ZTQ1pnRGVQZXJpNjBGN1dkNmoyV3RxeENoZzBDZFRCSU1lUzAzRGNjVEpPWUFuKzVyU2NKTko5bWNaeGkydWd6Y2JsVEpvUCs5ays4UGNWejk3cDk5ZmNVS0RCelhzTGswMHRRbzhZdC9mWDNGTlBHTGYzMTl4Undmb09jZllUWnFhR29XT0xJVEFZRW56RkVzTXdPdEpwcnNha24wVG9uV3BLNERTcURRN1NBcnBBQWswNnkrWVNBWTg5UG42VlNpUzVIRzBFZ0VucFRFc3NTQ3gyMlViVDU5YXVXN0pQcFZxM2FBL1dyU0laWHRZWW5mVDhhdElnR3dwNEZQQzAwaVd5cThrd0JUN1dHNjFLMXdDbzh4UHBWcEV0bkxqQlRwOUtrYkVyeXE5eGRNT0V0OXlXTFI0ODIwNmJmWDZVSEswMmlVeDc0Z0dtbW95bGNCaWdCeEZjcHdOY0lvR2NwVW9yb0ZBaHNWMWJaTlMyMG83d1BpQ1djMFcwdU1kQklMUjZBVTBoTm1lN2sxMmp6NEc2eExkeWRkZVErbktsUUl3NHVUVXlOVU51M29LZDNSNVZ5VWRpTEttckdGUzEzUmtQM3BNZ3lNdVdObUVUbTIxbWh3VWtoV09VRWdFbWRCT3BxN2RoV0toMWVER1paZytZbURUNlF1MkltcDhJQVBFZmw2OHFyMjF6R0t0WERycHNOcVMxc3J2UXgwekFnODkrUjE4NnlPTDdJT0NjcmdDVEdhVG9ZaVkyNTlkaFcvNFRnczVMTjhJK3AvU29PSnJyV21PY29iUm5saEdlbWVmanNsZC93Q0luczFQUFpGLytLc2Y1VCt0YXVhUmFyL1VUOW1YNmJINk1wLzhSYlgrTUo1ZUUvWFdrdlpJODczc25QOEExVnFHYWtxenZSK29uN0d2L05qOUdhdDlrei94dXYySTE1ZmFxSzFqSHc5enVydnlia3c1RWYzNVZycXE4UXdLWGx5dU9zSG1wSWlSU1daeTFQb2J3S080YVp6Q1hjNGtWY3RSeTE1ZjBxbHd6aHh0MnhiSk9oM0drajhxTFlmQ0FDSWdkQlU4VjlGSnY3SUJZekVhVEhzS3VXOE9CdnFhbVZZMEZQQzlhcElUWTBDcEFuV21tNUcxUmxpYXBJaHNsYTZCdFVUT1RTQzA0TFZDSXdLY0ZwOU5MVUFjSXB1V2tYcDlxNXJvSk5BaXdlRlhPN0Z3b2NoTUJvMG1xVjYxRzliTGhIQzcxOUFIY3JiR3lqWDJuUVVNN1FjSXNvOEMrb2dhcUllNFdrekoxeWphcXJWa2N0MFpSN3NIVC8zVXR1NkQ2OUtKNHZzLzNTTGVLYVA4TE1aWS9wUXpKcU5LVFJTZGlaNnEzY2FxNkZoUFRjK3dxNDlzRUVIbnA3MUhoN0NXL2dRQTlkejcwaHNsNFBiTjU0S09GaWN4MEJPbWdIUG5XMXdON0M0WWVOMUI2RHhON0NUV0xlOHgwa3gwMkZSUlRzVFZvM2o5dHNPREF0M0NPc0wrYlVxd2NVcXJteVBGRXIyN05FOERncE90VmtxOWgzcmpPNG00aHc0RWJDZzJONGFGMm1qalhpS2d4VjBFR2VsS3gwQ01LdVZQTWsrMjFQRlFFd2ZLbkRFQVV1eDlCaTFqY3FnRGxWREYzWnFtK0s5YWllNlRWV1JROW1waGFveVRYVU5JWktxOWFrbW93YW1TMzFwZGo2T0tKcnR0aG15N25uMEhxZVZUSW5TcDdXSEFxMUVoc3A0UEhxYnIydnRMbCtZWlFmenE1Y3hsdGZpZFI4eFE3ajNCTy9BYTJRbDBhQnRRQ3N6bFlqM0g5YUhZWHNleW1Ydi9BQ1JmT2QyUDVWMFJqQnEyem5sS2FkSkJxM3h5eXh5cTZrK3UvcDFxeUwwODZFWGV5MWtxQUdjRWZhT1VrK29nVFE5dUVZeXhyYWZ2RjZmK0xma2Fxby9USjVTWGFOVWlhelB5NVZJQldXdy9hTmtPVzliWlQ2SDZxZFI5YU5ZUGk5dTU4TEErWE1lb3BPTFExTk1KQmFhd05FdUE0dG5KczJ3RG5JVnZEbmpYYy9kQTlSUkRqSEM3TnJRM2d6L2RFYWZJYmZPaXRXSEpYUmwzdVJURkhTZm1ab2hpdXo0UW8xd0ZsZnhMSmtSUEliRGVyOTVMVmk4Q244UkJCMUVUMUVIYWloMkJiUERMdDVnbHN3VDVTZmxPbEV1RThLVzFmeTNDVlluS3pPWmpYbjBGUHZjUmk4YnRzWk5aVURsVlhGWXRyakZtTWs2azA5QzJ5OXgzRXVIYTB0NHRiR2d5bktwK1EzK2MwR1VSVDIxcHNVbXdTQ2RnZDViYlBkVmNnOEt0TEUrU2pZVUlkYWttbjJySll4UUJWTk5Cb3RqK0dpMllEcStreWtuNWJUUVRGNGhFM1A4QWZwdlJRV1RFVnlLZ3NZbmFSb2RqK3RUczRwRE9SU3FzM0ViWU1GMWtlWXBVQ3N1cWxXN0sxZHZjTVpUQkJGTUZpS3dhT2xNZ3VpcVdJYlExZnZMVkMvVVVVVVhGUXNsV3lsT1d3VHlvQUhzSzdscTlmd1RTQUJxZVZUL3VhN0dZbzBUbDJPL1NtbFlyb0U1YTR5MWF2WVpsSkJFRWJnMUdiZEZEc2ZZU3JhV2V0TEREb0tJcGdtaVltcmpHeUpTb3FxdlNuQ3IxcTJnbk9yYkdJMGh1Uk9oa1ZXS2l0T05HZkt4a21wN3Q4RkZYSW9LejRoT1pwKzlyeXFJaW1rMHhDQzFhVEFYQ21jS2NzeE1hVEV4VlJTYU84RnhGaTNyZlptNklzbVQ1OHZjMElUZElBWXEycEVPb0k4d0NCNzdVS2ZDMk1QOEF4d0lERlFZTXJyTUhYbDg2MDNHc1ZhdlBLMlFvRzJiWGYrVWFmalZXemhCZFBkdGt5blNIZ0pwcnJPZzIvQ3FUK2hOWHNpd1BhL0RXUXl1NFpXVWpLaEk4UjJKeS9uUTdDY2VzM0RDdHIwYlErM091dDJldytjc3laajVra2V3MEk5WnJtTjdQWWU2UGdDSGt5ZUUrMngrWXF2aVI4K3dzdUtKalhiYXBzYmZWMmxVQ0NCb0NTUFhYV3NpM0M4WFkxczNCZFg3cmFOOHBNZlVlbFhlRmNVdVhKVnJUSXltQ0drZk1TTlJTYTlEVXQ3RGFXaWRnVDZVMWxJb2wyZTcwSHZMaDdxMXFyc0Q0b1AyWVVHWjZUVmppYllSeUZ0Qnp5ek5NZXVwbjZVcUh5M1FBYTRPdE1OM29LS1crQTJiZDRDNkhkTnc0a2s5R1hOeW11NGZFV2JZY01pdElJVWs2cWV2blJRV0JDMTBraGJaSUgycEFHM3Y5S084RzRZU2h2WFJLcWZGbGtnZEJyRld1QTRzT0dzcm1kR2pNRXlneU5SNGp0VXZFdUc0aXphSVZmQ1k4T2ZRK3V3cDBLOWsxL3ROYUNHM2F3MGdnZzVpQm9SR3kvclZYaGVCdFhiZHorRGxjQ1ZDQlZYenpGdGFDVzdONHRxVlVlV3AyOU90YTdnSERiZTl6eEhvVElwMjJ5YVNXakhZbkRSTWtDcWlsVHN3MDByMGJpL0NNTzUwdEF1Mmc1OG9nTHR5NVZpZUo0UkVZckNnamNEU0NPb3BOVVZHVmcwNFZQdUw3Q2xUaEEwQnJ0U005WnVZeTFjdUFsQVJWSitDSTV1UVlKMVFjaDYxbkxQRUlOV1c0d1JzZGF5ZVJ0N1JmZ2NmMk9nWHhXd0VnQmd6U1E2Z0VaU0RHL09kOUtGbFpxYkgzNWFlWnFLeHpxRzdOb3FqaTJLdllXeFVLbXJGdS9GU1dqdHh3TVJiOHNuL1ZXMWZqQ0FScHVEOHh6cnppN2VtN1BtUHBWaDhVYWFiWFJuUEhHZjdndDIxeDZYSGhGV0d5bGpBelpsblVIbE02K2dyTXF0VFhXbmVrb3FtMit3akZSVkltd3lhaXRIaFlyUDJCcVBVZmpSaTFjcTRFekxtS3NxUnBRQzlaMm8xY3VhVlF1ck1mM3lOYUdZTU5zejVVaUFLSWQzVXY3TUR5b29BZFpSU1JKZ1RxUUpnZFk1MG50aVRHbzVWWnY0UWNxcU9yQ2dCM2NuZURUVHBSUGgzRkxkcFNMZ056bUZMNVZCaUpJRzUrVkQ3OTFIYVFBSjVEV2dWa1F1RDFvN3cvQUxjdCtQdTdVR2M3dEJQOHNTQlZYRWNHdUl2ZUJTVTVOR1dma2RhZGdNSmFaR054MHR3ZmlKTEhVYUxsSHBUU0UzclFNNGpoMkRrVzdpRmVzRS9vUHJWSGkxaS9sRFdTTTZ6NFcyWUhsTWlENjZVU1prVnRITEwxVlluL0FGVVJ4dkdiVHJsRmhpeEdydmNKYmFOdjYwSUdZOWJ2RWhiSTcyMUJJSnRiQXg1eHY4Nks0QzNkZUJteW5ucE5kdFcwQU9nQjBnbGlZSE1hNzh2YXJBc09FTndFNVFjcEkwRWtURTBOMkNqUnJzTnc2eXRuK0s1dU45NXp0NUtPbFozRjhPdHRMcUZLcXdFNlFDZFIrRkNyOTBzY3pFc2Vwcml2SEtpd1VUUThPNG5idzRVanhTSmhZa1FZZ2o3TlQ4VTdVaGpsVlNWMGt6QjVTSWoxRkFNTGlMZXZlekdVeGxLanhjcG5sVkc1ZEhYOGFMMEhGWFlYL2VvVzduQ0FvRElWdHlPakVmbFZURmNUZG1KRGxRU2ZDcElBSFRTaHh1aW8yeEFIVDVtbFk2TDlqRkZXemhtRERZZ21mZXJkckNtNnR5NUsrSFZzekFNWjZBNmswRFhGQTdRZlRXdXRpVDFqMm9zS0xKUGxTcWdjVVB2ajNwVWhoNEhXbzVKTTEzTlRMZ2tBYTdqWWtiYTh1VllIUVJEclVsazZHbzNydHM2VWhrcGF1QjZaWEtBSXZ0VkxOUXJ2VXRNUXFldGNGT0ZBRTFuY2V0RVZORHJIeENyNHJXSFJsUHNtemFVMGpiKytWTm1uSGxXaEIwQ3BrTlFpcEFhQUpIQU5WcmxtUWFubXUwZ0JGN0NEV3FuY2xUb1NQU2psMnExeTBEVEVDYjRjNmxtYi9NU2Z4cUJjVGwzZ2ZLaVZ4S0Y0MUtRRjBZOWNoVXJMRWdodFFRQk1pTnRkUGFxcHZqcFFjc1pPcDk2cVc4Y0RkN3NxZFpNbitXbGRqNk5DY1VCMDk2NGVJYVJtSHkxb1JoN29KWVI4SmoxL1NwODFUWlhFdE5qZk0reHFNNHJ5UHppZ0dMNDNsTGlJeXNGR3huZVoxMG1QclUzRHVJWjFCNmFHWW5UbVlxM0dTVmtLVVc2QzV4QjZEMy9wVEd2dDVmWDlhclBpQUJtTEFBYjZiaW9yOThBaHAzOElFNk1UQi9DSStkSkpzcHRJdHM3SG45QlFYRzhNdU8wcTRWZlUvcFJRd0pHY01jeEVBYmFEYnFQT29ydUlDa0FoOWVpTWZxQkh1YUU1SjZGSlJhMlVjQnd0cmJaamNuUWlOZjFvbGtIU3JkN0NLcVoxekVzUVJ0cEkyUDFxc2xwajluOHFVbTI5amlrbFNPWmFWUy9zN2RQcVAxcFZCWm9nYVJOTm11azFtYWtOdzYxMU5xaXVySjUrOFUwV3ZOdjlSL1dnQ3hGS0tIWW5HTGJkVUphV0U3bmFZcXZnYlp0NGk0TlN0eitJcmE3ODFuYno5S3JpVFlTdGJtcHhWZXh6L3ZuVTRxUmpoVDZqcm9wZ1dNTjhRL3ZsVjZxR0YrS3J0YXc2TXA5a2xQcUp6QVBwV2Z4SEVidVpFYnUyRE1ScWs3SXpkZjVhcHVpS05OWGFFNFBIWEd1S2paWUlPd0lPZzlhS3pRbllOVVBXbkEwd0duVXdHT2RhaGNVM0Y0bFVrc3dIbHorUW9QaWVPaVNFSG9XMzloVEVYOFJRcTZjeGlobC9pVjEyaVdVOVcwVWdiQmN2T3FWdDdobGd6emxNNTRtWjFGdUJ2dHZSVEZ5UWRHQVRmWDNxRmVFV2crZURtRS9hUFBmU2hxWHJoRFExd0FRUm5qT2ZKTXVuTG4xcHJYTGh6QU02cU5SbitNNmZDcFV4eSt0VHdmc3J5UjlCcGNIYkVuTHVaT3AxUFhlbi9zeWZkRlo1YnJ2S0t6S1BpbDgwem9JekIvbkZTWVN6ZHZPTE5wYnZpKzltWWpuT1lPSUdnL3MwdkcvWWVWZWdvM0M3R3Y4QUJ0Nm1US2d5ZGRUMU9wOTZkYndscGRGdG92b3FqOEJWL2gzQUxWZ1RkWTNiaEVGYzdHMkQ1a25YMEdubWFoZkNXdzVJUUQwbU51UXFKUytyTkl4dmRHZDdUSXBGdGRKTEhRRGxsTS9sVkRGWVFkNWJTUENGWDZUK2dyWS9zeWZkSHRVZC9CV2pxMXREQTVxRG9OYWNjaVFwWTJ6QmNFRndZck13Y0E1OVNERy9VK2xiSHZRZVlxOXc3Q0plQ2kzYlV6eXlqU05KUElDaWpZTEQ0ZVFsdTI5NC9FK1JZWHFCcHFmNzhxZVRKemQwVGp4dUNxenpyaDVjWDdtZG1JQk9YTXhJZ21kSk9uS3RFdUlYN3c5NkhjWndBTjVpQW9CZy9BdTVHdE5YRGtBYXI3UjdBYlZjdm5zaUw0YUMzN1F2VVZ5aGdRYzIxOVAvQUNwVlBqUlhrWnF3YVJOUllhK3JxR1V5Q0pCcVJqV0IwMlFMenB4TmN0ODZwOFh3eHUybXRLWVp3QUkxNWc3YzlxRlgyTktUMUZXdzFhczRlL2JDNVZjZ2ZHRzFCMzFqbDg2Q2NRbEhsdkN0dHdGRXhta2hjMGRJTzFaaXp4NU1KM2xxem56bVFYSmpLeS9aZ2p5UHpORGJ2RXJseitKYy9peG9EY0piVWtFd1puMnJxOE9qbDgyNlBRTFRnQWtrQURja3dQZXErTDR4YlRJQk56TVNCM2VWZ0lna3NaQUc0b1pmNEJpOFZZVzVtdGkxcTRWaVF6THVERWJBVEhXYU9XdUcyVXc5cVZNb1F4QUl6dXhBSkdXZGlmbHB2V1hCTHRsODIzMW9zVTRWUXhQRmJkc00xMGhNcFdRTXhBemJEcVRvYXBIdFpoUi85aC8wUCtsU3NjbjBpbmtpdTJhUENmRjhxZTJPVVhoWmd5VnpUcEhQVGVaMDZVRTRueFJyZUdhOWFCekZWeXlwbnhzb25MMWdrd2FBNEx0STZnWHJpbHJrNVZud2pKOW9OQTJrNkdKbnlyV0VYeE01eVhLajBLOGZDM29md3JOWTF3dHkwU1FGQmNra3dCL0RZYSs5V3gybHc3V1MvZUFFNlpZWXNEOGhxUE9nbkVMQnh5QmJCREFnNnpBblNKNXhJK2xEanRXSlMwNjdEdkNjVWx5NHJXMlZoRGFnenlGSGdheDNaVHM5ZXdSZHJvQnpEVElaWFFhU1NCQjFQMG9seEc3aWJoUGRqSXAreUdHb01hRXp5b3BSdElPVGFUYUROL0dva3lkUUNZNTZVRnZkcFErWkZPUWlBZEJtQklud3RQUWpsUWJIMkxxZ2wwQTAxSlpQTFhYZWhTY0h4UmMzd2pHMllKbFpQd3dQQVJ0NTAwcmZZbTlhUWF2c1dtVG1KNXpKOTVxTExBMlllWkIvR3FEM1NnbDB5LzVrajhDS00ydXpneGRwQVN0dEdoaVJPWWpjUXBrRDVtcUpwdm9nV3cyLy9kOU5LYVVnaVNJNXptL1NuOFM3UFhjSW9JSWUxTUsreDExQWNjankwMDArVlZ2MmlDUnFCckI3d3pIS1FmNzFvWUZobVQ3NC93QjM2VTF3di9FQitaL1N1NGR5MEFkNXZ1TGdJMTBuUVRIdlJqaExHMjhna2tuN1lramZVU05EVXlseEtqRnlHNEhzK2ZpdkVvdTRBZzNHOUFSNFI1bjJvd0hWRnlXMUNMekEzYnpkdDIvQ211eE9wTW5xYXpQSE9MbGI5cFZaZ3F0L0V5L2EyME9uTFhuenJMNVRkR3RSZ3JEOXg2RVluRnNISUFCMi9DcFU0a0h1TWlxWUNocytrR1kwamNIWDZHcTE4K0tvYXJzMFRLdUw0a3daSTBneXduUXFaM21xL2FMSDNqaHU5dHFSYjd4Rk54U1J2TUErcEFCOWZPcjR3aVBxU3dNZ2VHTmdDZFpIbWFreHBQN0sySFRTMnJHNFFkUzdCODh0dHBvQUFOb0hQV3RvY1ZUTU1uSjJyQVhZTGlWOFg3NnE3QzFsSXl5U0ZKY1pjczdHQTJvNlZxY1ZpMVFRWUxSb0pIMTZWbWVEdjNXWjRVRmxWUUFrQ1p6Wm1LNnNkVHFaK0t1NGZHdTdPYmxzeXZUeEVpZWthUitkUFB0dVNKd2Fpa3k4MkpsaVhLa21OeE1SeTNwdC9IQWFBTE1iZ2Yxb2J3dTYxck9wUm1Ec3pqTC9BRGRSQk0xSmNSWEdWeGNZR1BDVURlNG1xVWZaTGw2S3QzaXNFeEREcklwVTl1SXBiSlJMWUNnNkJrQk91cG5UenJsYVYrRE96YThLNFMxcTBsc2tTcWdIMWpYNjFjT0JQWDZVVVZCVHdvcmxhdDJkYTBxUm04Qlo3MjJIUmhCNUZkUWRpRERVSFZiall3VzFZZkhsSklPaWlNNUFub0NhTThDeEZ1dytLdHV3QVc2ekNUdG1Qd2dkQW5kZTlaYmdIYUhQZWJMa1IyaURkQklKZDlRSVlRU1k2NzhxcDRtM3BhTHc1NHdpM0o3YXBJOVE0WndEQldtTjFiS202K3B1TjRtSk84VG9zeHlpc3oyNjdJMjdoL2FiQkVvQm5zRVF0d0JpU1ZLN01kUWV2bHpKY0w0b3pmd3JvVlgreVZQZ1loWktpZFEwUzBIZUQwSXFUR1lsRVA4QUVZS2pBL0VRSjVIek80cmEyam4wWjFlMHVIbkpmdDVkTlF5RFlqUWFUSytRMzJvSDJxN1cyamRqRFduVmlGWXMwTkJaUThMWkJDamZtZE9sQzA0VWwrNjFtMWVHZFc4QllrZ3dUR1p0VHFOSTNuNndZYmgxL0QzbkxXTzh1UkM1V01ET0hVdEs2bUkxK3U5T0dER3RzeG5tbSt2OGxuaUdJYkZNbGk5ZnQyMlh4Rml1WE96QVpSa0pFRVppTkpHKzFXK0c5aUpDTzkyUm9TdVNKRTdFNWp2VmUzaExmN1IzMkx1aDFCbExRYVlZeG82azVsWFFjdGRKT211dndlTUpzb0FCM2h5SkV5b1o5SkowMEdzalRWU0tjNU5Lb2loRlNkek5OZ3piVUFLcWd4dWZpUHYrVlE0eXpaZVNVR2ZyQU05Sm1zeGR0WGNwdWQ4OEFFaFl0NWN1K3ZoME1jK1huR3NWM2ladGxjd2s1b0pBaVFVTEswY3ZoSWpxRFdQRTZ1WnJzVGNWTFpQaEVLWTJHdzBvSndWeFp0TGJrYlp0QnVYOFV6ODZEOW44TmJGMjREYTB1K1B4aFdoaXpFRUhvd0krWTIxcTd4KzVsWUtoZzVDeGlQQ3FSb0J5SnpBYTh2U254M1NKVS90aGNjUk9zSDgvcFFuaUdHdDVXdUFrTElabFRReVRCeVJFQXlESHJRNU1HUkI3MjVtSkFQakpIaUlVd3AwMG1mbFYvQjhDdWxBVnZSQkkySTFVbFNRWjIwUHlOSnJRK1R1Z2Z3M0FXN1Z3WFNXY25LVUx3Vnl1RklZVHFHR3EvaFdwYmlHVHhFaGZQUVZrTWR4RzNadkl0NitqQU0yWUljNUJLbi9FeWlRSk5jVGkyRVppOTI5Ykk4V1ZUNG9HWWdBQ0oyQU8zMnZJUmZCdlpIa2l0Qm50RlovYUF1VmJiaVplQ3VkbDhPMnhtSkcvVFdydkNMdTVnaGQxa1I0ZVdoMkdocnpEalBGMWU1Y05sR0NzUU0zaUI4TTVZRXd1a0Q1VnB1RmNadDNMS0lIQXpaQTRKR1lFRVp3WjVHRDhqVlBGSkVSelJibzFPTzQ1WjBSL0dqWmdSbEpWaUFDc0VqS2RZT2hvT25GdUdPcFkyeWdCeWtrWllQVDRxcWNRTnk2Mkg3aTViem9DNTd4NEc2SE1EdG1rRWYyYXR2ZTRobVlOWlc1YkFKVXhiZk1laEFxWktpMUt5YTIzRDJJRnU4VUpFZ1Jta0VTQ0F5bjZWYzRmWXNBNWx4VnRoSTVLcDBucEZaNStLaGY0bDdod1ZnY3NpeVZZYWJobDVjcWh1NHZob1Bkdmh6Yk56S2ZBN2lkZFBReVRVdU42My9ZS1ZiMS9SdjB0SWY4QTdGUG9SK3RZampuWjY2MTI2N1g3WVRMY3VETG1KOEFCQ3NzQUFtQU5DWmlZcHI0UEEzWVZNVGZ0bEJFQXFZSDgyaEorZFNYZUVhbHJlTWxTRC9DK0NkTmdacFJxSlVtNUFQQmNjc2gxY013Z0FRUnRBZ2FqbFc4UEEyY0IwZENHQUkzR2hFamtldGVldDJYeGpCQWJZdVJDaUdIaFVUb1duYjByVDRYR2NTczI0TnBtQ2dBS0FqYUNCcGxqK3hXMlpSa2xSamhsSk4yVzJLVzM3dHJ0dk1OWURheEJIUG5WREY4V3RoQ3NqTVprYXpEYlJ5TlBidFJjQXozOExFR1BGYllIeUkzMDh4VXR2dGZZWkE3V3hsT2s1dk9ObUFpc2VOZlJyenY3QTFuRkJFSmtTRlV4Q3NUdU12bHlOUHcrS0tzekRYTkhpQkFFY2h5a2VWR3Yzbmc3Z2tXeDY1RVllNE5ERTRkaGd4SzRxQVRPUnJZeWpXWUFBQUZVK0V0U0ZHVTRPNGtlSXNvZFRlWHJCVng5UUNLckw0aEFZQVR1eklCUE1tV210UU1GZ24wbTNQazVYNlpxNDNabkROOEpjZWpUK00wSm9UVHN5V0s0cFp6SG1kSjA1d0pwVUE3UVdoWnhOMjNxUXJHRDVIVVQ1NjBxN0ZoVFJ4U3pTVGFQZDY0Ym5uVmJBNG9YTGFYTXBYTW9hRHVKRXdhbUwxNTlIcHBtVjQ3aHJQN1M5OTBRaGJMTS9nVmlTbVdUcUNDY3JLUHpySi92NnlsM3ZMYWVBTm1BeUlwM3RITDcyei9yNlZyTzAxcTRMZUpjSkllMjRHc2taMXRwQUc1L3c1K2RlWldHS3RwS3R1TndaMjA4ek1WMVlrbWppeXlhWVZ0OXI4VURtRHJta05PVWJxVEhxTlR2MW9meFhqVi9Fc0d2M1djcm9KZ0FBa0hRS0FOd1Bhb2JnS2tqS0FmTURueWcrdEdjQndVNVVaOGlLNjN2RU5TU3BDbEJHbWNTZFBJNzZtdHZpdG1QeWxxd1h3bkc1SGdRRk15T3NBeFB6cThPS05uS08yYTJUQkhJZENQU2x4N0RrWXhnR1ZqbEJKVVpSSXR3ZENkOUlJNjhoVkUydThjS3BKa2J4RUFic2ZJYSsxSnFMZC9nRTVMWDVMdU92V0xUWlVCWWpSc3htQ09nQVVmVTFjZTlmdjRjdmJIZGpETXR3OG0xK0ZsMEdnS0NCSFB5b1BqY1REUGxWUEVRd2FKYUdHYlFuYVF3cVhzK1h1M0h0bHpCczM0Qlk1WjdwbzBwMXF3dmRGbTMydHhRVHU1UmxJSTFUWFhlQ0k2bWxoT01YTHVKdDNicEJoaDRWbGRwMlZmRVkzam1kT2RHdXltRXRqQ3RldVc3YktGekUzQ2RJYTRkQkJHMlVlMVUreG1EbHJ1SlpOUXA3c2RTK2RXS2p5aUI2bXBiaXIwV2xKMXZzMi9BTGlPQ1YxR1N6b1JFRUpHeDFCa1Y1N3grOWR3K092c3JETXpFK0lTQ2pnTUFmSWFEL2xyWTluN3d0a284NWpiczZUTU1sc0J4NUhVSHprMEg3WllnTGljTmVVUVVJekhUTkJmd3dEdkhqNWM2eWhxYlJyazNCUDBDY1YyaXYzZ2xxMmlXM2FGbFNTek1mQUluUlpuK3RlcllOVnRXMFJkRlJRb25vb2o4cThyeDFudThVTXgvd1VXNmRwQmJFWjJWUXNabzcwMXVMM0VpMW9tMlZZc3Zoa0VxWkhQeXBaVXFWRHd0Mjc3UE04TmcyeFYxN2s1VmU2MnNUQmZQYzFrZ2FCVHVSdUs3aStDRkZaODZsQm1qVUJ6bGRVMVNUbE1zTkpOYWpzdGdudzhLNnJJWjdnWWEvWVZBRDAzYXFuYVJqY0NBSTV6UGN6WkpnanZnMm9Ha3dOQ1J5SFFWdDVQbFM2TVBGVWJmWm92L0FPZDJiZHZCRzQ0bk83dWY4cWVBRC9ZVDg2RjlyK0NKYXNJd0NCeUI0Z29VbHBRUVFGMUpMYmsrZEVlREtpNFZiU1pnQ0RJYlVqTVpZZmlLc2NUd1A3VGtWeWNvTW1ER2dralgvTUZySGxVN04rRndTL0JGdy9zdWlTclpneXFnbGZHRG9kVHozbllBVk4rNW9iK0hmVE4wTW8zNHo5S01XU1F4WW5jS1BhZC9lcDdoRENHQUk2RUFqNjFsTGJzMmlxVkFYdWNiYjJMSDBiTjlHcXBmNGhkSCtOWVJoL05iL01hVWMvWTBId0Y3ZitSaUIvcE1yOUthd3ZqWjB1RG82NVQvQUtsMC93QnRJWm0wZkJzV1A3UGtMQWhqYmJjSGVScFZkZUNZUEt5Mjc5MjFtajRnVGxJNkdOUGVqK0pkRC9qWVFqK1pJdUQxMGdqMnFvTUpnN253WHNoNkV4cjZOVFVtUzRvb0RzL2Y3dFJZeE50M0IrSW5ValhRNzlSN1Vydjcwc29wQ200MnVZQnBXSjBpYXZYT3pqN3E2c1BQOVJVQnM0dTBaQmVPaXRtSHNhRTE2QnArMk12OXFzUlpSR3UyeVpBekxrMVV4cnRHbE1idFRoYmlCcnRpMlZiU1NCOVJCNkdwdjMvZVdBNFU5YzZRZnBGTXhQRXNMYzB2WVpTT3F3ZjAvR2hVRGJHb09HM1VJVzJVUnRDVTBIKzArbktsaCtBNFFLeTJyNUFia3htTkkwbUtZY0J3KzViTnRYZTBwNWErdk9RTnFaaE95WVdUYXhQZUFqUUVobzh4QjBwOXA3SnFtdERMWFpHNnJCbHhJdUtQc2tlWDNnYW9ZL2h1TXNrdVZRcE82a3lCUDlhbHQ5bnNkYmNIT0hRSFdEckh6SDUwM2lQRXNaWVlaVXVGWTEwWXdmcjVWVzNLcVRKMG8zdGY5L0prOGRkejNHYnFlWjE2YTBxMWxqdFBkWlFTQUR6bFJPaGpYU2xXNnpTU3JpYzd3d2s3NWY2UFZCYUFwRlJVcEZNSzF4bm9FTG9QL2RadmoyZDdsdTNheUtmR3pNUk1MQ29jbzVraHlQbldwYTNOVWJ2REVMWi90UmxuWGFaamZyVFRvbVN0SG1mR3VBbHNRWUppNHhsanFBVDRvQTNBaFQxNVZadDhJdUEyMGtsVll5UkpNWlRvQnlVeDd0Vyt1Y0l0c3lzWmxUSTljcFhYcm94cWRMQ3JzQVBwV25rZFVaK0ZYWjU0M1l1NWV1RjJjSXZMVE1RQjh3UC9BSFJkT3h0dFV5QzdjOC9oQVByQW1QS2ExN1ZFMUo1Sk1heFJXekFYK3dUbHY4WlF1bjJTV2dBQ0ltT1hXckQ5azdWaTI1WE96c3BUTnZHZndrZ0RiZXRveTAwclI1WkM4TWZSaFc0WXk0WjhPQVdVdG1HYlFnaUkyMzJtclhDRGRGdTNBaUxhcnRCMDJKOTYxajI2aTdtazV0bExHbDBBT0Y0TzZqczd2SmVKK1FnYVZGeHJnb3ZzcElKNjY3QUJvQTU3bXRJYlZOTm1rcE5iRzRKcW1ZMi93Vmd4ZFZsOU5TVHNDcC8vQUNLbDRMWXhDTVZaSXRtWWdpRjVpTlpqeTlLMW5kVjBXNmZOMVRGNDBuYUtGdXllZFNKZ2xBaVA3T3RYTWxMTFUyVlJYdDRZTG9BQjZWS2x1cElwUlJZVWRVMDhQVEJYWm9HUHpVczFNbXVHZ1JMbnFERVlkTG54b3JlbzE5OTY3TmRtZ0FjM0IxVXphZTVhUDhyRWo1Zy9yVGMyTXQ3TWwwZENJYjh2eE5FczFJbWdBVzNIRjJ2MldUeklrZldLak5uQlhmdXFUL3lHaTJibFZQRThNc3Y4U0NlbzhQNFVCUVB2ZGxsT3FYRDVUcUtHWW5zL2lFK0dENWd3ZnJSSzd3UjFNMkx6S2VobVBkZjBwdjdiamJYeG9MZzZnVC8wd2ZjVXlXQmx4V01zL2F1ajE4WStzaXA3UGEyOE5IVkhIcGxQMDI5cUtXKzAxczZYRUtubnorbTlUbTVoTDNORDYrRS9Xbi9CTmVtQy93RDVXblBEZjdoLzIwcXZIc3hoenFBZmt4ajhhNVQrSWZJOUJOTk5LbFdac05OTU5LbFFBMWhVVENsU3BpT1JYQ3RLbFNHTUtVd3JTcFVBTVlVMktWS2dRaUs1RktsUU00QlhLVktnQmhya1VxVkFqc1VwcmxLZ0JHa0tWS2dEazBwcFVxQkNwVXFWTURzVndpbFNvQVlUVFNhVktnQnBhbTVxN1NwQVJYN0NYTkhSVzlRRDdIbFF1LzJldEg0Q3lIL1VQWTYvV3UwcWRnMG1ETG5aeTdPald5UCtZZlNLVktsVDVNamdqLy9aXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgIH1cclxuXTtcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBwYXJ0ZW5lcmlfdGFibGU7XHJcbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJztcclxuaW1wb3J0IENhcmRzIGZyb20gJy4uL2NvbW1vbi9wb3J0b2ZvbGl1L2NhcmQnXHJcblxyXG4vLyBDb21wb25lbnRzXHJcbmltcG9ydCB7IENvbnRhaW5lciwgUm93LCBDb2wgfSBmcm9tIFwicmVhY3QtZ3JpZC1zeXN0ZW1cIjtcclxuaW1wb3J0IEhlYWRsaW5lIGZyb20gXCIuLi8uLi9jb21wb25lbnRzL2NvbW1vbi9IZWFkbGluZVwiO1xyXG5pbXBvcnQgcG9ydGZvbGlvIGZyb20gXCIuLi8uLi9jb21wb25lbnRzL2NvbW1vbi90YWJsZXMvcGFydGVuZXJpX3RhYmxlXCI7XHJcblxyXG5cclxuZnVuY3Rpb24gUGFydGVuZXJpKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJzZWN0aW9uIHNlY3Rpb24tcG9ydGZvbGlvIHNlY3Rpb24tcG9ydGZvbGlvLTEgYmctZ3JhZGllbnQtc2lkZSBvdmVybGF5LWNvbG9yXCI+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImJnLWNvbG9yIGJnLWRhcmstNjBcIj48L3NwYW4+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGlzcGxheS1zcGFjaW5nXCI+XHJcbiAgICAgICAgICAgICAgICA8Q29udGFpbmVyIGNsYXNzTmFtZT1cImNvbnRhaW5lclwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxIZWFkbGluZSBsYWJlbD1cIlBvcnRmb2xpb1wiIHRpdGxlPVwiTGV0J3MgU2VlIE91ciBwb3J0Zm9saW9cIiBkaXZpZGVyXzE9e3RydWV9IHBvc2l0aW9uPVwiY2VudGVyXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8Q2FyZHMgLz5cclxuICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgPC9Db250YWluZXI+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvc2VjdGlvbj5cclxuICAgICk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBhcnRlbmVyaTsiLCJmdW5jdGlvbiB0b1ZhbChtaXgpIHtcblx0dmFyIGssIHksIHN0cj0nJztcblxuXHRpZiAodHlwZW9mIG1peCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG1peCA9PT0gJ251bWJlcicpIHtcblx0XHRzdHIgKz0gbWl4O1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtaXggPT09ICdvYmplY3QnKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkobWl4KSkge1xuXHRcdFx0Zm9yIChrPTA7IGsgPCBtaXgubGVuZ3RoOyBrKyspIHtcblx0XHRcdFx0aWYgKG1peFtrXSkge1xuXHRcdFx0XHRcdGlmICh5ID0gdG9WYWwobWl4W2tdKSkge1xuXHRcdFx0XHRcdFx0c3RyICYmIChzdHIgKz0gJyAnKTtcblx0XHRcdFx0XHRcdHN0ciArPSB5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGsgaW4gbWl4KSB7XG5cdFx0XHRcdGlmIChtaXhba10pIHtcblx0XHRcdFx0XHRzdHIgJiYgKHN0ciArPSAnICcpO1xuXHRcdFx0XHRcdHN0ciArPSBrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHN0cjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuXHR2YXIgaT0wLCB0bXAsIHgsIHN0cj0nJztcblx0d2hpbGUgKGkgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0aWYgKHRtcCA9IGFyZ3VtZW50c1tpKytdKSB7XG5cdFx0XHRpZiAoeCA9IHRvVmFsKHRtcCkpIHtcblx0XHRcdFx0c3RyICYmIChzdHIgKz0gJyAnKTtcblx0XHRcdFx0c3RyICs9IHhcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHN0cjtcbn1cbiIsIlwidXNlIHN0cmljdFwiO3ZhciBhc3NpZ249T2JqZWN0LmFzc2lnbi5iaW5kKE9iamVjdCk7bW9kdWxlLmV4cG9ydHM9YXNzaWduO21vZHVsZS5leHBvcnRzLmRlZmF1bHQ9bW9kdWxlLmV4cG9ydHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYmplY3QtYXNzaWduLmpzLm1hcCIsIlxuICAgICh3aW5kb3cuX19ORVhUX1AgPSB3aW5kb3cuX19ORVhUX1AgfHwgW10pLnB1c2goW1xuICAgICAgXCIvcG9ydGZvbGlvXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwiRzpcXFxcTURNYXhcXFxcZ28gYnJhc292XFxcXHNpdGVfbmV4dGpzXFxcXGdvYnYtc2l0ZVxcXFxwYWdlc1xcXFxwb3J0Zm9saW8uanNcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICIsImltcG9ydCBSZWFjdCwgeyBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHtcbiAgYWRkQmFzZVBhdGgsXG4gIGFkZExvY2FsZSxcbiAgaXNMb2NhbFVSTCxcbiAgTmV4dFJvdXRlcixcbiAgUHJlZmV0Y2hPcHRpb25zLFxuICByZXNvbHZlSHJlZixcbn0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXInXG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICcuL3JvdXRlcidcblxudHlwZSBVcmwgPSBzdHJpbmcgfCBVcmxPYmplY3RcbnR5cGUgUmVxdWlyZWRLZXlzPFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBUXS0/OiB7fSBleHRlbmRzIFBpY2s8VCwgSz4gPyBuZXZlciA6IEtcbn1ba2V5b2YgVF1cbnR5cGUgT3B0aW9uYWxLZXlzPFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBUXS0/OiB7fSBleHRlbmRzIFBpY2s8VCwgSz4gPyBLIDogbmV2ZXJcbn1ba2V5b2YgVF1cblxuZXhwb3J0IHR5cGUgTGlua1Byb3BzID0ge1xuICBocmVmOiBVcmxcbiAgYXM/OiBVcmxcbiAgcmVwbGFjZT86IGJvb2xlYW5cbiAgc2Nyb2xsPzogYm9vbGVhblxuICBzaGFsbG93PzogYm9vbGVhblxuICBwYXNzSHJlZj86IGJvb2xlYW5cbiAgcHJlZmV0Y2g/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG59XG50eXBlIExpbmtQcm9wc1JlcXVpcmVkID0gUmVxdWlyZWRLZXlzPExpbmtQcm9wcz5cbnR5cGUgTGlua1Byb3BzT3B0aW9uYWwgPSBPcHRpb25hbEtleXM8TGlua1Byb3BzPlxuXG5sZXQgY2FjaGVkT2JzZXJ2ZXI6IEludGVyc2VjdGlvbk9ic2VydmVyXG5jb25zdCBsaXN0ZW5lcnMgPSBuZXcgTWFwPEVsZW1lbnQsICgpID0+IHZvaWQ+KClcbmNvbnN0IEludGVyc2VjdGlvbk9ic2VydmVyID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgOiBudWxsXG5jb25zdCBwcmVmZXRjaGVkOiB7IFtjYWNoZUtleTogc3RyaW5nXTogYm9vbGVhbiB9ID0ge31cblxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXIoKTogSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgfCB1bmRlZmluZWQge1xuICAvLyBSZXR1cm4gc2hhcmVkIGluc3RhbmNlIG9mIEludGVyc2VjdGlvbk9ic2VydmVyIGlmIGFscmVhZHkgY3JlYXRlZFxuICBpZiAoY2FjaGVkT2JzZXJ2ZXIpIHtcbiAgICByZXR1cm4gY2FjaGVkT2JzZXJ2ZXJcbiAgfVxuXG4gIC8vIE9ubHkgY3JlYXRlIHNoYXJlZCBJbnRlcnNlY3Rpb25PYnNlcnZlciBpZiBzdXBwb3J0ZWQgaW4gYnJvd3NlclxuICBpZiAoIUludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgcmV0dXJuIChjYWNoZWRPYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICAoZW50cmllcykgPT4ge1xuICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICBpZiAoIWxpc3RlbmVycy5oYXMoZW50cnkudGFyZ2V0KSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2IgPSBsaXN0ZW5lcnMuZ2V0KGVudHJ5LnRhcmdldCkhXG4gICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZyB8fCBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+IDApIHtcbiAgICAgICAgICBjYWNoZWRPYnNlcnZlci51bm9ic2VydmUoZW50cnkudGFyZ2V0KVxuICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUoZW50cnkudGFyZ2V0KVxuICAgICAgICAgIGNiKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LFxuICAgIHsgcm9vdE1hcmdpbjogJzIwMHB4JyB9XG4gICkpXG59XG5cbmNvbnN0IGxpc3RlblRvSW50ZXJzZWN0aW9ucyA9IChlbDogRWxlbWVudCwgY2I6ICgpID0+IHZvaWQpID0+IHtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBnZXRPYnNlcnZlcigpXG4gIGlmICghb2JzZXJ2ZXIpIHtcbiAgICByZXR1cm4gKCkgPT4ge31cbiAgfVxuXG4gIG9ic2VydmVyLm9ic2VydmUoZWwpXG4gIGxpc3RlbmVycy5zZXQoZWwsIGNiKVxuICByZXR1cm4gKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBvYnNlcnZlci51bm9ic2VydmUoZWwpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICB9XG4gICAgbGlzdGVuZXJzLmRlbGV0ZShlbClcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVmZXRjaChcbiAgcm91dGVyOiBOZXh0Um91dGVyLFxuICBocmVmOiBzdHJpbmcsXG4gIGFzOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBQcmVmZXRjaE9wdGlvbnNcbik6IHZvaWQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVyblxuICBpZiAoIWlzTG9jYWxVUkwoaHJlZikpIHJldHVyblxuICAvLyBQcmVmZXRjaCB0aGUgSlNPTiBwYWdlIGlmIGFza2VkIChvbmx5IGluIHRoZSBjbGllbnQpXG4gIC8vIFdlIG5lZWQgdG8gaGFuZGxlIGEgcHJlZmV0Y2ggZXJyb3IgaGVyZSBzaW5jZSB3ZSBtYXkgYmVcbiAgLy8gbG9hZGluZyB3aXRoIHByaW9yaXR5IHdoaWNoIGNhbiByZWplY3QgYnV0IHdlIGRvbid0XG4gIC8vIHdhbnQgdG8gZm9yY2UgbmF2aWdhdGlvbiBzaW5jZSB0aGlzIGlzIG9ubHkgYSBwcmVmZXRjaFxuICByb3V0ZXIucHJlZmV0Y2goaHJlZiwgYXMsIG9wdGlvbnMpLmNhdGNoKChlcnIpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gcmV0aHJvdyB0byBzaG93IGludmFsaWQgVVJMIGVycm9yc1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9KVxuICAvLyBKb2luIG9uIGFuIGludmFsaWQgVVJJIGNoYXJhY3RlclxuICBwcmVmZXRjaGVkW2hyZWYgKyAnJScgKyBhc10gPSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudDogUmVhY3QuTW91c2VFdmVudCkge1xuICBjb25zdCB7IHRhcmdldCB9ID0gZXZlbnQuY3VycmVudFRhcmdldCBhcyBIVE1MQW5jaG9yRWxlbWVudFxuICByZXR1cm4gKFxuICAgICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSAnX3NlbGYnKSB8fFxuICAgIGV2ZW50Lm1ldGFLZXkgfHxcbiAgICBldmVudC5jdHJsS2V5IHx8XG4gICAgZXZlbnQuc2hpZnRLZXkgfHxcbiAgICBldmVudC5hbHRLZXkgfHwgLy8gdHJpZ2dlcnMgcmVzb3VyY2UgZG93bmxvYWRcbiAgICAoZXZlbnQubmF0aXZlRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQud2hpY2ggPT09IDIpXG4gIClcbn1cblxuZnVuY3Rpb24gbGlua0NsaWNrZWQoXG4gIGU6IFJlYWN0Lk1vdXNlRXZlbnQsXG4gIHJvdXRlcjogTmV4dFJvdXRlcixcbiAgaHJlZjogc3RyaW5nLFxuICBhczogc3RyaW5nLFxuICByZXBsYWNlPzogYm9vbGVhbixcbiAgc2hhbGxvdz86IGJvb2xlYW4sXG4gIHNjcm9sbD86IGJvb2xlYW4sXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG4pOiB2b2lkIHtcbiAgY29uc3QgeyBub2RlTmFtZSB9ID0gZS5jdXJyZW50VGFyZ2V0XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQScgJiYgKGlzTW9kaWZpZWRFdmVudChlKSB8fCAhaXNMb2NhbFVSTChocmVmKSkpIHtcbiAgICAvLyBpZ25vcmUgY2xpY2sgZm9yIGJyb3dzZXLigJlzIGRlZmF1bHQgYmVoYXZpb3JcbiAgICByZXR1cm5cbiAgfVxuXG4gIGUucHJldmVudERlZmF1bHQoKVxuXG4gIC8vICBhdm9pZCBzY3JvbGwgZm9yIHVybHMgd2l0aCBhbmNob3IgcmVmc1xuICBpZiAoc2Nyb2xsID09IG51bGwpIHtcbiAgICBzY3JvbGwgPSBhcy5pbmRleE9mKCcjJykgPCAwXG4gIH1cblxuICAvLyByZXBsYWNlIHN0YXRlIGluc3RlYWQgb2YgcHVzaCBpZiBwcm9wIGlzIHByZXNlbnRcbiAgcm91dGVyW3JlcGxhY2UgPyAncmVwbGFjZScgOiAncHVzaCddKGhyZWYsIGFzLCB7IHNoYWxsb3csIGxvY2FsZSB9KS50aGVuKFxuICAgIChzdWNjZXNzOiBib29sZWFuKSA9PiB7XG4gICAgICBpZiAoIXN1Y2Nlc3MpIHJldHVyblxuICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMClcbiAgICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpXG4gICAgICB9XG4gICAgfVxuICApXG59XG5cbmZ1bmN0aW9uIExpbmsocHJvcHM6IFJlYWN0LlByb3BzV2l0aENoaWxkcmVuPExpbmtQcm9wcz4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9wRXJyb3IoYXJnczoge1xuICAgICAga2V5OiBzdHJpbmdcbiAgICAgIGV4cGVjdGVkOiBzdHJpbmdcbiAgICAgIGFjdHVhbDogc3RyaW5nXG4gICAgfSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIFxcYCR7YXJncy5rZXl9XFxgIGV4cGVjdHMgYSAke2FyZ3MuZXhwZWN0ZWR9IGluIFxcYDxMaW5rPlxcYCwgYnV0IGdvdCBcXGAke2FyZ3MuYWN0dWFsfVxcYCBpbnN0ZWFkLmAgK1xuICAgICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBcIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCJcbiAgICAgICAgICAgIDogJycpXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICBjb25zdCByZXF1aXJlZFByb3BzR3VhcmQ6IFJlY29yZDxMaW5rUHJvcHNSZXF1aXJlZCwgdHJ1ZT4gPSB7XG4gICAgICBocmVmOiB0cnVlLFxuICAgIH0gYXMgY29uc3RcbiAgICBjb25zdCByZXF1aXJlZFByb3BzOiBMaW5rUHJvcHNSZXF1aXJlZFtdID0gT2JqZWN0LmtleXMoXG4gICAgICByZXF1aXJlZFByb3BzR3VhcmRcbiAgICApIGFzIExpbmtQcm9wc1JlcXVpcmVkW11cbiAgICByZXF1aXJlZFByb3BzLmZvckVhY2goKGtleTogTGlua1Byb3BzUmVxdWlyZWQpID0+IHtcbiAgICAgIGlmIChrZXkgPT09ICdocmVmJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvcHNba2V5XSA9PSBudWxsIHx8XG4gICAgICAgICAgKHR5cGVvZiBwcm9wc1trZXldICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ29iamVjdCcpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgIGFjdHVhbDogcHJvcHNba2V5XSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBwcm9wc1trZXldLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgXzogbmV2ZXIgPSBrZXlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICBjb25zdCBvcHRpb25hbFByb3BzR3VhcmQ6IFJlY29yZDxMaW5rUHJvcHNPcHRpb25hbCwgdHJ1ZT4gPSB7XG4gICAgICBhczogdHJ1ZSxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICBzY3JvbGw6IHRydWUsXG4gICAgICBzaGFsbG93OiB0cnVlLFxuICAgICAgcGFzc0hyZWY6IHRydWUsXG4gICAgICBwcmVmZXRjaDogdHJ1ZSxcbiAgICAgIGxvY2FsZTogdHJ1ZSxcbiAgICB9IGFzIGNvbnN0XG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wczogTGlua1Byb3BzT3B0aW9uYWxbXSA9IE9iamVjdC5rZXlzKFxuICAgICAgb3B0aW9uYWxQcm9wc0d1YXJkXG4gICAgKSBhcyBMaW5rUHJvcHNPcHRpb25hbFtdXG4gICAgb3B0aW9uYWxQcm9wcy5mb3JFYWNoKChrZXk6IExpbmtQcm9wc09wdGlvbmFsKSA9PiB7XG4gICAgICBjb25zdCB2YWxUeXBlID0gdHlwZW9mIHByb3BzW2tleV1cblxuICAgICAgaWYgKGtleSA9PT0gJ2FzJykge1xuICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnc3RyaW5nJyAmJiB2YWxUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2xvY2FsZScpIHtcbiAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgc3RyaW5nYCcsXG4gICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAga2V5ID09PSAncmVwbGFjZScgfHxcbiAgICAgICAga2V5ID09PSAnc2Nyb2xsJyB8fFxuICAgICAgICBrZXkgPT09ICdzaGFsbG93JyB8fFxuICAgICAgICBrZXkgPT09ICdwYXNzSHJlZicgfHxcbiAgICAgICAga2V5ID09PSAncHJlZmV0Y2gnXG4gICAgICApIHtcbiAgICAgICAgaWYgKHByb3BzW2tleV0gIT0gbnVsbCAmJiB2YWxUeXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgYm9vbGVhbmAnLFxuICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgXzogbmV2ZXIgPSBrZXlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gVGhpcyBob29rIGlzIGluIGEgY29uZGl0aW9uYWwgYnV0IHRoYXQgaXMgb2sgYmVjYXVzZSBgcHJvY2Vzcy5lbnYuTk9ERV9FTlZgIG5ldmVyIGNoYW5nZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBjb25zdCBoYXNXYXJuZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpXG4gICAgaWYgKHByb3BzLnByZWZldGNoICYmICFoYXNXYXJuZWQuY3VycmVudCkge1xuICAgICAgaGFzV2FybmVkLmN1cnJlbnQgPSB0cnVlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdOZXh0LmpzIGF1dG8tcHJlZmV0Y2hlcyBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHZpZXdwb3J0LiBUaGUgcHJlZmV0Y2ggYXR0cmlidXRlIGlzIG5vIGxvbmdlciBuZWVkZWQuIE1vcmU6IGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL3ByZWZldGNoLXRydWUtZGVwcmVjYXRlZCdcbiAgICAgIClcbiAgICB9XG4gIH1cbiAgY29uc3QgcCA9IHByb3BzLnByZWZldGNoICE9PSBmYWxzZVxuXG4gIGNvbnN0IFtjaGlsZEVsbSwgc2V0Q2hpbGRFbG1dID0gUmVhY3QudXNlU3RhdGU8RWxlbWVudD4oKVxuXG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpXG4gIGNvbnN0IHBhdGhuYW1lID0gKHJvdXRlciAmJiByb3V0ZXIucGF0aG5hbWUpIHx8ICcvJ1xuXG4gIGNvbnN0IHsgaHJlZiwgYXMgfSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IFtyZXNvbHZlZEhyZWYsIHJlc29sdmVkQXNdID0gcmVzb2x2ZUhyZWYocGF0aG5hbWUsIHByb3BzLmhyZWYsIHRydWUpXG4gICAgcmV0dXJuIHtcbiAgICAgIGhyZWY6IHJlc29sdmVkSHJlZixcbiAgICAgIGFzOiBwcm9wcy5hc1xuICAgICAgICA/IHJlc29sdmVIcmVmKHBhdGhuYW1lLCBwcm9wcy5hcylcbiAgICAgICAgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZixcbiAgICB9XG4gIH0sIFtwYXRobmFtZSwgcHJvcHMuaHJlZiwgcHJvcHMuYXNdKVxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKFxuICAgICAgcCAmJlxuICAgICAgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgJiZcbiAgICAgIGNoaWxkRWxtICYmXG4gICAgICBjaGlsZEVsbS50YWdOYW1lICYmXG4gICAgICBpc0xvY2FsVVJMKGhyZWYpXG4gICAgKSB7XG4gICAgICAvLyBKb2luIG9uIGFuIGludmFsaWQgVVJJIGNoYXJhY3RlclxuICAgICAgY29uc3QgaXNQcmVmZXRjaGVkID0gcHJlZmV0Y2hlZFtocmVmICsgJyUnICsgYXNdXG4gICAgICBpZiAoIWlzUHJlZmV0Y2hlZCkge1xuICAgICAgICByZXR1cm4gbGlzdGVuVG9JbnRlcnNlY3Rpb25zKGNoaWxkRWxtLCAoKSA9PiB7XG4gICAgICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcylcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtwLCBjaGlsZEVsbSwgaHJlZiwgYXMsIHJvdXRlcl0pXG5cbiAgbGV0IHsgY2hpbGRyZW4sIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlIH0gPSBwcm9wc1xuICAvLyBEZXByZWNhdGVkLiBXYXJuaW5nIHNob3duIGJ5IHByb3BUeXBlIGNoZWNrLiBJZiB0aGUgY2hpbGRyZW4gcHJvdmlkZWQgaXMgYSBzdHJpbmcgKDxMaW5rPmV4YW1wbGU8L0xpbms+KSB3ZSB3cmFwIGl0IGluIGFuIDxhPiB0YWdcbiAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycpIHtcbiAgICBjaGlsZHJlbiA9IDxhPntjaGlsZHJlbn08L2E+XG4gIH1cblxuICAvLyBUaGlzIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBjaGlsZCwgaWYgbXVsdGlwbGUgYXJlIHByb3ZpZGVkIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgY29uc3QgY2hpbGQ6IGFueSA9IENoaWxkcmVuLm9ubHkoY2hpbGRyZW4pXG4gIGNvbnN0IGNoaWxkUHJvcHM6IHtcbiAgICBvbk1vdXNlRW50ZXI/OiBSZWFjdC5Nb3VzZUV2ZW50SGFuZGxlclxuICAgIG9uQ2xpY2s6IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyXG4gICAgaHJlZj86IHN0cmluZ1xuICAgIHJlZj86IGFueVxuICB9ID0ge1xuICAgIHJlZjogKGVsOiBhbnkpID0+IHtcbiAgICAgIGlmIChlbCkgc2V0Q2hpbGRFbG0oZWwpXG5cbiAgICAgIGlmIChjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmIGNoaWxkLnJlZikge1xuICAgICAgICBpZiAodHlwZW9mIGNoaWxkLnJlZiA9PT0gJ2Z1bmN0aW9uJykgY2hpbGQucmVmKGVsKVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGQucmVmID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGNoaWxkLnJlZi5jdXJyZW50ID0gZWxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgb25DbGljazogKGU6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcbiAgICAgIGlmIChjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjaGlsZC5wcm9wcy5vbkNsaWNrKGUpXG4gICAgICB9XG4gICAgICBpZiAoIWUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICBsaW5rQ2xpY2tlZChlLCByb3V0ZXIsIGhyZWYsIGFzLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSlcbiAgICAgIH1cbiAgICB9LFxuICB9XG5cbiAgaWYgKHApIHtcbiAgICBjaGlsZFByb3BzLm9uTW91c2VFbnRlciA9IChlOiBSZWFjdC5Nb3VzZUV2ZW50KSA9PiB7XG4gICAgICBpZiAoIWlzTG9jYWxVUkwoaHJlZikpIHJldHVyblxuICAgICAgaWYgKGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyKGUpXG4gICAgICB9XG4gICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7IHByaW9yaXR5OiB0cnVlIH0pXG4gICAgfVxuICB9XG5cbiAgLy8gSWYgY2hpbGQgaXMgYW4gPGE+IHRhZyBhbmQgZG9lc24ndCBoYXZlIGEgaHJlZiBhdHRyaWJ1dGUsIG9yIGlmIHRoZSAncGFzc0hyZWYnIHByb3BlcnR5IGlzXG4gIC8vIGRlZmluZWQsIHdlIHNwZWNpZnkgdGhlIGN1cnJlbnQgJ2hyZWYnLCBzbyB0aGF0IHJlcGV0aXRpb24gaXMgbm90IG5lZWRlZCBieSB0aGUgdXNlclxuICBpZiAocHJvcHMucGFzc0hyZWYgfHwgKGNoaWxkLnR5cGUgPT09ICdhJyAmJiAhKCdocmVmJyBpbiBjaGlsZC5wcm9wcykpKSB7XG4gICAgY2hpbGRQcm9wcy5ocmVmID0gYWRkQmFzZVBhdGgoXG4gICAgICBhZGRMb2NhbGUoXG4gICAgICAgIGFzLFxuICAgICAgICB0eXBlb2YgbG9jYWxlICE9PSAndW5kZWZpbmVkJyA/IGxvY2FsZSA6IHJvdXRlciAmJiByb3V0ZXIubG9jYWxlLFxuICAgICAgICByb3V0ZXIgJiYgcm91dGVyLmRlZmF1bHRMb2NhbGVcbiAgICAgIClcbiAgICApXG4gIH1cblxuICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaW5rXG4iLCIvKipcbiAqIFJlbW92ZXMgdGhlIHRyYWlsaW5nIHNsYXNoIG9mIGEgcGF0aCBpZiB0aGVyZSBpcyBvbmUuIFByZXNlcnZlcyB0aGUgcm9vdCBwYXRoIGAvYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBwYXRoLmVuZHNXaXRoKCcvJykgJiYgcGF0aCAhPT0gJy8nID8gcGF0aC5zbGljZSgwLCAtMSkgOiBwYXRoXG59XG5cbi8qKlxuICogTm9ybWFsaXplcyB0aGUgdHJhaWxpbmcgc2xhc2ggb2YgYSBwYXRoIGFjY29yZGluZyB0byB0aGUgYHRyYWlsaW5nU2xhc2hgIG9wdGlvblxuICogaW4gYG5leHQuY29uZmlnLmpzYC5cbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1RSQUlMSU5HX1NMQVNIXG4gID8gKHBhdGg6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICBpZiAoL1xcLlteL10rXFwvPyQvLnRlc3QocGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGgpXG4gICAgICB9IGVsc2UgaWYgKHBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICByZXR1cm4gcGF0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhdGggKyAnLydcbiAgICAgIH1cbiAgICB9XG4gIDogcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2hcbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBSb3V0ZXIsIHsgTmV4dFJvdXRlciB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvcm91dGVyJ1xuaW1wb3J0IHsgUm91dGVyQ29udGV4dCB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXItY29udGV4dCdcblxudHlwZSBDbGFzc0FyZ3VtZW50czxUPiA9IFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGluZmVyIFUpID0+IGFueSA/IFUgOiBhbnlcblxudHlwZSBSb3V0ZXJBcmdzID0gQ2xhc3NBcmd1bWVudHM8dHlwZW9mIFJvdXRlcj5cblxudHlwZSBTaW5nbGV0b25Sb3V0ZXJCYXNlID0ge1xuICByb3V0ZXI6IFJvdXRlciB8IG51bGxcbiAgcmVhZHlDYWxsYmFja3M6IEFycmF5PCgpID0+IGFueT5cbiAgcmVhZHkoY2I6ICgpID0+IGFueSk6IHZvaWRcbn1cblxuZXhwb3J0IHsgUm91dGVyLCBOZXh0Um91dGVyIH1cblxuZXhwb3J0IHR5cGUgU2luZ2xldG9uUm91dGVyID0gU2luZ2xldG9uUm91dGVyQmFzZSAmIE5leHRSb3V0ZXJcblxuY29uc3Qgc2luZ2xldG9uUm91dGVyOiBTaW5nbGV0b25Sb3V0ZXJCYXNlID0ge1xuICByb3V0ZXI6IG51bGwsIC8vIGhvbGRzIHRoZSBhY3R1YWwgcm91dGVyIGluc3RhbmNlXG4gIHJlYWR5Q2FsbGJhY2tzOiBbXSxcbiAgcmVhZHkoY2I6ICgpID0+IHZvaWQpIHtcbiAgICBpZiAodGhpcy5yb3V0ZXIpIHJldHVybiBjYigpXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnJlYWR5Q2FsbGJhY2tzLnB1c2goY2IpXG4gICAgfVxuICB9LFxufVxuXG4vLyBDcmVhdGUgcHVibGljIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgb2YgdGhlIHJvdXRlciBpbiB0aGUgc2luZ2xldG9uUm91dGVyXG5jb25zdCB1cmxQcm9wZXJ0eUZpZWxkcyA9IFtcbiAgJ3BhdGhuYW1lJyxcbiAgJ3JvdXRlJyxcbiAgJ3F1ZXJ5JyxcbiAgJ2FzUGF0aCcsXG4gICdjb21wb25lbnRzJyxcbiAgJ2lzRmFsbGJhY2snLFxuICAnYmFzZVBhdGgnLFxuICAnbG9jYWxlJyxcbiAgJ2xvY2FsZXMnLFxuICAnZGVmYXVsdExvY2FsZScsXG5dXG5jb25zdCByb3V0ZXJFdmVudHMgPSBbXG4gICdyb3V0ZUNoYW5nZVN0YXJ0JyxcbiAgJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLFxuICAncm91dGVDaGFuZ2VDb21wbGV0ZScsXG4gICdyb3V0ZUNoYW5nZUVycm9yJyxcbiAgJ2hhc2hDaGFuZ2VTdGFydCcsXG4gICdoYXNoQ2hhbmdlQ29tcGxldGUnLFxuXVxuY29uc3QgY29yZU1ldGhvZEZpZWxkcyA9IFtcbiAgJ3B1c2gnLFxuICAncmVwbGFjZScsXG4gICdyZWxvYWQnLFxuICAnYmFjaycsXG4gICdwcmVmZXRjaCcsXG4gICdiZWZvcmVQb3BTdGF0ZScsXG5dXG5cbi8vIEV2ZW50cyBpcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiB0aGUgcm91dGVyLCB0aGUgcm91dGVyIGRvZXNuJ3QgaGF2ZSB0byBiZSBpbml0aWFsaXplZCB0byB1c2UgaXRcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsICdldmVudHMnLCB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gUm91dGVyLmV2ZW50c1xuICB9LFxufSlcblxudXJsUHJvcGVydHlGaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgLy8gSGVyZSB3ZSBuZWVkIHRvIHVzZSBPYmplY3QuZGVmaW5lUHJvcGVydHkgYmVjYXVzZSwgd2UgbmVlZCB0byByZXR1cm5cbiAgLy8gdGhlIHByb3BlcnR5IGFzc2lnbmVkIHRvIHRoZSBhY3R1YWwgcm91dGVyXG4gIC8vIFRoZSB2YWx1ZSBtaWdodCBnZXQgY2hhbmdlZCBhcyB3ZSBjaGFuZ2Ugcm91dGVzIGFuZCB0aGlzIGlzIHRoZVxuICAvLyBwcm9wZXIgd2F5IHRvIGFjY2VzcyBpdFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2luZ2xldG9uUm91dGVyLCBmaWVsZCwge1xuICAgIGdldCgpIHtcbiAgICAgIGNvbnN0IHJvdXRlciA9IGdldFJvdXRlcigpIGFzIGFueVxuICAgICAgcmV0dXJuIHJvdXRlcltmaWVsZF0gYXMgc3RyaW5nXG4gICAgfSxcbiAgfSlcbn0pXG5cbmNvcmVNZXRob2RGaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgLy8gV2UgZG9uJ3QgcmVhbGx5IGtub3cgdGhlIHR5cGVzIGhlcmUsIHNvIHdlIGFkZCB0aGVtIGxhdGVyIGluc3RlYWRcbiAgOyhzaW5nbGV0b25Sb3V0ZXIgYXMgYW55KVtmaWVsZF0gPSAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICBjb25zdCByb3V0ZXIgPSBnZXRSb3V0ZXIoKSBhcyBhbnlcbiAgICByZXR1cm4gcm91dGVyW2ZpZWxkXSguLi5hcmdzKVxuICB9XG59KVxuXG5yb3V0ZXJFdmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgc2luZ2xldG9uUm91dGVyLnJlYWR5KCgpID0+IHtcbiAgICBSb3V0ZXIuZXZlbnRzLm9uKGV2ZW50LCAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgZXZlbnRGaWVsZCA9IGBvbiR7ZXZlbnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHtldmVudC5zdWJzdHJpbmcoXG4gICAgICAgIDFcbiAgICAgICl9YFxuICAgICAgY29uc3QgX3NpbmdsZXRvblJvdXRlciA9IHNpbmdsZXRvblJvdXRlciBhcyBhbnlcbiAgICAgIGlmIChfc2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX3NpbmdsZXRvblJvdXRlcltldmVudEZpZWxkXSguLi5hcmdzKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3aGVuIHJ1bm5pbmcgdGhlIFJvdXRlciBldmVudDogJHtldmVudEZpZWxkfWApXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgJHtlcnIubWVzc2FnZX1cXG4ke2Vyci5zdGFja31gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIGdldFJvdXRlcigpOiBSb3V0ZXIge1xuICBpZiAoIXNpbmdsZXRvblJvdXRlci5yb3V0ZXIpIHtcbiAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICdObyByb3V0ZXIgaW5zdGFuY2UgZm91bmQuXFxuJyArXG4gICAgICAnWW91IHNob3VsZCBvbmx5IHVzZSBcIm5leHQvcm91dGVyXCIgaW5zaWRlIHRoZSBjbGllbnQgc2lkZSBvZiB5b3VyIGFwcC5cXG4nXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gIH1cbiAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXJcbn1cblxuLy8gRXhwb3J0IHRoZSBzaW5nbGV0b25Sb3V0ZXIgYW5kIHRoaXMgaXMgdGhlIHB1YmxpYyBBUEkuXG5leHBvcnQgZGVmYXVsdCBzaW5nbGV0b25Sb3V0ZXIgYXMgU2luZ2xldG9uUm91dGVyXG5cbi8vIFJlZXhwb3J0IHRoZSB3aXRoUm91dGUgSE9DXG5leHBvcnQgeyBkZWZhdWx0IGFzIHdpdGhSb3V0ZXIgfSBmcm9tICcuL3dpdGgtcm91dGVyJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUm91dGVyKCk6IE5leHRSb3V0ZXIge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChSb3V0ZXJDb250ZXh0KVxufVxuXG4vLyBJTlRFUk5BTCBBUElTXG4vLyAtLS0tLS0tLS0tLS0tXG4vLyAoZG8gbm90IHVzZSBmb2xsb3dpbmcgZXhwb3J0cyBpbnNpZGUgdGhlIGFwcClcblxuLy8gQ3JlYXRlIGEgcm91dGVyIGFuZCBhc3NpZ24gaXQgYXMgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZS5cbi8vIFRoaXMgaXMgdXNlZCBpbiBjbGllbnQgc2lkZSB3aGVuIHdlIGFyZSBpbml0aWxpemluZyB0aGUgYXBwLlxuLy8gVGhpcyBzaG91bGQgKipub3QqKiB1c2UgaW5zaWRlIHRoZSBzZXJ2ZXIuXG5leHBvcnQgY29uc3QgY3JlYXRlUm91dGVyID0gKC4uLmFyZ3M6IFJvdXRlckFyZ3MpOiBSb3V0ZXIgPT4ge1xuICBzaW5nbGV0b25Sb3V0ZXIucm91dGVyID0gbmV3IFJvdXRlciguLi5hcmdzKVxuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHlDYWxsYmFja3MuZm9yRWFjaCgoY2IpID0+IGNiKCkpXG4gIHNpbmdsZXRvblJvdXRlci5yZWFkeUNhbGxiYWNrcyA9IFtdXG5cbiAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXJcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgYHdpdGhSb3V0ZXJgIHJvdXRlciBpbnN0YW5jZVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZShyb3V0ZXI6IFJvdXRlcik6IE5leHRSb3V0ZXIge1xuICBjb25zdCBfcm91dGVyID0gcm91dGVyIGFzIGFueVxuICBjb25zdCBpbnN0YW5jZSA9IHt9IGFzIGFueVxuXG4gIGZvciAoY29uc3QgcHJvcGVydHkgb2YgdXJsUHJvcGVydHlGaWVsZHMpIHtcbiAgICBpZiAodHlwZW9mIF9yb3V0ZXJbcHJvcGVydHldID09PSAnb2JqZWN0Jykge1xuICAgICAgaW5zdGFuY2VbcHJvcGVydHldID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgQXJyYXkuaXNBcnJheShfcm91dGVyW3Byb3BlcnR5XSkgPyBbXSA6IHt9LFxuICAgICAgICBfcm91dGVyW3Byb3BlcnR5XVxuICAgICAgKSAvLyBtYWtlcyBzdXJlIHF1ZXJ5IGlzIG5vdCBzdGF0ZWZ1bFxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpbnN0YW5jZVtwcm9wZXJ0eV0gPSBfcm91dGVyW3Byb3BlcnR5XVxuICB9XG5cbiAgLy8gRXZlbnRzIGlzIGEgc3RhdGljIHByb3BlcnR5IG9uIHRoZSByb3V0ZXIsIHRoZSByb3V0ZXIgZG9lc24ndCBoYXZlIHRvIGJlIGluaXRpYWxpemVkIHRvIHVzZSBpdFxuICBpbnN0YW5jZS5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzXG5cbiAgY29yZU1ldGhvZEZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgIGluc3RhbmNlW2ZpZWxkXSA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgICAgcmV0dXJuIF9yb3V0ZXJbZmllbGRdKC4uLmFyZ3MpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBpbnN0YW5jZVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgTmV4dENvbXBvbmVudFR5cGUsIE5leHRQYWdlQ29udGV4dCB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi91dGlscydcbmltcG9ydCB7IE5leHRSb3V0ZXIsIHVzZVJvdXRlciB9IGZyb20gJy4vcm91dGVyJ1xuXG5leHBvcnQgdHlwZSBXaXRoUm91dGVyUHJvcHMgPSB7XG4gIHJvdXRlcjogTmV4dFJvdXRlclxufVxuXG5leHBvcnQgdHlwZSBFeGNsdWRlUm91dGVyUHJvcHM8UD4gPSBQaWNrPFxuICBQLFxuICBFeGNsdWRlPGtleW9mIFAsIGtleW9mIFdpdGhSb3V0ZXJQcm9wcz5cbj5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2l0aFJvdXRlcjxcbiAgUCBleHRlbmRzIFdpdGhSb3V0ZXJQcm9wcyxcbiAgQyA9IE5leHRQYWdlQ29udGV4dFxuPihcbiAgQ29tcG9zZWRDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPEMsIGFueSwgUD5cbik6IFJlYWN0LkNvbXBvbmVudFR5cGU8RXhjbHVkZVJvdXRlclByb3BzPFA+PiB7XG4gIGZ1bmN0aW9uIFdpdGhSb3V0ZXJXcmFwcGVyKHByb3BzOiBhbnkpIHtcbiAgICByZXR1cm4gPENvbXBvc2VkQ29tcG9uZW50IHJvdXRlcj17dXNlUm91dGVyKCl9IHsuLi5wcm9wc30gLz5cbiAgfVxuXG4gIFdpdGhSb3V0ZXJXcmFwcGVyLmdldEluaXRpYWxQcm9wcyA9IENvbXBvc2VkQ29tcG9uZW50LmdldEluaXRpYWxQcm9wc1xuICAvLyBUaGlzIGlzIG5lZWRlZCB0byBhbGxvdyBjaGVja2luZyBmb3IgY3VzdG9tIGdldEluaXRpYWxQcm9wcyBpbiBfYXBwXG4gIDsoV2l0aFJvdXRlcldyYXBwZXIgYXMgYW55KS5vcmlnR2V0SW5pdGlhbFByb3BzID0gKENvbXBvc2VkQ29tcG9uZW50IGFzIGFueSkub3JpZ0dldEluaXRpYWxQcm9wc1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IG5hbWUgPVxuICAgICAgQ29tcG9zZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9zZWRDb21wb25lbnQubmFtZSB8fCAnVW5rbm93bidcbiAgICBXaXRoUm91dGVyV3JhcHBlci5kaXNwbGF5TmFtZSA9IGB3aXRoUm91dGVyKCR7bmFtZX0pYFxuICB9XG5cbiAgcmV0dXJuIFdpdGhSb3V0ZXJXcmFwcGVyXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogVG9rZW5pemUgaW5wdXQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBsZXhlcihzdHIpIHtcbiAgICB2YXIgdG9rZW5zID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICB2YXIgY2hhciA9IHN0cltpXTtcbiAgICAgICAgaWYgKGNoYXIgPT09IFwiKlwiIHx8IGNoYXIgPT09IFwiK1wiIHx8IGNoYXIgPT09IFwiP1wiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiTU9ESUZJRVJcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkVTQ0FQRURfQ0hBUlwiLCBpbmRleDogaSsrLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJPUEVOXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJDTE9TRVwiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwiOlwiKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgaiA9IGkgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChqKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gYDAtOWBcbiAgICAgICAgICAgICAgICAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBgQS1aYFxuICAgICAgICAgICAgICAgICAgICAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBgYS16YFxuICAgICAgICAgICAgICAgICAgICAoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEyMikgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYF9gXG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPT09IDk1KSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgKz0gc3RyW2orK107XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmFtZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzc2luZyBwYXJhbWV0ZXIgbmFtZSBhdCBcIiArIGkpO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIk5BTUVcIiwgaW5kZXg6IGksIHZhbHVlOiBuYW1lIH0pO1xuICAgICAgICAgICAgaSA9IGo7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDE7XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgaiA9IGkgKyAxO1xuICAgICAgICAgICAgaWYgKHN0cltqXSA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGF0dGVybiBjYW5ub3Qgc3RhcnQgd2l0aCBcXFwiP1xcXCIgYXQgXCIgKyBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChqIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChzdHJbal0gPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gc3RyW2orK10gKyBzdHJbaisrXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHJbal0gPT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyW2pdID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyW2ogKyAxXSAhPT0gXCI/XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYXB0dXJpbmcgZ3JvdXBzIGFyZSBub3QgYWxsb3dlZCBhdCBcIiArIGopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gc3RyW2orK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuYmFsYW5jZWQgcGF0dGVybiBhdCBcIiArIGkpO1xuICAgICAgICAgICAgaWYgKCFwYXR0ZXJuKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNaXNzaW5nIHBhdHRlcm4gYXQgXCIgKyBpKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJQQVRURVJOXCIsIGluZGV4OiBpLCB2YWx1ZTogcGF0dGVybiB9KTtcbiAgICAgICAgICAgIGkgPSBqO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkNIQVJcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICB9XG4gICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkVORFwiLCBpbmRleDogaSwgdmFsdWU6IFwiXCIgfSk7XG4gICAgcmV0dXJuIHRva2Vucztcbn1cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICovXG5mdW5jdGlvbiBwYXJzZShzdHIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciB0b2tlbnMgPSBsZXhlcihzdHIpO1xuICAgIHZhciBfYSA9IG9wdGlvbnMucHJlZml4ZXMsIHByZWZpeGVzID0gX2EgPT09IHZvaWQgMCA/IFwiLi9cIiA6IF9hO1xuICAgIHZhciBkZWZhdWx0UGF0dGVybiA9IFwiW15cIiArIGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCBcIi8jP1wiKSArIFwiXSs/XCI7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBrZXkgPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcGF0aCA9IFwiXCI7XG4gICAgdmFyIHRyeUNvbnN1bWUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAoaSA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2ldLnR5cGUgPT09IHR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zW2krK10udmFsdWU7XG4gICAgfTtcbiAgICB2YXIgbXVzdENvbnN1bWUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0cnlDb25zdW1lKHR5cGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFyIF9hID0gdG9rZW5zW2ldLCBuZXh0VHlwZSA9IF9hLnR5cGUsIGluZGV4ID0gX2EuaW5kZXg7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIFwiICsgbmV4dFR5cGUgKyBcIiBhdCBcIiArIGluZGV4ICsgXCIsIGV4cGVjdGVkIFwiICsgdHlwZSk7XG4gICAgfTtcbiAgICB2YXIgY29uc3VtZVRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB3aGlsZSAoKHZhbHVlID0gdHJ5Q29uc3VtZShcIkNIQVJcIikgfHwgdHJ5Q29uc3VtZShcIkVTQ0FQRURfQ0hBUlwiKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgd2hpbGUgKGkgPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGFyID0gdHJ5Q29uc3VtZShcIkNIQVJcIik7XG4gICAgICAgIHZhciBuYW1lID0gdHJ5Q29uc3VtZShcIk5BTUVcIik7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gdHJ5Q29uc3VtZShcIlBBVFRFUk5cIik7XG4gICAgICAgIGlmIChuYW1lIHx8IHBhdHRlcm4pIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBjaGFyIHx8IFwiXCI7XG4gICAgICAgICAgICBpZiAocHJlZml4ZXMuaW5kZXhPZihwcmVmaXgpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHBhdGggKz0gcHJlZml4O1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgICAgIHBhdGggPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4gfHwgZGVmYXVsdFBhdHRlcm4sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IHRyeUNvbnN1bWUoXCJNT0RJRklFUlwiKSB8fCBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZSA9IGNoYXIgfHwgdHJ5Q29uc3VtZShcIkVTQ0FQRURfQ0hBUlwiKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBwYXRoICs9IHZhbHVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgcGF0aCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wZW4gPSB0cnlDb25zdW1lKFwiT1BFTlwiKTtcbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBjb25zdW1lVGV4dCgpO1xuICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHRyeUNvbnN1bWUoXCJOQU1FXCIpIHx8IFwiXCI7XG4gICAgICAgICAgICB2YXIgcGF0dGVybl8xID0gdHJ5Q29uc3VtZShcIlBBVFRFUk5cIikgfHwgXCJcIjtcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSBjb25zdW1lVGV4dCgpO1xuICAgICAgICAgICAgbXVzdENvbnN1bWUoXCJDTE9TRVwiKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXzEgfHwgKHBhdHRlcm5fMSA/IGtleSsrIDogXCJcIiksXG4gICAgICAgICAgICAgICAgcGF0dGVybjogbmFtZV8xICYmICFwYXR0ZXJuXzEgPyBkZWZhdWx0UGF0dGVybiA6IHBhdHRlcm5fMSxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgICAgICAgICAgICBzdWZmaXg6IHN1ZmZpeCxcbiAgICAgICAgICAgICAgICBtb2RpZmllcjogdHJ5Q29uc3VtZShcIk1PRElGSUVSXCIpIHx8IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbXVzdENvbnN1bWUoXCJFTkRcIik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG4vKipcbiAqIENvbXBpbGUgYSBzdHJpbmcgdG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgdGhlIHBhdGguXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUoc3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbih0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciByZUZsYWdzID0gZmxhZ3Mob3B0aW9ucyk7XG4gICAgdmFyIF9hID0gb3B0aW9ucy5lbmNvZGUsIGVuY29kZSA9IF9hID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9hLCBfYiA9IG9wdGlvbnMudmFsaWRhdGUsIHZhbGlkYXRlID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYjtcbiAgICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cbiAgICB2YXIgbWF0Y2hlcyA9IHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgdG9rZW4ucGF0dGVybiArIFwiKSRcIiwgcmVGbGFncyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHBhdGggPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHBhdGggKz0gdG9rZW47XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhID8gZGF0YVt0b2tlbi5uYW1lXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBvcHRpb25hbCA9IHRva2VuLm1vZGlmaWVyID09PSBcIj9cIiB8fCB0b2tlbi5tb2RpZmllciA9PT0gXCIqXCI7XG4gICAgICAgICAgICB2YXIgcmVwZWF0ID0gdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiIHx8IHRva2VuLm1vZGlmaWVyID09PSBcIitcIjtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICghcmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIG5vdCByZXBlYXQsIGJ1dCBnb3QgYW4gYXJyYXlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIG5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGUgJiYgIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGFsbCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIG1hdGNoIFxcXCJcIiArIHRva2VuLnBhdHRlcm4gKyBcIlxcXCIsIGJ1dCBnb3QgXFxcIlwiICsgc2VnbWVudCArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnQgKyB0b2tlbi5zdWZmaXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IGVuY29kZShTdHJpbmcodmFsdWUpLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlICYmICFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFxcXCJcIiArIHRva2VuLm5hbWUgKyBcIlxcXCIgdG8gbWF0Y2ggXFxcIlwiICsgdG9rZW4ucGF0dGVybiArIFwiXFxcIiwgYnV0IGdvdCBcXFwiXCIgKyBzZWdtZW50ICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnQgKyB0b2tlbi5zdWZmaXg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9uYWwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdHlwZU9mTWVzc2FnZSA9IHJlcGVhdCA/IFwiYW4gYXJyYXlcIiA6IFwiYSBzdHJpbmdcIjtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIGJlIFwiICsgdHlwZU9mTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcbn1cbmV4cG9ydHMudG9rZW5zVG9GdW5jdGlvbiA9IHRva2Vuc1RvRnVuY3Rpb247XG4vKipcbiAqIENyZWF0ZSBwYXRoIG1hdGNoIGZ1bmN0aW9uIGZyb20gYHBhdGgtdG8tcmVnZXhwYCBzcGVjLlxuICovXG5mdW5jdGlvbiBtYXRjaChzdHIsIG9wdGlvbnMpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIHZhciByZSA9IHBhdGhUb1JlZ2V4cChzdHIsIGtleXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiByZWdleHBUb0Z1bmN0aW9uKHJlLCBrZXlzLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubWF0Y2ggPSBtYXRjaDtcbi8qKlxuICogQ3JlYXRlIGEgcGF0aCBtYXRjaCBmdW5jdGlvbiBmcm9tIGBwYXRoLXRvLXJlZ2V4cGAgb3V0cHV0LlxuICovXG5mdW5jdGlvbiByZWdleHBUb0Z1bmN0aW9uKHJlLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgX2EgPSBvcHRpb25zLmRlY29kZSwgZGVjb2RlID0gX2EgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9IDogX2E7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgICAgICB2YXIgbSA9IHJlLmV4ZWMocGF0aG5hbWUpO1xuICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBwYXRoID0gbVswXSwgaW5kZXggPSBtLmluZGV4O1xuICAgICAgICB2YXIgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICBpZiAobVtpXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpIC0gMV07XG4gICAgICAgICAgICBpZiAoa2V5Lm1vZGlmaWVyID09PSBcIipcIiB8fCBrZXkubW9kaWZpZXIgPT09IFwiK1wiKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2tleS5uYW1lXSA9IG1baV0uc3BsaXQoa2V5LnByZWZpeCArIGtleS5zdWZmaXgpLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZSh2YWx1ZSwga2V5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trZXkubmFtZV0gPSBkZWNvZGUobVtpXSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHBhdGg6IHBhdGgsIGluZGV4OiBpbmRleCwgcGFyYW1zOiBwYXJhbXMgfTtcbiAgICB9O1xufVxuZXhwb3J0cy5yZWdleHBUb0Z1bmN0aW9uID0gcmVnZXhwVG9GdW5jdGlvbjtcbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXwvXFxcXF0pL2csIFwiXFxcXCQxXCIpO1xufVxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBmbGFncyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5zZW5zaXRpdmUgPyBcIlwiIDogXCJpXCI7XG59XG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAocGF0aCwga2V5cykge1xuICAgIGlmICgha2V5cylcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZyk7XG4gICAgaWYgKGdyb3Vwcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBpLFxuICAgICAgICAgICAgICAgIHByZWZpeDogXCJcIixcbiAgICAgICAgICAgICAgICBzdWZmaXg6IFwiXCIsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IFwiXCIsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBhcnJheVRvUmVnZXhwKHBhdGhzLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnRzID0gcGF0aHMubWFwKGZ1bmN0aW9uIChwYXRoKSB7IHJldHVybiBwYXRoVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucykuc291cmNlOyB9KTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIig/OlwiICsgcGFydHMuam9pbihcInxcIikgKyBcIilcIiwgZmxhZ3Mob3B0aW9ucykpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICAgIHJldHVybiB0b2tlbnNUb1JlZ2V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucyk7XG59XG4vKipcbiAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciB0YWtpbmcgdG9rZW5zIGFuZCByZXR1cm5pbmcgYSBSZWdFeHAuXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvUmVnZXhwKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIF9hID0gb3B0aW9ucy5zdHJpY3QsIHN0cmljdCA9IF9hID09PSB2b2lkIDAgPyBmYWxzZSA6IF9hLCBfYiA9IG9wdGlvbnMuc3RhcnQsIHN0YXJ0ID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYiwgX2MgPSBvcHRpb25zLmVuZCwgZW5kID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYywgX2QgPSBvcHRpb25zLmVuY29kZSwgZW5jb2RlID0gX2QgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9IDogX2Q7XG4gICAgdmFyIGVuZHNXaXRoID0gXCJbXCIgKyBlc2NhcGVTdHJpbmcob3B0aW9ucy5lbmRzV2l0aCB8fCBcIlwiKSArIFwiXXwkXCI7XG4gICAgdmFyIGRlbGltaXRlciA9IFwiW1wiICsgZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8IFwiLyM/XCIpICsgXCJdXCI7XG4gICAgdmFyIHJvdXRlID0gc3RhcnQgPyBcIl5cIiA6IFwiXCI7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgICBmb3IgKHZhciBfaSA9IDAsIHRva2Vuc18xID0gdG9rZW5zOyBfaSA8IHRva2Vuc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNfMVtfaV07XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyhlbmNvZGUodG9rZW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcoZW5jb2RlKHRva2VuLnByZWZpeCkpO1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IGVzY2FwZVN0cmluZyhlbmNvZGUodG9rZW4uc3VmZml4KSk7XG4gICAgICAgICAgICBpZiAodG9rZW4ucGF0dGVybikge1xuICAgICAgICAgICAgICAgIGlmIChrZXlzKVxuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmaXggfHwgc3VmZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi5tb2RpZmllciA9PT0gXCIrXCIgfHwgdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kID0gdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiID8gXCI/XCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIiArIHByZWZpeCArIFwiKCg/OlwiICsgdG9rZW4ucGF0dGVybiArIFwiKSg/OlwiICsgc3VmZml4ICsgcHJlZml4ICsgXCIoPzpcIiArIHRva2VuLnBhdHRlcm4gKyBcIikpKilcIiArIHN1ZmZpeCArIFwiKVwiICsgbW9kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIiArIHByZWZpeCArIFwiKFwiICsgdG9rZW4ucGF0dGVybiArIFwiKVwiICsgc3VmZml4ICsgXCIpXCIgKyB0b2tlbi5tb2RpZmllcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoXCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpXCIgKyB0b2tlbi5tb2RpZmllcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3V0ZSArPSBcIig/OlwiICsgcHJlZml4ICsgc3VmZml4ICsgXCIpXCIgKyB0b2tlbi5tb2RpZmllcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kKSB7XG4gICAgICAgIGlmICghc3RyaWN0KVxuICAgICAgICAgICAgcm91dGUgKz0gZGVsaW1pdGVyICsgXCI/XCI7XG4gICAgICAgIHJvdXRlICs9ICFvcHRpb25zLmVuZHNXaXRoID8gXCIkXCIgOiBcIig/PVwiICsgZW5kc1dpdGggKyBcIilcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBlbmRUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBpc0VuZERlbGltaXRlZCA9IHR5cGVvZiBlbmRUb2tlbiA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyBkZWxpbWl0ZXIuaW5kZXhPZihlbmRUb2tlbltlbmRUb2tlbi5sZW5ndGggLSAxXSkgPiAtMVxuICAgICAgICAgICAgOiAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICBlbmRUb2tlbiA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIXN0cmljdCkge1xuICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIiArIGRlbGltaXRlciArIFwiKD89XCIgKyBlbmRzV2l0aCArIFwiKSk/XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VuZERlbGltaXRlZCkge1xuICAgICAgICAgICAgcm91dGUgKz0gXCIoPz1cIiArIGRlbGltaXRlciArIFwifFwiICsgZW5kc1dpdGggKyBcIilcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZ0V4cChyb3V0ZSwgZmxhZ3Mob3B0aW9ucykpO1xufVxuZXhwb3J0cy50b2tlbnNUb1JlZ2V4cCA9IHRva2Vuc1RvUmVnZXhwO1xuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKVxuICAgICAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwga2V5cyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpXG4gICAgICAgIHJldHVybiBhcnJheVRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBzdHJpbmdUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMucGF0aFRvUmVnZXhwID0gcGF0aFRvUmVnZXhwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLypcbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgSmFzb24gTWlsbGVyIChodHRwczovL2phc29uZm9ybWF0LmNvbS8pXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbi8vIFRoaXMgZmlsZSBpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L21pdHQvYmxvYi92MS4xLjMvc3JjL2luZGV4LmpzXG4vLyBJdCdzIGJlZW4gZWRpdGVkIGZvciB0aGUgbmVlZHMgb2YgdGhpcyBzY3JpcHRcbi8vIFNlZSB0aGUgTElDRU5TRSBhdCB0aGUgdG9wIG9mIHRoZSBmaWxlXG5cbnR5cGUgSGFuZGxlciA9ICguLi5ldnRzOiBhbnlbXSkgPT4gdm9pZFxuXG5leHBvcnQgdHlwZSBNaXR0RW1pdHRlciA9IHtcbiAgb24odHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKTogdm9pZFxuICBvZmYodHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKTogdm9pZFxuICBlbWl0KHR5cGU6IHN0cmluZywgLi4uZXZ0czogYW55W10pOiB2b2lkXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1pdHQoKTogTWl0dEVtaXR0ZXIge1xuICBjb25zdCBhbGw6IHsgW3M6IHN0cmluZ106IEhhbmRsZXJbXSB9ID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIHJldHVybiB7XG4gICAgb24odHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKSB7XG4gICAgICA7KGFsbFt0eXBlXSB8fCAoYWxsW3R5cGVdID0gW10pKS5wdXNoKGhhbmRsZXIpXG4gICAgfSxcblxuICAgIG9mZih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpIHtcbiAgICAgIGlmIChhbGxbdHlwZV0pIHtcbiAgICAgICAgYWxsW3R5cGVdLnNwbGljZShhbGxbdHlwZV0uaW5kZXhPZihoYW5kbGVyKSA+Pj4gMCwgMSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW1pdCh0eXBlOiBzdHJpbmcsIC4uLmV2dHM6IGFueVtdKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgICA7KGFsbFt0eXBlXSB8fCBbXSkuc2xpY2UoKS5tYXAoKGhhbmRsZXI6IEhhbmRsZXIpID0+IHtcbiAgICAgICAgaGFuZGxlciguLi5ldnRzKVxuICAgICAgfSlcbiAgICB9LFxuICB9XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi9yb3V0ZXIvcm91dGVyJ1xuXG5leHBvcnQgY29uc3QgUm91dGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8TmV4dFJvdXRlcj4obnVsbCBhcyBhbnkpXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnUm91dGVyQ29udGV4dCdcbn1cbiIsIi8qIGdsb2JhbCBfX05FWFRfREFUQV9fICovXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlXG5pbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHtcbiAgbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gsXG4gIHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoLFxufSBmcm9tICcuLi8uLi8uLi9jbGllbnQvbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoJ1xuaW1wb3J0IHsgR29vZFBhZ2VDYWNoZSwgU3R5bGVTaGVldFR1cGxlIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L3BhZ2UtbG9hZGVyJ1xuaW1wb3J0IHsgZGVub3JtYWxpemVQYWdlUGF0aCB9IGZyb20gJy4uLy4uL3NlcnZlci9kZW5vcm1hbGl6ZS1wYWdlLXBhdGgnXG5pbXBvcnQgbWl0dCwgeyBNaXR0RW1pdHRlciB9IGZyb20gJy4uL21pdHQnXG5pbXBvcnQge1xuICBBcHBDb250ZXh0VHlwZSxcbiAgZm9ybWF0V2l0aFZhbGlkYXRpb24sXG4gIGdldExvY2F0aW9uT3JpZ2luLFxuICBnZXRVUkwsXG4gIGxvYWRHZXRJbml0aWFsUHJvcHMsXG4gIE5leHRQYWdlQ29udGV4dCxcbiAgU1QsXG59IGZyb20gJy4uL3V0aWxzJ1xuaW1wb3J0IHsgaXNEeW5hbWljUm91dGUgfSBmcm9tICcuL3V0aWxzL2lzLWR5bmFtaWMnXG5pbXBvcnQgeyBwYXJzZVJlbGF0aXZlVXJsIH0gZnJvbSAnLi91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmwnXG5pbXBvcnQgeyBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IH0gZnJvbSAnLi91dGlscy9xdWVyeXN0cmluZydcbmltcG9ydCByZXNvbHZlUmV3cml0ZXMgZnJvbSAnLi91dGlscy9yZXNvbHZlLXJld3JpdGVzJ1xuaW1wb3J0IHsgZ2V0Um91dGVNYXRjaGVyIH0gZnJvbSAnLi91dGlscy9yb3V0ZS1tYXRjaGVyJ1xuaW1wb3J0IHsgZ2V0Um91dGVSZWdleCB9IGZyb20gJy4vdXRpbHMvcm91dGUtcmVnZXgnXG5pbXBvcnQgZXNjYXBlUGF0aERlbGltaXRlcnMgZnJvbSAnLi91dGlscy9lc2NhcGUtcGF0aC1kZWxpbWl0ZXJzJ1xuXG5pbnRlcmZhY2UgVHJhbnNpdGlvbk9wdGlvbnMge1xuICBzaGFsbG93PzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZVxufVxuXG5pbnRlcmZhY2UgTmV4dEhpc3RvcnlTdGF0ZSB7XG4gIHVybDogc3RyaW5nXG4gIGFzOiBzdHJpbmdcbiAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnNcbn1cblxudHlwZSBIaXN0b3J5U3RhdGUgPSBudWxsIHwgeyBfX046IGZhbHNlIH0gfCAoeyBfX046IHRydWUgfSAmIE5leHRIaXN0b3J5U3RhdGUpXG5cbmNvbnN0IGJhc2VQYXRoID0gKHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggYXMgc3RyaW5nKSB8fCAnJ1xuXG5mdW5jdGlvbiBidWlsZENhbmNlbGxhdGlvbkVycm9yKCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ1JvdXRlIENhbmNlbGxlZCcpLCB7XG4gICAgY2FuY2VsbGVkOiB0cnVlLFxuICB9KVxufVxuXG5mdW5jdGlvbiBhZGRQYXRoUHJlZml4KHBhdGg6IHN0cmluZywgcHJlZml4Pzogc3RyaW5nKSB7XG4gIHJldHVybiBwcmVmaXggJiYgcGF0aC5zdGFydHNXaXRoKCcvJylcbiAgICA/IHBhdGggPT09ICcvJ1xuICAgICAgPyBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaChwcmVmaXgpXG4gICAgICA6IGAke3ByZWZpeH0ke3BhdGh9YFxuICAgIDogcGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkTG9jYWxlKFxuICBwYXRoOiBzdHJpbmcsXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlLFxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICByZXR1cm4gbG9jYWxlICYmIGxvY2FsZSAhPT0gZGVmYXVsdExvY2FsZSAmJiAhcGF0aC5zdGFydHNXaXRoKCcvJyArIGxvY2FsZSlcbiAgICAgID8gYWRkUGF0aFByZWZpeChwYXRoLCAnLycgKyBsb2NhbGUpXG4gICAgICA6IHBhdGhcbiAgfVxuICByZXR1cm4gcGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsTG9jYWxlKHBhdGg6IHN0cmluZywgbG9jYWxlPzogc3RyaW5nKSB7XG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgcmV0dXJuIGxvY2FsZSAmJiBwYXRoLnN0YXJ0c1dpdGgoJy8nICsgbG9jYWxlKVxuICAgICAgPyBwYXRoLnN1YnN0cihsb2NhbGUubGVuZ3RoICsgMSkgfHwgJy8nXG4gICAgICA6IHBhdGhcbiAgfVxuICByZXR1cm4gcGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzQmFzZVBhdGgocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBwYXRoID09PSBiYXNlUGF0aCB8fCBwYXRoLnN0YXJ0c1dpdGgoYmFzZVBhdGggKyAnLycpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRCYXNlUGF0aChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyB3ZSBvbmx5IGFkZCB0aGUgYmFzZXBhdGggb24gcmVsYXRpdmUgdXJsc1xuICByZXR1cm4gYWRkUGF0aFByZWZpeChwYXRoLCBiYXNlUGF0aClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbEJhc2VQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBwYXRoLnNsaWNlKGJhc2VQYXRoLmxlbmd0aCkgfHwgJy8nXG59XG5cbi8qKlxuICogRGV0ZWN0cyB3aGV0aGVyIGEgZ2l2ZW4gdXJsIGlzIHJvdXRhYmxlIGJ5IHRoZSBOZXh0LmpzIHJvdXRlciAoYnJvd3NlciBvbmx5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTG9jYWxVUkwodXJsOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKHVybC5zdGFydHNXaXRoKCcvJykpIHJldHVybiB0cnVlXG4gIHRyeSB7XG4gICAgLy8gYWJzb2x1dGUgdXJscyBjYW4gYmUgbG9jYWwgaWYgdGhleSBhcmUgb24gdGhlIHNhbWUgb3JpZ2luXG4gICAgY29uc3QgbG9jYXRpb25PcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG4gICAgY29uc3QgcmVzb2x2ZWQgPSBuZXcgVVJMKHVybCwgbG9jYXRpb25PcmlnaW4pXG4gICAgcmV0dXJuIHJlc29sdmVkLm9yaWdpbiA9PT0gbG9jYXRpb25PcmlnaW4gJiYgaGFzQmFzZVBhdGgocmVzb2x2ZWQucGF0aG5hbWUpXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG50eXBlIFVybCA9IFVybE9iamVjdCB8IHN0cmluZ1xuXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJwb2xhdGVBcyhcbiAgcm91dGU6IHN0cmluZyxcbiAgYXNQYXRobmFtZTogc3RyaW5nLFxuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbikge1xuICBsZXQgaW50ZXJwb2xhdGVkUm91dGUgPSAnJ1xuXG4gIGNvbnN0IGR5bmFtaWNSZWdleCA9IGdldFJvdXRlUmVnZXgocm91dGUpXG4gIGNvbnN0IGR5bmFtaWNHcm91cHMgPSBkeW5hbWljUmVnZXguZ3JvdXBzXG4gIGNvbnN0IGR5bmFtaWNNYXRjaGVzID1cbiAgICAvLyBUcnkgdG8gbWF0Y2ggdGhlIGR5bmFtaWMgcm91dGUgYWdhaW5zdCB0aGUgYXNQYXRoXG4gICAgKGFzUGF0aG5hbWUgIT09IHJvdXRlID8gZ2V0Um91dGVNYXRjaGVyKGR5bmFtaWNSZWdleCkoYXNQYXRobmFtZSkgOiAnJykgfHxcbiAgICAvLyBGYWxsIGJhY2sgdG8gcmVhZGluZyB0aGUgdmFsdWVzIGZyb20gdGhlIGhyZWZcbiAgICAvLyBUT0RPOiBzaG91bGQgdGhpcyB0YWtlIHByaW9yaXR5OyBhbHNvIG5lZWQgdG8gY2hhbmdlIGluIHRoZSByb3V0ZXIuXG4gICAgcXVlcnlcblxuICBpbnRlcnBvbGF0ZWRSb3V0ZSA9IHJvdXRlXG4gIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5rZXlzKGR5bmFtaWNHcm91cHMpXG5cbiAgaWYgKFxuICAgICFwYXJhbXMuZXZlcnkoKHBhcmFtKSA9PiB7XG4gICAgICBsZXQgdmFsdWUgPSBkeW5hbWljTWF0Y2hlc1twYXJhbV0gfHwgJydcbiAgICAgIGNvbnN0IHsgcmVwZWF0LCBvcHRpb25hbCB9ID0gZHluYW1pY0dyb3Vwc1twYXJhbV1cblxuICAgICAgLy8gc3VwcG9ydCBzaW5nbGUtbGV2ZWwgY2F0Y2gtYWxsXG4gICAgICAvLyBUT0RPOiBtb3JlIHJvYnVzdCBoYW5kbGluZyBmb3IgdXNlci1lcnJvciAocGFzc2luZyBgL2ApXG4gICAgICBsZXQgcmVwbGFjZWQgPSBgWyR7cmVwZWF0ID8gJy4uLicgOiAnJ30ke3BhcmFtfV1gXG4gICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgcmVwbGFjZWQgPSBgJHshdmFsdWUgPyAnLycgOiAnJ31bJHtyZXBsYWNlZH1dYFxuICAgICAgfVxuICAgICAgaWYgKHJlcGVhdCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHZhbHVlID0gW3ZhbHVlXVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAob3B0aW9uYWwgfHwgcGFyYW0gaW4gZHluYW1pY01hdGNoZXMpICYmXG4gICAgICAgIC8vIEludGVycG9sYXRlIGdyb3VwIGludG8gZGF0YSBVUkwgaWYgcHJlc2VudFxuICAgICAgICAoaW50ZXJwb2xhdGVkUm91dGUgPVxuICAgICAgICAgIGludGVycG9sYXRlZFJvdXRlIS5yZXBsYWNlKFxuICAgICAgICAgICAgcmVwbGFjZWQsXG4gICAgICAgICAgICByZXBlYXRcbiAgICAgICAgICAgICAgPyAodmFsdWUgYXMgc3RyaW5nW10pLm1hcChlc2NhcGVQYXRoRGVsaW1pdGVycykuam9pbignLycpXG4gICAgICAgICAgICAgIDogZXNjYXBlUGF0aERlbGltaXRlcnModmFsdWUgYXMgc3RyaW5nKVxuICAgICAgICAgICkgfHwgJy8nKVxuICAgICAgKVxuICAgIH0pXG4gICkge1xuICAgIGludGVycG9sYXRlZFJvdXRlID0gJycgLy8gZGlkIG5vdCBzYXRpc2Z5IGFsbCByZXF1aXJlbWVudHNcblxuICAgIC8vIG4uYi4gV2UgaWdub3JlIHRoaXMgZXJyb3IgYmVjYXVzZSB3ZSBoYW5kbGUgd2FybmluZyBmb3IgdGhpcyBjYXNlIGluXG4gICAgLy8gZGV2ZWxvcG1lbnQgaW4gdGhlIGA8TGluaz5gIGNvbXBvbmVudCBkaXJlY3RseS5cbiAgfVxuICByZXR1cm4ge1xuICAgIHBhcmFtcyxcbiAgICByZXN1bHQ6IGludGVycG9sYXRlZFJvdXRlLFxuICB9XG59XG5cbmZ1bmN0aW9uIG9taXRQYXJtc0Zyb21RdWVyeShxdWVyeTogUGFyc2VkVXJsUXVlcnksIHBhcmFtczogc3RyaW5nW10pIHtcbiAgY29uc3QgZmlsdGVyZWRRdWVyeTogUGFyc2VkVXJsUXVlcnkgPSB7fVxuXG4gIE9iamVjdC5rZXlzKHF1ZXJ5KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoIXBhcmFtcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBmaWx0ZXJlZFF1ZXJ5W2tleV0gPSBxdWVyeVtrZXldXG4gICAgfVxuICB9KVxuICByZXR1cm4gZmlsdGVyZWRRdWVyeVxufVxuXG4vKipcbiAqIFJlc29sdmVzIGEgZ2l2ZW4gaHlwZXJsaW5rIHdpdGggYSBjZXJ0YWluIHJvdXRlciBzdGF0ZSAoYmFzZVBhdGggbm90IGluY2x1ZGVkKS5cbiAqIFByZXNlcnZlcyBhYnNvbHV0ZSB1cmxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUhyZWYoXG4gIGN1cnJlbnRQYXRoOiBzdHJpbmcsXG4gIGhyZWY6IFVybCxcbiAgcmVzb2x2ZUFzPzogYm9vbGVhblxuKTogc3RyaW5nIHtcbiAgLy8gd2UgdXNlIGEgZHVtbXkgYmFzZSB1cmwgZm9yIHJlbGF0aXZlIHVybHNcbiAgY29uc3QgYmFzZSA9IG5ldyBVUkwoY3VycmVudFBhdGgsICdodHRwOi8vbicpXG4gIGNvbnN0IHVybEFzU3RyaW5nID1cbiAgICB0eXBlb2YgaHJlZiA9PT0gJ3N0cmluZycgPyBocmVmIDogZm9ybWF0V2l0aFZhbGlkYXRpb24oaHJlZilcbiAgdHJ5IHtcbiAgICBjb25zdCBmaW5hbFVybCA9IG5ldyBVUkwodXJsQXNTdHJpbmcsIGJhc2UpXG4gICAgZmluYWxVcmwucGF0aG5hbWUgPSBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaChmaW5hbFVybC5wYXRobmFtZSlcbiAgICBsZXQgaW50ZXJwb2xhdGVkQXMgPSAnJ1xuXG4gICAgaWYgKFxuICAgICAgaXNEeW5hbWljUm91dGUoZmluYWxVcmwucGF0aG5hbWUpICYmXG4gICAgICBmaW5hbFVybC5zZWFyY2hQYXJhbXMgJiZcbiAgICAgIHJlc29sdmVBc1xuICAgICkge1xuICAgICAgY29uc3QgcXVlcnkgPSBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KGZpbmFsVXJsLnNlYXJjaFBhcmFtcylcblxuICAgICAgY29uc3QgeyByZXN1bHQsIHBhcmFtcyB9ID0gaW50ZXJwb2xhdGVBcyhcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUsXG4gICAgICAgIGZpbmFsVXJsLnBhdGhuYW1lLFxuICAgICAgICBxdWVyeVxuICAgICAgKVxuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGludGVycG9sYXRlZEFzID0gZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgIHBhdGhuYW1lOiByZXN1bHQsXG4gICAgICAgICAgaGFzaDogZmluYWxVcmwuaGFzaCxcbiAgICAgICAgICBxdWVyeTogb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBwYXJhbXMpLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSBvcmlnaW4gZGlkbid0IGNoYW5nZSwgaXQgbWVhbnMgd2UgcmVjZWl2ZWQgYSByZWxhdGl2ZSBocmVmXG4gICAgY29uc3QgcmVzb2x2ZWRIcmVmID1cbiAgICAgIGZpbmFsVXJsLm9yaWdpbiA9PT0gYmFzZS5vcmlnaW5cbiAgICAgICAgPyBmaW5hbFVybC5ocmVmLnNsaWNlKGZpbmFsVXJsLm9yaWdpbi5sZW5ndGgpXG4gICAgICAgIDogZmluYWxVcmwuaHJlZlxuXG4gICAgcmV0dXJuIChyZXNvbHZlQXNcbiAgICAgID8gW3Jlc29sdmVkSHJlZiwgaW50ZXJwb2xhdGVkQXMgfHwgcmVzb2x2ZWRIcmVmXVxuICAgICAgOiByZXNvbHZlZEhyZWYpIGFzIHN0cmluZ1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIChyZXNvbHZlQXMgPyBbdXJsQXNTdHJpbmddIDogdXJsQXNTdHJpbmcpIGFzIHN0cmluZ1xuICB9XG59XG5cbmNvbnN0IFBBR0VfTE9BRF9FUlJPUiA9IFN5bWJvbCgnUEFHRV9MT0FEX0VSUk9SJylcbmV4cG9ydCBmdW5jdGlvbiBtYXJrTG9hZGluZ0Vycm9yKGVycjogRXJyb3IpOiBFcnJvciB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCBQQUdFX0xPQURfRVJST1IsIHt9KVxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVXJsQXMocm91dGVyOiBOZXh0Um91dGVyLCB1cmw6IFVybCwgYXM6IFVybCkge1xuICAvLyBJZiB1cmwgYW5kIGFzIHByb3ZpZGVkIGFzIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbixcbiAgLy8gd2UnbGwgZm9ybWF0IHRoZW0gaW50byB0aGUgc3RyaW5nIHZlcnNpb24gaGVyZS5cbiAgcmV0dXJuIHtcbiAgICB1cmw6IGFkZEJhc2VQYXRoKHJlc29sdmVIcmVmKHJvdXRlci5wYXRobmFtZSwgdXJsKSksXG4gICAgYXM6IGFzID8gYWRkQmFzZVBhdGgocmVzb2x2ZUhyZWYocm91dGVyLnBhdGhuYW1lLCBhcykpIDogYXMsXG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQmFzZVJvdXRlciA9IHtcbiAgcm91dGU6IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBhc1BhdGg6IHN0cmluZ1xuICBiYXNlUGF0aDogc3RyaW5nXG4gIGxvY2FsZT86IHN0cmluZ1xuICBsb2NhbGVzPzogc3RyaW5nW11cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBOZXh0Um91dGVyID0gQmFzZVJvdXRlciAmXG4gIFBpY2s8XG4gICAgUm91dGVyLFxuICAgIHwgJ3B1c2gnXG4gICAgfCAncmVwbGFjZSdcbiAgICB8ICdyZWxvYWQnXG4gICAgfCAnYmFjaydcbiAgICB8ICdwcmVmZXRjaCdcbiAgICB8ICdiZWZvcmVQb3BTdGF0ZSdcbiAgICB8ICdldmVudHMnXG4gICAgfCAnaXNGYWxsYmFjaydcbiAgPlxuXG5leHBvcnQgdHlwZSBQcmVmZXRjaE9wdGlvbnMgPSB7XG4gIHByaW9yaXR5PzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBQcml2YXRlUm91dGVJbmZvID0ge1xuICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgc3R5bGVTaGVldHM6IFN0eWxlU2hlZXRUdXBsZVtdXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG4gIHByb3BzPzogUmVjb3JkPHN0cmluZywgYW55PlxuICBlcnI/OiBFcnJvclxuICBlcnJvcj86IGFueVxufVxuXG5leHBvcnQgdHlwZSBBcHBQcm9wcyA9IFBpY2s8UHJpdmF0ZVJvdXRlSW5mbywgJ0NvbXBvbmVudCcgfCAnZXJyJz4gJiB7XG4gIHJvdXRlcjogUm91dGVyXG59ICYgUmVjb3JkPHN0cmluZywgYW55PlxuZXhwb3J0IHR5cGUgQXBwQ29tcG9uZW50ID0gQ29tcG9uZW50VHlwZTxBcHBQcm9wcz5cblxudHlwZSBTdWJzY3JpcHRpb24gPSAoZGF0YTogUHJpdmF0ZVJvdXRlSW5mbywgQXBwOiBBcHBDb21wb25lbnQpID0+IFByb21pc2U8dm9pZD5cblxudHlwZSBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrID0gKHN0YXRlOiBOZXh0SGlzdG9yeVN0YXRlKSA9PiBib29sZWFuXG5cbnR5cGUgQ29tcG9uZW50TG9hZENhbmNlbCA9ICgoKSA9PiB2b2lkKSB8IG51bGxcblxudHlwZSBIaXN0b3J5TWV0aG9kID0gJ3JlcGxhY2VTdGF0ZScgfCAncHVzaFN0YXRlJ1xuXG5jb25zdCBtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiA9XG4gIHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04gJiZcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiB3aW5kb3cuaGlzdG9yeVxuXG5jb25zdCBTU0dfREFUQV9OT1RfRk9VTkRfRVJST1IgPSAnU1NHIERhdGEgTk9UX0ZPVU5EJ1xuXG5mdW5jdGlvbiBmZXRjaFJldHJ5KHVybDogc3RyaW5nLCBhdHRlbXB0czogbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgcmV0dXJuIGZldGNoKHVybCwge1xuICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgIC8vIENvb2tpZXMgbWF5IGFsc28gYmUgcmVxdWlyZWQgZm9yIGBnZXRTZXJ2ZXJTaWRlUHJvcHNgLlxuICAgIC8vXG4gICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgIC8vID4gb3B0aW9uLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkvVXNpbmdfRmV0Y2hcbiAgICAvL1xuICAgIC8vID4gRm9yIG1heGltdW0gYnJvd3NlciBjb21wYXRpYmlsaXR5IHdoZW4gaXQgY29tZXMgdG8gc2VuZGluZyAmXG4gICAgLy8gPiByZWNlaXZpbmcgY29va2llcywgYWx3YXlzIHN1cHBseSB0aGUgYGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nYFxuICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoI2NhdmVhdHNcbiAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgfSkudGhlbigocmVzKSA9PiB7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGlmIChhdHRlbXB0cyA+IDEgJiYgcmVzLnN0YXR1cyA+PSA1MDApIHtcbiAgICAgICAgcmV0dXJuIGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cyAtIDEpXG4gICAgICB9XG4gICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIC8vIFRPRE86IGhhbmRsZSByZWxvYWRpbmcgaW4gZGV2ZWxvcG1lbnQgZnJvbSBmYWxsYmFjayByZXR1cm5pbmcgMjAwXG4gICAgICAgIC8vIHRvIG9uLWRlbWFuZC1lbnRyeS1oYW5kbGVyIGNhdXNpbmcgaXQgdG8gcmVsb2FkIHBlcmlvZGljYWxseVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoU1NHX0RBVEFfTk9UX0ZPVU5EX0VSUk9SKVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNgKVxuICAgIH1cbiAgICByZXR1cm4gcmVzLmpzb24oKVxuICB9KVxufVxuXG5mdW5jdGlvbiBmZXRjaE5leHREYXRhKGRhdGFIcmVmOiBzdHJpbmcsIGlzU2VydmVyUmVuZGVyOiBib29sZWFuKSB7XG4gIHJldHVybiBmZXRjaFJldHJ5KGRhdGFIcmVmLCBpc1NlcnZlclJlbmRlciA/IDMgOiAxKS5jYXRjaCgoZXJyOiBFcnJvcikgPT4ge1xuICAgIC8vIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzIGNhdXNlZFxuICAgIC8vIG9uIGEgY2xpZW50LXNpZGUgdHJhbnNpdGlvbi4gT3RoZXJ3aXNlLCB3ZSdkIGdldCBpbnRvIGFuIGluZmluaXRlXG4gICAgLy8gbG9vcC5cblxuICAgIGlmICghaXNTZXJ2ZXJSZW5kZXIpIHtcbiAgICAgIG1hcmtMb2FkaW5nRXJyb3IoZXJyKVxuICAgIH1cbiAgICB0aHJvdyBlcnJcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm91dGVyIGltcGxlbWVudHMgQmFzZVJvdXRlciB7XG4gIHJvdXRlOiBzdHJpbmdcbiAgcGF0aG5hbWU6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYXNQYXRoOiBzdHJpbmdcbiAgYmFzZVBhdGg6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgYWxsIGNvbXBvbmVudHMgbG9hZGVkIGluIGBSb3V0ZXJgXG4gICAqL1xuICBjb21wb25lbnRzOiB7IFtwYXRobmFtZTogc3RyaW5nXTogUHJpdmF0ZVJvdXRlSW5mbyB9XG4gIC8vIFN0YXRpYyBEYXRhIENhY2hlXG4gIHNkYzogeyBbYXNQYXRoOiBzdHJpbmddOiBvYmplY3QgfSA9IHt9XG4gIHN1YjogU3Vic2NyaXB0aW9uXG4gIGNsYzogQ29tcG9uZW50TG9hZENhbmNlbFxuICBwYWdlTG9hZGVyOiBhbnlcbiAgX2JwczogQmVmb3JlUG9wU3RhdGVDYWxsYmFjayB8IHVuZGVmaW5lZFxuICBldmVudHM6IE1pdHRFbWl0dGVyXG4gIF93cmFwQXBwOiAoQXBwOiBBcHBDb21wb25lbnQpID0+IGFueVxuICBpc1NzcjogYm9vbGVhblxuICBpc0ZhbGxiYWNrOiBib29sZWFuXG4gIF9pbkZsaWdodFJvdXRlPzogc3RyaW5nXG4gIF9zaGFsbG93PzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmdcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcblxuICBzdGF0aWMgZXZlbnRzOiBNaXR0RW1pdHRlciA9IG1pdHQoKVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICAgIGFzOiBzdHJpbmcsXG4gICAge1xuICAgICAgaW5pdGlhbFByb3BzLFxuICAgICAgcGFnZUxvYWRlcixcbiAgICAgIEFwcCxcbiAgICAgIHdyYXBBcHAsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBpbml0aWFsU3R5bGVTaGVldHMsXG4gICAgICBlcnIsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBpc0ZhbGxiYWNrLFxuICAgICAgbG9jYWxlLFxuICAgICAgbG9jYWxlcyxcbiAgICAgIGRlZmF1bHRMb2NhbGUsXG4gICAgfToge1xuICAgICAgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb25cbiAgICAgIGluaXRpYWxQcm9wczogYW55XG4gICAgICBwYWdlTG9hZGVyOiBhbnlcbiAgICAgIENvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICAgICAgaW5pdGlhbFN0eWxlU2hlZXRzOiBTdHlsZVNoZWV0VHVwbGVbXVxuICAgICAgQXBwOiBBcHBDb21wb25lbnRcbiAgICAgIHdyYXBBcHA6IChBcHA6IEFwcENvbXBvbmVudCkgPT4gYW55XG4gICAgICBlcnI/OiBFcnJvclxuICAgICAgaXNGYWxsYmFjazogYm9vbGVhblxuICAgICAgbG9jYWxlPzogc3RyaW5nXG4gICAgICBsb2NhbGVzPzogc3RyaW5nW11cbiAgICAgIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgICB9XG4gICkge1xuICAgIC8vIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgY29tcG9uZW50IGtleVxuICAgIHRoaXMucm91dGUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcblxuICAgIC8vIHNldCB1cCB0aGUgY29tcG9uZW50IGNhY2hlIChieSByb3V0ZSBrZXlzKVxuICAgIHRoaXMuY29tcG9uZW50cyA9IHt9XG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBrZWVwIHRoZSBjYWNoZSwgaWYgdGhlcmUncyBhbiBlcnJvclxuICAgIC8vIE90aGVyd2lzZSwgdGhpcyBjYXVzZSBpc3N1ZXMgd2hlbiB3aGVuIGdvaW5nIGJhY2sgYW5kXG4gICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgIGlmIChwYXRobmFtZSAhPT0gJy9fZXJyb3InKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0gPSB7XG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgc3R5bGVTaGVldHM6IGluaXRpYWxTdHlsZVNoZWV0cyxcbiAgICAgICAgcHJvcHM6IGluaXRpYWxQcm9wcyxcbiAgICAgICAgZXJyLFxuICAgICAgICBfX05fU1NHOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU0csXG4gICAgICAgIF9fTl9TU1A6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTUCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10gPSB7XG4gICAgICBDb21wb25lbnQ6IEFwcCBhcyBDb21wb25lbnRUeXBlLFxuICAgICAgc3R5bGVTaGVldHM6IFtcbiAgICAgICAgLyogL19hcHAgZG9lcyBub3QgbmVlZCBpdHMgc3R5bGVzaGVldHMgbWFuYWdlZCAqL1xuICAgICAgXSxcbiAgICB9XG5cbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBSb3V0ZXIucm91dGVyLmV2ZW50c1xuICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXG4gICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzXG5cbiAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyXG4gICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5XG4gICAgLy8gaWYgYXV0byBwcmVyZW5kZXJlZCBhbmQgZHluYW1pYyByb3V0ZSB3YWl0IHRvIHVwZGF0ZSBhc1BhdGhcbiAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgIHRoaXMuYXNQYXRoID1cbiAgICAgIC8vIEB0cy1pZ25vcmUgdGhpcyBpcyB0ZW1wb3JhcmlseSBnbG9iYWwgKGF0dGFjaGVkIHRvIHdpbmRvdylcbiAgICAgIGlzRHluYW1pY1JvdXRlKHBhdGhuYW1lKSAmJiBfX05FWFRfREFUQV9fLmF1dG9FeHBvcnQgPyBwYXRobmFtZSA6IGFzXG4gICAgdGhpcy5iYXNlUGF0aCA9IGJhc2VQYXRoXG4gICAgdGhpcy5zdWIgPSBzdWJzY3JpcHRpb25cbiAgICB0aGlzLmNsYyA9IG51bGxcbiAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcFxuICAgIC8vIG1ha2Ugc3VyZSB0byBpZ25vcmUgZXh0cmEgcG9wU3RhdGUgaW4gc2FmYXJpIG9uIG5hdmlnYXRpbmdcbiAgICAvLyBiYWNrIGZyb20gZXh0ZXJuYWwgc2l0ZVxuICAgIHRoaXMuaXNTc3IgPSB0cnVlXG5cbiAgICB0aGlzLmlzRmFsbGJhY2sgPSBpc0ZhbGxiYWNrXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGVcbiAgICAgIHRoaXMubG9jYWxlcyA9IGxvY2FsZXNcbiAgICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBcImFzXCIgZG9lc24ndCBzdGFydCB3aXRoIGRvdWJsZSBzbGFzaGVzIG9yIGVsc2UgaXQgY2FuXG4gICAgICAvLyB0aHJvdyBhbiBlcnJvciBhcyBpdCdzIGNvbnNpZGVyZWQgaW52YWxpZFxuICAgICAgaWYgKGFzLnN1YnN0cigwLCAyKSAhPT0gJy8vJykge1xuICAgICAgICAvLyBpbiBvcmRlciBmb3IgYGUuc3RhdGVgIHRvIHdvcmsgb24gdGhlIGBvbnBvcHN0YXRlYCBldmVudFxuICAgICAgICAvLyB3ZSBoYXZlIHRvIHJlZ2lzdGVyIHRoZSBpbml0aWFsIHJvdXRlIHVwb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgICBmb3JtYXRXaXRoVmFsaWRhdGlvbih7IHBhdGhuYW1lOiBhZGRCYXNlUGF0aChwYXRobmFtZSksIHF1ZXJ5IH0pLFxuICAgICAgICAgIGdldFVSTCgpXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5vblBvcFN0YXRlKVxuXG4gICAgICAvLyBlbmFibGUgY3VzdG9tIHNjcm9sbCByZXN0b3JhdGlvbiBoYW5kbGluZyB3aGVuIGF2YWlsYWJsZVxuICAgICAgLy8gb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIGJyb3dzZXIncyBkZWZhdWx0IGhhbmRsaW5nXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9ICdtYW51YWwnXG5cbiAgICAgICAgICBsZXQgc2Nyb2xsRGVib3VuY2VUaW1lb3V0OiB1bmRlZmluZWQgfCBOb2RlSlMuVGltZW91dFxuXG4gICAgICAgICAgY29uc3QgZGVib3VuY2VkU2Nyb2xsU2F2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzY3JvbGxEZWJvdW5jZVRpbWVvdXQpIGNsZWFyVGltZW91dChzY3JvbGxEZWJvdW5jZVRpbWVvdXQpXG5cbiAgICAgICAgICAgIHNjcm9sbERlYm91bmNlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7IHVybCwgYXM6IGN1ckFzLCBvcHRpb25zIH0gPSBoaXN0b3J5LnN0YXRlXG4gICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICAgICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGN1ckFzLFxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgIF9OX1g6IHdpbmRvdy5zY3JvbGxYLFxuICAgICAgICAgICAgICAgICAgX05fWTogd2luZG93LnNjcm9sbFksXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSwgMTApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGRlYm91bmNlZFNjcm9sbFNhdmUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvblBvcFN0YXRlID0gKGU6IFBvcFN0YXRlRXZlbnQpOiB2b2lkID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IGUuc3RhdGUgYXMgSGlzdG9yeVN0YXRlXG5cbiAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAvLyBXZSBnZXQgc3RhdGUgYXMgdW5kZWZpbmVkIGZvciB0d28gcmVhc29ucy5cbiAgICAgIC8vICAxLiBXaXRoIG9sZGVyIHNhZmFyaSAoPCA4KSBhbmQgb2xkZXIgY2hyb21lICg8IDM0KVxuICAgICAgLy8gIDIuIFdoZW4gdGhlIFVSTCBjaGFuZ2VkIHdpdGggI1xuICAgICAgLy9cbiAgICAgIC8vIEluIHRoZSBib3RoIGNhc2VzLCB3ZSBkb24ndCBuZWVkIHRvIHByb2NlZWQgYW5kIGNoYW5nZSB0aGUgcm91dGUuXG4gICAgICAvLyAoYXMgaXQncyBhbHJlYWR5IGNoYW5nZWQpXG4gICAgICAvLyBCdXQgd2UgY2FuIHNpbXBseSByZXBsYWNlIHRoZSBzdGF0ZSB3aXRoIHRoZSBuZXcgY2hhbmdlcy5cbiAgICAgIC8vIEFjdHVhbGx5LCBmb3IgKDEpIHdlIGRvbid0IG5lZWQgdG8gbm90aGluZy4gQnV0IGl0J3MgaGFyZCB0byBkZXRlY3QgdGhhdCBldmVudC5cbiAgICAgIC8vIFNvLCBkb2luZyB0aGUgZm9sbG93aW5nIGZvciAoMSkgZG9lcyBubyBoYXJtLlxuICAgICAgY29uc3QgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHRoaXNcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgICBmb3JtYXRXaXRoVmFsaWRhdGlvbih7IHBhdGhuYW1lOiBhZGRCYXNlUGF0aChwYXRobmFtZSksIHF1ZXJ5IH0pLFxuICAgICAgICBnZXRVUkwoKVxuICAgICAgKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFzdGF0ZS5fX04pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHsgdXJsLCBhcywgb3B0aW9ucyB9ID0gc3RhdGVcblxuICAgIGNvbnN0IHsgcGF0aG5hbWUgfSA9IHBhcnNlUmVsYXRpdmVVcmwodXJsKVxuXG4gICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHJlLXJlbmRlciBvbiBpbml0aWFsIGxvYWQsXG4gICAgLy8gY2FuIGJlIGNhdXNlZCBieSBuYXZpZ2F0aW5nIGJhY2sgZnJvbSBhbiBleHRlcm5hbCBzaXRlXG4gICAgaWYgKHRoaXMuaXNTc3IgJiYgYXMgPT09IHRoaXMuYXNQYXRoICYmIHBhdGhuYW1lID09PSB0aGlzLnBhdGhuYW1lKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZG93bnN0cmVhbSBhcHBsaWNhdGlvbiByZXR1cm5zIGZhbHN5LCByZXR1cm4uXG4gICAgLy8gVGhleSB3aWxsIHRoZW4gYmUgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHRoZSBldmVudC5cbiAgICBpZiAodGhpcy5fYnBzICYmICF0aGlzLl9icHMoc3RhdGUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmNoYW5nZShcbiAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgdXJsLFxuICAgICAgYXMsXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHNoYWxsb3c6IG9wdGlvbnMuc2hhbGxvdyAmJiB0aGlzLl9zaGFsbG93LFxuICAgICAgICBsb2NhbGU6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZSxcbiAgICAgIH0pXG4gICAgKVxuICB9XG5cbiAgcmVsb2FkKCk6IHZvaWQge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdvIGJhY2sgaW4gaGlzdG9yeVxuICAgKi9cbiAgYmFjaygpIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKClcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIGBwdXNoU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi9cbiAgcHVzaCh1cmw6IFVybCwgYXM6IFVybCA9IHVybCwgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIDsoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpXG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdwdXNoU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHJlcGxhY2VTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqL1xuICByZXBsYWNlKHVybDogVXJsLCBhczogVXJsID0gdXJsLCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgOyh7IHVybCwgYXMgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSlcbiAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3JlcGxhY2VTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpXG4gIH1cblxuICBhc3luYyBjaGFuZ2UoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzOiBzdHJpbmcsXG4gICAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnNcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCFpc0xvY2FsVVJMKHVybCkpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgdGhpcy5sb2NhbGUgPSBvcHRpb25zLmxvY2FsZSB8fCB0aGlzLmxvY2FsZVxuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvcHRpb25zLmxvY2FsZSA9IHRoaXMubG9jYWxlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbm9ybWFsaXplTG9jYWxlUGF0aCxcbiAgICAgIH0gPSByZXF1aXJlKCcuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoJylcblxuICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9IG5vcm1hbGl6ZUxvY2FsZVBhdGgoYXMsIHRoaXMubG9jYWxlcylcblxuICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlXG4gICAgICAgIHVybCA9IGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIShvcHRpb25zIGFzIGFueSkuX2gpIHtcbiAgICAgIHRoaXMuaXNTc3IgPSBmYWxzZVxuICAgIH1cbiAgICAvLyBtYXJraW5nIHJvdXRlIGNoYW5nZXMgYXMgYSBuYXZpZ2F0aW9uIHN0YXJ0IGVudHJ5XG4gICAgaWYgKFNUKSB7XG4gICAgICBwZXJmb3JtYW5jZS5tYXJrKCdyb3V0ZUNoYW5nZScpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2luRmxpZ2h0Um91dGUpIHtcbiAgICAgIHRoaXMuYWJvcnRDb21wb25lbnRMb2FkKHRoaXMuX2luRmxpZ2h0Um91dGUpXG4gICAgfVxuXG4gICAgYXMgPSBhZGRMb2NhbGUoYXMsIG9wdGlvbnMubG9jYWxlLCB0aGlzLmRlZmF1bHRMb2NhbGUpXG4gICAgY29uc3QgY2xlYW5lZEFzID0gZGVsTG9jYWxlKFxuICAgICAgaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMsXG4gICAgICB0aGlzLmxvY2FsZVxuICAgIClcbiAgICB0aGlzLl9pbkZsaWdodFJvdXRlID0gYXNcblxuICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBwcm9jZWVkLiBXZSBzaG91bGQgb25seSBjaGFuZ2UgdGhlIHN0YXRlLlxuXG4gICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgIC8vIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuIEl0IG1heSBjaGFuZ2UgYXRcbiAgICAvLyBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICBpZiAoIShvcHRpb25zIGFzIGFueSkuX2ggJiYgdGhpcy5vbmx5QUhhc2hDaGFuZ2UoY2xlYW5lZEFzKSkge1xuICAgICAgdGhpcy5hc1BhdGggPSBjbGVhbmVkQXNcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZVN0YXJ0JywgYXMpXG4gICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRoZSByZXNvbHZlZCBocmVmIHdoZW4gb25seSBhIGhhc2ggY2hhbmdlP1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpXG4gICAgICB0aGlzLnNjcm9sbFRvSGFzaChjbGVhbmVkQXMpXG4gICAgICB0aGlzLm5vdGlmeSh0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0pXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VDb21wbGV0ZScsIGFzKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBUaGUgYnVpbGQgbWFuaWZlc3QgbmVlZHMgdG8gYmUgbG9hZGVkIGJlZm9yZSBhdXRvLXN0YXRpYyBkeW5hbWljIHBhZ2VzXG4gICAgLy8gZ2V0IHRoZWlyIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gYWxsb3cgZW5zdXJpbmcgdGhleSBjYW4gYmUgcGFyc2VkIHByb3Blcmx5XG4gICAgLy8gd2hlbiByZXdyaXR0ZW4gdG9cbiAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpXG4gICAgY29uc3QgeyBfX3Jld3JpdGVzOiByZXdyaXRlcyB9ID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLnByb21pc2VkQnVpbGRNYW5pZmVzdFxuXG4gICAgbGV0IHBhcnNlZCA9IHBhcnNlUmVsYXRpdmVVcmwodXJsKVxuXG4gICAgbGV0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSBwYXJzZWRcblxuICAgIHBhcnNlZCA9IHRoaXMuX3Jlc29sdmVIcmVmKHBhcnNlZCwgcGFnZXMpIGFzIHR5cGVvZiBwYXJzZWRcblxuICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XG4gICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZVxuICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgIH1cblxuICAgIC8vIHVybCBhbmQgYXMgc2hvdWxkIGFsd2F5cyBiZSBwcmVmaXhlZCB3aXRoIGJhc2VQYXRoIGJ5IHRoaXNcbiAgICAvLyBwb2ludCBieSBlaXRoZXIgbmV4dC9saW5rIG9yIHJvdXRlci5wdXNoL3JlcGxhY2Ugc28gc3RyaXAgdGhlXG4gICAgLy8gYmFzZVBhdGggZnJvbSB0aGUgcGF0aG5hbWUgdG8gbWF0Y2ggdGhlIHBhZ2VzIGRpciAxLXRvLTFcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgICA/IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKGRlbEJhc2VQYXRoKHBhdGhuYW1lKSlcbiAgICAgIDogcGF0aG5hbWVcblxuICAgIC8vIElmIGFza2VkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBVUkwgd2Ugc2hvdWxkIHJlbG9hZCB0aGUgY3VycmVudCBwYWdlXG4gICAgLy8gKG5vdCBsb2NhdGlvbi5yZWxvYWQoKSBidXQgcmVsb2FkIGdldEluaXRpYWxQcm9wcyBhbmQgb3RoZXIgTmV4dC5qcyBzdHVmZnMpXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIHNldCB0aGUgbWV0aG9kID0gcmVwbGFjZVN0YXRlIGFsd2F5c1xuICAgIC8vIGFzIHRoaXMgc2hvdWxkIG5vdCBnbyBpbnRvIHRoZSBoaXN0b3J5IChUaGF0J3MgaG93IGJyb3dzZXJzIHdvcmspXG4gICAgLy8gV2Ugc2hvdWxkIGNvbXBhcmUgdGhlIG5ldyBhc1BhdGggdG8gdGhlIGN1cnJlbnQgYXNQYXRoLCBub3QgdGhlIHVybFxuICAgIGlmICghdGhpcy51cmxJc05ldyhjbGVhbmVkQXMpKSB7XG4gICAgICBtZXRob2QgPSAncmVwbGFjZVN0YXRlJ1xuICAgIH1cblxuICAgIGxldCByb3V0ZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuICAgIGNvbnN0IHsgc2hhbGxvdyA9IGZhbHNlIH0gPSBvcHRpb25zXG5cbiAgICAvLyB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIGFzIHZhbHVlIHVzaW5nIHJld3JpdGVzIGZvciBkeW5hbWljIFNTR1xuICAgIC8vIHBhZ2VzIHRvIGFsbG93IGJ1aWxkaW5nIHRoZSBkYXRhIFVSTCBjb3JyZWN0bHlcbiAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUykge1xuICAgICAgcmVzb2x2ZWRBcyA9IHJlc29sdmVSZXdyaXRlcyhcbiAgICAgICAgcGFyc2VSZWxhdGl2ZVVybChhcykucGF0aG5hbWUsXG4gICAgICAgIHBhZ2VzLFxuICAgICAgICBiYXNlUGF0aCxcbiAgICAgICAgcmV3cml0ZXMsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICAocDogc3RyaW5nKSA9PiB0aGlzLl9yZXNvbHZlSHJlZih7IHBhdGhuYW1lOiBwIH0sIHBhZ2VzKS5wYXRobmFtZSFcbiAgICAgIClcblxuICAgICAgaWYgKHJlc29sdmVkQXMgIT09IGFzKSB7XG4gICAgICAgIGNvbnN0IHBvdGVudGlhbEhyZWYgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlSHJlZihcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHBhcnNlZCwgeyBwYXRobmFtZTogcmVzb2x2ZWRBcyB9KSxcbiAgICAgICAgICAgIHBhZ2VzLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApLnBhdGhuYW1lIVxuICAgICAgICApXG5cbiAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICBpZiAocGFnZXMuaW5jbHVkZXMocG90ZW50aWFsSHJlZikpIHtcbiAgICAgICAgICByb3V0ZSA9IHBvdGVudGlhbEhyZWZcbiAgICAgICAgICBwYXRobmFtZSA9IHBvdGVudGlhbEhyZWZcbiAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgICAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXNvbHZlZEFzID0gZGVsTG9jYWxlKGRlbEJhc2VQYXRoKHJlc29sdmVkQXMpLCB0aGlzLmxvY2FsZSlcblxuICAgIGlmIChpc0R5bmFtaWNSb3V0ZShyb3V0ZSkpIHtcbiAgICAgIGNvbnN0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChyZXNvbHZlZEFzKVxuICAgICAgY29uc3QgYXNQYXRobmFtZSA9IHBhcnNlZEFzLnBhdGhuYW1lXG5cbiAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSBnZXRSb3V0ZVJlZ2V4KHJvdXRlKVxuICAgICAgY29uc3Qgcm91dGVNYXRjaCA9IGdldFJvdXRlTWF0Y2hlcihyb3V0ZVJlZ2V4KShhc1BhdGhuYW1lKVxuICAgICAgY29uc3Qgc2hvdWxkSW50ZXJwb2xhdGUgPSByb3V0ZSA9PT0gYXNQYXRobmFtZVxuICAgICAgY29uc3QgaW50ZXJwb2xhdGVkQXMgPSBzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICA/IGludGVycG9sYXRlQXMocm91dGUsIGFzUGF0aG5hbWUsIHF1ZXJ5KVxuICAgICAgICA6ICh7fSBhcyB7IHJlc3VsdDogdW5kZWZpbmVkOyBwYXJhbXM6IHVuZGVmaW5lZCB9KVxuXG4gICAgICBpZiAoIXJvdXRlTWF0Y2ggfHwgKHNob3VsZEludGVycG9sYXRlICYmICFpbnRlcnBvbGF0ZWRBcy5yZXN1bHQpKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdQYXJhbXMgPSBPYmplY3Qua2V5cyhyb3V0ZVJlZ2V4Lmdyb3VwcykuZmlsdGVyKFxuICAgICAgICAgIChwYXJhbSkgPT4gIXF1ZXJ5W3BhcmFtXVxuICAgICAgICApXG5cbiAgICAgICAgaWYgKG1pc3NpbmdQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIGAke1xuICAgICAgICAgICAgICAgIHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgICAgICA/IGBJbnRlcnBvbGF0aW5nIGhyZWZgXG4gICAgICAgICAgICAgICAgICA6IGBNaXNtYXRjaGluZyBcXGBhc1xcYCBhbmQgXFxgaHJlZlxcYGBcbiAgICAgICAgICAgICAgfSBmYWlsZWQgdG8gbWFudWFsbHkgcHJvdmlkZSBgICtcbiAgICAgICAgICAgICAgICBgdGhlIHBhcmFtczogJHttaXNzaW5nUGFyYW1zLmpvaW4oXG4gICAgICAgICAgICAgICAgICAnLCAnXG4gICAgICAgICAgICAgICAgKX0gaW4gdGhlIFxcYGhyZWZcXGAncyBcXGBxdWVyeVxcYGBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAoc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgPyBgVGhlIHByb3ZpZGVkIFxcYGhyZWZcXGAgKCR7dXJsfSkgdmFsdWUgaXMgbWlzc2luZyBxdWVyeSB2YWx1ZXMgKCR7bWlzc2luZ1BhcmFtcy5qb2luKFxuICAgICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICAgICl9KSB0byBiZSBpbnRlcnBvbGF0ZWQgcHJvcGVybHkuIGBcbiAgICAgICAgICAgICAgOiBgVGhlIHByb3ZpZGVkIFxcYGFzXFxgIHZhbHVlICgke2FzUGF0aG5hbWV9KSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgXFxgaHJlZlxcYCB2YWx1ZSAoJHtyb3V0ZX0pLiBgKSArXG4gICAgICAgICAgICAgIGBSZWFkIG1vcmU6IGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzLyR7XG4gICAgICAgICAgICAgICAgc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgICAgID8gJ2hyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWQnXG4gICAgICAgICAgICAgICAgICA6ICdpbmNvbXBhdGlibGUtaHJlZi1hcydcbiAgICAgICAgICAgICAgfWBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSW50ZXJwb2xhdGUpIHtcbiAgICAgICAgYXMgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBwYXJzZWRBcywge1xuICAgICAgICAgICAgcGF0aG5hbWU6IGludGVycG9sYXRlZEFzLnJlc3VsdCxcbiAgICAgICAgICAgIHF1ZXJ5OiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnksIGludGVycG9sYXRlZEFzLnBhcmFtcyEpLFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIGBxdWVyeWAsIG92ZXJ3cml0aW5nIGFueSBzcGVjaWZpZWQgaW4gc2VhcmNoXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIHJvdXRlTWF0Y2gpXG4gICAgICB9XG4gICAgfVxuXG4gICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZVN0YXJ0JywgYXMpXG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oXG4gICAgICAgIHJvdXRlLFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGFzLFxuICAgICAgICBzaGFsbG93XG4gICAgICApXG4gICAgICBsZXQgeyBlcnJvciwgcHJvcHMsIF9fTl9TU0csIF9fTl9TU1AgfSA9IHJvdXRlSW5mb1xuXG4gICAgICAvLyBoYW5kbGUgcmVkaXJlY3Qgb24gY2xpZW50LXRyYW5zaXRpb25cbiAgICAgIGlmIChcbiAgICAgICAgKF9fTl9TU0cgfHwgX19OX1NTUCkgJiZcbiAgICAgICAgcHJvcHMgJiZcbiAgICAgICAgKHByb3BzIGFzIGFueSkucGFnZVByb3BzICYmXG4gICAgICAgIChwcm9wcyBhcyBhbnkpLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1RcbiAgICAgICkge1xuICAgICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IChwcm9wcyBhcyBhbnkpLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1RcblxuICAgICAgICAvLyBjaGVjayBpZiBkZXN0aW5hdGlvbiBpcyBpbnRlcm5hbCAocmVzb2x2ZXMgdG8gYSBwYWdlKSBhbmQgYXR0ZW1wdFxuICAgICAgICAvLyBjbGllbnQtbmF2aWdhdGlvbiBpZiBpdCBpcyBmYWxsaW5nIGJhY2sgdG8gaGFyZCBuYXZpZ2F0aW9uIGlmXG4gICAgICAgIC8vIGl0J3Mgbm90XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbi5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWRIcmVmID0gcGFyc2VSZWxhdGl2ZVVybChkZXN0aW5hdGlvbilcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlSHJlZihwYXJzZWRIcmVmLCBwYWdlcylcblxuICAgICAgICAgIGlmIChwYWdlcy5pbmNsdWRlcyhwYXJzZWRIcmVmLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgZGVzdGluYXRpb24sIGRlc3RpbmF0aW9uLCBvcHRpb25zKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZGVzdGluYXRpb25cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgfVxuXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLCBhcylcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgdXJsLFxuICAgICAgICBhZGRMb2NhbGUoYXMsIG9wdGlvbnMubG9jYWxlLCB0aGlzLmRlZmF1bHRMb2NhbGUpLFxuICAgICAgICBvcHRpb25zXG4gICAgICApXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGFwcENvbXA6IGFueSA9IHRoaXMuY29tcG9uZW50c1snL19hcHAnXS5Db21wb25lbnRcbiAgICAgICAgOyh3aW5kb3cgYXMgYW55KS5uZXh0LmlzUHJlcmVuZGVyZWQgPVxuICAgICAgICAgIGFwcENvbXAuZ2V0SW5pdGlhbFByb3BzID09PSBhcHBDb21wLm9yaWdHZXRJbml0aWFsUHJvcHMgJiZcbiAgICAgICAgICAhKHJvdXRlSW5mby5Db21wb25lbnQgYXMgYW55KS5nZXRJbml0aWFsUHJvcHNcbiAgICAgIH1cblxuICAgICAgYXdhaXQgdGhpcy5zZXQocm91dGUsIHBhdGhuYW1lISwgcXVlcnksIGNsZWFuZWRBcywgcm91dGVJbmZvKS5jYXRjaChcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICBpZiAoZS5jYW5jZWxsZWQpIGVycm9yID0gZXJyb3IgfHwgZVxuICAgICAgICAgIGVsc2UgdGhyb3cgZVxuICAgICAgICB9XG4gICAgICApXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnJvciwgY2xlYW5lZEFzKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24gJiYgJ19OX1gnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oKG9wdGlvbnMgYXMgYW55KS5fTl9YLCAob3B0aW9ucyBhcyBhbnkpLl9OX1kpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VDb21wbGV0ZScsIGFzKVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICBjaGFuZ2VTdGF0ZShcbiAgICBtZXRob2Q6IEhpc3RvcnlNZXRob2QsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYXM6IHN0cmluZyxcbiAgICBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9XG4gICk6IHZvaWQge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeSBpcyBub3QgYXZhaWxhYmxlLmApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LiR7bWV0aG9kfSBpcyBub3QgYXZhaWxhYmxlYClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgfHwgZ2V0VVJMKCkgIT09IGFzKSB7XG4gICAgICB0aGlzLl9zaGFsbG93ID0gb3B0aW9ucy5zaGFsbG93XG4gICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKFxuICAgICAgICB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGFzLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgX19OOiB0cnVlLFxuICAgICAgICB9IGFzIEhpc3RvcnlTdGF0ZSxcbiAgICAgICAgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgIC8vIFBhc3NpbmcgdGhlIGVtcHR5IHN0cmluZyBoZXJlIHNob3VsZCBiZSBzYWZlIGFnYWluc3QgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIG1ldGhvZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXG4gICAgICAgICcnLFxuICAgICAgICBhc1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGhhbmRsZVJvdXRlSW5mb0Vycm9yKFxuICAgIGVycjogRXJyb3IgJiB7IGNvZGU6IGFueTsgY2FuY2VsbGVkOiBib29sZWFuIH0sXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICBsb2FkRXJyb3JGYWlsPzogYm9vbGVhblxuICApOiBQcm9taXNlPFByaXZhdGVSb3V0ZUluZm8+IHtcbiAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGxhdGlvbiBlcnJvcnNcbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIGlmIChQQUdFX0xPQURfRVJST1IgaW4gZXJyIHx8IGxvYWRFcnJvckZhaWwpIHtcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgYXMpXG5cbiAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAvLyAgMS4gUGFnZSBkb2Vzbid0IGV4aXN0c1xuICAgICAgLy8gIDIuIFBhZ2UgZG9lcyBleGlzdCBpbiBhIGRpZmZlcmVudCB6b25lXG4gICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuXG4gICAgICAvLyBTbywgZG9pbmcgYSBoYXJkIHJlbG9hZCBpcyB0aGUgcHJvcGVyIHdheSB0byBkZWFsIHdpdGggdGhpcy5cbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXNcblxuICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAvLyBTbyBsZXQncyB0aHJvdyBhIGNhbmNlbGxhdGlvbiBlcnJvciBzdG9wIHRoZSByb3V0aW5nIGxvZ2ljLlxuICAgICAgdGhyb3cgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgICAgIGxldCBzdHlsZVNoZWV0czogU3R5bGVTaGVldFR1cGxlW11cbiAgICAgIGxldCBwcm9wczogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZFxuICAgICAgY29uc3Qgc3NnNDA0ID0gZXJyLm1lc3NhZ2UgPT09IFNTR19EQVRBX05PVF9GT1VORF9FUlJPUlxuXG4gICAgICBpZiAoc3NnNDA0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IG1vZDogYW55XG4gICAgICAgICAgOyh7IHBhZ2U6IENvbXBvbmVudCwgc3R5bGVTaGVldHMsIG1vZCB9ID0gYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChcbiAgICAgICAgICAgICcvNDA0J1xuICAgICAgICAgICkpXG5cbiAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgd2UgdG9sZXJhdGUgdGhlc2UgcHJvcHMgbWlzc2luZyBhbmQgc3RpbGwgcmVuZGVyIHRoZVxuICAgICAgICAgIC8vIHBhZ2UgaW5zdGVhZCBvZiBmYWxsaW5nIGJhY2sgdG8gX2Vycm9yP1xuICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fTl9TU0cpIHtcbiAgICAgICAgICAgIHByb3BzID0gYXdhaXQgdGhpcy5fZ2V0U3RhdGljRGF0YShcbiAgICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKCcvNDA0JywgJy80MDQnLCB0cnVlLCB0aGlzLmxvY2FsZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAvLyBub24tZmF0YWwgZmFsbGJhY2sgdG8gX2Vycm9yXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgQ29tcG9uZW50ISA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgdHlwZW9mIHN0eWxlU2hlZXRzISA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICkge1xuICAgICAgICA7KHsgcGFnZTogQ29tcG9uZW50LCBzdHlsZVNoZWV0cyB9ID0gYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChcbiAgICAgICAgICAnL19lcnJvcidcbiAgICAgICAgKSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgcm91dGVJbmZvOiBQcml2YXRlUm91dGVJbmZvID0ge1xuICAgICAgICBwcm9wcyxcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgZXJyOiBzc2c0MDQgPyB1bmRlZmluZWQgOiBlcnIsXG4gICAgICAgIGVycm9yOiBzc2c0MDQgPyB1bmRlZmluZWQgOiBlcnIsXG4gICAgICB9XG5cbiAgICAgIGlmICghcm91dGVJbmZvLnByb3BzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIH0gYXMgYW55KVxuICAgICAgICB9IGNhdGNoIChnaXBFcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBlcnJvciBwYWdlIGBnZXRJbml0aWFsUHJvcHNgOiAnLCBnaXBFcnIpXG4gICAgICAgICAgcm91dGVJbmZvLnByb3BzID0ge31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcm91dGVJbmZvXG4gICAgfSBjYXRjaCAocm91dGVJbmZvRXJyKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcihyb3V0ZUluZm9FcnIsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHRydWUpXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0Um91dGVJbmZvKFxuICAgIHJvdXRlOiBzdHJpbmcsXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogYW55LFxuICAgIGFzOiBzdHJpbmcsXG4gICAgc2hhbGxvdzogYm9vbGVhbiA9IGZhbHNlXG4gICk6IFByb21pc2U8UHJpdmF0ZVJvdXRlSW5mbz4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjYWNoZWRSb3V0ZUluZm8gPSB0aGlzLmNvbXBvbmVudHNbcm91dGVdXG5cbiAgICAgIGlmIChzaGFsbG93ICYmIGNhY2hlZFJvdXRlSW5mbyAmJiB0aGlzLnJvdXRlID09PSByb3V0ZSkge1xuICAgICAgICByZXR1cm4gY2FjaGVkUm91dGVJbmZvXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJvdXRlSW5mbzogUHJpdmF0ZVJvdXRlSW5mbyA9IGNhY2hlZFJvdXRlSW5mb1xuICAgICAgICA/IGNhY2hlZFJvdXRlSW5mb1xuICAgICAgICA6IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQocm91dGUpLnRoZW4oKHJlcykgPT4gKHtcbiAgICAgICAgICAgIENvbXBvbmVudDogcmVzLnBhZ2UsXG4gICAgICAgICAgICBzdHlsZVNoZWV0czogcmVzLnN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgX19OX1NTRzogcmVzLm1vZC5fX05fU1NHLFxuICAgICAgICAgICAgX19OX1NTUDogcmVzLm1vZC5fX05fU1NQLFxuICAgICAgICAgIH0pKVxuXG4gICAgICBjb25zdCB7IENvbXBvbmVudCwgX19OX1NTRywgX19OX1NTUCB9ID0gcm91dGVJbmZvXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlIH0gPSByZXF1aXJlKCdyZWFjdC1pcycpXG4gICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKENvbXBvbmVudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIiR7cGF0aG5hbWV9XCJgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBkYXRhSHJlZjogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgICAgIGlmIChfX05fU1NHIHx8IF9fTl9TU1ApIHtcbiAgICAgICAgZGF0YUhyZWYgPSB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoXG4gICAgICAgICAgZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZSwgcXVlcnkgfSksXG4gICAgICAgICAgZGVsQmFzZVBhdGgoYXMpLFxuICAgICAgICAgIF9fTl9TU0csXG4gICAgICAgICAgdGhpcy5sb2NhbGVcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9wcyA9IGF3YWl0IHRoaXMuX2dldERhdGE8UHJpdmF0ZVJvdXRlSW5mbz4oKCkgPT5cbiAgICAgICAgX19OX1NTR1xuICAgICAgICAgID8gdGhpcy5fZ2V0U3RhdGljRGF0YShkYXRhSHJlZiEpXG4gICAgICAgICAgOiBfX05fU1NQXG4gICAgICAgICAgPyB0aGlzLl9nZXRTZXJ2ZXJEYXRhKGRhdGFIcmVmISlcbiAgICAgICAgICA6IHRoaXMuZ2V0SW5pdGlhbFByb3BzKFxuICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgIC8vIHdlIHByb3ZpZGUgQXBwVHJlZSBsYXRlciBzbyB0aGlzIG5lZWRzIHRvIGJlIGBhbnlgXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgICB9IGFzIGFueVxuICAgICAgICAgICAgKVxuICAgICAgKVxuXG4gICAgICByb3V0ZUluZm8ucHJvcHMgPSBwcm9wc1xuICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mb1xuICAgICAgcmV0dXJuIHJvdXRlSW5mb1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoZXJyLCBwYXRobmFtZSwgcXVlcnksIGFzKVxuICAgIH1cbiAgfVxuXG4gIHNldChcbiAgICByb3V0ZTogc3RyaW5nLFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICAgIGFzOiBzdHJpbmcsXG4gICAgZGF0YTogUHJpdmF0ZVJvdXRlSW5mb1xuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmlzRmFsbGJhY2sgPSBmYWxzZVxuXG4gICAgdGhpcy5yb3V0ZSA9IHJvdXRlXG4gICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5XG4gICAgdGhpcy5hc1BhdGggPSBhc1xuICAgIHJldHVybiB0aGlzLm5vdGlmeShkYXRhKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHJlcGxhY2luZyByb3V0ZXIgc3RhdGVcbiAgICogQHBhcmFtIGNiIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG4gICAqL1xuICBiZWZvcmVQb3BTdGF0ZShjYjogQmVmb3JlUG9wU3RhdGVDYWxsYmFjaykge1xuICAgIHRoaXMuX2JwcyA9IGNiXG4gIH1cblxuICBvbmx5QUhhc2hDaGFuZ2UoYXM6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZVxuICAgIGNvbnN0IFtvbGRVcmxOb0hhc2gsIG9sZEhhc2hdID0gdGhpcy5hc1BhdGguc3BsaXQoJyMnKVxuICAgIGNvbnN0IFtuZXdVcmxOb0hhc2gsIG5ld0hhc2hdID0gYXMuc3BsaXQoJyMnKVxuXG4gICAgLy8gTWFrZXMgc3VyZSB3ZSBzY3JvbGwgdG8gdGhlIHByb3ZpZGVkIGhhc2ggaWYgdGhlIHVybC9oYXNoIGFyZSB0aGUgc2FtZVxuICAgIGlmIChuZXdIYXNoICYmIG9sZFVybE5vSGFzaCA9PT0gbmV3VXJsTm9IYXNoICYmIG9sZEhhc2ggPT09IG5ld0hhc2gpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuICAgIGlmIChvbGRVcmxOb0hhc2ggIT09IG5ld1VybE5vSGFzaCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGhhc2ggaGFzIGNoYW5nZWQsIHRoZW4gaXQncyBhIGhhc2ggb25seSBjaGFuZ2UuXG4gICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgIC8vIGxlYXZlIGhhc2ggPT09ICcnIGNhc2VzLiBUaGUgaWRlbnRpdHkgY2FzZSBmYWxscyB0aHJvdWdoXG4gICAgLy8gYW5kIGlzIHRyZWF0ZWQgYXMgYSBuZXh0IHJlbG9hZC5cbiAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaFxuICB9XG5cbiAgc2Nyb2xsVG9IYXNoKGFzOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBbLCBoYXNoXSA9IGFzLnNwbGl0KCcjJylcbiAgICAvLyBTY3JvbGwgdG8gdG9wIGlmIHRoZSBoYXNoIGlzIGp1c3QgYCNgIHdpdGggbm8gdmFsdWVcbiAgICBpZiAoaGFzaCA9PT0gJycpIHtcbiAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gRmlyc3Qgd2UgY2hlY2sgaWYgdGhlIGVsZW1lbnQgYnkgaWQgaXMgZm91bmRcbiAgICBjb25zdCBpZEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaClcbiAgICBpZiAoaWRFbCkge1xuICAgICAgaWRFbC5zY3JvbGxJbnRvVmlldygpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gSWYgdGhlcmUncyBubyBlbGVtZW50IHdpdGggdGhlIGlkLCB3ZSBjaGVjayB0aGUgYG5hbWVgIHByb3BlcnR5XG4gICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgY29uc3QgbmFtZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoaGFzaClbMF1cbiAgICBpZiAobmFtZUVsKSB7XG4gICAgICBuYW1lRWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgIH1cbiAgfVxuXG4gIHVybElzTmV3KGFzUGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYXNQYXRoICE9PSBhc1BhdGhcbiAgfVxuXG4gIF9yZXNvbHZlSHJlZihwYXJzZWRIcmVmOiBVcmxPYmplY3QsIHBhZ2VzOiBzdHJpbmdbXSwgYXBwbHlCYXNlUGF0aCA9IHRydWUpIHtcbiAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSBwYXJzZWRIcmVmXG4gICAgY29uc3QgY2xlYW5QYXRobmFtZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKFxuICAgICAgZGVub3JtYWxpemVQYWdlUGF0aChhcHBseUJhc2VQYXRoID8gZGVsQmFzZVBhdGgocGF0aG5hbWUhKSA6IHBhdGhuYW1lISlcbiAgICApXG5cbiAgICBpZiAoY2xlYW5QYXRobmFtZSA9PT0gJy80MDQnIHx8IGNsZWFuUGF0aG5hbWUgPT09ICcvX2Vycm9yJykge1xuICAgICAgcmV0dXJuIHBhcnNlZEhyZWZcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgcmVzb2x2aW5nIGhyZWYgZm9yIGR5bmFtaWMgcm91dGVzXG4gICAgaWYgKCFwYWdlcy5pbmNsdWRlcyhjbGVhblBhdGhuYW1lISkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICAgIHBhZ2VzLnNvbWUoKHBhZ2UpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGlzRHluYW1pY1JvdXRlKHBhZ2UpICYmXG4gICAgICAgICAgZ2V0Um91dGVSZWdleChwYWdlKS5yZS50ZXN0KGNsZWFuUGF0aG5hbWUhKVxuICAgICAgICApIHtcbiAgICAgICAgICBwYXJzZWRIcmVmLnBhdGhuYW1lID0gYXBwbHlCYXNlUGF0aCA/IGFkZEJhc2VQYXRoKHBhZ2UpIDogcGFnZVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBwYXJzZWRIcmVmXG4gIH1cblxuICAvKipcbiAgICogUHJlZmV0Y2ggcGFnZSBjb2RlLCB5b3UgbWF5IHdhaXQgZm9yIHRoZSBkYXRhIGR1cmluZyBwYWdlIHJlbmRlcmluZy5cbiAgICogVGhpcyBmZWF0dXJlIG9ubHkgd29ya3MgaW4gcHJvZHVjdGlvbiFcbiAgICogQHBhcmFtIHVybCB0aGUgaHJlZiBvZiBwcmVmZXRjaGVkIHBhZ2VcbiAgICogQHBhcmFtIGFzUGF0aCB0aGUgYXMgcGF0aCBvZiB0aGUgcHJlZmV0Y2hlZCBwYWdlXG4gICAqL1xuICBhc3luYyBwcmVmZXRjaChcbiAgICB1cmw6IHN0cmluZyxcbiAgICBhc1BhdGg6IHN0cmluZyA9IHVybCxcbiAgICBvcHRpb25zOiBQcmVmZXRjaE9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsZXQgcGFyc2VkID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG5cbiAgICBsZXQgeyBwYXRobmFtZSB9ID0gcGFyc2VkXG5cbiAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpXG5cbiAgICBwYXJzZWQgPSB0aGlzLl9yZXNvbHZlSHJlZihwYXJzZWQsIHBhZ2VzKSBhcyB0eXBlb2YgcGFyc2VkXG5cbiAgICBpZiAocGFyc2VkLnBhdGhuYW1lICE9PSBwYXRobmFtZSkge1xuICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWVcbiAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcbiAgICB9XG5cbiAgICAvLyBQcmVmZXRjaCBpcyBub3Qgc3VwcG9ydGVkIGluIGRldmVsb3BtZW50IG1vZGUgYmVjYXVzZSBpdCB3b3VsZCB0cmlnZ2VyIG9uLWRlbWFuZC1lbnRyaWVzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJvdXRlID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5wYWdlTG9hZGVyLnByZWZldGNoRGF0YShcbiAgICAgICAgdXJsLFxuICAgICAgICBhc1BhdGgsXG4gICAgICAgIHRoaXMubG9jYWxlLFxuICAgICAgICB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICksXG4gICAgICB0aGlzLnBhZ2VMb2FkZXJbb3B0aW9ucy5wcmlvcml0eSA/ICdsb2FkUGFnZScgOiAncHJlZmV0Y2gnXShyb3V0ZSksXG4gICAgXSlcbiAgfVxuXG4gIGFzeW5jIGZldGNoQ29tcG9uZW50KHJvdXRlOiBzdHJpbmcpOiBQcm9taXNlPEdvb2RQYWdlQ2FjaGU+IHtcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2VcbiAgICBjb25zdCBjYW5jZWwgPSAodGhpcy5jbGMgPSAoKSA9PiB7XG4gICAgICBjYW5jZWxsZWQgPSB0cnVlXG4gICAgfSlcblxuICAgIGNvbnN0IGNvbXBvbmVudFJlc3VsdCA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5sb2FkUGFnZShyb3V0ZSlcblxuICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoXG4gICAgICAgIGBBYm9ydCBmZXRjaGluZyBjb21wb25lbnQgZm9yIHJvdXRlOiBcIiR7cm91dGV9XCJgXG4gICAgICApXG4gICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cblxuICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICB0aGlzLmNsYyA9IG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcG9uZW50UmVzdWx0XG4gIH1cblxuICBfZ2V0RGF0YTxUPihmbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWVcbiAgICB9XG4gICAgdGhpcy5jbGMgPSBjYW5jZWxcbiAgICByZXR1cm4gZm4oKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgICB0aGlzLmNsYyA9IG51bGxcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICBjb25zdCBlcnI6IGFueSA9IG5ldyBFcnJvcignTG9hZGluZyBpbml0aWFsIHByb3BzIGNhbmNlbGxlZCcpXG4gICAgICAgIGVyci5jYW5jZWxsZWQgPSB0cnVlXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0pXG4gIH1cblxuICBfZ2V0U3RhdGljRGF0YShkYXRhSHJlZjogc3RyaW5nKTogUHJvbWlzZTxvYmplY3Q+IHtcbiAgICBjb25zdCB7IGhyZWY6IGNhY2hlS2V5IH0gPSBuZXcgVVJMKGRhdGFIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLnNkY1tjYWNoZUtleV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5zZGNbY2FjaGVLZXldKVxuICAgIH1cbiAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZiwgdGhpcy5pc1NzcikudGhlbigoZGF0YSkgPT4ge1xuICAgICAgdGhpcy5zZGNbY2FjaGVLZXldID0gZGF0YVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9KVxuICB9XG5cbiAgX2dldFNlcnZlckRhdGEoZGF0YUhyZWY6IHN0cmluZyk6IFByb21pc2U8b2JqZWN0PiB7XG4gICAgcmV0dXJuIGZldGNoTmV4dERhdGEoZGF0YUhyZWYsIHRoaXMuaXNTc3IpXG4gIH1cblxuICBnZXRJbml0aWFsUHJvcHMoXG4gICAgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlLFxuICAgIGN0eDogTmV4dFBhZ2VDb250ZXh0XG4gICk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgeyBDb21wb25lbnQ6IEFwcCB9ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddXG4gICAgY29uc3QgQXBwVHJlZSA9IHRoaXMuX3dyYXBBcHAoQXBwIGFzIEFwcENvbXBvbmVudClcbiAgICBjdHguQXBwVHJlZSA9IEFwcFRyZWVcbiAgICByZXR1cm4gbG9hZEdldEluaXRpYWxQcm9wczxBcHBDb250ZXh0VHlwZTxSb3V0ZXI+PihBcHAsIHtcbiAgICAgIEFwcFRyZWUsXG4gICAgICBDb21wb25lbnQsXG4gICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICBjdHgsXG4gICAgfSlcbiAgfVxuXG4gIGFib3J0Q29tcG9uZW50TG9hZChhczogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2xjKSB7XG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBidWlsZENhbmNlbGxhdGlvbkVycm9yKCksIGFzKVxuICAgICAgdGhpcy5jbGMoKVxuICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgbm90aWZ5KGRhdGE6IFByaXZhdGVSb3V0ZUluZm8pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5zdWIoZGF0YSwgdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudCBhcyBBcHBDb21wb25lbnQpXG4gIH1cbn1cbiIsIi8vIGVzY2FwZSBkZWxpbWl0ZXJzIHVzZWQgYnkgcGF0aC10by1yZWdleHBcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVzY2FwZVBhdGhEZWxpbWl0ZXJzKHNlZ21lbnQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzZWdtZW50LnJlcGxhY2UoL1svIz9dL2csIChjaGFyOiBzdHJpbmcpID0+IGVuY29kZVVSSUNvbXBvbmVudChjaGFyKSlcbn1cbiIsIi8vIEZvcm1hdCBmdW5jdGlvbiBtb2RpZmllZCBmcm9tIG5vZGVqc1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuXG5jb25zdCBzbGFzaGVkUHJvdG9jb2xzID0gL2h0dHBzP3xmdHB8Z29waGVyfGZpbGUvXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVcmwodXJsT2JqOiBVcmxPYmplY3QpIHtcbiAgbGV0IHsgYXV0aCwgaG9zdG5hbWUgfSA9IHVybE9ialxuICBsZXQgcHJvdG9jb2wgPSB1cmxPYmoucHJvdG9jb2wgfHwgJydcbiAgbGV0IHBhdGhuYW1lID0gdXJsT2JqLnBhdGhuYW1lIHx8ICcnXG4gIGxldCBoYXNoID0gdXJsT2JqLmhhc2ggfHwgJydcbiAgbGV0IHF1ZXJ5ID0gdXJsT2JqLnF1ZXJ5IHx8ICcnXG4gIGxldCBob3N0OiBzdHJpbmcgfCBmYWxzZSA9IGZhbHNlXG5cbiAgYXV0aCA9IGF1dGggPyBlbmNvZGVVUklDb21wb25lbnQoYXV0aCkucmVwbGFjZSgvJTNBL2ksICc6JykgKyAnQCcgOiAnJ1xuXG4gIGlmICh1cmxPYmouaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdXJsT2JqLmhvc3RcbiAgfSBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKH5ob3N0bmFtZS5pbmRleE9mKCc6JykgPyBgWyR7aG9zdG5hbWV9XWAgOiBob3N0bmFtZSlcbiAgICBpZiAodXJsT2JqLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdXJsT2JqLnBvcnRcbiAgICB9XG4gIH1cblxuICBpZiAocXVlcnkgJiYgdHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgIHF1ZXJ5ID0gU3RyaW5nKHF1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkgYXMgUGFyc2VkVXJsUXVlcnkpKVxuICB9XG5cbiAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgKHF1ZXJ5ICYmIGA/JHtxdWVyeX1gKSB8fCAnJ1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6J1xuXG4gIGlmIChcbiAgICB1cmxPYmouc2xhc2hlcyB8fFxuICAgICgoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbHMudGVzdChwcm90b2NvbCkpICYmIGhvc3QgIT09IGZhbHNlKVxuICApIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKVxuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZVswXSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lXG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJydcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2hbMF0gIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2hcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2hbMF0gIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoXG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGVuY29kZVVSSUNvbXBvbmVudClcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJylcblxuICByZXR1cm4gYCR7cHJvdG9jb2x9JHtob3N0fSR7cGF0aG5hbWV9JHtzZWFyY2h9JHtoYXNofWBcbn1cbiIsIi8vIElkZW50aWZ5IC9bcGFyYW1dLyBpbiByb3V0ZSBzdHJpbmdcbmNvbnN0IFRFU1RfUk9VVEUgPSAvXFwvXFxbW14vXSs/XFxdKD89XFwvfCQpL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEeW5hbWljUm91dGUocm91dGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gVEVTVF9ST1VURS50ZXN0KHJvdXRlKVxufVxuIiwiaW1wb3J0IHsgZ2V0TG9jYXRpb25PcmlnaW4gfSBmcm9tICcuLi8uLi91dGlscydcbmltcG9ydCB7IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkgfSBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuXG5jb25zdCBEVU1NWV9CQVNFID0gbmV3IFVSTChcbiAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAnaHR0cDovL24nIDogZ2V0TG9jYXRpb25PcmlnaW4oKVxuKVxuXG4vKipcbiAqIFBhcnNlcyBwYXRoLXJlbGF0aXZlIHVybHMgKGUuZy4gYC9oZWxsby93b3JsZD9mb289YmFyYCkuIElmIHVybCBpc24ndCBwYXRoLXJlbGF0aXZlXG4gKiAoZS5nLiBgLi9oZWxsb2ApIHRoZW4gYXQgbGVhc3QgYmFzZSBtdXN0IGJlLlxuICogQWJzb2x1dGUgdXJscyBhcmUgcmVqZWN0ZWQgd2l0aCBvbmUgZXhjZXB0aW9uLCBpbiB0aGUgYnJvd3NlciwgYWJzb2x1dGUgdXJscyB0aGF0IGFyZSBvblxuICogdGhlIGN1cnJlbnQgb3JpZ2luIHdpbGwgYmUgcGFyc2VkIGFzIHJlbGF0aXZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJlbGF0aXZlVXJsKHVybDogc3RyaW5nLCBiYXNlPzogc3RyaW5nKSB7XG4gIGNvbnN0IHJlc29sdmVkQmFzZSA9IGJhc2UgPyBuZXcgVVJMKGJhc2UsIERVTU1ZX0JBU0UpIDogRFVNTVlfQkFTRVxuICBjb25zdCB7XG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoUGFyYW1zLFxuICAgIHNlYXJjaCxcbiAgICBoYXNoLFxuICAgIGhyZWYsXG4gICAgb3JpZ2luLFxuICAgIHByb3RvY29sLFxuICB9ID0gbmV3IFVSTCh1cmwsIHJlc29sdmVkQmFzZSlcbiAgaWYgKFxuICAgIG9yaWdpbiAhPT0gRFVNTVlfQkFTRS5vcmlnaW4gfHxcbiAgICAocHJvdG9jb2wgIT09ICdodHRwOicgJiYgcHJvdG9jb2wgIT09ICdodHRwczonKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudDogaW52YWxpZCByZWxhdGl2ZSBVUkwnKVxuICB9XG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgcXVlcnk6IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoc2VhcmNoUGFyYW1zKSxcbiAgICBzZWFyY2gsXG4gICAgaGFzaCxcbiAgICBocmVmOiBocmVmLnNsaWNlKERVTU1ZX0JBU0Uub3JpZ2luLmxlbmd0aCksXG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIHBhdGhUb1JlZ2V4cCBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC10by1yZWdleHAnXG5cbmV4cG9ydCB7IHBhdGhUb1JlZ2V4cCB9XG5cbmV4cG9ydCBjb25zdCBtYXRjaGVyT3B0aW9uczogcGF0aFRvUmVnZXhwLlRva2Vuc1RvUmVnZXhwT3B0aW9ucyAmXG4gIHBhdGhUb1JlZ2V4cC5QYXJzZU9wdGlvbnMgPSB7XG4gIHNlbnNpdGl2ZTogZmFsc2UsXG4gIGRlbGltaXRlcjogJy8nLFxufVxuXG5leHBvcnQgY29uc3QgY3VzdG9tUm91dGVNYXRjaGVyT3B0aW9uczogcGF0aFRvUmVnZXhwLlRva2Vuc1RvUmVnZXhwT3B0aW9ucyAmXG4gIHBhdGhUb1JlZ2V4cC5QYXJzZU9wdGlvbnMgPSB7XG4gIC4uLm1hdGNoZXJPcHRpb25zLFxuICBzdHJpY3Q6IHRydWUsXG59XG5cbmV4cG9ydCBkZWZhdWx0IChjdXN0b21Sb3V0ZSA9IGZhbHNlKSA9PiB7XG4gIHJldHVybiAocGF0aDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qga2V5czogcGF0aFRvUmVnZXhwLktleVtdID0gW11cbiAgICBjb25zdCBtYXRjaGVyUmVnZXggPSBwYXRoVG9SZWdleHAucGF0aFRvUmVnZXhwKFxuICAgICAgcGF0aCxcbiAgICAgIGtleXMsXG4gICAgICBjdXN0b21Sb3V0ZSA/IGN1c3RvbVJvdXRlTWF0Y2hlck9wdGlvbnMgOiBtYXRjaGVyT3B0aW9uc1xuICAgIClcbiAgICBjb25zdCBtYXRjaGVyID0gcGF0aFRvUmVnZXhwLnJlZ2V4cFRvRnVuY3Rpb24obWF0Y2hlclJlZ2V4LCBrZXlzKVxuXG4gICAgcmV0dXJuIChwYXRobmFtZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCwgcGFyYW1zPzogYW55KSA9PiB7XG4gICAgICBjb25zdCByZXMgPSBwYXRobmFtZSA9PSBudWxsID8gZmFsc2UgOiBtYXRjaGVyKHBhdGhuYW1lKVxuICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmIChjdXN0b21Sb3V0ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgLy8gdW5uYW1lZCBwYXJhbXMgc2hvdWxkIGJlIHJlbW92ZWQgYXMgdGhleVxuICAgICAgICAgIC8vIGFyZSBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIHRoZSBkZXN0aW5hdGlvblxuICAgICAgICAgIGlmICh0eXBlb2Yga2V5Lm5hbWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBkZWxldGUgKHJlcy5wYXJhbXMgYXMgYW55KVtrZXkubmFtZV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgLi4ucGFyYW1zLCAuLi5yZXMucGFyYW1zIH1cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IH0gZnJvbSAnLi9xdWVyeXN0cmluZydcbmltcG9ydCB7IHBhcnNlUmVsYXRpdmVVcmwgfSBmcm9tICcuL3BhcnNlLXJlbGF0aXZlLXVybCdcbmltcG9ydCAqIGFzIHBhdGhUb1JlZ2V4cCBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC10by1yZWdleHAnXG5cbnR5cGUgUGFyYW1zID0geyBbcGFyYW06IHN0cmluZ106IGFueSB9XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHByZXBhcmVEZXN0aW5hdGlvbihcbiAgZGVzdGluYXRpb246IHN0cmluZyxcbiAgcGFyYW1zOiBQYXJhbXMsXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgYXBwZW5kUGFyYW1zVG9RdWVyeTogYm9vbGVhbixcbiAgYmFzZVBhdGg6IHN0cmluZ1xuKSB7XG4gIGxldCBwYXJzZWREZXN0aW5hdGlvbjoge1xuICAgIHF1ZXJ5PzogUGFyc2VkVXJsUXVlcnlcbiAgICBwcm90b2NvbD86IHN0cmluZ1xuICAgIGhvc3RuYW1lPzogc3RyaW5nXG4gICAgcG9ydD86IHN0cmluZ1xuICB9ICYgUmV0dXJuVHlwZTx0eXBlb2YgcGFyc2VSZWxhdGl2ZVVybD4gPSB7fSBhcyBhbnlcblxuICBpZiAoZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgcGFyc2VkRGVzdGluYXRpb24gPSBwYXJzZVJlbGF0aXZlVXJsKGRlc3RpbmF0aW9uKVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgc2VhcmNoUGFyYW1zLFxuICAgICAgaGFzaCxcbiAgICAgIGhvc3RuYW1lLFxuICAgICAgcG9ydCxcbiAgICAgIHByb3RvY29sLFxuICAgICAgc2VhcmNoLFxuICAgICAgaHJlZixcbiAgICB9ID0gbmV3IFVSTChkZXN0aW5hdGlvbilcblxuICAgIHBhcnNlZERlc3RpbmF0aW9uID0ge1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBxdWVyeTogc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShzZWFyY2hQYXJhbXMpLFxuICAgICAgaGFzaCxcbiAgICAgIHByb3RvY29sLFxuICAgICAgaG9zdG5hbWUsXG4gICAgICBwb3J0LFxuICAgICAgc2VhcmNoLFxuICAgICAgaHJlZixcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZXN0UXVlcnkgPSBwYXJzZWREZXN0aW5hdGlvbi5xdWVyeVxuICBjb25zdCBkZXN0UGF0aCA9IGAke3BhcnNlZERlc3RpbmF0aW9uLnBhdGhuYW1lIX0ke1xuICAgIHBhcnNlZERlc3RpbmF0aW9uLmhhc2ggfHwgJydcbiAgfWBcbiAgY29uc3QgZGVzdFBhdGhQYXJhbUtleXM6IHBhdGhUb1JlZ2V4cC5LZXlbXSA9IFtdXG4gIHBhdGhUb1JlZ2V4cC5wYXRoVG9SZWdleHAoZGVzdFBhdGgsIGRlc3RQYXRoUGFyYW1LZXlzKVxuXG4gIGNvbnN0IGRlc3RQYXRoUGFyYW1zID0gZGVzdFBhdGhQYXJhbUtleXMubWFwKChrZXkpID0+IGtleS5uYW1lKVxuXG4gIGxldCBkZXN0aW5hdGlvbkNvbXBpbGVyID0gcGF0aFRvUmVnZXhwLmNvbXBpbGUoXG4gICAgZGVzdFBhdGgsXG4gICAgLy8gd2UgZG9uJ3QgdmFsaWRhdGUgd2hpbGUgY29tcGlsaW5nIHRoZSBkZXN0aW5hdGlvbiBzaW5jZSB3ZSBzaG91bGRcbiAgICAvLyBoYXZlIGFscmVhZHkgdmFsaWRhdGVkIGJlZm9yZSB3ZSBnb3QgdG8gdGhpcyBwb2ludCBhbmQgdmFsaWRhdGluZ1xuICAgIC8vIGJyZWFrcyBjb21waWxpbmcgZGVzdGluYXRpb25zIHdpdGggbmFtZWQgcGF0dGVybiBwYXJhbXMgZnJvbSB0aGUgc291cmNlXG4gICAgLy8gZS5nLiAvc29tZXRoaW5nOmhlbGxvKC4qKSAtPiAvYW5vdGhlci86aGVsbG8gaXMgYnJva2VuIHdpdGggdmFsaWRhdGlvblxuICAgIC8vIHNpbmNlIGNvbXBpbGUgdmFsaWRhdGlvbiBpcyBtZWFudCBmb3IgcmV2ZXJzaW5nIGFuZCBub3QgZm9yIGluc2VydGluZ1xuICAgIC8vIHBhcmFtcyBmcm9tIGEgc2VwYXJhdGUgcGF0aC1yZWdleCBpbnRvIGFub3RoZXJcbiAgICB7IHZhbGlkYXRlOiBmYWxzZSB9XG4gIClcbiAgbGV0IG5ld1VybFxuXG4gIC8vIHVwZGF0ZSBhbnkgcGFyYW1zIGluIHF1ZXJ5IHZhbHVlc1xuICBmb3IgKGNvbnN0IFtrZXksIHN0ck9yQXJyYXldIG9mIE9iamVjdC5lbnRyaWVzKGRlc3RRdWVyeSkpIHtcbiAgICBsZXQgdmFsdWUgPSBBcnJheS5pc0FycmF5KHN0ck9yQXJyYXkpID8gc3RyT3JBcnJheVswXSA6IHN0ck9yQXJyYXlcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIC8vIHRoZSB2YWx1ZSBuZWVkcyB0byBzdGFydCB3aXRoIGEgZm9yd2FyZC1zbGFzaCB0byBiZSBjb21waWxlZFxuICAgICAgLy8gY29ycmVjdGx5XG4gICAgICB2YWx1ZSA9IGAvJHt2YWx1ZX1gXG4gICAgICBjb25zdCBxdWVyeUNvbXBpbGVyID0gcGF0aFRvUmVnZXhwLmNvbXBpbGUodmFsdWUsIHsgdmFsaWRhdGU6IGZhbHNlIH0pXG4gICAgICB2YWx1ZSA9IHF1ZXJ5Q29tcGlsZXIocGFyYW1zKS5zdWJzdHIoMSlcbiAgICB9XG4gICAgZGVzdFF1ZXJ5W2tleV0gPSB2YWx1ZVxuICB9XG5cbiAgLy8gYWRkIHBhdGggcGFyYW1zIHRvIHF1ZXJ5IGlmIGl0J3Mgbm90IGEgcmVkaXJlY3QgYW5kIG5vdFxuICAvLyBhbHJlYWR5IGRlZmluZWQgaW4gZGVzdGluYXRpb24gcXVlcnkgb3IgcGF0aFxuICBjb25zdCBwYXJhbUtleXMgPSBPYmplY3Qua2V5cyhwYXJhbXMpXG5cbiAgaWYgKFxuICAgIGFwcGVuZFBhcmFtc1RvUXVlcnkgJiZcbiAgICAhcGFyYW1LZXlzLnNvbWUoKGtleSkgPT4gZGVzdFBhdGhQYXJhbXMuaW5jbHVkZXMoa2V5KSlcbiAgKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgcGFyYW1LZXlzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gZGVzdFF1ZXJ5KSkge1xuICAgICAgICBkZXN0UXVlcnlba2V5XSA9IHBhcmFtc1trZXldXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc2hvdWxkQWRkQmFzZVBhdGggPSBkZXN0aW5hdGlvbi5zdGFydHNXaXRoKCcvJykgJiYgYmFzZVBhdGhcblxuICB0cnkge1xuICAgIG5ld1VybCA9IGAke3Nob3VsZEFkZEJhc2VQYXRoID8gYmFzZVBhdGggOiAnJ30ke2Rlc3RpbmF0aW9uQ29tcGlsZXIoXG4gICAgICBwYXJhbXNcbiAgICApfWBcblxuICAgIGNvbnN0IFtwYXRobmFtZSwgaGFzaF0gPSBuZXdVcmwuc3BsaXQoJyMnKVxuICAgIHBhcnNlZERlc3RpbmF0aW9uLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICBwYXJzZWREZXN0aW5hdGlvbi5oYXNoID0gYCR7aGFzaCA/ICcjJyA6ICcnfSR7aGFzaCB8fCAnJ31gXG4gICAgZGVsZXRlIHBhcnNlZERlc3RpbmF0aW9uLnNlYXJjaFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLm1lc3NhZ2UubWF0Y2goL0V4cGVjdGVkIC4qPyB0byBub3QgcmVwZWF0LCBidXQgZ290IGFuIGFycmF5LykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRvIHVzZSBhIG11bHRpLW1hdGNoIGluIHRoZSBkZXN0aW5hdGlvbiB5b3UgbXVzdCBhZGQgXFxgKlxcYCBhdCB0aGUgZW5kIG9mIHRoZSBwYXJhbSBuYW1lIHRvIHNpZ25pZnkgaXQgc2hvdWxkIHJlcGVhdC4gaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvaW52YWxpZC1tdWx0aS1tYXRjaGBcbiAgICAgIClcbiAgICB9XG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICAvLyBRdWVyeSBtZXJnZSBvcmRlciBsb3dlc3QgcHJpb3JpdHkgdG8gaGlnaGVzdFxuICAvLyAxLiBpbml0aWFsIFVSTCBxdWVyeSB2YWx1ZXNcbiAgLy8gMi4gcGF0aCBzZWdtZW50IHZhbHVlc1xuICAvLyAzLiBkZXN0aW5hdGlvbiBzcGVjaWZpZWQgcXVlcnkgdmFsdWVzXG4gIHBhcnNlZERlc3RpbmF0aW9uLnF1ZXJ5ID0ge1xuICAgIC4uLnF1ZXJ5LFxuICAgIC4uLnBhcnNlZERlc3RpbmF0aW9uLnF1ZXJ5LFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuZXdVcmwsXG4gICAgcGFyc2VkRGVzdGluYXRpb24sXG4gIH1cbn1cbiIsImltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5cbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KFxuICBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc1xuKTogUGFyc2VkVXJsUXVlcnkge1xuICBjb25zdCBxdWVyeTogUGFyc2VkVXJsUXVlcnkgPSB7fVxuICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmICh0eXBlb2YgcXVlcnlba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHF1ZXJ5W2tleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkge1xuICAgICAgOyhxdWVyeVtrZXldIGFzIHN0cmluZ1tdKS5wdXNoKHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeVtrZXldID0gW3F1ZXJ5W2tleV0gYXMgc3RyaW5nLCB2YWx1ZV1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBxdWVyeVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHBhcmFtOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoXG4gICAgdHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJyB8fFxuICAgICh0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInICYmICFpc05hTihwYXJhbSkpIHx8XG4gICAgdHlwZW9mIHBhcmFtID09PSAnYm9vbGVhbidcbiAgKSB7XG4gICAgcmV0dXJuIFN0cmluZyhwYXJhbSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJydcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhcbiAgdXJsUXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4pOiBVUkxTZWFyY2hQYXJhbXMge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKClcbiAgT2JqZWN0LmVudHJpZXModXJsUXVlcnkpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSkgPT4gcmVzdWx0LmFwcGVuZChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0oaXRlbSkpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbSh2YWx1ZSkpXG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24oXG4gIHRhcmdldDogVVJMU2VhcmNoUGFyYW1zLFxuICAuLi5zZWFyY2hQYXJhbXNMaXN0OiBVUkxTZWFyY2hQYXJhbXNbXVxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgc2VhcmNoUGFyYW1zTGlzdC5mb3JFYWNoKChzZWFyY2hQYXJhbXMpID0+IHtcbiAgICBBcnJheS5mcm9tKHNlYXJjaFBhcmFtcy5rZXlzKCkpLmZvckVhY2goKGtleSkgPT4gdGFyZ2V0LmRlbGV0ZShrZXkpKVxuICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB0YXJnZXQuYXBwZW5kKGtleSwgdmFsdWUpKVxuICB9KVxuICByZXR1cm4gdGFyZ2V0XG59XG4iLCJpbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHBhdGhNYXRjaCBmcm9tICcuL3BhdGgtbWF0Y2gnXG5pbXBvcnQgcHJlcGFyZURlc3RpbmF0aW9uIGZyb20gJy4vcHJlcGFyZS1kZXN0aW5hdGlvbidcbmltcG9ydCB7IFJld3JpdGUgfSBmcm9tICcuLi8uLi8uLi8uLi9saWIvbG9hZC1jdXN0b20tcm91dGVzJ1xuaW1wb3J0IHsgcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2ggfSBmcm9tICcuLi8uLi8uLi8uLi9jbGllbnQvbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoJ1xuXG5jb25zdCBjdXN0b21Sb3V0ZU1hdGNoZXIgPSBwYXRoTWF0Y2godHJ1ZSlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVzb2x2ZVJld3JpdGVzKFxuICBhc1BhdGg6IHN0cmluZyxcbiAgcGFnZXM6IHN0cmluZ1tdLFxuICBiYXNlUGF0aDogc3RyaW5nLFxuICByZXdyaXRlczogUmV3cml0ZVtdLFxuICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gIHJlc29sdmVIcmVmOiAocGF0aDogc3RyaW5nKSA9PiBzdHJpbmdcbikge1xuICBpZiAoIXBhZ2VzLmluY2x1ZGVzKGFzUGF0aCkpIHtcbiAgICBmb3IgKGNvbnN0IHJld3JpdGUgb2YgcmV3cml0ZXMpIHtcbiAgICAgIGNvbnN0IG1hdGNoZXIgPSBjdXN0b21Sb3V0ZU1hdGNoZXIocmV3cml0ZS5zb3VyY2UpXG4gICAgICBjb25zdCBwYXJhbXMgPSBtYXRjaGVyKGFzUGF0aClcblxuICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICBpZiAoIXJld3JpdGUuZGVzdGluYXRpb24pIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIGEgcHJveGllZCByZXdyaXRlIHdoaWNoIGlzbid0IGhhbmRsZWQgb24gdGhlIGNsaWVudFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVzdFJlcyA9IHByZXBhcmVEZXN0aW5hdGlvbihcbiAgICAgICAgICByZXdyaXRlLmRlc3RpbmF0aW9uLFxuICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIHJld3JpdGUuYmFzZVBhdGggPT09IGZhbHNlID8gJycgOiBiYXNlUGF0aFxuICAgICAgICApXG4gICAgICAgIGFzUGF0aCA9IGRlc3RSZXMucGFyc2VkRGVzdGluYXRpb24ucGF0aG5hbWUhXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIGRlc3RSZXMucGFyc2VkRGVzdGluYXRpb24ucXVlcnkpXG5cbiAgICAgICAgaWYgKHBhZ2VzLmluY2x1ZGVzKHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKGFzUGF0aCkpKSB7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgd2Ugbm93IG1hdGNoIGEgcGFnZSBhcyB0aGlzIG1lYW5zIHdlIGFyZSBkb25lXG4gICAgICAgICAgLy8gcmVzb2x2aW5nIHRoZSByZXdyaXRlc1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBtYXRjaCBhIGR5bmFtaWMtcm91dGUsIGlmIHNvIHdlIGJyZWFrIHRoZSByZXdyaXRlcyBjaGFpblxuICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSByZXNvbHZlSHJlZihhc1BhdGgpXG5cbiAgICAgICAgaWYgKHJlc29sdmVkSHJlZiAhPT0gYXNQYXRoICYmIHBhZ2VzLmluY2x1ZGVzKHJlc29sdmVkSHJlZikpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhc1BhdGhcbn1cbiIsImltcG9ydCB7IGdldFJvdXRlUmVnZXggfSBmcm9tICcuL3JvdXRlLXJlZ2V4J1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um91dGVNYXRjaGVyKHJvdXRlUmVnZXg6IFJldHVyblR5cGU8dHlwZW9mIGdldFJvdXRlUmVnZXg+KSB7XG4gIGNvbnN0IHsgcmUsIGdyb3VwcyB9ID0gcm91dGVSZWdleFxuICByZXR1cm4gKHBhdGhuYW1lOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgY29uc3Qgcm91dGVNYXRjaCA9IHJlLmV4ZWMocGF0aG5hbWUhKVxuICAgIGlmICghcm91dGVNYXRjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgZGVjb2RlID0gKHBhcmFtOiBzdHJpbmcpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pXG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIGNvbnN0IGVycjogRXJyb3IgJiB7IGNvZGU/OiBzdHJpbmcgfSA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnZmFpbGVkIHRvIGRlY29kZSBwYXJhbSdcbiAgICAgICAgKVxuICAgICAgICBlcnIuY29kZSA9ICdERUNPREVfRkFJTEVEJ1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFyYW1zOiB7IFtwYXJhbU5hbWU6IHN0cmluZ106IHN0cmluZyB8IHN0cmluZ1tdIH0gPSB7fVxuXG4gICAgT2JqZWN0LmtleXMoZ3JvdXBzKS5mb3JFYWNoKChzbHVnTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBnID0gZ3JvdXBzW3NsdWdOYW1lXVxuICAgICAgY29uc3QgbSA9IHJvdXRlTWF0Y2hbZy5wb3NdXG4gICAgICBpZiAobSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtc1tzbHVnTmFtZV0gPSB+bS5pbmRleE9mKCcvJylcbiAgICAgICAgICA/IG0uc3BsaXQoJy8nKS5tYXAoKGVudHJ5KSA9PiBkZWNvZGUoZW50cnkpKVxuICAgICAgICAgIDogZy5yZXBlYXRcbiAgICAgICAgICA/IFtkZWNvZGUobSldXG4gICAgICAgICAgOiBkZWNvZGUobSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBwYXJhbXNcbiAgfVxufVxuIiwiaW50ZXJmYWNlIEdyb3VwIHtcbiAgcG9zOiBudW1iZXJcbiAgcmVwZWF0OiBib29sZWFuXG4gIG9wdGlvbmFsOiBib29sZWFuXG59XG5cbi8vIHRoaXMgaXNuJ3QgaW1wb3J0aW5nIHRoZSBlc2NhcGUtc3RyaW5nLXJlZ2V4IG1vZHVsZVxuLy8gdG8gcmVkdWNlIGJ5dGVzXG5mdW5jdGlvbiBlc2NhcGVSZWdleChzdHI6IHN0cmluZykge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrKj8uLV0vZywgJ1xcXFwkJicpXG59XG5cbmZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyKHBhcmFtOiBzdHJpbmcpIHtcbiAgY29uc3Qgb3B0aW9uYWwgPSBwYXJhbS5zdGFydHNXaXRoKCdbJykgJiYgcGFyYW0uZW5kc1dpdGgoJ10nKVxuICBpZiAob3B0aW9uYWwpIHtcbiAgICBwYXJhbSA9IHBhcmFtLnNsaWNlKDEsIC0xKVxuICB9XG4gIGNvbnN0IHJlcGVhdCA9IHBhcmFtLnN0YXJ0c1dpdGgoJy4uLicpXG4gIGlmIChyZXBlYXQpIHtcbiAgICBwYXJhbSA9IHBhcmFtLnNsaWNlKDMpXG4gIH1cbiAgcmV0dXJuIHsga2V5OiBwYXJhbSwgcmVwZWF0LCBvcHRpb25hbCB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3V0ZVJlZ2V4KFxuICBub3JtYWxpemVkUm91dGU6IHN0cmluZ1xuKToge1xuICByZTogUmVnRXhwXG4gIG5hbWVkUmVnZXg/OiBzdHJpbmdcbiAgcm91dGVLZXlzPzogeyBbbmFtZWQ6IHN0cmluZ106IHN0cmluZyB9XG4gIGdyb3VwczogeyBbZ3JvdXBOYW1lOiBzdHJpbmddOiBHcm91cCB9XG59IHtcbiAgY29uc3Qgc2VnbWVudHMgPSAobm9ybWFsaXplZFJvdXRlLnJlcGxhY2UoL1xcLyQvLCAnJykgfHwgJy8nKVxuICAgIC5zbGljZSgxKVxuICAgIC5zcGxpdCgnLycpXG5cbiAgY29uc3QgZ3JvdXBzOiB7IFtncm91cE5hbWU6IHN0cmluZ106IEdyb3VwIH0gPSB7fVxuICBsZXQgZ3JvdXBJbmRleCA9IDFcbiAgY29uc3QgcGFyYW1ldGVyaXplZFJvdXRlID0gc2VnbWVudHNcbiAgICAubWFwKChzZWdtZW50KSA9PiB7XG4gICAgICBpZiAoc2VnbWVudC5zdGFydHNXaXRoKCdbJykgJiYgc2VnbWVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50LnNsaWNlKDEsIC0xKSlcbiAgICAgICAgZ3JvdXBzW2tleV0gPSB7IHBvczogZ3JvdXBJbmRleCsrLCByZXBlYXQsIG9wdGlvbmFsIH1cbiAgICAgICAgcmV0dXJuIHJlcGVhdCA/IChvcHRpb25hbCA/ICcoPzovKC4rPykpPycgOiAnLyguKz8pJykgOiAnLyhbXi9dKz8pJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAvJHtlc2NhcGVSZWdleChzZWdtZW50KX1gXG4gICAgICB9XG4gICAgfSlcbiAgICAuam9pbignJylcblxuICAvLyBkZWFkIGNvZGUgZWxpbWluYXRlIGZvciBicm93c2VyIHNpbmNlIGl0J3Mgb25seSBuZWVkZWRcbiAgLy8gd2hpbGUgZ2VuZXJhdGluZyByb3V0ZXMtbWFuaWZlc3RcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbGV0IHJvdXRlS2V5Q2hhckNvZGUgPSA5N1xuICAgIGxldCByb3V0ZUtleUNoYXJMZW5ndGggPSAxXG5cbiAgICAvLyBidWlsZHMgYSBtaW5pbWFsIHJvdXRlS2V5IHVzaW5nIG9ubHkgYS16IGFuZCBtaW5pbWFsIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgY29uc3QgZ2V0U2FmZVJvdXRlS2V5ID0gKCkgPT4ge1xuICAgICAgbGV0IHJvdXRlS2V5ID0gJydcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZUtleUNoYXJMZW5ndGg7IGkrKykge1xuICAgICAgICByb3V0ZUtleSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJvdXRlS2V5Q2hhckNvZGUpXG4gICAgICAgIHJvdXRlS2V5Q2hhckNvZGUrK1xuXG4gICAgICAgIGlmIChyb3V0ZUtleUNoYXJDb2RlID4gMTIyKSB7XG4gICAgICAgICAgcm91dGVLZXlDaGFyTGVuZ3RoKytcbiAgICAgICAgICByb3V0ZUtleUNoYXJDb2RlID0gOTdcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJvdXRlS2V5XG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGVLZXlzOiB7IFtuYW1lZDogc3RyaW5nXTogc3RyaW5nIH0gPSB7fVxuXG4gICAgbGV0IG5hbWVkUGFyYW1ldGVyaXplZFJvdXRlID0gc2VnbWVudHNcbiAgICAgIC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICAgICAgaWYgKHNlZ21lbnQuc3RhcnRzV2l0aCgnWycpICYmIHNlZ21lbnQuZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50LnNsaWNlKDEsIC0xKSlcbiAgICAgICAgICAvLyByZXBsYWNlIGFueSBub24td29yZCBjaGFyYWN0ZXJzIHNpbmNlIHRoZXkgY2FuIGJyZWFrXG4gICAgICAgICAgLy8gdGhlIG5hbWVkIHJlZ2V4XG4gICAgICAgICAgbGV0IGNsZWFuZWRLZXkgPSBrZXkucmVwbGFjZSgvXFxXL2csICcnKVxuICAgICAgICAgIGxldCBpbnZhbGlkS2V5ID0gZmFsc2VcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBrZXkgaXMgc3RpbGwgaW52YWxpZCBhbmQgZmFsbGJhY2sgdG8gdXNpbmcgYSBrbm93blxuICAgICAgICAgIC8vIHNhZmUga2V5XG4gICAgICAgICAgaWYgKGNsZWFuZWRLZXkubGVuZ3RoID09PSAwIHx8IGNsZWFuZWRLZXkubGVuZ3RoID4gMzApIHtcbiAgICAgICAgICAgIGludmFsaWRLZXkgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VJbnQoY2xlYW5lZEtleS5zdWJzdHIoMCwgMSkpKSkge1xuICAgICAgICAgICAgaW52YWxpZEtleSA9IHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW52YWxpZEtleSkge1xuICAgICAgICAgICAgY2xlYW5lZEtleSA9IGdldFNhZmVSb3V0ZUtleSgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm91dGVLZXlzW2NsZWFuZWRLZXldID0ga2V5XG4gICAgICAgICAgcmV0dXJuIHJlcGVhdFxuICAgICAgICAgICAgPyBvcHRpb25hbFxuICAgICAgICAgICAgICA/IGAoPzovKD88JHtjbGVhbmVkS2V5fT4uKz8pKT9gXG4gICAgICAgICAgICAgIDogYC8oPzwke2NsZWFuZWRLZXl9Pi4rPylgXG4gICAgICAgICAgICA6IGAvKD88JHtjbGVhbmVkS2V5fT5bXi9dKz8pYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgLyR7ZXNjYXBlUmVnZXgoc2VnbWVudCl9YFxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmpvaW4oJycpXG5cbiAgICByZXR1cm4ge1xuICAgICAgcmU6IG5ldyBSZWdFeHAoYF4ke3BhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYCksXG4gICAgICBncm91cHMsXG4gICAgICByb3V0ZUtleXMsXG4gICAgICBuYW1lZFJlZ2V4OiBgXiR7bmFtZWRQYXJhbWV0ZXJpemVkUm91dGV9KD86Lyk/JGAsXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZTogbmV3IFJlZ0V4cChgXiR7cGFyYW1ldGVyaXplZFJvdXRlfSg/Oi8pPyRgKSxcbiAgICBncm91cHMsXG4gIH1cbn1cbiIsImltcG9ydCB7IEluY29taW5nTWVzc2FnZSwgU2VydmVyUmVzcG9uc2UgfSBmcm9tICdodHRwJ1xuaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7IGZvcm1hdFVybCB9IGZyb20gJy4vcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwnXG5pbXBvcnQgeyBNYW5pZmVzdEl0ZW0gfSBmcm9tICcuLi9zZXJ2ZXIvbG9hZC1jb21wb25lbnRzJ1xuaW1wb3J0IHsgTmV4dFJvdXRlciB9IGZyb20gJy4vcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IEVudiB9IGZyb20gJ0BuZXh0L2VudidcbmltcG9ydCB7IEJ1aWxkTWFuaWZlc3QgfSBmcm9tICcuLi9zZXJ2ZXIvZ2V0LXBhZ2UtZmlsZXMnXG5cbi8qKlxuICogVHlwZXMgdXNlZCBieSBib3RoIG5leHQgYW5kIG5leHQtc2VydmVyXG4gKi9cblxuZXhwb3J0IHR5cGUgTmV4dENvbXBvbmVudFR5cGU8XG4gIEMgZXh0ZW5kcyBCYXNlQ29udGV4dCA9IE5leHRQYWdlQ29udGV4dCxcbiAgSVAgPSB7fSxcbiAgUCA9IHt9XG4+ID0gQ29tcG9uZW50VHlwZTxQPiAmIHtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGluaXRpYWwgcGFnZSBsb2FkIGRhdGEgcG9wdWxhdGlvbi4gRGF0YSByZXR1cm5lZCBmcm9tIGBnZXRJbml0aWFsUHJvcHNgIGlzIHNlcmlhbGl6ZWQgd2hlbiBzZXJ2ZXIgcmVuZGVyZWQuXG4gICAqIE1ha2Ugc3VyZSB0byByZXR1cm4gcGxhaW4gYE9iamVjdGAgd2l0aG91dCB1c2luZyBgRGF0ZWAsIGBNYXBgLCBgU2V0YC5cbiAgICogQHBhcmFtIGN0eCBDb250ZXh0IG9mIGBwYWdlYFxuICAgKi9cbiAgZ2V0SW5pdGlhbFByb3BzPyhjb250ZXh0OiBDKTogSVAgfCBQcm9taXNlPElQPlxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFR5cGUgPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgRG9jdW1lbnRDb250ZXh0LFxuICBEb2N1bWVudEluaXRpYWxQcm9wcyxcbiAgRG9jdW1lbnRQcm9wc1xuPiAmIHtcbiAgcmVuZGVyRG9jdW1lbnQoXG4gICAgRG9jdW1lbnQ6IERvY3VtZW50VHlwZSxcbiAgICBwcm9wczogRG9jdW1lbnRQcm9wc1xuICApOiBSZWFjdC5SZWFjdEVsZW1lbnRcbn1cblxuZXhwb3J0IHR5cGUgQXBwVHlwZSA9IE5leHRDb21wb25lbnRUeXBlPFxuICBBcHBDb250ZXh0VHlwZSxcbiAgQXBwSW5pdGlhbFByb3BzLFxuICBBcHBQcm9wc1R5cGVcbj5cblxuZXhwb3J0IHR5cGUgQXBwVHJlZVR5cGUgPSBDb21wb25lbnRUeXBlPFxuICBBcHBJbml0aWFsUHJvcHMgJiB7IFtuYW1lOiBzdHJpbmddOiBhbnkgfVxuPlxuXG4vKipcbiAqIFdlYiB2aXRhbHMgcHJvdmlkZWQgdG8gX2FwcC5yZXBvcnRXZWJWaXRhbHMgYnkgQ29yZSBXZWIgVml0YWxzIHBsdWdpbiBkZXZlbG9wZWQgYnkgR29vZ2xlIENocm9tZSB0ZWFtLlxuICogaHR0cHM6Ly9uZXh0anMub3JnL2Jsb2cvbmV4dC05LTQjaW50ZWdyYXRlZC13ZWItdml0YWxzLXJlcG9ydGluZ1xuICovXG5leHBvcnQgdHlwZSBOZXh0V2ViVml0YWxzTWV0cmljID0ge1xuICBpZDogc3RyaW5nXG4gIGxhYmVsOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4gIHZhbHVlOiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgRW5oYW5jZXI8Qz4gPSAoQ29tcG9uZW50OiBDKSA9PiBDXG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudHNFbmhhbmNlciA9XG4gIHwge1xuICAgICAgZW5oYW5jZUFwcD86IEVuaGFuY2VyPEFwcFR5cGU+XG4gICAgICBlbmhhbmNlQ29tcG9uZW50PzogRW5oYW5jZXI8TmV4dENvbXBvbmVudFR5cGU+XG4gICAgfVxuICB8IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuXG5leHBvcnQgdHlwZSBSZW5kZXJQYWdlUmVzdWx0ID0ge1xuICBodG1sOiBzdHJpbmdcbiAgaGVhZD86IEFycmF5PEpTWC5FbGVtZW50IHwgbnVsbD5cbn1cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZSA9IChcbiAgb3B0aW9ucz86IENvbXBvbmVudHNFbmhhbmNlclxuKSA9PiBSZW5kZXJQYWdlUmVzdWx0IHwgUHJvbWlzZTxSZW5kZXJQYWdlUmVzdWx0PlxuXG5leHBvcnQgdHlwZSBCYXNlQ29udGV4dCA9IHtcbiAgcmVzPzogU2VydmVyUmVzcG9uc2VcbiAgW2s6IHN0cmluZ106IGFueVxufVxuXG5leHBvcnQgdHlwZSBIZWFkRW50cnkgPSBbc3RyaW5nLCB7IFtrZXk6IHN0cmluZ106IGFueSB9XVxuXG5leHBvcnQgdHlwZSBORVhUX0RBVEEgPSB7XG4gIHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIHBhZ2U6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYnVpbGRJZDogc3RyaW5nXG4gIGFzc2V0UHJlZml4Pzogc3RyaW5nXG4gIHJ1bnRpbWVDb25maWc/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gIG5leHRFeHBvcnQ/OiBib29sZWFuXG4gIGF1dG9FeHBvcnQ/OiBib29sZWFuXG4gIGlzRmFsbGJhY2s/OiBib29sZWFuXG4gIGR5bmFtaWNJZHM/OiBzdHJpbmdbXVxuICBlcnI/OiBFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9XG4gIGdzcD86IGJvb2xlYW5cbiAgZ3NzcD86IGJvb2xlYW5cbiAgY3VzdG9tU2VydmVyPzogYm9vbGVhblxuICBnaXA/OiBib29sZWFuXG4gIGFwcEdpcD86IGJvb2xlYW5cbiAgaGVhZDogSGVhZEVudHJ5W11cbiAgbG9jYWxlPzogc3RyaW5nXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG59XG5cbi8qKlxuICogYE5leHRgIGNvbnRleHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0UGFnZUNvbnRleHQge1xuICAvKipcbiAgICogRXJyb3Igb2JqZWN0IGlmIGVuY291bnRlcmVkIGR1cmluZyByZW5kZXJpbmdcbiAgICovXG4gIGVycj86IChFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9KSB8IG51bGxcbiAgLyoqXG4gICAqIGBIVFRQYCByZXF1ZXN0IG9iamVjdC5cbiAgICovXG4gIHJlcT86IEluY29taW5nTWVzc2FnZVxuICAvKipcbiAgICogYEhUVFBgIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIHJlcz86IFNlcnZlclJlc3BvbnNlXG4gIC8qKlxuICAgKiBQYXRoIHNlY3Rpb24gb2YgYFVSTGAuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nXG4gIC8qKlxuICAgKiBRdWVyeSBzdHJpbmcgc2VjdGlvbiBvZiBgVVJMYCBwYXJzZWQgYXMgYW4gb2JqZWN0LlxuICAgKi9cbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIC8qKlxuICAgKiBgU3RyaW5nYCBvZiB0aGUgYWN0dWFsIHBhdGggaW5jbHVkaW5nIHF1ZXJ5LlxuICAgKi9cbiAgYXNQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBgQ29tcG9uZW50YCB0aGUgdHJlZSBvZiB0aGUgQXBwIHRvIHVzZSBpZiBuZWVkaW5nIHRvIHJlbmRlciBzZXBhcmF0ZWx5XG4gICAqL1xuICBBcHBUcmVlOiBBcHBUcmVlVHlwZVxufVxuXG5leHBvcnQgdHlwZSBBcHBDb250ZXh0VHlwZTxSIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXI+ID0ge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dD5cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbiAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgcm91dGVyOiBSXG59XG5cbmV4cG9ydCB0eXBlIEFwcEluaXRpYWxQcm9wcyA9IHtcbiAgcGFnZVByb3BzOiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgQXBwUHJvcHNUeXBlPFxuICBSIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXIsXG4gIFAgPSB7fVxuPiA9IEFwcEluaXRpYWxQcm9wcyAmIHtcbiAgQ29tcG9uZW50OiBOZXh0Q29tcG9uZW50VHlwZTxOZXh0UGFnZUNvbnRleHQsIGFueSwgUD5cbiAgcm91dGVyOiBSXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50Q29udGV4dCA9IE5leHRQYWdlQ29udGV4dCAmIHtcbiAgcmVuZGVyUGFnZTogUmVuZGVyUGFnZVxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudEluaXRpYWxQcm9wcyA9IFJlbmRlclBhZ2VSZXN1bHQgJiB7XG4gIHN0eWxlcz86IFJlYWN0LlJlYWN0RWxlbWVudFtdIHwgUmVhY3QuUmVhY3RGcmFnbWVudFxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFByb3BzID0gRG9jdW1lbnRJbml0aWFsUHJvcHMgJiB7XG4gIF9fTkVYVF9EQVRBX186IE5FWFRfREFUQVxuICBkYW5nZXJvdXNBc1BhdGg6IHN0cmluZ1xuICBkb2NDb21wb25lbnRzUmVuZGVyZWQ6IHtcbiAgICBIdG1sPzogYm9vbGVhblxuICAgIE1haW4/OiBib29sZWFuXG4gICAgSGVhZD86IGJvb2xlYW5cbiAgICBOZXh0U2NyaXB0PzogYm9vbGVhblxuICB9XG4gIGJ1aWxkTWFuaWZlc3Q6IEJ1aWxkTWFuaWZlc3RcbiAgYW1wUGF0aDogc3RyaW5nXG4gIGluQW1wTW9kZTogYm9vbGVhblxuICBoeWJyaWRBbXA6IGJvb2xlYW5cbiAgaXNEZXZlbG9wbWVudDogYm9vbGVhblxuICBkeW5hbWljSW1wb3J0czogTWFuaWZlc3RJdGVtW11cbiAgYXNzZXRQcmVmaXg/OiBzdHJpbmdcbiAgY2Fub25pY2FsQmFzZTogc3RyaW5nXG4gIGhlYWRUYWdzOiBhbnlbXVxuICB1bnN0YWJsZV9ydW50aW1lSlM/OiBmYWxzZVxuICBkZXZPbmx5Q2FjaGVCdXN0ZXJRdWVyeVN0cmluZzogc3RyaW5nXG4gIGxvY2FsZT86IHN0cmluZ1xufVxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgcmVxdWVzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5leHRBcGlSZXF1ZXN0IGV4dGVuZHMgSW5jb21pbmdNZXNzYWdlIHtcbiAgLyoqXG4gICAqIE9iamVjdCBvZiBgcXVlcnlgIHZhbHVlcyBmcm9tIHVybFxuICAgKi9cbiAgcXVlcnk6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBzdHJpbmdbXVxuICB9XG4gIC8qKlxuICAgKiBPYmplY3Qgb2YgYGNvb2tpZXNgIGZyb20gaGVhZGVyXG4gICAqL1xuICBjb29raWVzOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nXG4gIH1cblxuICBib2R5OiBhbnlcblxuICBlbnY6IEVudlxuXG4gIHByZXZpZXc/OiBib29sZWFuXG4gIC8qKlxuICAgKiBQcmV2aWV3IGRhdGEgc2V0IG9uIHRoZSByZXF1ZXN0LCBpZiBhbnlcbiAgICogKi9cbiAgcHJldmlld0RhdGE/OiBhbnlcbn1cblxuLyoqXG4gKiBTZW5kIGJvZHkgb2YgcmVzcG9uc2VcbiAqL1xudHlwZSBTZW5kPFQ+ID0gKGJvZHk6IFQpID0+IHZvaWRcblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIHJlc3BvbnNlXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRBcGlSZXNwb25zZTxUID0gYW55PiA9IFNlcnZlclJlc3BvbnNlICYge1xuICAvKipcbiAgICogU2VuZCBkYXRhIGBhbnlgIGRhdGEgaW4gcmVzcG9uc2VcbiAgICovXG4gIHNlbmQ6IFNlbmQ8VD5cbiAgLyoqXG4gICAqIFNlbmQgZGF0YSBganNvbmAgZGF0YSBpbiByZXNwb25zZVxuICAgKi9cbiAganNvbjogU2VuZDxUPlxuICBzdGF0dXM6IChzdGF0dXNDb2RlOiBudW1iZXIpID0+IE5leHRBcGlSZXNwb25zZTxUPlxuICByZWRpcmVjdCh1cmw6IHN0cmluZyk6IE5leHRBcGlSZXNwb25zZTxUPlxuICByZWRpcmVjdChzdGF0dXM6IG51bWJlciwgdXJsOiBzdHJpbmcpOiBOZXh0QXBpUmVzcG9uc2U8VD5cblxuICAvKipcbiAgICogU2V0IHByZXZpZXcgZGF0YSBmb3IgTmV4dC5qcycgcHJlcmVuZGVyIG1vZGVcbiAgICovXG4gIHNldFByZXZpZXdEYXRhOiAoXG4gICAgZGF0YTogb2JqZWN0IHwgc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIChpbiBzZWNvbmRzKSBmb3IgdGhlIHByZXZpZXcgc2Vzc2lvbiB0byBsYXN0IGZvci5cbiAgICAgICAqIFRoZSBnaXZlbiBudW1iZXIgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlciBieSByb3VuZGluZyBkb3duLlxuICAgICAgICogQnkgZGVmYXVsdCwgbm8gbWF4aW11bSBhZ2UgaXMgc2V0IGFuZCB0aGUgcHJldmlldyBzZXNzaW9uIGZpbmlzaGVzXG4gICAgICAgKiB3aGVuIHRoZSBjbGllbnQgc2h1dHMgZG93biAoYnJvd3NlciBpcyBjbG9zZWQpLlxuICAgICAgICovXG4gICAgICBtYXhBZ2U/OiBudW1iZXJcbiAgICB9XG4gICkgPT4gTmV4dEFwaVJlc3BvbnNlPFQ+XG4gIGNsZWFyUHJldmlld0RhdGE6ICgpID0+IE5leHRBcGlSZXNwb25zZTxUPlxufVxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgaGFuZGxlclxuICovXG5leHBvcnQgdHlwZSBOZXh0QXBpSGFuZGxlcjxUID0gYW55PiA9IChcbiAgcmVxOiBOZXh0QXBpUmVxdWVzdCxcbiAgcmVzOiBOZXh0QXBpUmVzcG9uc2U8VD5cbikgPT4gdm9pZCB8IFByb21pc2U8dm9pZD5cblxuLyoqXG4gKiBVdGlsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXhlY09uY2U8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gUmV0dXJuVHlwZTxUPj4oXG4gIGZuOiBUXG4pOiBUIHtcbiAgbGV0IHVzZWQgPSBmYWxzZVxuICBsZXQgcmVzdWx0OiBSZXR1cm5UeXBlPFQ+XG5cbiAgcmV0dXJuICgoLi4uYXJnczogYW55W10pID0+IHtcbiAgICBpZiAoIXVzZWQpIHtcbiAgICAgIHVzZWQgPSB0cnVlXG4gICAgICByZXN1bHQgPSBmbiguLi5hcmdzKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pIGFzIFRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvY2F0aW9uT3JpZ2luKCkge1xuICBjb25zdCB7IHByb3RvY29sLCBob3N0bmFtZSwgcG9ydCB9ID0gd2luZG93LmxvY2F0aW9uXG4gIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdG5hbWV9JHtwb3J0ID8gJzonICsgcG9ydCA6ICcnfWBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVSTCgpIHtcbiAgY29uc3QgeyBocmVmIH0gPSB3aW5kb3cubG9jYXRpb25cbiAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuICByZXR1cm4gaHJlZi5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lPFA+KENvbXBvbmVudDogQ29tcG9uZW50VHlwZTxQPikge1xuICByZXR1cm4gdHlwZW9mIENvbXBvbmVudCA9PT0gJ3N0cmluZydcbiAgICA/IENvbXBvbmVudFxuICAgIDogQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZXNTZW50KHJlczogU2VydmVyUmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlcy5maW5pc2hlZCB8fCByZXMuaGVhZGVyc1NlbnRcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRHZXRJbml0aWFsUHJvcHM8XG4gIEMgZXh0ZW5kcyBCYXNlQ29udGV4dCxcbiAgSVAgPSB7fSxcbiAgUCA9IHt9XG4+KEFwcDogTmV4dENvbXBvbmVudFR5cGU8QywgSVAsIFA+LCBjdHg6IEMpOiBQcm9taXNlPElQPiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKEFwcC5wcm90b3R5cGU/LmdldEluaXRpYWxQcm9wcykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICAgIEFwcFxuICAgICAgKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAtIHZpc2l0IGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL2dldC1pbml0aWFsLXByb3BzLWFzLWFuLWluc3RhbmNlLW1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICB9XG4gIH1cbiAgLy8gd2hlbiBjYWxsZWQgZnJvbSBfYXBwIGBjdHhgIGlzIG5lc3RlZCBpbiBgY3R4YFxuICBjb25zdCByZXMgPSBjdHgucmVzIHx8IChjdHguY3R4ICYmIGN0eC5jdHgucmVzKVxuXG4gIGlmICghQXBwLmdldEluaXRpYWxQcm9wcykge1xuICAgIGlmIChjdHguY3R4ICYmIGN0eC5Db21wb25lbnQpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgcGFnZVByb3BzIGRlZmF1bHRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VQcm9wczogYXdhaXQgbG9hZEdldEluaXRpYWxQcm9wcyhjdHguQ29tcG9uZW50LCBjdHguY3R4KSxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHt9IGFzIElQXG4gIH1cblxuICBjb25zdCBwcm9wcyA9IGF3YWl0IEFwcC5nZXRJbml0aWFsUHJvcHMoY3R4KVxuXG4gIGlmIChyZXMgJiYgaXNSZXNTZW50KHJlcykpIHtcbiAgICByZXR1cm4gcHJvcHNcbiAgfVxuXG4gIGlmICghcHJvcHMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShcbiAgICAgIEFwcFxuICAgICl9LmdldEluaXRpYWxQcm9wcygpXCIgc2hvdWxkIHJlc29sdmUgdG8gYW4gb2JqZWN0LiBCdXQgZm91bmQgXCIke3Byb3BzfVwiIGluc3RlYWQuYFxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA9PT0gMCAmJiAhY3R4LmN0eCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgJHtnZXREaXNwbGF5TmFtZShcbiAgICAgICAgICBBcHBcbiAgICAgICAgKX0gcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gXFxgZ2V0SW5pdGlhbFByb3BzXFxgLiBUaGlzIGRlLW9wdGltaXplcyBhbmQgcHJldmVudHMgYXV0b21hdGljIHN0YXRpYyBvcHRpbWl6YXRpb24uIGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL2VtcHR5LW9iamVjdC1nZXRJbml0aWFsUHJvcHNgXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3BzXG59XG5cbmV4cG9ydCBjb25zdCB1cmxPYmplY3RLZXlzID0gW1xuICAnYXV0aCcsXG4gICdoYXNoJyxcbiAgJ2hvc3QnLFxuICAnaG9zdG5hbWUnLFxuICAnaHJlZicsXG4gICdwYXRoJyxcbiAgJ3BhdGhuYW1lJyxcbiAgJ3BvcnQnLFxuICAncHJvdG9jb2wnLFxuICAncXVlcnknLFxuICAnc2VhcmNoJyxcbiAgJ3NsYXNoZXMnLFxuXVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0V2l0aFZhbGlkYXRpb24odXJsOiBVcmxPYmplY3QpOiBzdHJpbmcge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBpZiAodXJsICE9PSBudWxsICYmIHR5cGVvZiB1cmwgPT09ICdvYmplY3QnKSB7XG4gICAgICBPYmplY3Qua2V5cyh1cmwpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAodXJsT2JqZWN0S2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYFVua25vd24ga2V5IHBhc3NlZCB2aWEgdXJsT2JqZWN0IGludG8gdXJsLmZvcm1hdDogJHtrZXl9YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm9ybWF0VXJsKHVybClcbn1cblxuZXhwb3J0IGNvbnN0IFNQID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJ1xuZXhwb3J0IGNvbnN0IFNUID1cbiAgU1AgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUgPT09ICdmdW5jdGlvbidcbiIsIlwidXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMubm9ybWFsaXplUGF0aFNlcD1ub3JtYWxpemVQYXRoU2VwO2V4cG9ydHMuZGVub3JtYWxpemVQYWdlUGF0aD1kZW5vcm1hbGl6ZVBhZ2VQYXRoO2Z1bmN0aW9uIG5vcm1hbGl6ZVBhdGhTZXAocGF0aCl7cmV0dXJuIHBhdGgucmVwbGFjZSgvXFxcXC9nLCcvJyk7fWZ1bmN0aW9uIGRlbm9ybWFsaXplUGFnZVBhdGgocGFnZSl7cGFnZT1ub3JtYWxpemVQYXRoU2VwKHBhZ2UpO2lmKHBhZ2Uuc3RhcnRzV2l0aCgnL2luZGV4LycpKXtwYWdlPXBhZ2Uuc2xpY2UoNik7fWVsc2UgaWYocGFnZT09PScvaW5kZXgnKXtwYWdlPScvJzt9cmV0dXJuIHBhZ2U7fVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVub3JtYWxpemUtcGFnZS1wYXRoLmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2NsaWVudC9saW5rJylcbiIsImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheTsiLCJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzOyIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG52YXIgaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gcmVxdWlyZShcIi4vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0XCIpO1xuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBzZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0OyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5OyIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsO1xuICB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4gIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH07XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJkZWZhdWx0XCI6IG9ialxuICAgIH07XG4gIH1cblxuICB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTtcblxuICBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XG4gIH1cblxuICB2YXIgbmV3T2JqID0ge307XG4gIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsO1xuXG4gICAgICBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7XG5cbiAgaWYgKGNhY2hlKSB7XG4gICAgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTtcbiAgfVxuXG4gIHJldHVybiBuZXdPYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQ7IiwiZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3Q7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdDsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVJlc3Q7IiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2Y7IiwidmFyIGFycmF5V2l0aEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRoSG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXlMaW1pdCA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheUxpbWl0XCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlUmVzdFwiKTtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5XCIpO1xuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG52YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGVsZW1lbnRUeXBlOiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSAgKyAnYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIVJlYWN0SXMuaXNWYWxpZEVsZW1lbnRUeXBlKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50IHR5cGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudHMgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LCBnb3QgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIGFyZ3VtZW50cy4gJyArXG4gICAgICAgICAgICAnQSBjb21tb24gbWlzdGFrZSBpcyB0byB3cml0ZSBvbmVPZih4LCB5LCB6KSBpbnN0ZWFkIG9mIG9uZU9mKFt4LCB5LCB6XSkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMsIGZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIFN0cmluZyhwcm9wVmFsdWUpICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChoYXMocHJvcFZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAnICsgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpICsgJyBhdCBpbmRleCAnICsgaSArICcuJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZmFsc3kgdmFsdWUgY2FuJ3QgYmUgYSBTeW1ib2xcbiAgICBpZiAoIXByb3BWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGU7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zZXRDb25maWd1cmF0aW9uID0gZXhwb3J0cy5nZXRDb25maWd1cmF0aW9uID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGNvbmZpZ3VyYXRpb24gPSB7XG4gIGJyZWFrcG9pbnRzOiBbNTc2LCA3NjgsIDk5MiwgMTIwMCwgMTYwMF0sXG4gIGNvbnRhaW5lcldpZHRoczogWzU0MCwgNzUwLCA5NjAsIDExNDAsIDE1NDBdLFxuICBndXR0ZXJXaWR0aDogMzAsXG4gIGdyaWRDb2x1bW5zOiAxMixcbiAgZGVmYXVsdFNjcmVlbkNsYXNzOiAneHhsJyxcbiAgbWF4U2NyZWVuQ2xhc3M6ICd4eGwnXG59O1xuXG52YXIgZ2V0Q29uZmlndXJhdGlvbiA9IGZ1bmN0aW9uIGdldENvbmZpZ3VyYXRpb24oKSB7XG4gIHJldHVybiBjb25maWd1cmF0aW9uO1xufTtcblxuZXhwb3J0cy5nZXRDb25maWd1cmF0aW9uID0gZ2V0Q29uZmlndXJhdGlvbjtcblxudmFyIHNldENvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbiBzZXRDb25maWd1cmF0aW9uKG5ld0NvbmZpZ3VyYXRpb24pIHtcbiAgY29uZmlndXJhdGlvbiA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY29uZmlndXJhdGlvbiksIG5ld0NvbmZpZ3VyYXRpb24pO1xufTtcblxuZXhwb3J0cy5zZXRDb25maWd1cmF0aW9uID0gc2V0Q29uZmlndXJhdGlvbjsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5TY3JlZW5DbGFzc0NvbnRleHQgPSBleHBvcnRzLk5PX1BST1ZJREVSX0ZMQUcgPSB2b2lkIDA7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuXG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jb25maWdcIik7XG5cbnZhciBfcHJpbWl0aXZlcyA9IHJlcXVpcmUoXCIuLi8uLi9wcmltaXRpdmVzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG52YXIgTk9fUFJPVklERVJfRkxBRyA9ICdOT19QUk9WSURFUl9GTEFHJztcbmV4cG9ydHMuTk9fUFJPVklERVJfRkxBRyA9IE5PX1BST1ZJREVSX0ZMQUc7XG5cbnZhciBTY3JlZW5DbGFzc0NvbnRleHQgPSAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlQ29udGV4dChOT19QUk9WSURFUl9GTEFHKTtcblxuZXhwb3J0cy5TY3JlZW5DbGFzc0NvbnRleHQgPSBTY3JlZW5DbGFzc0NvbnRleHQ7XG5cbnZhciBTY3JlZW5DbGFzc1Byb3ZpZGVyID0gZnVuY3Rpb24gU2NyZWVuQ2xhc3NQcm92aWRlcihfcmVmKSB7XG4gIHZhciB1c2VPd25XaWR0aCA9IF9yZWYudXNlT3duV2lkdGgsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBmYWxsYmFja1NjcmVlbkNsYXNzID0gX3JlZi5mYWxsYmFja1NjcmVlbkNsYXNzO1xuICB2YXIgc2NyZWVuQ2xhc3NSZWYgPSAoMCwgX3JlYWN0LnVzZVJlZikoKTtcblxuICB2YXIgX3VzZVN0YXRlID0gKDAsIF9yZWFjdC51c2VTdGF0ZSkoZmFsc2UpLFxuICAgICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgICBtb3VudGVkID0gX3VzZVN0YXRlMlswXSxcbiAgICAgIHNldE1vdW50ZWQgPSBfdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBkZXRlY3RlZFNjcmVlbkNsYXNzID0gKDAsIF91dGlscy51c2VTY3JlZW5DbGFzcykoc2NyZWVuQ2xhc3NSZWYsIGZhbGxiYWNrU2NyZWVuQ2xhc3MpO1xuXG4gIHZhciBfZ2V0Q29uZmlndXJhdGlvbiA9ICgwLCBfY29uZmlnLmdldENvbmZpZ3VyYXRpb24pKCksXG4gICAgICBkZWZhdWx0U2NyZWVuQ2xhc3MgPSBfZ2V0Q29uZmlndXJhdGlvbi5kZWZhdWx0U2NyZWVuQ2xhc3M7XG5cbiAgdmFyIHNjcmVlbkNsYXNzID0gbW91bnRlZCA/IGRldGVjdGVkU2NyZWVuQ2xhc3MgOiBmYWxsYmFja1NjcmVlbkNsYXNzIHx8IGRlZmF1bHRTY3JlZW5DbGFzcztcbiAgKDAsIF9yZWFjdC51c2VFZmZlY3QpKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2V0TW91bnRlZCh0cnVlKTtcbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU2NyZWVuQ2xhc3NDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHNjcmVlbkNsYXNzXG4gIH0sIHVzZU93bldpZHRoID8gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3ByaW1pdGl2ZXMuRGl2LCB7XG4gICAgcmVmOiB1c2VPd25XaWR0aCA/IHNjcmVlbkNsYXNzUmVmIDogbnVsbFxuICB9LCBjaGlsZHJlbikgOiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pKTtcbn07XG5cblNjcmVlbkNsYXNzUHJvdmlkZXIucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogQ2hpbGRyZW4gb2YgdGhlIFNjcmVlbkNsYXNzUHJvdmlkZXIuXG4gICAqIFRoaXMgc2hvdWxkIGJlIGFsbCB5b3VyIGNoaWxkIFJlYWN0IG5vZGVzIHRoYXQgYXJlIHVzaW5nIGByZWFjdC1ncmlkLXN5c3RlbWAuXG4gICAqL1xuICBjaGlsZHJlbjogX3Byb3BUeXBlcy5kZWZhdWx0Lm5vZGUuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogQm9vbGVhbiB0byBkZXRlcm1pbmUgd2hldGhlciBvd24gd2lkdGggc2hvdWxkIGJlIHVzZWQgYXMgc291cmNlLlxuICAgKiBXaGVuIHByb3ZpZGVkLCB0aGUgc2NyZWVuIGNsYXNzIGlzIGRlcml2ZWQgZnJvbSBvd24gZGltZW5zaW9ucyBpbnN0ZWFkIG9mIHRoZSB3aW5kb3cuXG4gICAqL1xuICB1c2VPd25XaWR0aDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIFNjcmVlbiBjbGFzcyB0byB1c2Ugd2hlbiBpdCBjYW5ub3QgYmUgZGV0ZXJtaW5lZCBvdGhlcndpc2UuXG4gICAqIFVzZWZ1bCBmb3Igc2VydmVyIHNpZGUgcmVuZGVyaW5nLlxuICAgKi9cbiAgZmFsbGJhY2tTY3JlZW5DbGFzczogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mKFtudWxsLCAneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnLCAneHhsJ10pXG59O1xuU2NyZWVuQ2xhc3NQcm92aWRlci5kZWZhdWx0UHJvcHMgPSB7XG4gIHVzZU93bldpZHRoOiBmYWxzZSxcbiAgZmFsbGJhY2tTY3JlZW5DbGFzczogbnVsbFxufTtcbnZhciBfZGVmYXVsdCA9IFNjcmVlbkNsYXNzUHJvdmlkZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuXG52YXIgX1NjcmVlbkNsYXNzUHJvdmlkZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi4vU2NyZWVuQ2xhc3NQcm92aWRlclwiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBTY3JlZW5DbGFzc1Jlc29sdmVyID0gZnVuY3Rpb24gU2NyZWVuQ2xhc3NSZXNvbHZlcihfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfU2NyZWVuQ2xhc3NQcm92aWRlci5TY3JlZW5DbGFzc0NvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChzY3JlZW5DbGFzc0NoZWNrKSB7XG4gICAgaWYgKHNjcmVlbkNsYXNzQ2hlY2sgPT09IF9TY3JlZW5DbGFzc1Byb3ZpZGVyLk5PX1BST1ZJREVSX0ZMQUcpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfU2NyZWVuQ2xhc3NQcm92aWRlci5kZWZhdWx0LCBudWxsLCAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfU2NyZWVuQ2xhc3NQcm92aWRlci5TY3JlZW5DbGFzc0NvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChzY3JlZW5DbGFzc1Jlc29sdmVkKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbihzY3JlZW5DbGFzc1Jlc29sdmVkKTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGRyZW4oc2NyZWVuQ2xhc3NDaGVjayk7XG4gIH0pO1xufTtcblxuU2NyZWVuQ2xhc3NSZXNvbHZlci5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYy5pc1JlcXVpcmVkXG59O1xudmFyIF9kZWZhdWx0ID0gU2NyZWVuQ2xhc3NSZXNvbHZlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuXG52YXIgX3N0eWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zdHlsZVwiKSk7XG5cbnZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NvbmZpZ1wiKTtcblxudmFyIF9Sb3cgPSByZXF1aXJlKFwiLi4vUm93XCIpO1xuXG52YXIgX1NjcmVlbkNsYXNzUmVzb2x2ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9jb250ZXh0L1NjcmVlbkNsYXNzUmVzb2x2ZXJcIikpO1xuXG52YXIgX3ByaW1pdGl2ZXMgPSByZXF1aXJlKFwiLi4vLi4vcHJpbWl0aXZlc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBDb2wgPSBmdW5jdGlvbiBDb2woX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgeHMgPSBfcmVmLnhzLFxuICAgICAgc20gPSBfcmVmLnNtLFxuICAgICAgbWQgPSBfcmVmLm1kLFxuICAgICAgbGcgPSBfcmVmLmxnLFxuICAgICAgeGwgPSBfcmVmLnhsLFxuICAgICAgeHhsID0gX3JlZi54eGwsXG4gICAgICBvZmZzZXQgPSBfcmVmLm9mZnNldCxcbiAgICAgIHB1bGwgPSBfcmVmLnB1bGwsXG4gICAgICBwdXNoID0gX3JlZi5wdXNoLFxuICAgICAgZGVidWcgPSBfcmVmLmRlYnVnLFxuICAgICAgc3R5bGUgPSBfcmVmLnN0eWxlLFxuICAgICAgY29tcG9uZW50ID0gX3JlZi5jb21wb25lbnQsXG4gICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBvdGhlclByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwieHNcIiwgXCJzbVwiLCBcIm1kXCIsIFwibGdcIiwgXCJ4bFwiLCBcInh4bFwiLCBcIm9mZnNldFwiLCBcInB1bGxcIiwgXCJwdXNoXCIsIFwiZGVidWdcIiwgXCJzdHlsZVwiLCBcImNvbXBvbmVudFwiLCBcIndpZHRoXCJdKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX1NjcmVlbkNsYXNzUmVzb2x2ZXIuZGVmYXVsdCwgbnVsbCwgZnVuY3Rpb24gKHNjcmVlbkNsYXNzKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9Sb3cuR3V0dGVyV2lkdGhDb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoZ3V0dGVyV2lkdGgpIHtcbiAgICAgIHZhciB0aGVTdHlsZSA9ICgwLCBfc3R5bGUuZGVmYXVsdCkoe1xuICAgICAgICBmb3JjZVdpZHRoOiB3aWR0aCxcbiAgICAgICAgd2lkdGg6IHtcbiAgICAgICAgICB4czogeHMsXG4gICAgICAgICAgc206IHNtLFxuICAgICAgICAgIG1kOiBtZCxcbiAgICAgICAgICBsZzogbGcsXG4gICAgICAgICAgeGw6IHhsLFxuICAgICAgICAgIHh4bDogeHhsXG4gICAgICAgIH0sXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBwdWxsOiBwdWxsLFxuICAgICAgICBwdXNoOiBwdXNoLFxuICAgICAgICBkZWJ1ZzogZGVidWcsXG4gICAgICAgIHNjcmVlbkNsYXNzOiBzY3JlZW5DbGFzcyxcbiAgICAgICAgZ3V0dGVyV2lkdGg6IGd1dHRlcldpZHRoLFxuICAgICAgICBncmlkQ29sdW1uczogKDAsIF9jb25maWcuZ2V0Q29uZmlndXJhdGlvbikoKS5ncmlkQ29sdW1ucyxcbiAgICAgICAgbW9yZVN0eWxlOiBzdHlsZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qLygwLCBfcmVhY3QuY3JlYXRlRWxlbWVudCkoY29tcG9uZW50LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBzdHlsZTogdGhlU3R5bGVcbiAgICAgIH0sIG90aGVyUHJvcHMpLCB7fSwge1xuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5Db2wucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogQ29udGVudCBvZiB0aGUgY29sdW1uXG4gICAqL1xuICBjaGlsZHJlbjogX3Byb3BUeXBlcy5kZWZhdWx0Lm5vZGUsXG5cbiAgLyoqXG4gICAqIFRoZSB3aWR0aCBvZiB0aGUgY29sdW1uIGZvciBzY3JlZW5jbGFzcyBgeHNgLCBlaXRoZXIgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxMiwgb3IgXCJjb250ZW50XCJcbiAgICovXG4gIHhzOiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLCBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2YoWydjb250ZW50J10pXSksXG5cbiAgLyoqXG4gICAqIFRoZSB3aWR0aCBvZiB0aGUgY29sdW1uIGZvciBzY3JlZW5jbGFzcyBgc21gLCBlaXRoZXIgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxMiwgb3IgXCJjb250ZW50XCJcbiAgICovXG4gIHNtOiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLCBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2YoWydjb250ZW50J10pXSksXG5cbiAgLyoqXG4gICAqIFRoZSB3aWR0aCBvZiB0aGUgY29sdW1uIGZvciBzY3JlZW5jbGFzcyBgbWRgLCBlaXRoZXIgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxMiwgb3IgXCJjb250ZW50XCJcbiAgICovXG4gIG1kOiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLCBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2YoWydjb250ZW50J10pXSksXG5cbiAgLyoqXG4gICAqIFRoZSB3aWR0aCBvZiB0aGUgY29sdW1uIGZvciBzY3JlZW5jbGFzcyBgbGdgLCBlaXRoZXIgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxMiwgb3IgXCJjb250ZW50XCJcbiAgICovXG4gIGxnOiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLCBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2YoWydjb250ZW50J10pXSksXG5cbiAgLyoqXG4gICAqIFRoZSB3aWR0aCBvZiB0aGUgY29sdW1uIGZvciBzY3JlZW5jbGFzcyBgeGxgLCBlaXRoZXIgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxMiwgb3IgXCJjb250ZW50XCJcbiAgICovXG4gIHhsOiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLCBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2YoWydjb250ZW50J10pXSksXG5cbiAgLyoqXG4gICAqIFRoZSB3aWR0aCBvZiB0aGUgY29sdW1uIGZvciBzY3JlZW5jbGFzcyBgeHhsYCwgZWl0aGVyIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMTIsIG9yIFwiY29udGVudFwiXG4gICAqL1xuICB4eGw6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsIF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbJ2NvbnRlbnQnXSldKSxcblxuICAvKipcbiAgICogQSBmaXhlZCB3aWR0aCBvZiB0aGUgY29sdW1uIGZvciBhbGwgc2NyZWVuY2xhc3Nlc1wiXG4gICAqL1xuICB3aWR0aDogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlciwgX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBUaGUgb2Zmc2V0IG9mIHRoaXMgY29sdW1uIGZvciBhbGwgc2NyZWVuY2xhc3Nlc1xuICAgKi9cbiAgb2Zmc2V0OiBfcHJvcFR5cGVzLmRlZmF1bHQuc2hhcGUoe1xuICAgIHhzOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHNtOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIG1kOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIGxnOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHhsOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHh4bDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlclxuICB9KSxcblxuICAvKipcbiAgICogVGhlIGFtb3VudCB0aGlzIGNvbHVtbiBpcyBwdXNoZWQgdG8gdGhlIHJpZ2h0IGZvciBhbGwgc2NyZWVuY2xhc3Nlc1xuICAgKi9cbiAgcHVzaDogX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICB4czogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICBzbTogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICBtZDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICBsZzogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICB4bDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICB4eGw6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXJcbiAgfSksXG5cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgdGhpcyBjb2x1bW4gaXMgcHVsbGVkIHRvIHRoZSBsZWZ0IGZvciBhbGwgc2NyZWVuY2xhc3Nlc1xuICAgKi9cbiAgcHVsbDogX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICB4czogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICBzbTogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICBtZDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICBsZzogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICB4bDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICB4eGw6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXJcbiAgfSksXG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIHN0eWxpbmdcbiAgICovXG4gIHN0eWxlOiBfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0T2YoX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlciwgX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZ10pKSxcblxuICAvKipcbiAgICogU2V0IHRvIGFwcGx5IHNvbWUgZGVidWcgc3R5bGluZ1xuICAgKi9cbiAgZGVidWc6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBVc2UgeW91ciBvd24gY29tcG9uZW50XG4gICAqL1xuICBjb21wb25lbnQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5lbGVtZW50VHlwZVxufTtcbkNvbC5kZWZhdWx0UHJvcHMgPSB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICB4czogbnVsbCxcbiAgc206IG51bGwsXG4gIG1kOiBudWxsLFxuICBsZzogbnVsbCxcbiAgeGw6IG51bGwsXG4gIHh4bDogbnVsbCxcbiAgd2lkdGg6IG51bGwsXG4gIG9mZnNldDoge30sXG4gIHB1c2g6IHt9LFxuICBwdWxsOiB7fSxcbiAgc3R5bGU6IHt9LFxuICBkZWJ1ZzogZmFsc2UsXG4gIGNvbXBvbmVudDogX3ByaW1pdGl2ZXMuRGl2XG59O1xudmFyIF9kZWZhdWx0ID0gQ29sO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgaGFzV2lkdGggPSBmdW5jdGlvbiBoYXNXaWR0aCh3aWR0aHMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHdpZHRocykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cikge1xuICAgIHJldHVybiBhY2MgfHwgd2lkdGhzW2N1cl07XG4gIH0sIGZhbHNlKTtcbn07XG5cbnZhciBnZXRXaWR0aCA9IGZ1bmN0aW9uIGdldFdpZHRoKHdpZHRoLCBncmlkQ29sdW1ucykge1xuICBpZiAodHlwZW9mIHdpZHRoICE9PSAnbnVtYmVyJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgdmFyIG5vcm1hbGl6ZWRXaWR0aCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGdyaWRDb2x1bW5zLCB3aWR0aCkpO1xuICByZXR1cm4gXCJcIi5jb25jYXQoMTAwIC8gZ3JpZENvbHVtbnMgKiBub3JtYWxpemVkV2lkdGgsIFwiJVwiKTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IGZ1bmN0aW9uIF9kZWZhdWx0KF9yZWYpIHtcbiAgdmFyIF9yZWYkZm9yY2VXaWR0aCA9IF9yZWYuZm9yY2VXaWR0aCxcbiAgICAgIGZvcmNlV2lkdGggPSBfcmVmJGZvcmNlV2lkdGggPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmJGZvcmNlV2lkdGgsXG4gICAgICBfcmVmJHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIHdpZHRoID0gX3JlZiR3aWR0aCA9PT0gdm9pZCAwID8ge30gOiBfcmVmJHdpZHRoLFxuICAgICAgX3JlZiRvZmZzZXQgPSBfcmVmLm9mZnNldCxcbiAgICAgIG9mZnNldCA9IF9yZWYkb2Zmc2V0ID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkb2Zmc2V0LFxuICAgICAgX3JlZiRwdWxsID0gX3JlZi5wdWxsLFxuICAgICAgcHVsbCA9IF9yZWYkcHVsbCA9PT0gdm9pZCAwID8ge30gOiBfcmVmJHB1bGwsXG4gICAgICBfcmVmJHB1c2ggPSBfcmVmLnB1c2gsXG4gICAgICBwdXNoID0gX3JlZiRwdXNoID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkcHVzaCxcbiAgICAgIGRlYnVnID0gX3JlZi5kZWJ1ZyxcbiAgICAgIHNjcmVlbkNsYXNzID0gX3JlZi5zY3JlZW5DbGFzcyxcbiAgICAgIGd1dHRlcldpZHRoID0gX3JlZi5ndXR0ZXJXaWR0aCxcbiAgICAgIG1vcmVTdHlsZSA9IF9yZWYubW9yZVN0eWxlLFxuICAgICAgZ3JpZENvbHVtbnMgPSBfcmVmLmdyaWRDb2x1bW5zO1xuICB2YXIgc3R5bGVzID0ge1xuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIG1pbkhlaWdodDogMSxcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBwYWRkaW5nTGVmdDogZ3V0dGVyV2lkdGggLyAyLFxuICAgIHBhZGRpbmdSaWdodDogZ3V0dGVyV2lkdGggLyAyLFxuICAgIHdpZHRoOiAnMTAwJSdcbiAgfTtcblxuICBpZiAoZGVidWcpIHtcbiAgICBzdHlsZXMub3V0bGluZSA9ICcxcHggc29saWQgc2lsdmVyJztcbiAgICBzdHlsZXMuYmFja2dyb3VuZCA9ICdyZ2JhKDAsMCwwLC4wNSknO1xuICAgIHN0eWxlcy5saW5lSGVpZ2h0ID0gJzMycHgnO1xuICB9XG5cbiAgc3R5bGVzLmZsZXhCYXNpcyA9ICcxMDAlJztcbiAgc3R5bGVzLmZsZXhHcm93ID0gMDtcbiAgc3R5bGVzLmZsZXhTaHJpbmsgPSAwO1xuICBzdHlsZXMubWF4V2lkdGggPSAnMTAwJSc7XG4gIHN0eWxlcy5tYXJnaW5MZWZ0ID0gJzAlJztcbiAgc3R5bGVzLnJpZ2h0ID0gJ2F1dG8nO1xuICBzdHlsZXMubGVmdCA9ICdhdXRvJztcblxuICBfdXRpbHMuc2NyZWVuQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaXplLCBpbmRleCkge1xuICAgIGlmIChfdXRpbHMuc2NyZWVuQ2xhc3Nlcy5pbmRleE9mKHNjcmVlbkNsYXNzKSA+PSBpbmRleCkge1xuICAgICAgdmFyIGN1cnJlbnRXaWR0aCA9IGdldFdpZHRoKHdpZHRoW3NpemVdLCBncmlkQ29sdW1ucyk7XG4gICAgICB2YXIgaXNTaXplZFRvQ29udGVudCA9IHdpZHRoW3NpemVdID09PSAnY29udGVudCc7XG4gICAgICBzdHlsZXMuZmxleEJhc2lzID0gaXNTaXplZFRvQ29udGVudCA/ICdhdXRvJyA6IGN1cnJlbnRXaWR0aCB8fCBzdHlsZXMuZmxleEJhc2lzO1xuICAgICAgc3R5bGVzLndpZHRoID0gc3R5bGVzLmZsZXhCYXNpcztcbiAgICAgIHN0eWxlcy5tYXhXaWR0aCA9IGN1cnJlbnRXaWR0aCB8fCBzdHlsZXMubWF4V2lkdGg7XG4gICAgICBzdHlsZXMubWFyZ2luTGVmdCA9IGdldFdpZHRoKG9mZnNldFtzaXplXSwgZ3JpZENvbHVtbnMpIHx8IHN0eWxlcy5tYXJnaW5MZWZ0O1xuICAgICAgc3R5bGVzLnJpZ2h0ID0gZ2V0V2lkdGgocHVsbFtzaXplXSwgZ3JpZENvbHVtbnMpIHx8IHN0eWxlcy5yaWdodDtcbiAgICAgIHN0eWxlcy5sZWZ0ID0gZ2V0V2lkdGgocHVzaFtzaXplXSwgZ3JpZENvbHVtbnMpIHx8IHN0eWxlcy5sZWZ0O1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKCFoYXNXaWR0aCh3aWR0aCkpIHtcbiAgICBzdHlsZXMuZmxleEJhc2lzID0gMDtcbiAgICBzdHlsZXMuZmxleEdyb3cgPSAxO1xuICB9XG5cbiAgaWYgKGZvcmNlV2lkdGgpIHtcbiAgICBzdHlsZXMuZmxleEJhc2lzID0gJ3Vuc2V0JztcbiAgICBzdHlsZXMuZmxleEdyb3cgPSAndW5zZXQnO1xuICAgIHN0eWxlcy5mbGV4U2hyaW5rID0gJ3Vuc2V0JztcbiAgICBzdHlsZXMud2lkdGggPSBmb3JjZVdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3R5bGVzKSwgbW9yZVN0eWxlKTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuXG52YXIgX3N0eWxlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vc3R5bGVcIikpO1xuXG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jb25maWdcIik7XG5cbnZhciBfU2NyZWVuQ2xhc3NSZXNvbHZlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL2NvbnRleHQvU2NyZWVuQ2xhc3NSZXNvbHZlclwiKSk7XG5cbnZhciBfcHJpbWl0aXZlcyA9IHJlcXVpcmUoXCIuLi8uLi9wcmltaXRpdmVzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIENvbnRhaW5lciA9IGZ1bmN0aW9uIENvbnRhaW5lcihfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBmbHVpZCA9IF9yZWYuZmx1aWQsXG4gICAgICB4cyA9IF9yZWYueHMsXG4gICAgICBzbSA9IF9yZWYuc20sXG4gICAgICBtZCA9IF9yZWYubWQsXG4gICAgICBsZyA9IF9yZWYubGcsXG4gICAgICB4bCA9IF9yZWYueGwsXG4gICAgICB4eGwgPSBfcmVmLnh4bCxcbiAgICAgIHN0eWxlID0gX3JlZi5zdHlsZSxcbiAgICAgIGNvbXBvbmVudCA9IF9yZWYuY29tcG9uZW50LFxuICAgICAgb3RoZXJQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJjaGlsZHJlblwiLCBcImZsdWlkXCIsIFwieHNcIiwgXCJzbVwiLCBcIm1kXCIsIFwibGdcIiwgXCJ4bFwiLCBcInh4bFwiLCBcInN0eWxlXCIsIFwiY29tcG9uZW50XCJdKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX1NjcmVlbkNsYXNzUmVzb2x2ZXIuZGVmYXVsdCwgbnVsbCwgZnVuY3Rpb24gKHNjcmVlbkNsYXNzKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNyZWF0ZUVsZW1lbnQpKGNvbXBvbmVudCwgX29iamVjdFNwcmVhZCh7XG4gICAgICBzdHlsZTogKDAsIF9zdHlsZS5kZWZhdWx0KSh7XG4gICAgICAgIGZsdWlkOiBmbHVpZCxcbiAgICAgICAgeHM6IHhzLFxuICAgICAgICBzbTogc20sXG4gICAgICAgIG1kOiBtZCxcbiAgICAgICAgbGc6IGxnLFxuICAgICAgICB4bDogeGwsXG4gICAgICAgIHh4bDogeHhsLFxuICAgICAgICBzY3JlZW5DbGFzczogc2NyZWVuQ2xhc3MsXG4gICAgICAgIGNvbnRhaW5lcldpZHRoczogKDAsIF9jb25maWcuZ2V0Q29uZmlndXJhdGlvbikoKS5jb250YWluZXJXaWR0aHMsXG4gICAgICAgIGd1dHRlcldpZHRoOiAoMCwgX2NvbmZpZy5nZXRDb25maWd1cmF0aW9uKSgpLmd1dHRlcldpZHRoLFxuICAgICAgICBtb3JlU3R5bGU6IHN0eWxlXG4gICAgICB9KVxuICAgIH0sIG90aGVyUHJvcHMpLCAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4sIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9wcmltaXRpdmVzLlNwYW4sIHtcbiAgICAgIHN0eWxlOiAoMCwgX3N0eWxlLmdldEFmdGVyU3R5bGUpKClcbiAgICB9KSkpO1xuICB9KTtcbn07XG5cbkNvbnRhaW5lci5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBDb250ZW50IG9mIHRoZSBjb21wb25lbnRcbiAgICovXG4gIGNoaWxkcmVuOiBfcHJvcFR5cGVzLmRlZmF1bHQubm9kZS5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBUcnVlIG1ha2VzIHRoZSBjb250YWluZXIgZnVsbC13aWR0aCwgZmFsc2UgZml4ZWQtd2lkdGhcbiAgICovXG4gIGZsdWlkOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcblxuICAvKipcbiAgICogVGhpcyBpcyBpbiBjb21iaW5hdGlvbiB3aXRoIGZsdWlkIGVuYWJsZWRcbiAgICogVHJ1ZSBtYWtlcyBjb250YWluZXIgZmx1aWQgb25seSBpbiB4cywgbm90IHByZXNlbnQgbWVhbnMgZmx1aWQgZXZlcnl3aGVyZVxuICAgKi9cbiAgeHM6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGluIGNvbWJpbmF0aW9uIHdpdGggZmx1aWQgZW5hYmxlZFxuICAgKiBUcnVlIG1ha2VzIGNvbnRhaW5lciBmbHVpZCBvbmx5IGluIHNtLCBub3QgcHJlc2VudCBtZWFucyBmbHVpZCBldmVyeXdoZXJlXG4gICAqL1xuICBzbTogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgaW4gY29tYmluYXRpb24gd2l0aCBmbHVpZCBlbmFibGVkXG4gICAqIFRydWUgbWFrZXMgY29udGFpbmVyIGZsdWlkIG9ubHkgaW4gbWQsIG5vdCBwcmVzZW50IG1lYW5zIGZsdWlkIGV2ZXJ5d2hlcmVcbiAgICovXG4gIG1kOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcblxuICAvKipcbiAgICogVGhpcyBpcyBpbiBjb21iaW5hdGlvbiB3aXRoIGZsdWlkIGVuYWJsZWRcbiAgICogVHJ1ZSBtYWtlcyBjb250YWluZXIgZmx1aWQgb25seSBpbiBsZywgbm90IHByZXNlbnQgbWVhbnMgZmx1aWQgZXZlcnl3aGVyZVxuICAgKi9cbiAgbGc6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGluIGNvbWJpbmF0aW9uIHdpdGggZmx1aWQgZW5hYmxlZFxuICAgKiBUcnVlIG1ha2VzIGNvbnRhaW5lciBmbHVpZCBvbmx5IGluIHhsLCBub3QgcHJlc2VudCBtZWFucyBmbHVpZCBldmVyeXdoZXJlXG4gICAqL1xuICB4bDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgaW4gY29tYmluYXRpb24gd2l0aCBmbHVpZCBlbmFibGVkXG4gICAqIFRydWUgbWFrZXMgY29udGFpbmVyIGZsdWlkIG9ubHkgaW4geHhsLCBub3QgcHJlc2VudCBtZWFucyBmbHVpZCBldmVyeXdoZXJlXG4gICAqL1xuICB4eGw6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBzdHlsaW5nXG4gICAqL1xuICBzdHlsZTogX3Byb3BUeXBlcy5kZWZhdWx0Lm9iamVjdE9mKF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsIF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmddKSksXG5cbiAgLyoqXG4gICAqIFVzZSB5b3VyIG93biBjb21wb25lbnRcbiAgICovXG4gIGNvbXBvbmVudDogX3Byb3BUeXBlcy5kZWZhdWx0LmVsZW1lbnRUeXBlXG59O1xuQ29udGFpbmVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgZmx1aWQ6IGZhbHNlLFxuICB4czogZmFsc2UsXG4gIHNtOiBmYWxzZSxcbiAgbWQ6IGZhbHNlLFxuICBsZzogZmFsc2UsXG4gIHhsOiBmYWxzZSxcbiAgeHhsOiBmYWxzZSxcbiAgc3R5bGU6IHt9LFxuICBjb21wb25lbnQ6IF9wcmltaXRpdmVzLkRpdlxufTtcbnZhciBfZGVmYXVsdCA9IENvbnRhaW5lcjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRBZnRlclN0eWxlID0gZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQoX3JlZikge1xuICB2YXIgZmx1aWQgPSBfcmVmLmZsdWlkLFxuICAgICAgeHMgPSBfcmVmLnhzLFxuICAgICAgc20gPSBfcmVmLnNtLFxuICAgICAgbWQgPSBfcmVmLm1kLFxuICAgICAgbGcgPSBfcmVmLmxnLFxuICAgICAgeGwgPSBfcmVmLnhsLFxuICAgICAgeHhsID0gX3JlZi54eGwsXG4gICAgICBzY3JlZW5DbGFzcyA9IF9yZWYuc2NyZWVuQ2xhc3MsXG4gICAgICBjb250YWluZXJXaWR0aHMgPSBfcmVmLmNvbnRhaW5lcldpZHRocyxcbiAgICAgIGd1dHRlcldpZHRoID0gX3JlZi5ndXR0ZXJXaWR0aCxcbiAgICAgIG1vcmVTdHlsZSA9IF9yZWYubW9yZVN0eWxlO1xuICB2YXIgc3R5bGVzID0ge1xuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIG1hcmdpbkxlZnQ6ICdhdXRvJyxcbiAgICBtYXJnaW5SaWdodDogJ2F1dG8nLFxuICAgIHBhZGRpbmdMZWZ0OiBndXR0ZXJXaWR0aCAvIDIsXG4gICAgcGFkZGluZ1JpZ2h0OiBndXR0ZXJXaWR0aCAvIDJcbiAgfTtcblxuICBpZiAoZmx1aWQgJiYgIXNtICYmICFtZCAmJiAhbGcgJiYgIXhsKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3R5bGVzKSwgbW9yZVN0eWxlKTtcbiAgfVxuXG4gIGlmIChzY3JlZW5DbGFzcyA9PT0gJ3NtJyAmJiBjb250YWluZXJXaWR0aHNbMF0gJiYgIXNtICYmICF4cykge1xuICAgIHN0eWxlcy5tYXhXaWR0aCA9IGNvbnRhaW5lcldpZHRoc1swXTtcbiAgfVxuXG4gIGlmIChzY3JlZW5DbGFzcyA9PT0gJ21kJyAmJiBjb250YWluZXJXaWR0aHNbMV0gJiYgIW1kKSB7XG4gICAgc3R5bGVzLm1heFdpZHRoID0gY29udGFpbmVyV2lkdGhzWzFdO1xuICB9XG5cbiAgaWYgKHNjcmVlbkNsYXNzID09PSAnbGcnICYmIGNvbnRhaW5lcldpZHRoc1syXSAmJiAhbGcpIHtcbiAgICBzdHlsZXMubWF4V2lkdGggPSBjb250YWluZXJXaWR0aHNbMl07XG4gIH1cblxuICBpZiAoc2NyZWVuQ2xhc3MgPT09ICd4bCcgJiYgY29udGFpbmVyV2lkdGhzWzNdICYmICF4bCkge1xuICAgIHN0eWxlcy5tYXhXaWR0aCA9IGNvbnRhaW5lcldpZHRoc1szXTtcbiAgfVxuXG4gIGlmIChzY3JlZW5DbGFzcyA9PT0gJ3h4bCcgJiYgY29udGFpbmVyV2lkdGhzWzRdICYmICF4eGwpIHtcbiAgICBzdHlsZXMubWF4V2lkdGggPSBjb250YWluZXJXaWR0aHNbNF07XG4gIH1cblxuICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdHlsZXMpLCBtb3JlU3R5bGUpO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cbnZhciBnZXRBZnRlclN0eWxlID0gZnVuY3Rpb24gZ2V0QWZ0ZXJTdHlsZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBkaXNwbGF5OiAndGFibGUnLFxuICAgIGNsZWFyOiAnYm90aCdcbiAgfTtcbn07XG5cbmV4cG9ydHMuZ2V0QWZ0ZXJTdHlsZSA9IGdldEFmdGVyU3R5bGU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLkd1dHRlcldpZHRoQ29udGV4dCA9IHZvaWQgMDtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcblxudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcblxudmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vLi4vY29uZmlnXCIpO1xuXG52YXIgX3N0eWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zdHlsZVwiKSk7XG5cbnZhciBfcHJpbWl0aXZlcyA9IHJlcXVpcmUoXCIuLi8uLi9wcmltaXRpdmVzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIEd1dHRlcldpZHRoQ29udGV4dCA9IC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVDb250ZXh0KGZhbHNlKTtcblxuZXhwb3J0cy5HdXR0ZXJXaWR0aENvbnRleHQgPSBHdXR0ZXJXaWR0aENvbnRleHQ7XG5cbnZhciBSb3cgPSBmdW5jdGlvbiBSb3coX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgc3R5bGUgPSBfcmVmLnN0eWxlLFxuICAgICAgYWxpZ24gPSBfcmVmLmFsaWduLFxuICAgICAganVzdGlmeSA9IF9yZWYuanVzdGlmeSxcbiAgICAgIGRlYnVnID0gX3JlZi5kZWJ1ZyxcbiAgICAgIG5vZ3V0dGVyID0gX3JlZi5ub2d1dHRlcixcbiAgICAgIGd1dHRlcldpZHRoID0gX3JlZi5ndXR0ZXJXaWR0aCxcbiAgICAgIGNvbXBvbmVudCA9IF9yZWYuY29tcG9uZW50LFxuICAgICAgbm93cmFwID0gX3JlZi5ub3dyYXAsXG4gICAgICBvdGhlclByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwic3R5bGVcIiwgXCJhbGlnblwiLCBcImp1c3RpZnlcIiwgXCJkZWJ1Z1wiLCBcIm5vZ3V0dGVyXCIsIFwiZ3V0dGVyV2lkdGhcIiwgXCJjb21wb25lbnRcIiwgXCJub3dyYXBcIl0pO1xuXG4gIHZhciB0aGVHdXR0ZXJXaWR0aCA9ICgwLCBfY29uZmlnLmdldENvbmZpZ3VyYXRpb24pKCkuZ3V0dGVyV2lkdGg7XG4gIGlmIChub2d1dHRlcikgdGhlR3V0dGVyV2lkdGggPSAwO1xuICBpZiAodHlwZW9mIGd1dHRlcldpZHRoID09PSAnbnVtYmVyJykgdGhlR3V0dGVyV2lkdGggPSBndXR0ZXJXaWR0aDtcbiAgdmFyIHRoZVN0eWxlID0gKDAsIF9zdHlsZS5kZWZhdWx0KSh7XG4gICAgZ3V0dGVyV2lkdGg6IHRoZUd1dHRlcldpZHRoLFxuICAgIGFsaWduOiBhbGlnbixcbiAgICBqdXN0aWZ5OiBqdXN0aWZ5LFxuICAgIGRlYnVnOiBkZWJ1ZyxcbiAgICBtb3JlU3R5bGU6IHN0eWxlLFxuICAgIG5vd3JhcDogbm93cmFwXG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBfb2JqZWN0U3ByZWFkKHtcbiAgICBzdHlsZTogdGhlU3R5bGVcbiAgfSwgb3RoZXJQcm9wcyksIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEd1dHRlcldpZHRoQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB0aGVHdXR0ZXJXaWR0aFxuICB9LCBjaGlsZHJlbikpO1xufTtcblxuUm93LnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIENvbnRlbnQgb2YgdGhlIGVsZW1lbnRcbiAgICovXG4gIGNoaWxkcmVuOiBfcHJvcFR5cGVzLmRlZmF1bHQubm9kZS5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBWZXJ0aWNhbCBjb2x1bW4gYWxpZ25tZW50XG4gICAqL1xuICBhbGlnbjogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mKFsnbm9ybWFsJywgJ3N0YXJ0JywgJ2NlbnRlcicsICdlbmQnLCAnc3RyZXRjaCddKSxcblxuICAvKipcbiAgICogSG9yaXpvbnRhbCBjb2x1bW4gYWxpZ25tZW50XG4gICAqL1xuICBqdXN0aWZ5OiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2YoWydzdGFydCcsICdjZW50ZXInLCAnZW5kJywgJ2JldHdlZW4nLCAnYXJvdW5kJywgJ2luaXRpYWwnLCAnaW5oZXJpdCddKSxcblxuICAvKipcbiAgICogTm8gZ3V0dGVyIGZvciB0aGlzIHJvd1xuICAgKi9cbiAgbm9ndXR0ZXI6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gZ3V0dGVyIHdpZHRoIGZvciB0aGlzIHJvd1xuICAgKi9cbiAgZ3V0dGVyV2lkdGg6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIHN0eWxpbmdcbiAgICovXG4gIHN0eWxlOiBfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0T2YoX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlciwgX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZ10pKSxcblxuICAvKipcbiAgICogU2V0IHRvIGFwcGx5IHNvbWUgZGVidWcgc3R5bGluZ1xuICAgKi9cbiAgZGVidWc6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBVc2UgeW91ciBvd24gY29tcG9uZW50XG4gICAqL1xuICBjb21wb25lbnQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgY29scyBzaG91bGQgbm90IHdyYXBcbiAgICovXG4gIG5vd3JhcDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2xcbn07XG5Sb3cuZGVmYXVsdFByb3BzID0ge1xuICBhbGlnbjogJ25vcm1hbCcsXG4gIGp1c3RpZnk6ICdzdGFydCcsXG4gIG5vZ3V0dGVyOiBmYWxzZSxcbiAgZ3V0dGVyV2lkdGg6IG51bGwsXG4gIHN0eWxlOiB7fSxcbiAgZGVidWc6IGZhbHNlLFxuICBjb21wb25lbnQ6IF9wcmltaXRpdmVzLkRpdixcbiAgbm93cmFwOiBmYWxzZVxufTtcbnZhciBfZGVmYXVsdCA9IFJvdztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQoX3JlZikge1xuICB2YXIgZ3V0dGVyV2lkdGggPSBfcmVmLmd1dHRlcldpZHRoLFxuICAgICAgYWxpZ24gPSBfcmVmLmFsaWduLFxuICAgICAganVzdGlmeSA9IF9yZWYuanVzdGlmeSxcbiAgICAgIGRlYnVnID0gX3JlZi5kZWJ1ZyxcbiAgICAgIG1vcmVTdHlsZSA9IF9yZWYubW9yZVN0eWxlLFxuICAgICAgbm93cmFwID0gX3JlZi5ub3dyYXA7XG4gIC8vIFZlcnRpY2FsIGFsaWdubWVudFxuICB2YXIgYWxpZ25JdGVtcyA9IGFsaWduO1xuICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIGFsaWduSXRlbXMgPSAnZmxleC1zdGFydCc7XG4gIGlmIChhbGlnbiA9PT0gJ2VuZCcpIGFsaWduSXRlbXMgPSAnZmxleC1lbmQnOyAvLyBIb3Jpem9udGFsIGFsaWdubWVudFxuXG4gIHZhciBqdXN0aWZ5Q29udGVudCA9IGp1c3RpZnk7XG4gIGlmIChqdXN0aWZ5ID09PSAnc3RhcnQnKSBqdXN0aWZ5Q29udGVudCA9ICdmbGV4LXN0YXJ0JztcbiAgaWYgKGp1c3RpZnkgPT09ICdlbmQnKSBqdXN0aWZ5Q29udGVudCA9ICdmbGV4LWVuZCc7XG4gIGlmIChqdXN0aWZ5ID09PSAnYmV0d2VlbicpIGp1c3RpZnlDb250ZW50ID0gJ3NwYWNlLWJldHdlZW4nO1xuICBpZiAoanVzdGlmeSA9PT0gJ2Fyb3VuZCcpIGp1c3RpZnlDb250ZW50ID0gJ3NwYWNlLWFyb3VuZCc7XG4gIGlmIChqdXN0aWZ5ID09PSAnY2VudGVyJykganVzdGlmeUNvbnRlbnQgPSAnY2VudGVyJztcbiAgaWYgKGp1c3RpZnkgPT09ICdpbml0aWFsJykganVzdGlmeUNvbnRlbnQgPSAnaW5pdGlhbCc7XG4gIGlmIChqdXN0aWZ5ID09PSAnaW5oZXJpdCcpIGp1c3RpZnlDb250ZW50ID0gJ2luaGVyaXQnO1xuICB2YXIgc3R5bGVzID0ge1xuICAgIG1hcmdpbkxlZnQ6IC1ndXR0ZXJXaWR0aCAvIDIsXG4gICAgbWFyZ2luUmlnaHQ6IC1ndXR0ZXJXaWR0aCAvIDIsXG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGZsZXhXcmFwOiBub3dyYXAgPyAnbm93cmFwJyA6ICd3cmFwJyxcbiAgICBmbGV4R3JvdzogMCxcbiAgICBmbGV4U2hyaW5rOiAwLFxuICAgIGFsaWduSXRlbXM6IGFsaWduSXRlbXMsXG4gICAganVzdGlmeUNvbnRlbnQ6IGp1c3RpZnlDb250ZW50XG4gIH07XG5cbiAgaWYgKGRlYnVnKSB7XG4gICAgc3R5bGVzLmJhY2tncm91bmQgPSAncmdiYSgxMjgsMTI4LDEyOCwuMDUpJztcbiAgfVxuXG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0eWxlcyksIG1vcmVTdHlsZSk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29sXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Db2wuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb250YWluZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0NvbnRhaW5lci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJvd1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUm93LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSGlkZGVuXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9IaWRkZW4uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWaXNpYmxlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9WaXNpYmxlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2NyZWVuQ2xhc3NSZW5kZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1NjcmVlbkNsYXNzUmVuZGVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2NyZWVuQ2xhc3NQcm92aWRlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfU2NyZWVuQ2xhc3NQcm92aWRlci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNjcmVlbkNsYXNzQ29udGV4dFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfU2NyZWVuQ2xhc3NQcm92aWRlci5TY3JlZW5DbGFzc0NvbnRleHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2V0Q29uZmlndXJhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29uZmlnLnNldENvbmZpZ3VyYXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXNlU2NyZWVuQ2xhc3NcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3V0aWxzLnVzZVNjcmVlbkNsYXNzO1xuICB9XG59KTtcblxudmFyIF9Db2wgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2dyaWQvQ29sXCIpKTtcblxudmFyIF9Db250YWluZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2dyaWQvQ29udGFpbmVyXCIpKTtcblxudmFyIF9Sb3cgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2dyaWQvUm93XCIpKTtcblxudmFyIF9IaWRkZW4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxpdGllcy9IaWRkZW5cIikpO1xuXG52YXIgX1Zpc2libGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxpdGllcy9WaXNpYmxlXCIpKTtcblxudmFyIF9TY3JlZW5DbGFzc1JlbmRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbGl0aWVzL1NjcmVlbkNsYXNzUmVuZGVyXCIpKTtcblxudmFyIF9TY3JlZW5DbGFzc1Byb3ZpZGVyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vY29udGV4dC9TY3JlZW5DbGFzc1Byb3ZpZGVyXCIpKTtcblxudmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi9jb25maWdcIik7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZGVmYXVsdCA9ICdkaXYnO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2RlZmF1bHQgPSAnc3Bhbic7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuLyogZ2xvYmFsIHdpbmRvdyAqL1xudmFyIF9kZWZhdWx0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGl2XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9EaXYuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTcGFuXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9TcGFuLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV2luZG93XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9XaW5kb3cuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfRGl2ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9EaXZcIikpO1xuXG52YXIgX1NwYW4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1NwYW5cIikpO1xuXG52YXIgX1dpbmRvdyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vV2luZG93XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuXG52YXIgc3R5bGUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9zdHlsZVwiKSk7XG5cbnZhciBfU2NyZWVuQ2xhc3NSZXNvbHZlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL2NvbnRleHQvU2NyZWVuQ2xhc3NSZXNvbHZlclwiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBIaWRkZW4gPSBmdW5jdGlvbiBIaWRkZW4oX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgeHMgPSBfcmVmLnhzLFxuICAgICAgc20gPSBfcmVmLnNtLFxuICAgICAgbWQgPSBfcmVmLm1kLFxuICAgICAgbGcgPSBfcmVmLmxnLFxuICAgICAgeGwgPSBfcmVmLnhsLFxuICAgICAgeHhsID0gX3JlZi54eGw7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfU2NyZWVuQ2xhc3NSZXNvbHZlci5kZWZhdWx0LCBudWxsLCBmdW5jdGlvbiAoc2NyZWVuQ2xhc3MpIHtcbiAgICByZXR1cm4gc3R5bGUuaGlkZGVuKHtcbiAgICAgIHNjcmVlbkNsYXNzOiBzY3JlZW5DbGFzcyxcbiAgICAgIHhzOiB4cyxcbiAgICAgIHNtOiBzbSxcbiAgICAgIG1kOiBtZCxcbiAgICAgIGxnOiBsZyxcbiAgICAgIHhsOiB4bCxcbiAgICAgIHh4bDogeHhsXG4gICAgfSkgPyBudWxsIDogY2hpbGRyZW47XG4gIH0pO1xufTtcblxuSGlkZGVuLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIENvbnRlbnQgb2YgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgY2hpbGRyZW46IF9wcm9wVHlwZXMuZGVmYXVsdC5ub2RlLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIEhpZGUgb24gZXh0cmEgc21hbGwgZGV2aWNlc1xuICAgKi9cbiAgeHM6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBIaWRlIG9uIHNtYWxsIGRldmljZXNcbiAgICovXG4gIHNtOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcblxuICAvKipcbiAgICogSGlkZSBvbiBtZWRpdW0gZGV2aWNlc1xuICAgKi9cbiAgbWQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBIaWRlIG9uIGxhcmdlIGRldmljZXNcbiAgICovXG4gIGxnOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcblxuICAvKipcbiAgICogSGlkZSBvbiB4bGFyZ2UgZGV2aWNlc1xuICAgKi9cbiAgeGw6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBIaWRlIG9uIHh4bGFyZ2UgZGV2aWNlc1xuICAgKi9cbiAgeHhsOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbFxufTtcbkhpZGRlbi5kZWZhdWx0UHJvcHMgPSB7XG4gIHhzOiBmYWxzZSxcbiAgc206IGZhbHNlLFxuICBtZDogZmFsc2UsXG4gIGxnOiBmYWxzZSxcbiAgeGw6IGZhbHNlLFxuICB4eGw6IGZhbHNlXG59O1xudmFyIF9kZWZhdWx0ID0gSGlkZGVuO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLmhpZGRlbiA9IHZvaWQgMDtcblxudmFyIGhpZGRlbiA9IGZ1bmN0aW9uIGhpZGRlbihfcmVmKSB7XG4gIHZhciBzY3JlZW5DbGFzcyA9IF9yZWYuc2NyZWVuQ2xhc3MsXG4gICAgICB4cyA9IF9yZWYueHMsXG4gICAgICBzbSA9IF9yZWYuc20sXG4gICAgICBtZCA9IF9yZWYubWQsXG4gICAgICBsZyA9IF9yZWYubGcsXG4gICAgICB4bCA9IF9yZWYueGwsXG4gICAgICB4eGwgPSBfcmVmLnh4bDtcbiAgaWYgKHNjcmVlbkNsYXNzID09PSAneHhsJykgcmV0dXJuIHh4bDtcbiAgaWYgKHNjcmVlbkNsYXNzID09PSAneGwnKSByZXR1cm4geGw7XG4gIGlmIChzY3JlZW5DbGFzcyA9PT0gJ2xnJykgcmV0dXJuIGxnO1xuICBpZiAoc2NyZWVuQ2xhc3MgPT09ICdtZCcpIHJldHVybiBtZDtcbiAgaWYgKHNjcmVlbkNsYXNzID09PSAnc20nKSByZXR1cm4gc207XG4gIHJldHVybiB4cztcbn07XG5cbmV4cG9ydHMuaGlkZGVuID0gaGlkZGVuO1xudmFyIF9kZWZhdWx0ID0gaGlkZGVuO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfcHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG5cbnZhciBfU2NyZWVuQ2xhc3NSZXNvbHZlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL2NvbnRleHQvU2NyZWVuQ2xhc3NSZXNvbHZlclwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBTY3JlZW5DbGFzc1JlbmRlciA9IGZ1bmN0aW9uIFNjcmVlbkNsYXNzUmVuZGVyKF9yZWYpIHtcbiAgdmFyIHJlbmRlciA9IF9yZWYucmVuZGVyO1xuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX1NjcmVlbkNsYXNzUmVzb2x2ZXIuZGVmYXVsdCwgbnVsbCwgZnVuY3Rpb24gKHNjcmVlbkNsYXNzKSB7XG4gICAgcmV0dXJuIHJlbmRlcihzY3JlZW5DbGFzcyk7XG4gIH0pO1xufTtcblxuU2NyZWVuQ2xhc3NSZW5kZXIucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogVGhlIGZ1bmN0aW9uIHdoaWNoIHJldHVybiB2YWx1ZSB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKiBXaWxsIGJlIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudDogdGhlIHNjcmVlbiBjbGFzcy5cbiAgICovXG4gIHJlbmRlcjogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMuaXNSZXF1aXJlZFxufTtcbnZhciBfZGVmYXVsdCA9IFNjcmVlbkNsYXNzUmVuZGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcblxudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcblxudmFyIHN0eWxlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vc3R5bGVcIikpO1xuXG52YXIgX1NjcmVlbkNsYXNzUmVzb2x2ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9jb250ZXh0L1NjcmVlbkNsYXNzUmVzb2x2ZXJcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgVmlzaWJsZSA9IGZ1bmN0aW9uIFZpc2libGUoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgeHMgPSBfcmVmLnhzLFxuICAgICAgc20gPSBfcmVmLnNtLFxuICAgICAgbWQgPSBfcmVmLm1kLFxuICAgICAgbGcgPSBfcmVmLmxnLFxuICAgICAgeGwgPSBfcmVmLnhsLFxuICAgICAgeHhsID0gX3JlZi54eGw7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfU2NyZWVuQ2xhc3NSZXNvbHZlci5kZWZhdWx0LCBudWxsLCBmdW5jdGlvbiAoc2NyZWVuQ2xhc3MpIHtcbiAgICByZXR1cm4gIXN0eWxlLnZpc2libGUoe1xuICAgICAgc2NyZWVuQ2xhc3M6IHNjcmVlbkNsYXNzLFxuICAgICAgeHM6IHhzLFxuICAgICAgc206IHNtLFxuICAgICAgbWQ6IG1kLFxuICAgICAgbGc6IGxnLFxuICAgICAgeGw6IHhsLFxuICAgICAgeHhsOiB4eGxcbiAgICB9KSA/IG51bGwgOiBjaGlsZHJlbjtcbiAgfSk7XG59O1xuXG5WaXNpYmxlLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIENvbnRlbnQgb2YgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgY2hpbGRyZW46IF9wcm9wVHlwZXMuZGVmYXVsdC5ub2RlLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIFNob3cgb24gZXh0cmEgc21hbGwgZGV2aWNlc1xuICAgKi9cbiAgeHM6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBTaG93IG9uIHNtYWxsIGRldmljZXNcbiAgICovXG4gIHNtOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcblxuICAvKipcbiAgICogU2hvdyBvbiBtZWRpdW0gZGV2aWNlc1xuICAgKi9cbiAgbWQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBTaG93IG9uIGxhcmdlIGRldmljZXNcbiAgICovXG4gIGxnOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcblxuICAvKipcbiAgICogU2hvdyBvbiB4bGFyZ2UgZGV2aWNlc1xuICAgKi9cbiAgeGw6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBTaG93IG9uIHh4bGFyZ2UgZGV2aWNlc1xuICAgKi9cbiAgeHhsOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbFxufTtcblZpc2libGUuZGVmYXVsdFByb3BzID0ge1xuICB4czogZmFsc2UsXG4gIHNtOiBmYWxzZSxcbiAgbWQ6IGZhbHNlLFxuICBsZzogZmFsc2UsXG4gIHhsOiBmYWxzZSxcbiAgeHhsOiBmYWxzZVxufTtcbnZhciBfZGVmYXVsdCA9IFZpc2libGU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMudmlzaWJsZSA9IHZvaWQgMDtcblxudmFyIHZpc2libGUgPSBmdW5jdGlvbiB2aXNpYmxlKF9yZWYpIHtcbiAgdmFyIHNjcmVlbkNsYXNzID0gX3JlZi5zY3JlZW5DbGFzcyxcbiAgICAgIHhzID0gX3JlZi54cyxcbiAgICAgIHNtID0gX3JlZi5zbSxcbiAgICAgIG1kID0gX3JlZi5tZCxcbiAgICAgIGxnID0gX3JlZi5sZyxcbiAgICAgIHhsID0gX3JlZi54bCxcbiAgICAgIHh4bCA9IF9yZWYueHhsO1xuICBpZiAoc2NyZWVuQ2xhc3MgPT09ICd4eGwnKSByZXR1cm4geHhsO1xuICBpZiAoc2NyZWVuQ2xhc3MgPT09ICd4bCcpIHJldHVybiB4bDtcbiAgaWYgKHNjcmVlbkNsYXNzID09PSAnbGcnKSByZXR1cm4gbGc7XG4gIGlmIChzY3JlZW5DbGFzcyA9PT0gJ21kJykgcmV0dXJuIG1kO1xuICBpZiAoc2NyZWVuQ2xhc3MgPT09ICdzbScpIHJldHVybiBzbTtcbiAgcmV0dXJuIHhzO1xufTtcblxuZXhwb3J0cy52aXNpYmxlID0gdmlzaWJsZTtcbnZhciBfZGVmYXVsdCA9IHZpc2libGU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudXNlU2NyZWVuQ2xhc3MgPSBleHBvcnRzLnNjcmVlbkNsYXNzZXMgPSB2b2lkIDA7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG5cbnZhciBfY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuXG52YXIgX3ByaW1pdGl2ZXMgPSByZXF1aXJlKFwiLi9wcmltaXRpdmVzXCIpO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG52YXIgZ2V0Vmlld1BvcnQgPSBmdW5jdGlvbiBnZXRWaWV3UG9ydChzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSAmJiBzb3VyY2UuY3VycmVudCAmJiBzb3VyY2UuY3VycmVudC5jbGllbnRXaWR0aCkge1xuICAgIHJldHVybiBzb3VyY2UuY3VycmVudC5jbGllbnRXaWR0aDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgX3ByaW1pdGl2ZXMuV2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBfcHJpbWl0aXZlcy5XaW5kb3cuaW5uZXJXaWR0aCkge1xuICAgIHJldHVybiBfcHJpbWl0aXZlcy5XaW5kb3cuaW5uZXJXaWR0aDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIHNjcmVlbkNsYXNzZXMgPSBbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJywgJ3h4bCddO1xuZXhwb3J0cy5zY3JlZW5DbGFzc2VzID0gc2NyZWVuQ2xhc3NlcztcblxudmFyIHVzZVNjcmVlbkNsYXNzID0gZnVuY3Rpb24gdXNlU2NyZWVuQ2xhc3Moc291cmNlLCBmYWxsYmFja1NjcmVlbkNsYXNzKSB7XG4gIHZhciBnZXRTY3JlZW5DbGFzcyA9IGZ1bmN0aW9uIGdldFNjcmVlbkNsYXNzKCkge1xuICAgIHZhciBfZ2V0Q29uZmlndXJhdGlvbiA9ICgwLCBfY29uZmlnLmdldENvbmZpZ3VyYXRpb24pKCksXG4gICAgICAgIGJyZWFrcG9pbnRzID0gX2dldENvbmZpZ3VyYXRpb24uYnJlYWtwb2ludHMsXG4gICAgICAgIGRlZmF1bHRTY3JlZW5DbGFzcyA9IF9nZXRDb25maWd1cmF0aW9uLmRlZmF1bHRTY3JlZW5DbGFzcyxcbiAgICAgICAgbWF4U2NyZWVuQ2xhc3MgPSBfZ2V0Q29uZmlndXJhdGlvbi5tYXhTY3JlZW5DbGFzcztcblxuICAgIHZhciBuZXdTY3JlZW5DbGFzcyA9IGRlZmF1bHRTY3JlZW5DbGFzcztcbiAgICB2YXIgdmlld3BvcnQgPSBnZXRWaWV3UG9ydChzb3VyY2UpO1xuXG4gICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICBuZXdTY3JlZW5DbGFzcyA9ICd4cyc7XG4gICAgICBpZiAoYnJlYWtwb2ludHNbMF0gJiYgdmlld3BvcnQgPj0gYnJlYWtwb2ludHNbMF0pIG5ld1NjcmVlbkNsYXNzID0gJ3NtJztcbiAgICAgIGlmIChicmVha3BvaW50c1sxXSAmJiB2aWV3cG9ydCA+PSBicmVha3BvaW50c1sxXSkgbmV3U2NyZWVuQ2xhc3MgPSAnbWQnO1xuICAgICAgaWYgKGJyZWFrcG9pbnRzWzJdICYmIHZpZXdwb3J0ID49IGJyZWFrcG9pbnRzWzJdKSBuZXdTY3JlZW5DbGFzcyA9ICdsZyc7XG4gICAgICBpZiAoYnJlYWtwb2ludHNbM10gJiYgdmlld3BvcnQgPj0gYnJlYWtwb2ludHNbM10pIG5ld1NjcmVlbkNsYXNzID0gJ3hsJztcbiAgICAgIGlmIChicmVha3BvaW50c1s0XSAmJiB2aWV3cG9ydCA+PSBicmVha3BvaW50c1s0XSkgbmV3U2NyZWVuQ2xhc3MgPSAneHhsJztcbiAgICB9IGVsc2UgaWYgKGZhbGxiYWNrU2NyZWVuQ2xhc3MpIHtcbiAgICAgIG5ld1NjcmVlbkNsYXNzID0gZmFsbGJhY2tTY3JlZW5DbGFzcztcbiAgICB9XG5cbiAgICB2YXIgbmV3U2NyZWVuQ2xhc3NJbmRleCA9IHNjcmVlbkNsYXNzZXMuaW5kZXhPZihuZXdTY3JlZW5DbGFzcyk7XG4gICAgdmFyIG1heFNjcmVlbkNsYXNzSW5kZXggPSBzY3JlZW5DbGFzc2VzLmluZGV4T2YobWF4U2NyZWVuQ2xhc3MpO1xuXG4gICAgaWYgKG1heFNjcmVlbkNsYXNzSW5kZXggPj0gMCAmJiBuZXdTY3JlZW5DbGFzc0luZGV4ID4gbWF4U2NyZWVuQ2xhc3NJbmRleCkge1xuICAgICAgbmV3U2NyZWVuQ2xhc3MgPSBzY3JlZW5DbGFzc2VzW21heFNjcmVlbkNsYXNzSW5kZXhdO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdTY3JlZW5DbGFzcztcbiAgfTtcblxuICB2YXIgX3VzZVN0YXRlID0gKDAsIF9yZWFjdC51c2VTdGF0ZSkoZ2V0U2NyZWVuQ2xhc3MoKSksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIHNjcmVlbkNsYXNzID0gX3VzZVN0YXRlMlswXSxcbiAgICAgIHNldFNjcmVlbkNsYXNzID0gX3VzZVN0YXRlMlsxXTtcblxuICAoMCwgX3JlYWN0LnVzZUVmZmVjdCkoZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGVXaW5kb3dSZXNpemVkID0gZnVuY3Rpb24gaGFuZGxlV2luZG93UmVzaXplZCgpIHtcbiAgICAgIHJldHVybiBzZXRTY3JlZW5DbGFzcyhnZXRTY3JlZW5DbGFzcygpKTtcbiAgICB9O1xuXG4gICAgX3ByaW1pdGl2ZXMuV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVdpbmRvd1Jlc2l6ZWQsIGZhbHNlKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBfcHJpbWl0aXZlcy5XaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlV2luZG93UmVzaXplZCwgZmFsc2UpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHNjcmVlbkNsYXNzO1xufTtcblxuZXhwb3J0cy51c2VTY3JlZW5DbGFzcyA9IHVzZVNjcmVlbkNsYXNzOyIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3Jhcnlcbi8vICh1bnN0YWJsZSkgQVBJcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiBDYW4gd2UgcmVtb3ZlIHRoZSBzeW1ib2xzP1xuXG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpIDogMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmJsb2NrJykgOiAweGVhZDk7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJykgOiAweGVhZDU7XG52YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKSA6IDB4ZWFkNztcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IC8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcblxudmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbnZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcblxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCJmdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjeCBmcm9tICdjbHN4JztcbnZhciBERUZBVUxUX0NMQVNTID0gJ3JlYWN0LXRhYnNfX3RhYic7XG5cbnZhciBUYWIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoVGFiLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUYWIoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRhYi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5jaGVja0ZvY3VzKCk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB0aGlzLmNoZWNrRm9jdXMoKTtcbiAgfTtcblxuICBfcHJvdG8uY2hlY2tGb2N1cyA9IGZ1bmN0aW9uIGNoZWNrRm9jdXMoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgc2VsZWN0ZWQgPSBfdGhpcyRwcm9wcy5zZWxlY3RlZCxcbiAgICAgICAgZm9jdXMgPSBfdGhpcyRwcm9wcy5mb2N1cztcblxuICAgIGlmIChzZWxlY3RlZCAmJiBmb2N1cykge1xuICAgICAgdGhpcy5ub2RlLmZvY3VzKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9jeCxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMyLmNoaWxkcmVuLFxuICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczIuY2xhc3NOYW1lLFxuICAgICAgICBkaXNhYmxlZCA9IF90aGlzJHByb3BzMi5kaXNhYmxlZCxcbiAgICAgICAgZGlzYWJsZWRDbGFzc05hbWUgPSBfdGhpcyRwcm9wczIuZGlzYWJsZWRDbGFzc05hbWUsXG4gICAgICAgIGZvY3VzID0gX3RoaXMkcHJvcHMyLmZvY3VzLFxuICAgICAgICBpZCA9IF90aGlzJHByb3BzMi5pZCxcbiAgICAgICAgcGFuZWxJZCA9IF90aGlzJHByb3BzMi5wYW5lbElkLFxuICAgICAgICBzZWxlY3RlZCA9IF90aGlzJHByb3BzMi5zZWxlY3RlZCxcbiAgICAgICAgc2VsZWN0ZWRDbGFzc05hbWUgPSBfdGhpcyRwcm9wczIuc2VsZWN0ZWRDbGFzc05hbWUsXG4gICAgICAgIHRhYkluZGV4ID0gX3RoaXMkcHJvcHMyLnRhYkluZGV4LFxuICAgICAgICB0YWJSZWYgPSBfdGhpcyRwcm9wczIudGFiUmVmLFxuICAgICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMyLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiLCBcImRpc2FibGVkXCIsIFwiZGlzYWJsZWRDbGFzc05hbWVcIiwgXCJmb2N1c1wiLCBcImlkXCIsIFwicGFuZWxJZFwiLCBcInNlbGVjdGVkXCIsIFwic2VsZWN0ZWRDbGFzc05hbWVcIiwgXCJ0YWJJbmRleFwiLCBcInRhYlJlZlwiXSk7XG5cbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgICAgY2xhc3NOYW1lOiBjeChjbGFzc05hbWUsIChfY3ggPSB7fSwgX2N4W3NlbGVjdGVkQ2xhc3NOYW1lXSA9IHNlbGVjdGVkLCBfY3hbZGlzYWJsZWRDbGFzc05hbWVdID0gZGlzYWJsZWQsIF9jeCkpLFxuICAgICAgcmVmOiBmdW5jdGlvbiByZWYobm9kZSkge1xuICAgICAgICBfdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgaWYgKHRhYlJlZikgdGFiUmVmKG5vZGUpO1xuICAgICAgfSxcbiAgICAgIHJvbGU6IFwidGFiXCIsXG4gICAgICBpZDogaWQsXG4gICAgICBcImFyaWEtc2VsZWN0ZWRcIjogc2VsZWN0ZWQgPyAndHJ1ZScgOiAnZmFsc2UnLFxuICAgICAgXCJhcmlhLWRpc2FibGVkXCI6IGRpc2FibGVkID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBwYW5lbElkLFxuICAgICAgdGFiSW5kZXg6IHRhYkluZGV4IHx8IChzZWxlY3RlZCA/ICcwJyA6IG51bGwpXG4gICAgfSksIGNoaWxkcmVuKTtcbiAgfTtcblxuICByZXR1cm4gVGFiO1xufShDb21wb25lbnQpO1xuXG5UYWIuZGVmYXVsdFByb3BzID0ge1xuICBjbGFzc05hbWU6IERFRkFVTFRfQ0xBU1MsXG4gIGRpc2FibGVkQ2xhc3NOYW1lOiBERUZBVUxUX0NMQVNTICsgXCItLWRpc2FibGVkXCIsXG4gIGZvY3VzOiBmYWxzZSxcbiAgaWQ6IG51bGwsXG4gIHBhbmVsSWQ6IG51bGwsXG4gIHNlbGVjdGVkOiBmYWxzZSxcbiAgc2VsZWN0ZWRDbGFzc05hbWU6IERFRkFVTFRfQ0xBU1MgKyBcIi0tc2VsZWN0ZWRcIlxufTtcbmV4cG9ydCB7IFRhYiBhcyBkZWZhdWx0IH07XG5UYWIucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmFycmF5LCBQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmFycmF5LCBQcm9wVHlwZXMub2JqZWN0XSksXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgdGFiSW5kZXg6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGRpc2FibGVkQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBmb2N1czogUHJvcFR5cGVzLmJvb2wsXG4gIC8vIHByaXZhdGVcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8vIHByaXZhdGVcbiAgcGFuZWxJZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgLy8gcHJpdmF0ZVxuICBzZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wsXG4gIC8vIHByaXZhdGVcbiAgc2VsZWN0ZWRDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRhYlJlZjogUHJvcFR5cGVzLmZ1bmMgLy8gcHJpdmF0ZVxuXG59IDoge307XG5UYWIudGFic1JvbGUgPSAnVGFiJzsiLCJmdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjeCBmcm9tICdjbHN4JztcblxudmFyIFRhYkxpc3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoVGFiTGlzdCwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVGFiTGlzdCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVGFiTGlzdC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wcy5jbGFzc05hbWUsXG4gICAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIl0pO1xuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwidWxcIiwgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICAgIGNsYXNzTmFtZTogY3goY2xhc3NOYW1lKSxcbiAgICAgIHJvbGU6IFwidGFibGlzdFwiXG4gICAgfSksIGNoaWxkcmVuKTtcbiAgfTtcblxuICByZXR1cm4gVGFiTGlzdDtcbn0oQ29tcG9uZW50KTtcblxuVGFiTGlzdC5kZWZhdWx0UHJvcHMgPSB7XG4gIGNsYXNzTmFtZTogJ3JlYWN0LXRhYnNfX3RhYi1saXN0J1xufTtcbmV4cG9ydCB7IFRhYkxpc3QgYXMgZGVmYXVsdCB9O1xuVGFiTGlzdC5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuYXJyYXldKSxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYXJyYXksIFByb3BUeXBlcy5vYmplY3RdKVxufSA6IHt9O1xuVGFiTGlzdC50YWJzUm9sZSA9ICdUYWJMaXN0JzsiLCJmdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjeCBmcm9tICdjbHN4JztcbnZhciBERUZBVUxUX0NMQVNTID0gJ3JlYWN0LXRhYnNfX3RhYi1wYW5lbCc7XG5cbnZhciBUYWJQYW5lbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShUYWJQYW5lbCwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVGFiUGFuZWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRhYlBhbmVsLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfY3g7XG5cbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wcy5jbGFzc05hbWUsXG4gICAgICAgIGZvcmNlUmVuZGVyID0gX3RoaXMkcHJvcHMuZm9yY2VSZW5kZXIsXG4gICAgICAgIGlkID0gX3RoaXMkcHJvcHMuaWQsXG4gICAgICAgIHNlbGVjdGVkID0gX3RoaXMkcHJvcHMuc2VsZWN0ZWQsXG4gICAgICAgIHNlbGVjdGVkQ2xhc3NOYW1lID0gX3RoaXMkcHJvcHMuc2VsZWN0ZWRDbGFzc05hbWUsXG4gICAgICAgIHRhYklkID0gX3RoaXMkcHJvcHMudGFiSWQsXG4gICAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJmb3JjZVJlbmRlclwiLCBcImlkXCIsIFwic2VsZWN0ZWRcIiwgXCJzZWxlY3RlZENsYXNzTmFtZVwiLCBcInRhYklkXCJdKTtcblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgICAgY2xhc3NOYW1lOiBjeChjbGFzc05hbWUsIChfY3ggPSB7fSwgX2N4W3NlbGVjdGVkQ2xhc3NOYW1lXSA9IHNlbGVjdGVkLCBfY3gpKSxcbiAgICAgIHJvbGU6IFwidGFicGFuZWxcIixcbiAgICAgIGlkOiBpZCxcbiAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHRhYklkXG4gICAgfSksIGZvcmNlUmVuZGVyIHx8IHNlbGVjdGVkID8gY2hpbGRyZW4gOiBudWxsKTtcbiAgfTtcblxuICByZXR1cm4gVGFiUGFuZWw7XG59KENvbXBvbmVudCk7XG5cblRhYlBhbmVsLmRlZmF1bHRQcm9wcyA9IHtcbiAgY2xhc3NOYW1lOiBERUZBVUxUX0NMQVNTLFxuICBmb3JjZVJlbmRlcjogZmFsc2UsXG4gIHNlbGVjdGVkQ2xhc3NOYW1lOiBERUZBVUxUX0NMQVNTICsgXCItLXNlbGVjdGVkXCJcbn07XG5leHBvcnQgeyBUYWJQYW5lbCBhcyBkZWZhdWx0IH07XG5UYWJQYW5lbC5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYXJyYXksIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgZm9yY2VSZW5kZXI6IFByb3BUeXBlcy5ib29sLFxuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgLy8gcHJpdmF0ZVxuICBzZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wsXG4gIC8vIHByaXZhdGVcbiAgc2VsZWN0ZWRDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRhYklkOiBQcm9wVHlwZXMuc3RyaW5nIC8vIHByaXZhdGVcblxufSA6IHt9O1xuVGFiUGFuZWwudGFic1JvbGUgPSAnVGFiUGFuZWwnOyIsImZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY2hpbGRyZW5Qcm9wVHlwZSwgb25TZWxlY3RQcm9wVHlwZSwgc2VsZWN0ZWRJbmRleFByb3BUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9wcm9wVHlwZXMnO1xuaW1wb3J0IFVuY29udHJvbGxlZFRhYnMgZnJvbSAnLi9VbmNvbnRyb2xsZWRUYWJzJztcbmltcG9ydCB7IGdldFRhYnNDb3VudCB9IGZyb20gJy4uL2hlbHBlcnMvY291bnQnO1xudmFyIE1PREVfQ09OVFJPTExFRCA9IDA7XG52YXIgTU9ERV9VTkNPTlRST0xMRUQgPSAxO1xuXG52YXIgVGFicyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShUYWJzLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUYWJzKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5oYW5kbGVTZWxlY3RlZCA9IGZ1bmN0aW9uIChpbmRleCwgbGFzdCwgZXZlbnQpIHtcbiAgICAgIHZhciBvblNlbGVjdCA9IF90aGlzLnByb3BzLm9uU2VsZWN0O1xuICAgICAgdmFyIG1vZGUgPSBfdGhpcy5zdGF0ZS5tb2RlOyAvLyBDYWxsIGNoYW5nZSBldmVudCBoYW5kbGVyXG5cbiAgICAgIGlmICh0eXBlb2Ygb25TZWxlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNoYW5nZSBldmVudCBoYW5kbGVyIGNhbmNlbHMgdGhlIHRhYiBjaGFuZ2VcbiAgICAgICAgaWYgKG9uU2VsZWN0KGluZGV4LCBsYXN0LCBldmVudCkgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgLy8gU2V0IGZvY3VzIGlmIHRoZSBjaGFuZ2Ugd2FzIHRyaWdnZXJlZCBmcm9tIHRoZSBrZXlib2FyZFxuICAgICAgICBmb2N1czogZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nXG4gICAgICB9O1xuXG4gICAgICBpZiAobW9kZSA9PT0gTU9ERV9VTkNPTlRST0xMRUQpIHtcbiAgICAgICAgLy8gVXBkYXRlIHNlbGVjdGVkIGluZGV4XG4gICAgICAgIHN0YXRlLnNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5zdGF0ZSA9IFRhYnMuY29weVByb3BzVG9TdGF0ZShfdGhpcy5wcm9wcywge30sIHByb3BzLmRlZmF1bHRGb2N1cyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgVGFicy5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgcmV0dXJuIFRhYnMuY29weVByb3BzVG9TdGF0ZShwcm9wcywgc3RhdGUpO1xuICB9O1xuXG4gIFRhYnMuZ2V0TW9kZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldE1vZGVGcm9tUHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMuc2VsZWN0ZWRJbmRleCA9PT0gbnVsbCA/IE1PREVfVU5DT05UUk9MTEVEIDogTU9ERV9DT05UUk9MTEVEO1xuICB9O1xuXG4gIC8vIHByZXNlcnZlIHRoZSBleGlzdGluZyBzZWxlY3RlZEluZGV4IGZyb20gc3RhdGUuXG4gIC8vIElmIHRoZSBzdGF0ZSBoYXMgbm90IHNlbGVjdGVkSW5kZXgsIGRlZmF1bHQgdG8gdGhlIGRlZmF1bHRJbmRleCBvciAwXG4gIFRhYnMuY29weVByb3BzVG9TdGF0ZSA9IGZ1bmN0aW9uIGNvcHlQcm9wc1RvU3RhdGUocHJvcHMsIHN0YXRlLCBmb2N1cykge1xuICAgIGlmIChmb2N1cyA9PT0gdm9pZCAwKSB7XG4gICAgICBmb2N1cyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRlLm1vZGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZS5tb2RlICE9PSBUYWJzLmdldE1vZGVGcm9tUHJvcHMocHJvcHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTd2l0Y2hpbmcgYmV0d2VlbiBjb250cm9sbGVkIG1vZGUgKGJ5IHVzaW5nIGBzZWxlY3RlZEluZGV4YCkgYW5kIHVuY29udHJvbGxlZCBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYFRhYnNgLlxcbkZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGNvbnRyb2xsZWQgYW5kIHVuY29udHJvbGxlZCBtb2RlIG9mIHJlYWN0LXRhYnMgc2VlIHRoZSBSRUFETUUuXCIpO1xuICAgIH1cblxuICAgIHZhciBuZXdTdGF0ZSA9IHtcbiAgICAgIGZvY3VzOiBmb2N1cyxcbiAgICAgIG1vZGU6IFRhYnMuZ2V0TW9kZUZyb21Qcm9wcyhwcm9wcylcbiAgICB9O1xuXG4gICAgaWYgKG5ld1N0YXRlLm1vZGUgPT09IE1PREVfVU5DT05UUk9MTEVEKSB7XG4gICAgICB2YXIgbWF4VGFiSW5kZXggPSBnZXRUYWJzQ291bnQocHJvcHMuY2hpbGRyZW4pIC0gMTtcbiAgICAgIHZhciBzZWxlY3RlZEluZGV4ID0gbnVsbDtcblxuICAgICAgaWYgKHN0YXRlLnNlbGVjdGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBzZWxlY3RlZEluZGV4ID0gTWF0aC5taW4oc3RhdGUuc2VsZWN0ZWRJbmRleCwgbWF4VGFiSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0ZWRJbmRleCA9IHByb3BzLmRlZmF1bHRJbmRleCB8fCAwO1xuICAgICAgfVxuXG4gICAgICBuZXdTdGF0ZS5zZWxlY3RlZEluZGV4ID0gc2VsZWN0ZWRJbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH07XG5cbiAgdmFyIF9wcm90byA9IFRhYnMucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgZGVmYXVsdEluZGV4ID0gX3RoaXMkcHJvcHMuZGVmYXVsdEluZGV4LFxuICAgICAgICBkZWZhdWx0Rm9jdXMgPSBfdGhpcyRwcm9wcy5kZWZhdWx0Rm9jdXMsXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIFtcImNoaWxkcmVuXCIsIFwiZGVmYXVsdEluZGV4XCIsIFwiZGVmYXVsdEZvY3VzXCJdKTtcblxuICAgIHZhciBfdGhpcyRzdGF0ZSA9IHRoaXMuc3RhdGUsXG4gICAgICAgIGZvY3VzID0gX3RoaXMkc3RhdGUuZm9jdXMsXG4gICAgICAgIHNlbGVjdGVkSW5kZXggPSBfdGhpcyRzdGF0ZS5zZWxlY3RlZEluZGV4O1xuICAgIHByb3BzLmZvY3VzID0gZm9jdXM7XG4gICAgcHJvcHMub25TZWxlY3QgPSB0aGlzLmhhbmRsZVNlbGVjdGVkO1xuXG4gICAgaWYgKHNlbGVjdGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgcHJvcHMuc2VsZWN0ZWRJbmRleCA9IHNlbGVjdGVkSW5kZXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFVuY29udHJvbGxlZFRhYnMsIHByb3BzLCBjaGlsZHJlbik7XG4gIH07XG5cbiAgcmV0dXJuIFRhYnM7XG59KENvbXBvbmVudCk7XG5cblRhYnMuZGVmYXVsdFByb3BzID0ge1xuICBkZWZhdWx0Rm9jdXM6IGZhbHNlLFxuICBmb3JjZVJlbmRlclRhYlBhbmVsOiBmYWxzZSxcbiAgc2VsZWN0ZWRJbmRleDogbnVsbCxcbiAgZGVmYXVsdEluZGV4OiBudWxsXG59O1xuZXhwb3J0IHsgVGFicyBhcyBkZWZhdWx0IH07XG5UYWJzLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgY2hpbGRyZW46IGNoaWxkcmVuUHJvcFR5cGUsXG4gIGRpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsncnRsJywgJ2x0ciddKSxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYXJyYXksIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgZGVmYXVsdEZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcbiAgZGVmYXVsdEluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICBkaXNhYmxlZFRhYkNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZG9tUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgZm9yY2VSZW5kZXJUYWJQYW5lbDogUHJvcFR5cGVzLmJvb2wsXG4gIG9uU2VsZWN0OiBvblNlbGVjdFByb3BUeXBlLFxuICBzZWxlY3RlZEluZGV4OiBzZWxlY3RlZEluZGV4UHJvcFR5cGUsXG4gIHNlbGVjdGVkVGFiQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzZWxlY3RlZFRhYlBhbmVsQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nXG59IDoge307XG5UYWJzLnRhYnNSb2xlID0gJ1RhYnMnOyIsImZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHsgY2xvbmVFbGVtZW50LCBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgdXVpZCBmcm9tICcuLi9oZWxwZXJzL3V1aWQnO1xuaW1wb3J0IHsgY2hpbGRyZW5Qcm9wVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvcHJvcFR5cGVzJztcbmltcG9ydCB7IGdldFBhbmVsc0NvdW50IGFzIF9nZXRQYW5lbHNDb3VudCwgZ2V0VGFic0NvdW50IGFzIF9nZXRUYWJzQ291bnQgfSBmcm9tICcuLi9oZWxwZXJzL2NvdW50JztcbmltcG9ydCB7IGRlZXBNYXAgfSBmcm9tICcuLi9oZWxwZXJzL2NoaWxkcmVuRGVlcE1hcCc7XG5pbXBvcnQgeyBpc1RhYkxpc3QsIGlzVGFiUGFuZWwsIGlzVGFiIH0gZnJvbSAnLi4vaGVscGVycy9lbGVtZW50VHlwZXMnO1xuXG5mdW5jdGlvbiBpc05vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiAnZ2V0QXR0cmlidXRlJyBpbiBub2RlO1xufSAvLyBEZXRlcm1pbmUgaWYgYSBub2RlIGZyb20gZXZlbnQudGFyZ2V0IGlzIGEgVGFiIGVsZW1lbnRcblxuXG5mdW5jdGlvbiBpc1RhYk5vZGUobm9kZSkge1xuICByZXR1cm4gaXNOb2RlKG5vZGUpICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICd0YWInO1xufSAvLyBEZXRlcm1pbmUgaWYgYSB0YWIgbm9kZSBpcyBkaXNhYmxlZFxuXG5cbmZ1bmN0aW9uIGlzVGFiRGlzYWJsZWQobm9kZSkge1xuICByZXR1cm4gaXNOb2RlKG5vZGUpICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJykgPT09ICd0cnVlJztcbn1cblxudmFyIGNhblVzZUFjdGl2ZUVsZW1lbnQ7XG5cbnRyeSB7XG4gIGNhblVzZUFjdGl2ZUVsZW1lbnQgPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xufSBjYXRjaCAoZSkge1xuICAvLyBXb3JrIGFyb3VuZCBmb3IgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gIC8vIFJlZmVyIHRvIHRoZSBmb2xsb3dpbmcgcmVzb3VyY2VzOlxuICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMDk4Mjk2MC8zNjk2ODdcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTI3MzM1OTlcbiAgY2FuVXNlQWN0aXZlRWxlbWVudCA9IGZhbHNlO1xufVxuXG52YXIgVW5jb250cm9sbGVkVGFicyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShVbmNvbnRyb2xsZWRUYWJzLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBVbmNvbnRyb2xsZWRUYWJzKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9Db21wb25lbnQuY2FsbC5hcHBseShfQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLnRhYk5vZGVzID0gW107XG5cbiAgICBfdGhpcy5oYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBfdGhpcy5wcm9wcy5kaXJlY3Rpb247XG5cbiAgICAgIGlmIChfdGhpcy5pc1RhYkZyb21Db250YWluZXIoZS50YXJnZXQpKSB7XG4gICAgICAgIHZhciBpbmRleCA9IF90aGlzLnByb3BzLnNlbGVjdGVkSW5kZXg7XG4gICAgICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICB2YXIgdXNlU2VsZWN0ZWRJbmRleCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDMyIHx8IGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgdXNlU2VsZWN0ZWRJbmRleCA9IGZhbHNlO1xuXG4gICAgICAgICAgX3RoaXMuaGFuZGxlQ2xpY2soZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAzNyB8fCBlLmtleUNvZGUgPT09IDM4KSB7XG4gICAgICAgICAgLy8gU2VsZWN0IG5leHQgdGFiIHRvIHRoZSBsZWZ0XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgICAgICAgIGluZGV4ID0gX3RoaXMuZ2V0TmV4dFRhYihpbmRleCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gX3RoaXMuZ2V0UHJldlRhYihpbmRleCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgIHVzZVNlbGVjdGVkSW5kZXggPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gMzkgfHwgZS5rZXlDb2RlID09PSA0MCkge1xuICAgICAgICAgIC8vIFNlbGVjdCBuZXh0IHRhYiB0byB0aGUgcmlnaHRcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgICAgICAgaW5kZXggPSBfdGhpcy5nZXRQcmV2VGFiKGluZGV4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXggPSBfdGhpcy5nZXROZXh0VGFiKGluZGV4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgdXNlU2VsZWN0ZWRJbmRleCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09PSAzNSkge1xuICAgICAgICAgIC8vIFNlbGVjdCBsYXN0IHRhYiAoRW5kIGtleSlcbiAgICAgICAgICBpbmRleCA9IF90aGlzLmdldExhc3RUYWIoKTtcbiAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgdXNlU2VsZWN0ZWRJbmRleCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09PSAzNikge1xuICAgICAgICAgIC8vIFNlbGVjdCBmaXJzdCB0YWIgKEhvbWUga2V5KVxuICAgICAgICAgIGluZGV4ID0gX3RoaXMuZ2V0Rmlyc3RUYWIoKTtcbiAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgdXNlU2VsZWN0ZWRJbmRleCA9IHRydWU7XG4gICAgICAgIH0gLy8gVGhpcyBwcmV2ZW50cyBzY3JvbGxiYXJzIGZyb20gbW92aW5nIGFyb3VuZFxuXG5cbiAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IC8vIE9ubHkgdXNlIHRoZSBzZWxlY3RlZCBpbmRleCBpbiB0aGUgc3RhdGUgaWYgd2UncmUgbm90IHVzaW5nIHRoZSB0YWJiZWQgaW5kZXhcblxuXG4gICAgICAgIGlmICh1c2VTZWxlY3RlZEluZGV4KSB7XG4gICAgICAgICAgX3RoaXMuc2V0U2VsZWN0ZWQoaW5kZXgsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBub2RlID0gZS50YXJnZXQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKF90aGlzLmlzVGFiRnJvbUNvbnRhaW5lcihub2RlKSkge1xuICAgICAgICAgIGlmIChpc1RhYkRpc2FibGVkKG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluZGV4ID0gW10uc2xpY2UuY2FsbChub2RlLnBhcmVudE5vZGUuY2hpbGRyZW4pLmZpbHRlcihpc1RhYk5vZGUpLmluZGV4T2Yobm9kZSk7XG5cbiAgICAgICAgICBfdGhpcy5zZXRTZWxlY3RlZChpbmRleCwgZSk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG5cbiAgICAgIH0gd2hpbGUgKChub2RlID0gbm9kZS5wYXJlbnROb2RlKSAhPSBudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFVuY29udHJvbGxlZFRhYnMucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXRTZWxlY3RlZCA9IGZ1bmN0aW9uIHNldFNlbGVjdGVkKGluZGV4LCBldmVudCkge1xuICAgIC8vIENoZWNrIGluZGV4IGJvdW5kYXJ5XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmdldFRhYnNDb3VudCgpKSByZXR1cm47XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgb25TZWxlY3QgPSBfdGhpcyRwcm9wcy5vblNlbGVjdCxcbiAgICAgICAgc2VsZWN0ZWRJbmRleCA9IF90aGlzJHByb3BzLnNlbGVjdGVkSW5kZXg7IC8vIENhbGwgY2hhbmdlIGV2ZW50IGhhbmRsZXJcblxuICAgIG9uU2VsZWN0KGluZGV4LCBzZWxlY3RlZEluZGV4LCBldmVudCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldE5leHRUYWIgPSBmdW5jdGlvbiBnZXROZXh0VGFiKGluZGV4KSB7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5nZXRUYWJzQ291bnQoKTsgLy8gTG9vayBmb3Igbm9uLWRpc2FibGVkIHRhYiBmcm9tIGluZGV4IHRvIHRoZSBsYXN0IHRhYiBvbiB0aGUgcmlnaHRcblxuICAgIGZvciAodmFyIGkgPSBpbmRleCArIDE7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICBpZiAoIWlzVGFiRGlzYWJsZWQodGhpcy5nZXRUYWIoaSkpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH0gLy8gSWYgbm8gdGFiIGZvdW5kLCBjb250aW51ZSBzZWFyY2hpbmcgZnJvbSBmaXJzdCBvbiBsZWZ0IHRvIGluZGV4XG5cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBpbmRleDsgX2krKykge1xuICAgICAgaWYgKCFpc1RhYkRpc2FibGVkKHRoaXMuZ2V0VGFiKF9pKSkpIHtcbiAgICAgICAgcmV0dXJuIF9pO1xuICAgICAgfVxuICAgIH0gLy8gTm8gdGFicyBhcmUgZGlzYWJsZWQsIHJldHVybiBpbmRleFxuXG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG5cbiAgX3Byb3RvLmdldFByZXZUYWIgPSBmdW5jdGlvbiBnZXRQcmV2VGFiKGluZGV4KSB7XG4gICAgdmFyIGkgPSBpbmRleDsgLy8gTG9vayBmb3Igbm9uLWRpc2FibGVkIHRhYiBmcm9tIGluZGV4IHRvIGZpcnN0IHRhYiBvbiB0aGUgbGVmdFxuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKCFpc1RhYkRpc2FibGVkKHRoaXMuZ2V0VGFiKGkpKSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9IC8vIElmIG5vIHRhYiBmb3VuZCwgY29udGludWUgc2VhcmNoaW5nIGZyb20gbGFzdCB0YWIgb24gcmlnaHQgdG8gaW5kZXhcblxuXG4gICAgaSA9IHRoaXMuZ2V0VGFic0NvdW50KCk7XG5cbiAgICB3aGlsZSAoaS0tID4gaW5kZXgpIHtcbiAgICAgIGlmICghaXNUYWJEaXNhYmxlZCh0aGlzLmdldFRhYihpKSkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfSAvLyBObyB0YWJzIGFyZSBkaXNhYmxlZCwgcmV0dXJuIGluZGV4XG5cblxuICAgIHJldHVybiBpbmRleDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0Rmlyc3RUYWIgPSBmdW5jdGlvbiBnZXRGaXJzdFRhYigpIHtcbiAgICB2YXIgY291bnQgPSB0aGlzLmdldFRhYnNDb3VudCgpOyAvLyBMb29rIGZvciBub24gZGlzYWJsZWQgdGFiIGZyb20gdGhlIGZpcnN0IHRhYlxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICBpZiAoIWlzVGFiRGlzYWJsZWQodGhpcy5nZXRUYWIoaSkpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIF9wcm90by5nZXRMYXN0VGFiID0gZnVuY3Rpb24gZ2V0TGFzdFRhYigpIHtcbiAgICB2YXIgaSA9IHRoaXMuZ2V0VGFic0NvdW50KCk7IC8vIExvb2sgZm9yIG5vbiBkaXNhYmxlZCB0YWIgZnJvbSB0aGUgbGFzdCB0YWJcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmICghaXNUYWJEaXNhYmxlZCh0aGlzLmdldFRhYihpKSkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLmdldFRhYnNDb3VudCA9IGZ1bmN0aW9uIGdldFRhYnNDb3VudCgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIHJldHVybiBfZ2V0VGFic0NvdW50KGNoaWxkcmVuKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0UGFuZWxzQ291bnQgPSBmdW5jdGlvbiBnZXRQYW5lbHNDb3VudCgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIHJldHVybiBfZ2V0UGFuZWxzQ291bnQoY2hpbGRyZW4pO1xuICB9O1xuXG4gIF9wcm90by5nZXRUYWIgPSBmdW5jdGlvbiBnZXRUYWIoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy50YWJOb2Rlc1tcInRhYnMtXCIgKyBpbmRleF07XG4gIH07XG5cbiAgX3Byb3RvLmdldENoaWxkcmVuID0gZnVuY3Rpb24gZ2V0Q2hpbGRyZW4oKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzMi5jaGlsZHJlbixcbiAgICAgICAgZGlzYWJsZWRUYWJDbGFzc05hbWUgPSBfdGhpcyRwcm9wczIuZGlzYWJsZWRUYWJDbGFzc05hbWUsXG4gICAgICAgIGZvY3VzID0gX3RoaXMkcHJvcHMyLmZvY3VzLFxuICAgICAgICBmb3JjZVJlbmRlclRhYlBhbmVsID0gX3RoaXMkcHJvcHMyLmZvcmNlUmVuZGVyVGFiUGFuZWwsXG4gICAgICAgIHNlbGVjdGVkSW5kZXggPSBfdGhpcyRwcm9wczIuc2VsZWN0ZWRJbmRleCxcbiAgICAgICAgc2VsZWN0ZWRUYWJDbGFzc05hbWUgPSBfdGhpcyRwcm9wczIuc2VsZWN0ZWRUYWJDbGFzc05hbWUsXG4gICAgICAgIHNlbGVjdGVkVGFiUGFuZWxDbGFzc05hbWUgPSBfdGhpcyRwcm9wczIuc2VsZWN0ZWRUYWJQYW5lbENsYXNzTmFtZTtcbiAgICB0aGlzLnRhYklkcyA9IHRoaXMudGFiSWRzIHx8IFtdO1xuICAgIHRoaXMucGFuZWxJZHMgPSB0aGlzLnBhbmVsSWRzIHx8IFtdO1xuICAgIHZhciBkaWZmID0gdGhpcy50YWJJZHMubGVuZ3RoIC0gdGhpcy5nZXRUYWJzQ291bnQoKTsgLy8gQWRkIGlkcyBpZiBuZXcgdGFicyBoYXZlIGJlZW4gYWRkZWRcbiAgICAvLyBEb24ndCBib3RoZXIgcmVtb3ZpbmcgaWRzLCBqdXN0IGtlZXAgdGhlbSBpbiBjYXNlIHRoZXkgYXJlIGFkZGVkIGFnYWluXG4gICAgLy8gVGhpcyBpcyBtb3JlIGVmZmljaWVudCwgYW5kIGtlZXBzIHRoZSB1dWlkIGNvdW50ZXIgdW5kZXIgY29udHJvbFxuXG4gICAgd2hpbGUgKGRpZmYrKyA8IDApIHtcbiAgICAgIHRoaXMudGFiSWRzLnB1c2godXVpZCgpKTtcbiAgICAgIHRoaXMucGFuZWxJZHMucHVzaCh1dWlkKCkpO1xuICAgIH0gLy8gTWFwIGNoaWxkcmVuIHRvIGR5bmFtaWNhbGx5IHNldHVwIHJlZnNcblxuXG4gICAgcmV0dXJuIGRlZXBNYXAoY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGNoaWxkOyAvLyBDbG9uZSBUYWJMaXN0IGFuZCBUYWIgY29tcG9uZW50cyB0byBoYXZlIHJlZnNcblxuICAgICAgaWYgKGlzVGFiTGlzdChjaGlsZCkpIHtcbiAgICAgICAgdmFyIGxpc3RJbmRleCA9IDA7IC8vIEZpZ3VyZSBvdXQgaWYgdGhlIGN1cnJlbnQgZm9jdXMgaW4gdGhlIERPTSBpcyBzZXQgb24gYSBUYWJcbiAgICAgICAgLy8gSWYgaXQgaXMgd2Ugc2hvdWxkIGtlZXAgdGhlIGZvY3VzIG9uIHRoZSBuZXh0IHNlbGVjdGVkIHRhYlxuXG4gICAgICAgIHZhciB3YXNUYWJGb2N1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGNhblVzZUFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICB3YXNUYWJGb2N1c2VkID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheShjaGlsZC5wcm9wcy5jaGlsZHJlbikuZmlsdGVyKGlzVGFiKS5zb21lKGZ1bmN0aW9uICh0YWIsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBfdGhpczIuZ2V0VGFiKGkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgICAgY2hpbGRyZW46IGRlZXBNYXAoY2hpbGQucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uICh0YWIpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBcInRhYnMtXCIgKyBsaXN0SW5kZXg7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RlZEluZGV4ID09PSBsaXN0SW5kZXg7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgICAgIHRhYlJlZjogZnVuY3Rpb24gdGFiUmVmKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpczIudGFiTm9kZXNba2V5XSA9IG5vZGU7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGlkOiBfdGhpczIudGFiSWRzW2xpc3RJbmRleF0sXG4gICAgICAgICAgICAgIHBhbmVsSWQ6IF90aGlzMi5wYW5lbElkc1tsaXN0SW5kZXhdLFxuICAgICAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICAgICAgICAgIGZvY3VzOiBzZWxlY3RlZCAmJiAoZm9jdXMgfHwgd2FzVGFiRm9jdXNlZClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRUYWJDbGFzc05hbWUpIHByb3BzLnNlbGVjdGVkQ2xhc3NOYW1lID0gc2VsZWN0ZWRUYWJDbGFzc05hbWU7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWRUYWJDbGFzc05hbWUpIHByb3BzLmRpc2FibGVkQ2xhc3NOYW1lID0gZGlzYWJsZWRUYWJDbGFzc05hbWU7XG4gICAgICAgICAgICBsaXN0SW5kZXgrKztcbiAgICAgICAgICAgIHJldHVybiBjbG9uZUVsZW1lbnQodGFiLCBwcm9wcyk7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzVGFiUGFuZWwoY2hpbGQpKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICBpZDogX3RoaXMyLnBhbmVsSWRzW2luZGV4XSxcbiAgICAgICAgICB0YWJJZDogX3RoaXMyLnRhYklkc1tpbmRleF0sXG4gICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkSW5kZXggPT09IGluZGV4XG4gICAgICAgIH07XG4gICAgICAgIGlmIChmb3JjZVJlbmRlclRhYlBhbmVsKSBwcm9wcy5mb3JjZVJlbmRlciA9IGZvcmNlUmVuZGVyVGFiUGFuZWw7XG4gICAgICAgIGlmIChzZWxlY3RlZFRhYlBhbmVsQ2xhc3NOYW1lKSBwcm9wcy5zZWxlY3RlZENsYXNzTmFtZSA9IHNlbGVjdGVkVGFiUGFuZWxDbGFzc05hbWU7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHJlc3VsdCA9IGNsb25lRWxlbWVudChjaGlsZCwgcHJvcHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgYSBub2RlIGZyb20gZXZlbnQudGFyZ2V0IGlzIGEgVGFiIGVsZW1lbnQgZm9yIHRoZSBjdXJyZW50IFRhYnMgY29udGFpbmVyLlxuICAgKiBJZiB0aGUgY2xpY2tlZCBlbGVtZW50IGlzIG5vdCBhIFRhYiwgaXQgcmV0dXJucyBmYWxzZS5cbiAgICogSWYgaXQgZmluZHMgYW5vdGhlciBUYWJzIGNvbnRhaW5lciBiZXR3ZWVuIHRoZSBUYWIgYW5kIGB0aGlzYCwgaXQgcmV0dXJucyBmYWxzZS5cbiAgICovXG4gIF9wcm90by5pc1RhYkZyb21Db250YWluZXIgPSBmdW5jdGlvbiBpc1RhYkZyb21Db250YWluZXIobm9kZSkge1xuICAgIC8vIHJldHVybiBpbW1lZGlhdGVseSBpZiB0aGUgY2xpY2tlZCBlbGVtZW50IGlzIG5vdCBhIFRhYi5cbiAgICBpZiAoIWlzVGFiTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQ2hlY2sgaWYgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBUYWJzIGNvbnRhaW5lciBpcyBgdGhpc2Agb25lLlxuXG5cbiAgICB2YXIgbm9kZUFuY2VzdG9yID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuXG4gICAgZG8ge1xuICAgICAgaWYgKG5vZGVBbmNlc3RvciA9PT0gdGhpcy5ub2RlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChub2RlQW5jZXN0b3IuZ2V0QXR0cmlidXRlKCdkYXRhLXRhYnMnKSkgYnJlYWs7XG4gICAgICBub2RlQW5jZXN0b3IgPSBub2RlQW5jZXN0b3IucGFyZW50RWxlbWVudDtcbiAgICB9IHdoaWxlIChub2RlQW5jZXN0b3IpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAvLyBEZWxldGUgYWxsIGtub3duIHByb3BzLCBzbyB0aGV5IGRvbid0IGdldCBhZGRlZCB0byBET01cbiAgICB2YXIgX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczMuY2hpbGRyZW4sXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzMy5jbGFzc05hbWUsXG4gICAgICAgIGRpc2FibGVkVGFiQ2xhc3NOYW1lID0gX3RoaXMkcHJvcHMzLmRpc2FibGVkVGFiQ2xhc3NOYW1lLFxuICAgICAgICBkb21SZWYgPSBfdGhpcyRwcm9wczMuZG9tUmVmLFxuICAgICAgICBmb2N1cyA9IF90aGlzJHByb3BzMy5mb2N1cyxcbiAgICAgICAgZm9yY2VSZW5kZXJUYWJQYW5lbCA9IF90aGlzJHByb3BzMy5mb3JjZVJlbmRlclRhYlBhbmVsLFxuICAgICAgICBvblNlbGVjdCA9IF90aGlzJHByb3BzMy5vblNlbGVjdCxcbiAgICAgICAgc2VsZWN0ZWRJbmRleCA9IF90aGlzJHByb3BzMy5zZWxlY3RlZEluZGV4LFxuICAgICAgICBzZWxlY3RlZFRhYkNsYXNzTmFtZSA9IF90aGlzJHByb3BzMy5zZWxlY3RlZFRhYkNsYXNzTmFtZSxcbiAgICAgICAgc2VsZWN0ZWRUYWJQYW5lbENsYXNzTmFtZSA9IF90aGlzJHByb3BzMy5zZWxlY3RlZFRhYlBhbmVsQ2xhc3NOYW1lLFxuICAgICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMzLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiLCBcImRpc2FibGVkVGFiQ2xhc3NOYW1lXCIsIFwiZG9tUmVmXCIsIFwiZm9jdXNcIiwgXCJmb3JjZVJlbmRlclRhYlBhbmVsXCIsIFwib25TZWxlY3RcIiwgXCJzZWxlY3RlZEluZGV4XCIsIFwic2VsZWN0ZWRUYWJDbGFzc05hbWVcIiwgXCJzZWxlY3RlZFRhYlBhbmVsQ2xhc3NOYW1lXCJdKTtcblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgICAgY2xhc3NOYW1lOiBjeChjbGFzc05hbWUpLFxuICAgICAgb25DbGljazogdGhpcy5oYW5kbGVDbGljayxcbiAgICAgIG9uS2V5RG93bjogdGhpcy5oYW5kbGVLZXlEb3duLFxuICAgICAgcmVmOiBmdW5jdGlvbiByZWYobm9kZSkge1xuICAgICAgICBfdGhpczMubm9kZSA9IG5vZGU7XG4gICAgICAgIGlmIChkb21SZWYpIGRvbVJlZihub2RlKTtcbiAgICAgIH0sXG4gICAgICBcImRhdGEtdGFic1wiOiB0cnVlXG4gICAgfSksIHRoaXMuZ2V0Q2hpbGRyZW4oKSk7XG4gIH07XG5cbiAgcmV0dXJuIFVuY29udHJvbGxlZFRhYnM7XG59KENvbXBvbmVudCk7XG5cblVuY29udHJvbGxlZFRhYnMuZGVmYXVsdFByb3BzID0ge1xuICBjbGFzc05hbWU6ICdyZWFjdC10YWJzJyxcbiAgZm9jdXM6IGZhbHNlXG59O1xuZXhwb3J0IHsgVW5jb250cm9sbGVkVGFicyBhcyBkZWZhdWx0IH07XG5VbmNvbnRyb2xsZWRUYWJzLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgY2hpbGRyZW46IGNoaWxkcmVuUHJvcFR5cGUsXG4gIGRpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsncnRsJywgJ2x0ciddKSxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYXJyYXksIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgZGlzYWJsZWRUYWJDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGRvbVJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIGZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcbiAgZm9yY2VSZW5kZXJUYWJQYW5lbDogUHJvcFR5cGVzLmJvb2wsXG4gIG9uU2VsZWN0OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBzZWxlY3RlZEluZGV4OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIHNlbGVjdGVkVGFiQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzZWxlY3RlZFRhYlBhbmVsQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nXG59IDoge307IiwiZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmltcG9ydCB7IENoaWxkcmVuLCBjbG9uZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpc1RhYlBhbmVsLCBpc1RhYiwgaXNUYWJMaXN0IH0gZnJvbSAnLi9lbGVtZW50VHlwZXMnO1xuXG5mdW5jdGlvbiBpc1RhYkNoaWxkKGNoaWxkKSB7XG4gIHJldHVybiBpc1RhYihjaGlsZCkgfHwgaXNUYWJMaXN0KGNoaWxkKSB8fCBpc1RhYlBhbmVsKGNoaWxkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZXBNYXAoY2hpbGRyZW4sIGNhbGxiYWNrKSB7XG4gIHJldHVybiBDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIC8vIG51bGwgaGFwcGVucyB3aGVuIGNvbmRpdGlvbmFsbHkgcmVuZGVyaW5nIFRhYlBhbmVsL1RhYlxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC10YWJzL2lzc3Vlcy8zN1xuICAgIGlmIChjaGlsZCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAoaXNUYWJDaGlsZChjaGlsZCkpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkLnByb3BzICYmIGNoaWxkLnByb3BzLmNoaWxkcmVuICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5jaGlsZHJlbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIENsb25lIHRoZSBjaGlsZCB0aGF0IGhhcyBjaGlsZHJlbiBhbmQgbWFwIHRoZW0gdG9vXG4gICAgICByZXR1cm4gY2xvbmVFbGVtZW50KGNoaWxkLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNoaWxkLnByb3BzKSwge30sIHtcbiAgICAgICAgY2hpbGRyZW46IGRlZXBNYXAoY2hpbGQucHJvcHMuY2hpbGRyZW4sIGNhbGxiYWNrKVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGlsZDtcbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVlcEZvckVhY2goY2hpbGRyZW4sIGNhbGxiYWNrKSB7XG4gIHJldHVybiBDaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAvLyBudWxsIGhhcHBlbnMgd2hlbiBjb25kaXRpb25hbGx5IHJlbmRlcmluZyBUYWJQYW5lbC9UYWJcbiAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3QtdGFicy9pc3N1ZXMvMzdcbiAgICBpZiAoY2hpbGQgPT09IG51bGwpIHJldHVybjtcblxuICAgIGlmIChpc1RhYihjaGlsZCkgfHwgaXNUYWJQYW5lbChjaGlsZCkpIHtcbiAgICAgIGNhbGxiYWNrKGNoaWxkKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkLnByb3BzICYmIGNoaWxkLnByb3BzLmNoaWxkcmVuICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5jaGlsZHJlbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChpc1RhYkxpc3QoY2hpbGQpKSBjYWxsYmFjayhjaGlsZCk7XG4gICAgICBkZWVwRm9yRWFjaChjaGlsZC5wcm9wcy5jaGlsZHJlbiwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSk7XG59IiwiaW1wb3J0IHsgZGVlcEZvckVhY2ggfSBmcm9tICcuL2NoaWxkcmVuRGVlcE1hcCc7XG5pbXBvcnQgeyBpc1RhYiwgaXNUYWJQYW5lbCB9IGZyb20gJy4vZWxlbWVudFR5cGVzJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRUYWJzQ291bnQoY2hpbGRyZW4pIHtcbiAgdmFyIHRhYkNvdW50ID0gMDtcbiAgZGVlcEZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChpc1RhYihjaGlsZCkpIHRhYkNvdW50Kys7XG4gIH0pO1xuICByZXR1cm4gdGFiQ291bnQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFuZWxzQ291bnQoY2hpbGRyZW4pIHtcbiAgdmFyIHBhbmVsQ291bnQgPSAwO1xuICBkZWVwRm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGlzVGFiUGFuZWwoY2hpbGQpKSBwYW5lbENvdW50Kys7XG4gIH0pO1xuICByZXR1cm4gcGFuZWxDb3VudDtcbn0iLCJmdW5jdGlvbiBtYWtlVHlwZUNoZWNrZXIodGFic1JvbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuICEhZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS50YWJzUm9sZSA9PT0gdGFic1JvbGU7XG4gIH07XG59XG5cbmV4cG9ydCB2YXIgaXNUYWIgPSBtYWtlVHlwZUNoZWNrZXIoJ1RhYicpO1xuZXhwb3J0IHZhciBpc1RhYkxpc3QgPSBtYWtlVHlwZUNoZWNrZXIoJ1RhYkxpc3QnKTtcbmV4cG9ydCB2YXIgaXNUYWJQYW5lbCA9IG1ha2VUeXBlQ2hlY2tlcignVGFiUGFuZWwnKTsiLCJpbXBvcnQgeyBkZWVwRm9yRWFjaCB9IGZyb20gJy4vY2hpbGRyZW5EZWVwTWFwJztcbmltcG9ydCB7IGlzVGFiLCBpc1RhYkxpc3QsIGlzVGFiUGFuZWwgfSBmcm9tICcuL2VsZW1lbnRUeXBlcyc7XG5leHBvcnQgZnVuY3Rpb24gY2hpbGRyZW5Qcm9wVHlwZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgdmFyIGVycm9yO1xuICB2YXIgdGFic0NvdW50ID0gMDtcbiAgdmFyIHBhbmVsc0NvdW50ID0gMDtcbiAgdmFyIHRhYkxpc3RGb3VuZCA9IGZhbHNlO1xuICB2YXIgbGlzdFRhYnMgPSBbXTtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHNbcHJvcE5hbWVdO1xuICBkZWVwRm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGlzVGFiTGlzdChjaGlsZCkpIHtcbiAgICAgIGlmIChjaGlsZC5wcm9wcyAmJiBjaGlsZC5wcm9wcy5jaGlsZHJlbiAmJiB0eXBlb2YgY2hpbGQucHJvcHMuY2hpbGRyZW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGRlZXBGb3JFYWNoKGNoaWxkLnByb3BzLmNoaWxkcmVuLCBmdW5jdGlvbiAobGlzdENoaWxkKSB7XG4gICAgICAgICAgcmV0dXJuIGxpc3RUYWJzLnB1c2gobGlzdENoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0YWJMaXN0Rm91bmQpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJGb3VuZCBtdWx0aXBsZSAnVGFiTGlzdCcgY29tcG9uZW50cyBpbnNpZGUgJ1RhYnMnLiBPbmx5IG9uZSBpcyBhbGxvd2VkLlwiKTtcbiAgICAgIH1cblxuICAgICAgdGFiTGlzdEZvdW5kID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNUYWIoY2hpbGQpKSB7XG4gICAgICBpZiAoIXRhYkxpc3RGb3VuZCB8fCBsaXN0VGFicy5pbmRleE9mKGNoaWxkKSA9PT0gLTEpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJGb3VuZCBhICdUYWInIGNvbXBvbmVudCBvdXRzaWRlIG9mIHRoZSAnVGFiTGlzdCcgY29tcG9uZW50LiAnVGFiJyBjb21wb25lbnRzIFwiICsgXCJoYXZlIHRvIGJlIGluc2lkZSB0aGUgJ1RhYkxpc3QnIGNvbXBvbmVudC5cIik7XG4gICAgICB9XG5cbiAgICAgIHRhYnNDb3VudCsrO1xuICAgIH0gZWxzZSBpZiAoaXNUYWJQYW5lbChjaGlsZCkpIHtcbiAgICAgIHBhbmVsc0NvdW50Kys7XG4gICAgfVxuICB9KTtcblxuICBpZiAoIWVycm9yICYmIHRhYnNDb3VudCAhPT0gcGFuZWxzQ291bnQpIHtcbiAgICBlcnJvciA9IG5ldyBFcnJvcihcIlRoZXJlIHNob3VsZCBiZSBhbiBlcXVhbCBudW1iZXIgb2YgJ1RhYicgYW5kICdUYWJQYW5lbCcgaW4gYFwiICsgY29tcG9uZW50TmFtZSArIFwiYC4gXCIgKyAoXCJSZWNlaXZlZCBcIiArIHRhYnNDb3VudCArIFwiICdUYWInIGFuZCBcIiArIHBhbmVsc0NvdW50ICsgXCIgJ1RhYlBhbmVsJy5cIikpO1xuICB9XG5cbiAgcmV0dXJuIGVycm9yO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG9uU2VsZWN0UHJvcFR5cGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gIHZhciBwcm9wID0gcHJvcHNbcHJvcE5hbWVdO1xuICB2YXIgbmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcbiAgdmFyIGVycm9yID0gbnVsbDtcblxuICBpZiAocHJvcCAmJiB0eXBlb2YgcHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGVycm9yID0gbmV3IEVycm9yKFwiSW52YWxpZCBcIiArIGxvY2F0aW9uICsgXCIgYFwiICsgbmFtZSArIFwiYCBvZiB0eXBlIGBcIiArIHR5cGVvZiBwcm9wICsgXCJgIHN1cHBsaWVkIFwiICsgKFwidG8gYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCwgZXhwZWN0ZWQgYGZ1bmN0aW9uYC5cIikpO1xuICB9IGVsc2UgaWYgKHByb3BzLnNlbGVjdGVkSW5kZXggIT0gbnVsbCAmJiBwcm9wID09IG51bGwpIHtcbiAgICBlcnJvciA9IG5ldyBFcnJvcihcIlRoZSBcIiArIGxvY2F0aW9uICsgXCIgYFwiICsgbmFtZSArIFwiYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCwgYnV0IFwiICsgXCJpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAgb3IgYG51bGxgLlxcblwiICsgXCJgb25TZWxlY3RgIGlzIHJlcXVpcmVkIHdoZW4gYHNlbGVjdGVkSW5kZXhgIGlzIGFsc28gc2V0LiBOb3QgZG9pbmcgc28gd2lsbCBcIiArIFwibWFrZSB0aGUgdGFicyBub3QgZG8gYW55dGhpbmcsIGFzIGBzZWxlY3RlZEluZGV4YCBpbmRpY2F0ZXMgdGhhdCB5b3Ugd2FudCB0byBcIiArIFwiaGFuZGxlIHRoZSBzZWxlY3RlZCB0YWIgeW91cnNlbGYuXFxuXCIgKyBcIklmIHlvdSBvbmx5IHdhbnQgdG8gc2V0IHRoZSBpbml0YWwgdGFiIHJlcGxhY2UgYHNlbGVjdGVkSW5kZXhgIHdpdGggYGRlZmF1bHRJbmRleGAuXCIpO1xuICB9XG5cbiAgcmV0dXJuIGVycm9yO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdGVkSW5kZXhQcm9wVHlwZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgdmFyIHByb3AgPSBwcm9wc1twcm9wTmFtZV07XG4gIHZhciBuYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuICB2YXIgZXJyb3IgPSBudWxsO1xuXG4gIGlmIChwcm9wICE9IG51bGwgJiYgdHlwZW9mIHByb3AgIT09ICdudW1iZXInKSB7XG4gICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJJbnZhbGlkIFwiICsgbG9jYXRpb24gKyBcIiBgXCIgKyBuYW1lICsgXCJgIG9mIHR5cGUgYFwiICsgdHlwZW9mIHByb3AgKyBcImAgc3VwcGxpZWQgdG8gXCIgKyAoXCJgXCIgKyBjb21wb25lbnROYW1lICsgXCJgLCBleHBlY3RlZCBgbnVtYmVyYC5cIikpO1xuICB9IGVsc2UgaWYgKHByb3BzLmRlZmF1bHRJbmRleCAhPSBudWxsICYmIHByb3AgIT0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJUaGUgXCIgKyBsb2NhdGlvbiArIFwiIGBcIiArIG5hbWUgKyBcImAgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIgd2l0aCBgZGVmYXVsdEluZGV4YCBcIiArIChcImluIGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAuXFxuXCIpICsgKFwiRWl0aGVyIHJlbW92ZSBgXCIgKyBuYW1lICsgXCJgIHRvIGxldCBgXCIgKyBjb21wb25lbnROYW1lICsgXCJgIGhhbmRsZSB0aGUgc2VsZWN0ZWQgXCIpICsgXCJ0YWIgaW50ZXJuYWxseSBvciByZW1vdmUgYGRlZmF1bHRJbmRleGAgdG8gaGFuZGxlIGl0IHlvdXJzZWxmLlwiKTtcbiAgfVxuXG4gIHJldHVybiBlcnJvcjtcbn0iLCIvLyBHZXQgYSB1bml2ZXJzYWxseSB1bmlxdWUgaWRlbnRpZmllclxudmFyIGNvdW50ID0gMDtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHV1aWQoKSB7XG4gIHJldHVybiBcInJlYWN0LXRhYnMtXCIgKyBjb3VudCsrO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KCkge1xuICBjb3VudCA9IDA7XG59IiwiZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJzIH0gZnJvbSAnLi9jb21wb25lbnRzL1RhYnMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJMaXN0IH0gZnJvbSAnLi9jb21wb25lbnRzL1RhYkxpc3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWIgfSBmcm9tICcuL2NvbXBvbmVudHMvVGFiJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGFiUGFuZWwgfSBmcm9tICcuL2NvbXBvbmVudHMvVGFiUGFuZWwnO1xuZXhwb3J0IHsgcmVzZXQgYXMgcmVzZXRJZENvdW50ZXIgfSBmcm9tICcuL2hlbHBlcnMvdXVpZCc7IiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjFcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbmV4cG9ydHMuRnJhZ21lbnQgPSAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gMHhlYWQ5O1xudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIGV4cG9ydHMuRnJhZ21lbnQgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xuICBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2VydmVyLmJsb2NrJyk7XG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vcGFxdWUuaWQnKTtcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbn1cblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFIHx8IHR5cGVbMF0gPT09IFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50KSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWJDEgPSAganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLmpzeERFViA9IGpzeERFViQxO1xuICB9KSgpO1xufVxuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjFcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNy4wLjEnO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xuZXhwb3J0cy5GcmFnbWVudCA9IDB4ZWFjYjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IDB4ZWFjYztcbmV4cG9ydHMuUHJvZmlsZXIgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbmV4cG9ydHMuU3VzcGVuc2UgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBleHBvcnRzLkZyYWdtZW50ID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBleHBvcnRzLlN0cmljdE1vZGUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIGV4cG9ydHMuUHJvZmlsZXIgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBleHBvcnRzLlN1c3BlbnNlID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xuICBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2VydmVyLmJsb2NrJyk7XG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vcGFxdWUuaWQnKTtcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbn1cblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgZGlzcGF0Y2hlci5cbiAqL1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBiYXRjaCdzIGNvbmZpZ3VyYXRpb24gc3VjaCBhcyBob3cgbG9uZyBhbiB1cGRhdGVcbiAqIHNob3VsZCBzdXNwZW5kIGZvciBpZiBpdCBuZWVkcyB0by5cbiAqL1xudmFyIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnID0ge1xuICB0cmFuc2l0aW9uOiAwXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG52YXIgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IG51bGw7XG5mdW5jdGlvbiBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spIHtcbiAge1xuICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgfVxufVxuXG57XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAge1xuICAgICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICAgIH1cbiAgfTsgLy8gU3RhY2sgaW1wbGVtZW50YXRpb24gaW5qZWN0ZWQgYnkgdGhlIGN1cnJlbnQgcmVuZGVyZXIuXG5cblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnOyAvLyBBZGQgYW4gZXh0cmEgdG9wIGZyYW1lIHdoaWxlIGFuIGVsZW1lbnQgaXMgYmVpbmcgdmFsaWRhdGVkXG5cbiAgICBpZiAoY3VycmVudEV4dHJhU3RhY2tGcmFtZSkge1xuICAgICAgc3RhY2sgKz0gY3VycmVudEV4dHJhU3RhY2tGcmFtZTtcbiAgICB9IC8vIERlbGVnYXRlIHRvIHRoZSBpbmplY3RlZCByZW5kZXJlci1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvblxuXG5cbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuXG4gICAgaWYgKGltcGwpIHtcbiAgICAgIHN0YWNrICs9IGltcGwoKSB8fCAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG59XG5cbi8qKlxuICogVXNlZCBieSBhY3QoKSB0byB0cmFjayB3aGV0aGVyIHlvdSdyZSBpbnNpZGUgYW4gYWN0KCkgc2NvcGUuXG4gKi9cbnZhciBJc1NvbWVSZW5kZXJlckFjdGluZyA9IHtcbiAgY3VycmVudDogZmFsc2Vcbn07XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IHtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjogUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWc6IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLFxuICBSZWFjdEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXIsXG4gIElzU29tZVJlbmRlcmVyQWN0aW5nOiBJc1NvbWVSZW5kZXJlckFjdGluZyxcbiAgLy8gVXNlZCBieSByZW5kZXJlcnMgdG8gYXZvaWQgYnVuZGxpbmcgb2JqZWN0LWFzc2lnbiB0d2ljZSBpbiBVTUQgYnVuZGxlczpcbiAgYXNzaWduOiBfYXNzaWduXG59O1xuXG57XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lO1xufVxuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIChfY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgX2NvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyBcIi5cIiArIGNhbGxlck5hbWU7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXJyb3IoXCJDYW4ndCBjYWxsICVzIG9uIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHlldCBtb3VudGVkLiBcIiArICdUaGlzIGlzIGEgbm8tb3AsIGJ1dCBpdCBtaWdodCBpbmRpY2F0ZSBhIGJ1ZyBpbiB5b3VyIGFwcGxpY2F0aW9uLiAnICsgJ0luc3RlYWQsIGFzc2lnbiB0byBgdGhpcy5zdGF0ZWAgZGlyZWN0bHkgb3IgZGVmaW5lIGEgYHN0YXRlID0ge307YCAnICsgJ2NsYXNzIHByb3BlcnR5IHdpdGggdGhlIGRlc2lyZWQgc3RhdGUgaW4gdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cblxuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7IC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gIGlmICghKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwic2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuXCIgKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cblxuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuXG5cbntcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuXG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybignJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKTtcblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuXG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuLyoqXG4gKiBDb252ZW5pZW5jZSBjb21wb25lbnQgd2l0aCBkZWZhdWx0IHNoYWxsb3cgZXF1YWxpdHkgY2hlY2sgZm9yIHNDVS5cbiAqL1xuXG5mdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbnZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50OyAvLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cblxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcblxucHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbi8vIGFuIGltbXV0YWJsZSBvYmplY3Qgd2l0aCBhIHNpbmdsZSBtdXRhYmxlIHZhbHVlXG5mdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG4gIHZhciByZWZPYmplY3QgPSB7XG4gICAgY3VycmVudDogbnVsbFxuICB9O1xuXG4gIHtcbiAgICBPYmplY3Quc2VhbChyZWZPYmplY3QpO1xuICB9XG5cbiAgcmV0dXJuIHJlZk9iamVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5GcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgZXhwb3J0cy5Qcm9maWxlcjpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBleHBvcnRzLlN0cmljdE1vZGU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBleHBvcnRzLlN1c3BlbnNlOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biwgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgY29uZmlnLl9fc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gY29uZmlnLl9fc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBjb21wb25lbnROYW1lLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuXG4gICAgICB7XG4gICAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTsgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIGlmICghIShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArIGVsZW1lbnQgKyBcIi5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm9wTmFtZTsgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cblxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjsgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cblxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7IC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7IC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuXG5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuXG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0ga2V5LnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcblxuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgZWxlbWVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBlbGVtZW50IEEgZWxlbWVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0RWxlbWVudEtleShlbGVtZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0JyAmJiBlbGVtZW50ICE9PSBudWxsICYmIGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gZXNjYXBlKCcnICsgZWxlbWVudC5rZXkpO1xuICB9IC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG5cblxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuYW1lU29GYXIsIGNhbGxiYWNrKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIHZhciBfY2hpbGQgPSBjaGlsZHJlbjtcbiAgICB2YXIgbWFwcGVkQ2hpbGQgPSBjYWxsYmFjayhfY2hpbGQpOyAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3M6XG5cbiAgICB2YXIgY2hpbGRLZXkgPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0RWxlbWVudEtleShfY2hpbGQsIDApIDogbmFtZVNvRmFyO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgICB2YXIgZXNjYXBlZENoaWxkS2V5ID0gJyc7XG5cbiAgICAgIGlmIChjaGlsZEtleSAhPSBudWxsKSB7XG4gICAgICAgIGVzY2FwZWRDaGlsZEtleSA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShjaGlsZEtleSkgKyAnLyc7XG4gICAgICB9XG5cbiAgICAgIG1hcEludG9BcnJheShtYXBwZWRDaGlsZCwgYXJyYXksIGVzY2FwZWRDaGlsZEtleSwgJycsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICAgIG1hcHBlZENoaWxkID0gY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLCAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgICAgZXNjYXBlZFByZWZpeCArICggLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgIG1hcHBlZENoaWxkLmtleSAmJiAoIV9jaGlsZCB8fCBfY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBleGlzdGluZyBlbGVtZW50J3Mga2V5IGNhbiBiZSBhIG51bWJlclxuICAgICAgICBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoJycgKyBtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgICAgfVxuXG4gICAgICBhcnJheS5wdXNoKG1hcHBlZENoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cblxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGl0ZXJhYmxlQ2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGl0ZXJhYmxlQ2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgICAgd2FybignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGl0ZXJhYmxlQ2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaWkgPSAwO1xuXG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSAnJyArIGNoaWxkcmVuO1xuXG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZykgKyBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBjb3VudCA9IDA7XG4gIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCAnJywgJycsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGNvdW50KyspO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cblxuXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBuID0gMDtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBuKys7IC8vIERvbid0IHJldHVybiBhbnl0aGluZ1xuICB9KTtcbiAgcmV0dXJuIG47XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBmb3JFYWNoRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmcuXG4gIH0sIGZvckVhY2hDb250ZXh0KTtcbn1cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVudG9hcnJheVxuICovXG5cblxuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICByZXR1cm4gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZDtcbiAgfSkgfHwgW107XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5cblxuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBjYWxjdWxhdGVDaGFuZ2VkQml0cykge1xuICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgIT09IG51bGwgJiYgdHlwZW9mIGNhbGN1bGF0ZUNoYW5nZWRCaXRzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdjcmVhdGVDb250ZXh0OiBFeHBlY3RlZCB0aGUgb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjYWxjdWxhdGVDaGFuZ2VkQml0cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNhbGN1bGF0ZUNoYW5nZWRCaXRzLFxuICAgIC8vIEFzIGEgd29ya2Fyb3VuZCB0byBzdXBwb3J0IG11bHRpcGxlIGNvbmN1cnJlbnQgcmVuZGVyZXJzLCB3ZSBjYXRlZ29yaXplXG4gICAgLy8gc29tZSByZW5kZXJlcnMgYXMgcHJpbWFyeSBhbmQgb3RoZXJzIGFzIHNlY29uZGFyeS4gV2Ugb25seSBleHBlY3RcbiAgICAvLyB0aGVyZSB0byBiZSB0d28gY29uY3VycmVudCByZW5kZXJlcnMgYXQgbW9zdDogUmVhY3QgTmF0aXZlIChwcmltYXJ5KSBhbmRcbiAgICAvLyBGYWJyaWMgKHNlY29uZGFyeSk7IFJlYWN0IERPTSAocHJpbWFyeSkgYW5kIFJlYWN0IEFSVCAoc2Vjb25kYXJ5KS5cbiAgICAvLyBTZWNvbmRhcnkgcmVuZGVyZXJzIHN0b3JlIHRoZWlyIGNvbnRleHQgdmFsdWVzIG9uIHNlcGFyYXRlIGZpZWxkcy5cbiAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICAvLyBVc2VkIHRvIHRyYWNrIGhvdyBtYW55IGNvbmN1cnJlbnQgcmVuZGVyZXJzIHRoaXMgY29udGV4dCBjdXJyZW50bHlcbiAgICAvLyBzdXBwb3J0cyB3aXRoaW4gaW4gYSBzaW5nbGUgcmVuZGVyZXIuIFN1Y2ggYXMgcGFyYWxsZWwgc2VydmVyIHJlbmRlcmluZy5cbiAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgLy8gVGhlc2UgYXJlIGNpcmN1bGFyXG4gICAgUHJvdmlkZXI6IG51bGwsXG4gICAgQ29uc3VtZXI6IG51bGxcbiAgfTtcbiAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICBfY29udGV4dDogY29udGV4dFxuICB9O1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IGZhbHNlO1xuXG4gIHtcbiAgICAvLyBBIHNlcGFyYXRlIG9iamVjdCwgYnV0IHByb3hpZXMgYmFjayB0byB0aGUgb3JpZ2luYWwgY29udGV4dCBvYmplY3QgZm9yXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEl0IGhhcyBhIGRpZmZlcmVudCAkJHR5cGVvZiwgc28gd2UgY2FuIHByb3Blcmx5XG4gICAgLy8gd2FybiBmb3IgdGhlIGluY29ycmVjdCB1c2FnZSBvZiBDb250ZXh0IGFzIGEgQ29uc3VtZXIuXG4gICAgdmFyIENvbnN1bWVyID0ge1xuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjb250ZXh0Ll9jYWxjdWxhdGVDaGFuZ2VkQml0c1xuICAgIH07IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG5vdCBzZXR0aW5nIGEgdmFsdWUsIHdoaWNoIGlzIGludGVudGlvbmFsIGhlcmVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbnN1bWVyLCB7XG4gICAgICBQcm92aWRlcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuUHJvdmlkZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuUHJvdmlkZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuUHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9Qcm92aWRlcikge1xuICAgICAgICAgIGNvbnRleHQuUHJvdmlkZXIgPSBfUHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBfY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZTI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUyKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IF9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3RocmVhZENvdW50OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll90aHJlYWRDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX3RocmVhZENvdW50KSB7XG4gICAgICAgICAgY29udGV4dC5fdGhyZWFkQ291bnQgPSBfdGhyZWFkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDb25zdW1lcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuQ29uc3VtZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuQ29uc3VtZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkaXNwbGF5TmFtZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXNwbGF5TmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyKSB7XG4gICAgICAgICAgICB3YXJuKCdTZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gQ29udGV4dC5Db25zdW1lciBoYXMgbm8gZWZmZWN0LiAnICsgXCJZb3Ugc2hvdWxkIHNldCBpdCBkaXJlY3RseSBvbiB0aGUgY29udGV4dCB3aXRoIENvbnRleHQuZGlzcGxheU5hbWUgPSAnJXMnLlwiLCBkaXNwbGF5TmFtZSk7XG5cbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbWlzc2luZyBwcm9wZXJ0aWVzIGJlY2F1c2UgaXQgZG9lc24ndCB1bmRlcnN0YW5kIGRlZmluZVByb3BlcnR5XG5cbiAgICBjb250ZXh0LkNvbnN1bWVyID0gQ29uc3VtZXI7XG4gIH1cblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG52YXIgVW5pbml0aWFsaXplZCA9IC0xO1xudmFyIFBlbmRpbmcgPSAwO1xudmFyIFJlc29sdmVkID0gMTtcbnZhciBSZWplY3RlZCA9IDI7XG5cbmZ1bmN0aW9uIGxhenlJbml0aWFsaXplcihwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICB2YXIgY3RvciA9IHBheWxvYWQuX3Jlc3VsdDtcbiAgICB2YXIgdGhlbmFibGUgPSBjdG9yKCk7IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG5cbiAgICB2YXIgcGVuZGluZyA9IHBheWxvYWQ7XG4gICAgcGVuZGluZy5fc3RhdHVzID0gUGVuZGluZztcbiAgICBwZW5kaW5nLl9yZXN1bHQgPSB0aGVuYWJsZTtcbiAgICB0aGVuYWJsZS50aGVuKGZ1bmN0aW9uIChtb2R1bGVPYmplY3QpIHtcbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRFeHBvcnQgPSBtb2R1bGVPYmplY3QuZGVmYXVsdDtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRFeHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyb3IoJ2xhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcG9ydCgpIGNhbGwuICcgKyAnSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICAnICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgICdjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wJyArIFwib3J0KCcuL015Q29tcG9uZW50JykpXCIsIG1vZHVsZU9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG5cblxuICAgICAgICB2YXIgcmVzb2x2ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZXNvbHZlZC5fc3RhdHVzID0gUmVzb2x2ZWQ7XG4gICAgICAgIHJlc29sdmVkLl9yZXN1bHQgPSBkZWZhdWx0RXhwb3J0O1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZWplY3RlZC5fc3RhdHVzID0gUmVqZWN0ZWQ7XG4gICAgICAgIHJlamVjdGVkLl9yZXN1bHQgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFJlc29sdmVkKSB7XG4gICAgcmV0dXJuIHBheWxvYWQuX3Jlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBwYXlsb2FkLl9yZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGF6eShjdG9yKSB7XG4gIHZhciBwYXlsb2FkID0ge1xuICAgIC8vIFdlIHVzZSB0aGVzZSBmaWVsZHMgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAgICBfc3RhdHVzOiAtMSxcbiAgICBfcmVzdWx0OiBjdG9yXG4gIH07XG4gIHZhciBsYXp5VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgIF9wYXlsb2FkOiBwYXlsb2FkLFxuICAgIF9pbml0OiBsYXp5SW5pdGlhbGl6ZXJcbiAgfTtcblxuICB7XG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCBqdXN0IHNldCBpdCBvbiB0aGUgb2JqZWN0LlxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgdmFyIHByb3BUeXBlczsgLy8gJEZsb3dGaXhNZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobGF6eVR5cGUsIHtcbiAgICAgIGRlZmF1bHRQcm9wczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0UHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0RlZmF1bHRQcm9wcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBkZWZhdWx0UHJvcHNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBkZWZhdWx0UHJvcHMgPSBuZXdEZWZhdWx0UHJvcHM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ2RlZmF1bHRQcm9wcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3BUeXBlczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wVHlwZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1Byb3BUeXBlcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBwcm9wVHlwZXNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBwcm9wVHlwZXMgPSBuZXdQcm9wVHlwZXM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ3Byb3BUeXBlcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGxhenlUeXBlO1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICB7XG4gICAgaWYgKHJlbmRlciAhPSBudWxsICYmIHJlbmRlci4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgJyArICdjb21wb25lbnQuIEluc3RlYWQgb2YgZm9yd2FyZFJlZihtZW1vKC4uLikpLCB1c2UgJyArICdtZW1vKGZvcndhcmRSZWYoLi4uKSkuJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVuZGVyLmxlbmd0aCAhPT0gMCAmJiByZW5kZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgYWNjZXB0IGV4YWN0bHkgdHdvIHBhcmFtZXRlcnM6IHByb3BzIGFuZCByZWYuICVzJywgcmVuZGVyLmxlbmd0aCA9PT0gMSA/ICdEaWQgeW91IGZvcmdldCB0byB1c2UgdGhlIHJlZiBwYXJhbWV0ZXI/JyA6ICdBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICBpZiAocmVuZGVyLmRlZmF1bHRQcm9wcyAhPSBudWxsIHx8IHJlbmRlci5wcm9wVHlwZXMgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGRvIG5vdCBzdXBwb3J0IHByb3BUeXBlcyBvciBkZWZhdWx0UHJvcHMuICcgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIFJlYWN0IGNvbXBvbmVudD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gICAgcmVuZGVyOiByZW5kZXJcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGlmIChyZW5kZXIuZGlzcGxheU5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJlbmRlci5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQgfHwgdHlwZSA9PT0gZXhwb3J0cy5Qcm9maWxlciB8fCB0eXBlID09PSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSB8fCB0eXBlID09PSBleHBvcnRzLlN0cmljdE1vZGUgfHwgdHlwZSA9PT0gZXhwb3J0cy5TdXNwZW5zZSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUgfHwgdHlwZVswXSA9PT0gUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWVtbyh0eXBlLCBjb21wYXJlKSB7XG4gIHtcbiAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSkge1xuICAgICAgZXJyb3IoJ21lbW86IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgY29tcG9uZW50LiBJbnN0ZWFkICcgKyAncmVjZWl2ZWQ6ICVzJywgdHlwZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB0eXBlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX01FTU9fVFlQRSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGNvbXBhcmU6IGNvbXBhcmUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb21wYXJlXG4gIH07XG5cbiAge1xuICAgIHZhciBvd25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvd25OYW1lID0gbmFtZTtcblxuICAgICAgICBpZiAodHlwZS5kaXNwbGF5TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZURpc3BhdGNoZXIoKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuXG4gIGlmICghKGRpc3BhdGNoZXIgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlcjtcbn1cblxuZnVuY3Rpb24gdXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuXG4gIHtcbiAgICBpZiAodW5zdGFibGVfb2JzZXJ2ZWRCaXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yKCd1c2VDb250ZXh0KCkgc2Vjb25kIGFyZ3VtZW50IGlzIHJlc2VydmVkIGZvciBmdXR1cmUgJyArICd1c2UgaW4gUmVhY3QuIFBhc3NpbmcgaXQgaXMgbm90IHN1cHBvcnRlZC4gJyArICdZb3UgcGFzc2VkOiAlcy4lcycsIHVuc3RhYmxlX29ic2VydmVkQml0cywgdHlwZW9mIHVuc3RhYmxlX29ic2VydmVkQml0cyA9PT0gJ251bWJlcicgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMl0pID8gJ1xcblxcbkRpZCB5b3UgY2FsbCBhcnJheS5tYXAodXNlQ29udGV4dCk/ICcgKyAnQ2FsbGluZyBIb29rcyBpbnNpZGUgYSBsb29wIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3MnIDogJycpO1xuICAgIH0gLy8gVE9ETzogYWRkIGEgbW9yZSBnZW5lcmljIHdhcm5pbmcgZm9yIGludmFsaWQgdmFsdWVzLlxuXG5cbiAgICBpZiAoQ29udGV4dC5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmVhbENvbnRleHQgPSBDb250ZXh0Ll9jb250ZXh0OyAvLyBEb24ndCBkZWR1cGxpY2F0ZSBiZWNhdXNlIHRoaXMgbGVnaXRpbWF0ZWx5IGNhdXNlcyBidWdzXG4gICAgICAvLyBhbmQgbm9ib2R5IHNob3VsZCBiZSB1c2luZyB0aGlzIGluIGV4aXN0aW5nIGNvZGUuXG5cbiAgICAgIGlmIChyZWFsQ29udGV4dC5Db25zdW1lciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuQ29uc3VtZXIpIGlzIG5vdCBzdXBwb3J0ZWQsIG1heSBjYXVzZSBidWdzLCBhbmQgd2lsbCBiZSAnICsgJ3JlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfSBlbHNlIGlmIChyZWFsQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuUHJvdmlkZXIpIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNvbnRleHQoQ29udGV4dCwgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzKTtcbn1cbmZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xufVxuZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZihpbml0aWFsVmFsdWUpO1xufVxuZnVuY3Rpb24gdXNlRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VNZW1vKGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZU1lbW8oY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pO1xuICB9XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5TdXNwZW5zZTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcy5fX3NvdXJjZSk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmZvO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICB9XG5cbiAge1xuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcblxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhwcm9wcyk7XG5cbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBlcnJvcignUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgaWYgKHZhbGlkVHlwZSkge1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50KSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG52YXIgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSBmYWxzZTtcbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAge1xuICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkpIHtcbiAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gdHJ1ZTtcblxuICAgICAgd2FybignUmVhY3QuY3JlYXRlRmFjdG9yeSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIENvbnNpZGVyIHVzaW5nIEpTWCAnICsgJ29yIHVzZSBSZWFjdC5jcmVhdGVFbGVtZW50KCkgZGlyZWN0bHkgaW5zdGVhZC4nKTtcbiAgICB9IC8vIExlZ2FjeSBob29rOiByZW1vdmUgaXRcblxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybignRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbn1cbmZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgbmV3RWxlbWVudCA9IGNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICB9XG5cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG57XG5cbiAgdHJ5IHtcbiAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG5cbiAgICBuZXcgTWFwKFtbZnJvemVuT2JqZWN0LCBudWxsXV0pO1xuICAgIG5ldyBTZXQoW2Zyb3plbk9iamVjdF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxuXG52YXIgY3JlYXRlRWxlbWVudCQxID0gIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY2xvbmVFbGVtZW50JDEgPSAgY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNyZWF0ZUZhY3RvcnkgPSAgY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uIDtcbnZhciBDaGlsZHJlbiA9IHtcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheSxcbiAgb25seTogb25seUNoaWxkXG59O1xuXG5leHBvcnRzLkNoaWxkcmVuID0gQ2hpbGRyZW47XG5leHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbmV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IFB1cmVDb21wb25lbnQ7XG5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5leHBvcnRzLmNsb25lRWxlbWVudCA9IGNsb25lRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDtcbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlRmFjdG9yeSA9IGNyZWF0ZUZhY3Rvcnk7XG5leHBvcnRzLmNyZWF0ZVJlZiA9IGNyZWF0ZVJlZjtcbmV4cG9ydHMuZm9yd2FyZFJlZiA9IGZvcndhcmRSZWY7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50ID0gaXNWYWxpZEVsZW1lbnQ7XG5leHBvcnRzLmxhenkgPSBsYXp5O1xuZXhwb3J0cy5tZW1vID0gbWVtbztcbmV4cG9ydHMudXNlQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaztcbmV4cG9ydHMudXNlQ29udGV4dCA9IHVzZUNvbnRleHQ7XG5leHBvcnRzLnVzZURlYnVnVmFsdWUgPSB1c2VEZWJ1Z1ZhbHVlO1xuZXhwb3J0cy51c2VFZmZlY3QgPSB1c2VFZmZlY3Q7XG5leHBvcnRzLnVzZUltcGVyYXRpdmVIYW5kbGUgPSB1c2VJbXBlcmF0aXZlSGFuZGxlO1xuZXhwb3J0cy51c2VMYXlvdXRFZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3Q7XG5leHBvcnRzLnVzZU1lbW8gPSB1c2VNZW1vO1xuZXhwb3J0cy51c2VSZWR1Y2VyID0gdXNlUmVkdWNlcjtcbmV4cG9ydHMudXNlUmVmID0gdXNlUmVmO1xuZXhwb3J0cy51c2VTdGF0ZSA9IHVzZVN0YXRlO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsTW9kdWxlKSB7XG5cdGlmICghb3JpZ2luYWxNb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0dmFyIG1vZHVsZSA9IE9iamVjdC5jcmVhdGUob3JpZ2luYWxNb2R1bGUpO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImV4cG9ydHNcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiaW1wb3J0IFBhcnRlbmVyaSBmcm9tICBcIi4uL2NvbXBvbmVudHMvcGFnZV9jb21wb25lbnRzL3BhcnRlbmVyaVwiXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZXNwcmUoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8PjxQYXJ0ZW5lcmkgLz48Lz5cclxuICAgIClcclxuICB9Il0sInNvdXJjZVJvb3QiOiIifQ==