_N_E =
(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([["pages/portfolio"],{

/***/ "./components/common/Headline.js":
/*!***************************************!*\
  !*** ./components/common/Headline.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);

var _jsxFileName = "G:\\MDMax\\go brasov\\site_nextjs\\gobv-site\\components\\common\\Headline.js";


function Headline(props) {
  var label = props.label,
      title = props.title,
      subtitle = props.subtitle,
      divider_1 = props.divider_1,
      divider_2 = props.divider_2,
      position = props.position,
      className = props.className;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("header", {
    className: "el-headline ".concat(position || "side", " ").concat(className),
    children: [label && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "el-headline-label",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
        children: label
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 9,
        columnNumber: 21
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 8,
      columnNumber: 17
    }, this), title && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h3", {
      className: "el-headline-title",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
        children: title
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 14,
        columnNumber: 21
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 13,
      columnNumber: 17
    }, this), divider_1 && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: "divider divider-1-reverse divider-1-1"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 19,
        columnNumber: 21
      }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: "divider divider-1-reverse divider-1-2"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 20,
        columnNumber: 21
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 18,
      columnNumber: 17
    }, this), divider_2 && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
        className: "divider divider-1-reverse divider-1-2 divider-single"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 25,
        columnNumber: 21
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 24,
      columnNumber: 17
    }, this), subtitle && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
      children: subtitle
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 28,
      columnNumber: 26
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 6,
    columnNumber: 9
  }, this);
}

_c = Headline;
/* harmony default export */ __webpack_exports__["default"] = (Headline);

var _c;

$RefreshReg$(_c, "Headline");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/common/portofoliu/card.js":
/*!**********************************************!*\
  !*** ./components/common/portofoliu/card.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react_grid_system__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-grid-system */ "./node_modules/react-grid-system/build/index.js");
/* harmony import */ var react_grid_system__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_grid_system__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react_tabs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-tabs */ "./node_modules/react-tabs/esm/index.js");
/* harmony import */ var _tables_parteneri_table__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tables/parteneri_table */ "./components/common/tables/parteneri_table.js");

var _jsxFileName = "G:\\MDMax\\go brasov\\site_nextjs\\gobv-site\\components\\common\\portofoliu\\card.js";






function Cards() {
  var _this = this;

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_tabs__WEBPACK_IMPORTED_MODULE_4__["Tabs"], {
    className: "el-tabs el-tabs-1 ".concat(_tables_parteneri_table__WEBPACK_IMPORTED_MODULE_5__["default"]["class"]),
    selectedTabClassName: "active",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_tabs__WEBPACK_IMPORTED_MODULE_4__["TabList"], {
      className: "el-tabs-links ".concat(_tables_parteneri_table__WEBPACK_IMPORTED_MODULE_5__["default"]["class"]),
      children: _tables_parteneri_table__WEBPACK_IMPORTED_MODULE_5__["default"].map(function (category, categoryIndex) {
        return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_tabs__WEBPACK_IMPORTED_MODULE_4__["Tab"], {
          children: category.name
        }, categoryIndex, false, {
          fileName: _jsxFileName,
          lineNumber: 17,
          columnNumber: 17
        }, _this);
      })
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 15,
      columnNumber: 9
    }, this), _tables_parteneri_table__WEBPACK_IMPORTED_MODULE_5__["default"].map(function (category, categoryIndex) {
      return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_tabs__WEBPACK_IMPORTED_MODULE_4__["TabPanel"], {
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_grid_system__WEBPACK_IMPORTED_MODULE_3__["Row"], {
          className: "row-center mb--30",
          children: category.items.map(function (item, index) {
            return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_grid_system__WEBPACK_IMPORTED_MODULE_3__["Col"], {
              xs: 6,
              sm: 6,
              md: 6,
              lg: 3,
              xl: 3,
              children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
                className: "portfolio-item",
                children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {
                  href: "/parteneri_details".concat(item.link),
                  children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
                    className: "portfolio-card",
                    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
                      className: "image overlay-image",
                      style: {
                        backgroundImage: "url(".concat(item.image, ")")
                      }
                    }, void 0, false, {
                      fileName: _jsxFileName,
                      lineNumber: 28,
                      columnNumber: 41
                    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
                      className: "content",
                      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
                        children: item.title
                      }, void 0, false, {
                        fileName: _jsxFileName,
                        lineNumber: 30,
                        columnNumber: 45
                      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h3", {
                        children: item.subtitle
                      }, void 0, false, {
                        fileName: _jsxFileName,
                        lineNumber: 31,
                        columnNumber: 45
                      }, _this)]
                    }, void 0, true, {
                      fileName: _jsxFileName,
                      lineNumber: 29,
                      columnNumber: 41
                    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
                      className: category["class"],
                      children: item.title
                    }, void 0, false, {
                      fileName: _jsxFileName,
                      lineNumber: 33,
                      columnNumber: 41
                    }, _this)]
                  }, void 0, true, {
                    fileName: _jsxFileName,
                    lineNumber: 27,
                    columnNumber: 37
                  }, _this)
                }, void 0, false, {
                  fileName: _jsxFileName,
                  lineNumber: 26,
                  columnNumber: 33
                }, _this)
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 25,
                columnNumber: 29
              }, _this)
            }, index, false, {
              fileName: _jsxFileName,
              lineNumber: 24,
              columnNumber: 25
            }, _this);
          })
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 22,
          columnNumber: 17
        }, _this)
      }, categoryIndex, false, {
        fileName: _jsxFileName,
        lineNumber: 21,
        columnNumber: 13
      }, _this);
    })]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 14,
    columnNumber: 9
  }, this);
}

_c = Cards;
/* harmony default export */ __webpack_exports__["default"] = (Cards);

var _c;

$RefreshReg$(_c, "Cards");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/common/tables/parteneri_table.js":
/*!*****************************************************!*\
  !*** ./components/common/tables/parteneri_table.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {var parteneri_table = [{
  name: "Culese din toate",
  "class": "Culese_din_toate",
  items: [{
    title: "Hotel Stop",
    link: "/hotel2",
    subtitle: "Brașov",
    image: "/images/parteneri/hotel2.jpg",
    thumbnail: "/images/parteneri/hotel2.jpg"
  }, {
    title: "Le Pompon Rouge",
    subtitle: "Restaurant Franțuzesc",
    link: "/restaurant1",
    image: "/images/parteneri/restaurant5.jpg",
    thumbnail: "/images/parteneri/restaurant5.jpg"
  }, {
    title: "English Club",
    subtitle: "Bar englezesc",
    link: "/",
    image: "/images/parteneri/bar1.jpg",
    thumbnail: "/images/parteneri/bar1.jpg"
  }, {
    title: "Iron Will",
    subtitle: "fitness",
    link: "/",
    image: "data:image/jpeg;base64,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",
    thumbnail: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxMTEhUTExMVFRUXFxUYFxcYFxcVFxcXFRYWFxgVFRcYHSggGh0lHRcXITEhJSkrLi4uGB8zODMtNygtLisBCgoKDQ0NFQ8PFSsZFRkrKystLS0rKy0rLSsrKysrKy0rKzctKzc3LS0rKzc3KystLS0tKysrKysrLS0rKysrK//AABEIALcBEwMBIgACEQEDEQH/xAAcAAACAgMBAQAAAAAAAAAAAAAEBQMGAAIHAQj/xABJEAACAQIDAwgFCAgFBAIDAAABAhEAAwQSIQUxQQYTIlFhcYGxBzKRocEUI0JSYnKy0SQzY3OCkqLwFUOzwuElU8PSRPE0g5P/xAAXAQEBAQEAAAAAAAAAAAAAAAAAAQID/8QAGREBAQEAAwAAAAAAAAAAAAAAABEBITFB/9oADAMBAAIRAxEAPwDmbmoWNNsRsS4D6y+8fChTsm59n2n8q6ICzV5noo7Mu/VB/iHxrT/Dbv1D7V/OgBvHWvFqTG2GQgMMvfWiUHorYVgFbRUHgavc1eRXlB7NZNYKyKDCa9U14RWCglVqKtYiP7/5oKtlagYNiePZ5n360HduE8ez+zXhbw8fM1G9B4z1oWr0itYoPC1b27kGa0IrAKCybK2nk1Bj2an2RG7t9pona21mcSdZ07BxMnWO4VWVuxBHxNSvdn+/GggxD0RgjoKDuUbgx0RVC0tvrA1eNvPfXgoJUapVeoEqZaCUXK2V6jFbgUBuGvVY9m4iCNfGqtZMf3rR1rER/wDe7t0qC5/4h2j+Y/AVlVhMYY/OT8ayin20rOppYyU+xyzSu5boAwlT2rNbpbou0lA45Lcj2xnOFbxtZMggTrOfXQ9la8quRT4S2He9zgO4QesDWe+rh6LP/kD9z/5fyon0opOGHYf9yVLyOLXNnakDWCfoqfhUZ2YOz/8Amv5V1T0V2lN7EhlB6NsiQDxbr76t73LQfXDiASPUTXhSj51u7KH2fZHlSrH4fIyiBrPXwjt7a+neUOzLPydmFpFaU1CqCJdZEjsJFfNm2Vm6g7D7SdfIVc0DWsMCO3T4z8KlXBA9dGthyqz2jyP5VvYtFjoKI8wWwOcBgXGiJKwYmd+nZWYjk8V4XB3qPzFdZ9CYgYr/APR/5qk9KduXtn7w/oFSq4x/hf3/AOQf+1Rvs6OJ8VI8pruHJ/kFhr+GtXWNwM6KxgiJO+NKl2h6NMMqMwuXdATErw8KUcAuIAYn3N+VYuHZvVE93/NMtt4cDEG2B6uYeAYgeVFbKw5kwOIH4oqoR/JH+qamGzLkA5RH3k8pmrScFcGaUgAxJIM9UCav2N5OYddk2r62gLpw9pi2s5jbknfG+lVxU7OufUY9wJ8q1OBf6jj+Ej4V1HYHIF8Zba6jWlAdlhgZ6MdQ7a0296N7uHtNddrRVQScuadATxA6qVHL+YI3j2g1mU8P77qJt25Z43BmA7pNNbGDmJXSBqApO7qJHnVFeuWj2+NF4VOiP74mmG39mXMOLedVXnMxA6JaFy6kDd6wilWdlAgwIn3kfCgBa3qa1K1fbXo62hcPRwRynUM160oIO5vWnUa0bs/0UYp8QLF17VolOcJVmuwubLqIUTPbUo5vaWpwtdbtehjMrNbxeoZ1h7cSUYrvVtASJ3GJ40uveiDHqdBh3HWLzA+xrQ86XBzlVqW2lWTFckHs3ebuvlYHpAANGu4NMHvio8JydvknJL5QCStgXPaJPvFAhCRW4ova2BvWiBcIWdwNnmye7oVtsbYWLxRIsIbhWJhlSM05dXKjXKfZQQhf7mvabPyU2ghytZuAjhnXjrwaONZTgWDENQVw0RdahWqK9QVMLqrvIHeYqFK02gug7z5VR0n0V3VLYjKQdLO7vu019I6zhj3H8SVVfQ0CMRiweNvDn2G6vwq48vlnDN3N5T8Kz6K16L9MReHXatn8P510quaejbTF3R+wX3c1+ddLpoB22s2X/h9zLXzDtpIv2/4vxCvqHag+abw8xXzTyisxft97/iFXAZtDoWs0GCyg+/UzXuAw73FZ0C5EHSLPbXerERLamEbdOo7aYYvHWreGuhwXz28gyFSyPzltleCeBXdVxXHWMZsn5abNkXVV1uEIiNnQMMuYCQCcp8RVDr0abCv4VsQL6BM4slYZWnKbs+qT1ioPSZbk2+/zVvyqwcl8VhbkthlVQ1u2WCrl4tEjd9bdSf0kJ+pP2x5PWfQ95Ff/AIOH+58TTPaA+af7reRpXyJP6DY+6fc7U2xg+bf7reRqD5n25b/6gw+0/wDqPTFLWQggT01nhAyvrQnKAf8AUW+/c/1Gq0YbAI9pyf1ga3zWpAzEXC0jj0VO/vrYSYnG3CzHmnyhFaTIGlkPB006u+r5sfbwxuw3It5DZBslc2aebtCGmBvBGlOvklpsNtBbTBg63EnOHEDDrlOnefGue+iu6Ts7aVvgCH/mtOp/AKg6P6Lx+i3P39zySmHLxZwV77j/AIGoH0Zj9Gu/v3/BbpnyzWcHe/dv+Bqno+c9iWcxuD7beZp0iumoUNGWBmAJ0GokdfbQPJe3L3fvt+I10Xauy7SYW1fGHW6RYZnWWUsEVurw9laHOeXW0TeNglWUqtwEMI4oNCND6vCq/f8AVT7h/G9N+VuLFxcORZt2tLp+bZ2DBjbIBVycpXXUHWdwik+Jbop+7/3vVHefSNyivYXAWHwt4I8orQLbkA2idQ4Mbhw41JyK5S22w5xmJug3OZsq5jpE2ree42VBpLOToI3VQNvbCvpgcReuEKouoFt5FBbPDc6bm86ECJO8nSarCbVa3hLK23IL8/zuZnNsADIqi2DlzEINTO9eqswd+5E7btX0vFSYD85mIIBW7JDCdYlWHgab7O27h78c1eR82aBME5QrMMp10DqT3ivmWzyixJVbCMgXm1SObScqtnEvGf1idzDfVt5FYe9iMXat28ViLQ5vMxtuPmySyEKrSu63bGomI7KQWzb2yr1/F3blq2zoHKlhEAqYZZ6watHJXAm1cVWQI3yW3nGk5hcuSTG8676m5G4Z7Vi9buO1xlxGIBdozP0yQzRpJBB0ppbX9JJ/ZD/UaoOcemXAZ72FI+q494I+NJeTe2P8Nw+MxBVGcCwqI303ZrgEGQQBJJjWBVv9JdqcRhD9m9/sqqbewamyQ+vzls5dNYFzWI13xv8ApVc6FHx3pF2jcdnOICzwW1ayiBEDMpMd5NZQOM2EwdoAjs3doHZWVoW+eiO4VGTW106UPzlQThwASdANT4UFtDaFtguV0Op3Ok7u1qMtNWm1D0V7/hQXb0Q3FOIvFQQDaUa6zkfrBI+numfaKu/LRJw5/i/03qh+iG6TirgJJ+ZbeZ/zLddC5VLNg/xf6b1nexVeQ+EFvEi4W/WobQXqKhWnui2R3xXQqonJFw19FI9VWYd8R8TV7poH2h+rbu8q+ftvYWcZZXruMP61r6Bx4+bf7reVcT23ajHWT1XLx/lGb4Uwc/2qhuYx8okl34E/WO4Amr9yNwn6FisI7EMyLiIGYZQCFOZCQdRzZ1G6eoTzp7zC87KxUiekOAZgpP8AVXTdhYBLDJdQDNlKnU9NXXKQ5+kTO8zrWhYPQpiSUuoYhFSN0jM93MCQJPSBOsxOlP8A0gW8wsj7a++RVZ9Dt39Jxa6Tlts0fWZ7hI9/vq28tUkW/vL5mp6DuSNsJh1tCTzcgE/SDEtPtJH8M8aa4r1G+63kaVcknnDIx9Y5p8HYCmuI1Rvut5GsjgW19lo+OuO2Js2St26Aj84WbpkyoRTprHhTHFXeaChbyHpBpVb4JypcUhS1oAdG4xknhSzljZjaQ7Xufiqfb5KopBj157sh31sJvRYbgx117dk3RzF1XglMitDZiw+5EHfJ415yK222Fu4rDiy104iLQAYLDA3NTIOkZj2QafehWy3N465bZEchEzXJyiFYxodCS/b6u6geQFtf8VxKsATzGIdDvhujDL/A7juNQdO5HX8RbtFbeEBzMXJN9R0stsGOieGX30XylxeLbDXQ2FRVKPJF8MQMjSQMonThNHcjB8y88H/8dujuUazh7o+xc/02qD5+5NoRcu5AWOdpzALBk6AhjNWzG8vhYFqy9tHNtCrKpzGGkZXDQAY1gE6EdYpFyYtRevj9o34jVf5bYYLiDcUaEw5+3LQP5APYK0Ido38PcCZnurE7rSGZj9rpu99D3reGKrN296pA+ZU6Zm/a99Lbx0HjWXDoO74mqjo+3OVHyvCXLCqRzfSYxEm2uX6xgdE8KouBsG8qWoIALQVhiSW3ZSV4kcasPJ65m+WrBH6LeO8GWUk5hoI0gRrumdYAfIjCc4zSxVUL5oMFsyoFQneBMnTfqKipbdqzbAVrzjLKj9HUnefpC/rM9QptycxiYO9zlm65c5Vy3MNAP0wNMQu8f3NJ9s4FLTgqIAOaOHHh76n5VOXuJlyAhEzEkglgGjcOpvKguW1OUGPSLofILjXwqrZXJcuPaDENGKJlVEqdIJM5tw6ZsLFNdFq40Znw9tmjcCxJIHjXELmOuuLFi3aRig5xrnOLfQC6mXSVBRpRg0dcdtPdu8t79qyFsvbtEW0tErLXAASSyn1V6txqQW70mYtLVzDtcYKoW6ST2ZN3E9wrlm3+WXOApZSF+s2rGCCCANBqBxNIcXtbnnDXrly627NcdnIk8MxMDsom3hcrK3NyAQYO4jqqwANtO6TJY+wflWU9TE2o1w+v8P8A61lBBg9svezTbtIBHqKwJJneWY1s1wzQOy0CqRIkktoQdNBGh86JnWgY4Zq92q/RXv8AhVV2tj7qXYVyogQBu3an2zXlrbV//ue0KfhQdU9D939OI67Fz3PaNdT5Qkc1qQBJ3kD6DddcY9DOPe5tMZ2J+YujcFG9D6o46b6tnKj0VJiLjXWxLdK5cbpW1cjnXZ8uZj6omAKm9hjybxVlMQpN22OgwPTXt7as2I5T4JJzY3DL33rQ82rmGz/Q9h2cK+IuwZnKlpTpO6Vbqqw2fQ3gV/zcUf47Y/DbFTgWccqcFeW6lrF2HIRictxSIjfMwfCuYcosVZN8st205UYk9F1Y6pA3HrNXix6NNn2s7lHuypAW6/OICNcwB+l21zvltyZsWGvOlpVXLNuJAUl0BA4cdOw1cHPLQBW/9YhABxM3FY+5ab7A2zeR7a3HbmVPGDAAMaxmjsoTZ+FzYTFXIlhcw6qQJI1ctHETImgsM5t3FZwwymYiDu00PhWkdL9GW3sNhcXirl26xW6BlOS45JFxiAAqkgBSN9XHlBy2wtwDKuJfUHTD3RuJ+sBSb0VEf4jfK7nwtt+wkuFJ/p99dK2sNPAedY3tVH2Ny0RLdtVwO0rhBOqYQldWJ9YsBxpvc5Y3WVguytobj6yWk8dblN8HdVQo16JO6O3rPbRF7aIykQdZ3kDfQcT5QNib+ODDA3QwW6/NF0DESozSNNGdJG8z40m27tq8Ve1cwxtFcwJzhiDqpBAAq+coMS/y8NZaG+S4mSOlEvh4PtA9hqq8v7QFprk9NmKnt1kk9u6tBPyI5TYjB23WxzY555YsqOYQBQOlcQLvbeTPUOO+zLty1jM1tmTEtbIE83lZGtiQoC3ATkE+Bqt4LG80qnMM0zlKhxB6wf77t9ONjbeDbSwN7KECPh7bEkKCP1bP1IIbdJiN9EXfkh6WLeGW4mL5y6SwKG22GaAFggmbfUNIPHXhTnHemjAXEZBZxMkMP/jcVI/7/bTp+UWFE5nsHr+dw76x9lyaU7S5T7PjU4bxS634bBHvrKuebL5T2bd26+S6Q7lhHNSATOvzm+k/KDHG/cYoGCF88NkmcoXgTwHXUXK02TfDWnR0ZpJRCirLHo5TvgRrA30mRVnVRHdW0F37LQNDpQz3uHxH5149tQYgb+oTBA0mvSBG4UDbY22bqOxtWc+a3cRwouPK3JliFG8A92grTY+1XsC6UgglQQeM5joeB6I99NLWMw9np2rjI3NlWDg/rTbiVIExvG46kHtqt2tc4G7on2SPjQP9v4rPZR92ayp7ujBHuNC4Nrr21YsSYgyM0hQFUmQdwUa1oBnwyKD6ouIT1E3HcD2MKg2ndJt4cZektu2uvHpPEHq0jwioq57Sxb2sHh1APO3bSFokkAjooskkDUmO2kljZ93mr3OJLuFyagkQSTJ4cPZVxxQU4pgd9q2ir2aQfL30vu3emw0gGI4xlnNPVOlBWti3LadB1VX3ElAW9p/KmuFx/RglNNBO8xp8PfSflWAGRl0YyPZB/Oodur0MM2/5tZ7d9BZPlq/s/d+dZVJydcT2GvKoNRoOhpnh7ZNV7ntasWzcWMtES4vAC4hQ9Wh4g8DVWa1lTKdGkkjtBygT/N7auICvxI8YpNtXYnFKKsHoXbJtO2WIEpdG/X1C2o4erX0BjMUCugJgg6Cd3dXyzsnalzDsWtsVZJKsrMpGZYIkQePnRd/lljH33nPfcut5vWdwd/8AlbA/qr47eauD35YrLu2QPWkfeu20/G4r5wvbYvNqWE9wP4pqP/Erv1z4BR5CkH0Je2/aP07Pjfst+Bmql8v9oh8K+V7TDMghGdonMdcyKOHAmuWNjrp33H/mb86YW75+RPJJLXgNTPqWweP36QN+SeJW3gr0suc3swUyJVEURMRJ1pthcTbvKwdcvRAKsBAITKwtzOkkae88OfbOALaxENqe410HC9DCm8dUt2y6TqJGo7yLggdiRubWgLkfy0XAsji2bnzT2mBuFSg5yVOiGdFHAb6f7Q9LocQMOvi90+RSuTZpJgkgZQJAEdkDTST56TWTSI6Bc9J9z6Nm2O/nW/HfI91A3/SPiT6qWV7rNifa1sn31TKwCTABJMAAakk7gBxNILK/LvGkki5lLbyoVCY3TzYWoNq7XvX8IGvXGc88wBZmbQIh+kTxJqDF7Kt2rUu7tdguURRlVAQuZmP0cxy5o1PqhhDmLaGmFsCCJ5xoIg6sQD3QBQCJYKrnyp0YJJbVg0AAA9Xdx46VpeYnK0ELmEHWPonQn86kv3wI5tV6hmAe5P3W0HYQvjUN1LjhrjFmy5QSxJjMGIXX7p07Ko8e4x3sT3kmoiK2Y1oaDa4eh4/lWttt1bBJVuyD7Jmo7W7xoCr/AK3gK3TRWeAcoEA7izGBPXxMccsVpfEwRwEHs149VTOsWBpq9w+y2oA991vZQHcnNmW7l9FuktJEiYJ6LGCd/Abo31BhcGGxL21KoPnNTOUBDPkvlReE5QGyoFoSwIJMLGaANWIk9wpZhLx58Mw1OeRqohlaR18dO2KCXB57bkMOixyt9llIExv0LQe+m2zSDft22UHOLdndMMMSLgYQwjQwTrx0M0LiQIIMnOE6XVoCJ7TGvd1zJHJO/nxmFBEkMCdD/l22ae/o1Ax5T7Va3jHdesgjgRO73UTZx9u4ARftKSNVYvKnqaEI9k0j2k4uYpydQS3uNehQN26ipdpYQsSS9p+rIXIA4zmUdlL3w9wwGuSAIAM6AUcnHurUmiAfkTfWFZR015QVrPRdrERQ4tzRVnAE1QZhcaRxp3hcUGEGkgwBomxbK1BJtTBgKxG+PCNZ+Hvqvirkq50IPUaqeLs5HIoqKsFeTWTRHs0yxWmDtfae63vCf7KWTTHaxixh1/Zk/wA7u3+4UAuyxLqIzSDpJE9E8RV5vKTsu7qVCm2Mg1kC7aViDv0CMI4zNULAk5xlEnWABJJg6AcautvaTjZ11SjIyhMzRpPOWwoYcDr5fWoqnYhAF0VxrvYQPDShZplaS7iGFpdSTxMKIBJJJ3ACaa3sPhsMhUHnrpEZ4gKT/wBteHfRFd5h/qN/Kfyo7ZV1sPeW6whlzFQSoYEqQGKHpaTOo4CgLqazrUUADQVQftjbVy9fuMHKK+RQo9ULbXKgA+yN3USSKN5W4oO1shVVcgKquiqv0VA6gAKQW7cmNcxIjSQZPEzp76tGI2A2IjmriM6qqm1MXAFUaqDo/gZ7KCqmSJ3dUDjTbFsBhbYAjnbrP4W7aIB/M1ygr+AZGCuCuvrHRdDrw0PYRPZRG2IU27Y3W7SDxebp/wBQeygCNamsrygnwn0h9k+X/Nb3MM2VYB+cZgum+NIHsPtrbAXkVWm2WYkQ0tCgakZV3z1k6RpWyYq5NsAki1nZRwWYLNQAXozEDQCQPD41MSebEkkDd3tw9xofPDSYOpPtozH4pnVVOUZAq6AD1QRr1ntNBmBvoH+cMLE5hqRxjSi9qOpvQuihQBwJ6OkxuOooHAmWUAdKRHGDO8jqqXPme4d8k9umaR5CgbYjGF7FpQPokbtcwMyT1EMR/Dw1ptyJwon5ROtsX4GnCyAD173I8DSmwrNhy0CEuQ2muV9Ynhx75jqozkgGNy6foiy2nVLIfNRUAH+ee40VQVtpvnuajCaDdOPdWhr1Dv7q1JoNqysFZQAbPwHE00WBXi6CK1ZqCXPXoqDNUqUBGHuwaQbbMvNOTQOOwmfcy9uZlQDxcifCaKRTT7AbMX5HdxJCuwYKqtmyqNQXOUiTOgmR47ld/BhQfnrTEfRXnWJ7m5vJ/VTzFbQZNnIjlc9wrkQAAiyiwrvHFjqOJ3miK2x4j2dRpht1SObT6tq0PZbWaWWruXeAw4gzB8RqD2im20ofELJIVmQSNSFMDTwqhdYgNqYGuvSHwq2bJfCph+Za4lzMVJRXyjotnUOSQSQZ0HWYNLNo4fDgxbzz9/MB3mNT2CgDhQePtANAZtMXRcNxFdVnRQrBAIiANxHspbYdiSWGnEma8bBidI74iO0mdKit4TMWhgSoncddQNJ76Ai7eRjvCiN+rT2wKHhPrnwUkx1w0D30wt7JVFDX2ZZ9W2I5xu8R0R30Dea2pboEQG0mSDBy5i3bEgcJ3Gg9t4hEIKhmMMNSF3qRIUBt0zv4V7cxrF+cAytvBE6dREmrGcGlvDC2qq95wc28k3AnOtu3JZRlXKvr3G1nKAUF8MU6Xr22ZG7CCf8AkeFBJex9/FMlu7de5mZVEmd5CzAG+OO/Stb2HuYi/cNpGeXaIGgE9ETuHRjfW2xnhi+g5tHbxC5V/qYGgbbQpE6HeNP7NBZsD6O9oXBmFpEHW123/sLH21HtHkFjbIlxZj9/bX33CopJZ2jcQEW3ZJ+qxXyqTZu279nObdxlZ4zPPTMbukdffU5EuH2VjFJFtLwkam0WZWAB0L2SVPHSePbUNzZlznCCjW4UmSrLEAzE79NIp5heVWNCHNfzLpLsUusCZgQZaT1btKSbU2jcY9K8zsfWGUJHUDlgT1gSB11QJg8MWuKrCJMmRHRUFm9wNRvBJJkSTrvH976N2cdLrnXLaYeNxlTyZqDsoJnPlPj50BWzVCtm3wGafuqSPeBUWFJAJG+Ru0O7TX21Nh7YAusGzdCN0asyj86gcEIsDfPid/kwoHGzXZrV1RuJTNJJEFbqyfEr4gU65HiLOLY/UtDwJbT+mqzsvUOrEiUJEH6ano929te2rLsB/wBDxLdbovfCk+bVBX8Mfnj3NRxNL8H+sPcaPoNlO/urQmtl491aGgkBrKjrKCfPUDvXhaobhoImxBJ0ozB3TS+1bM02s2gBVEzNQeNOlTM9B4x9KgUPxo3aWK59kO5sltI3AlFCCO+BQeQngalw1g511A6S8Z4jqqifBYdbd1eeAiCYOoO+JjeJG7jRG2mDgXF3Hu0g9lMcTydvXbiswNu2UDBmHCTuBIPbO7dJEioMZhLS22t23L5TJbeNQNAY7PfQCqwyhusTWjseo9wEsfyHaaEtYkKIMyNxiY7hUT4gnfJ7yTQT32YjLAUb4ke/WTW2y2yXVYNGsaTx0nXqMHwoNrh7u6vDmPWaAy9dYMxYktOpJ1Pt19lLw2uu4kE9sHjTDHJmYH6wB8SNR7ZqF8C4U9CQYObisTOnbPuoC7e1zacXEUMwV8hYk827vmF1QCAWXes6AwYMChNmtOZT9IT4ihymoLSFmM0adsGtsErG6BbBYzoANYmJPVQEoctq71sUXwEsfJa0TBseFT2Sy3hlKqSYl1R1E8SrgrVotXMVGgwV371hF99uKCs2tlMd815svBZ3dT9GPiPhVs+U4jjgcO/7u46e4uBSjZ9u5Yu3bj4a8Q5JyqJyjMSOkA0xMbqipMRsY21lVAVLb3SQeMLBI7FY++qg5O88dfbTTaWPctcHSUEMMpmYLEgGQODdQpXcaY7gPZpVQXcsMqosEc4QwkRK7l798+NQ4jeQNwphd2iWvWWMEW1UKOAyKAoj+FfZSo75PEmgkzwIUnpASPtAkAeR8adsyC6QUORTlgakBdBGm+lGzkm9bA+uvsDAn3A1dMTgrT6sgJ6/jQe/I7PNF1MAo2u4iQeFQ7Kf/p9w/WvN7kSoygtjKkZZ9U7uvWp+bCYAAcbjnyFRVdwR+cPcaYUBgAMx640+NHUR6p8q1r0fCtaBtgsNhygLuQ2sjMo4mNDrurKk2djcMttRctZmEycoM6njPVWUCDNUTNUa3K1ZqonS5UpxVA561L0Bpv16RIoFWpvs5kBBuTlG+AD7jvoFWUTunv8A+KsOy8MmGy4i8VDDpJbhSdRoWDDfrPYYOsRXt/EWQ5+S2WZzuJU5U+6GJjvJqfBbOvAl3SzdY7+dTnB4SdPCopftXlA18ksWgmcoJlu123n+4il2EuXC4kQpBEDcJ3e+KvGHQqIOAw7DqU+S3QQPCiBdwv8Am7OvW+23mb8LFR/LQcy+TlnyjfrECd3dRQ2aRv079POpcUwtYlXE5VuA6jpZM2sgxrl4aV1DBW8M3q30Pfx/lzCqOZ2tlHqou1squmrsrDE68zPX0VPt0NErySw76jMO1bhb3NIqUcg21hzbyMOHwM0fiUdl6IhGAMgAmDrvNXTl7ySFvBtcRi3NlTBUTDEKdVgaSDu4Ut5CbNfE4QMuQm2zW2BYhtIZdMseqy8eFKKYmz7qiFdgNdNQNewVtaOJt+qV8NKv2P2WyHVYP3k8g0+6leIw4A1gnq118aCkYi4yXFuEQwOYjhv1Hcdas+ExNu4NbQB7DFJNs2b1w6WlEdT5jHeY8qK2aXFtQQQRpHduPsiqh6lgfRZ199RvfuAxnB76Wvij1mhHumd9RWvKHZly43ODKTABAMZgNx14/kKr17CXF3oR/fXVibEt10LdvMSCeBBjSD2GqhXirYS4y69Hoz1MI8yCPGh1bgd2vhPGjbtsksSZzEkz1mozYFBvsy8Fuh+ABie7KN3GKcttKeNJINeCaBzjQcqsSdRJH3icg9ilvEUTZvE4ODwd48daUPezKJO4DTuVV/2++nFwH5IjH6RY+AMDyqBVgD0j1xR1AYP1vA0dQeitCa9mtCaB/sy5fFpclkMusEkCekZ49dZUOA57m1y3Qq8BlmJJ4xXtB1La3IPZqRKKpPUW8gfhVO5Y8ksLbtlrCPPA7l9+vuroXKCJXXjSzb1rNZbjp8KiuAsa1mp8UkOw6ifOoaqJLI1pthLYYhTuNK7O+m+B9dO8edBdsNse6qAqFcRuMg+dGYa5bH6xWtnuzD2irjsDBLzS8dBRuJ2bbI9UVKquYO3Zf1bit4ijxs0dnhSjaOyLWY9AT17vKgMioYm4nc7RQVD0q7M5vEK4GlxAf4l6J92X21ZOR+yMHi8FZuPh7ZfLkdgMjFrZykkpBkwD40u5d2Ocw4fnC/Ntx3gP0Tr35apmw9s462rYfCMwDMXIVQWBgKTmI6I0FUdTxPIvCqsrfv4cDiL3R8edB86qW1cVZsH5ragun6vMc4fG4jACl+H5H4zFHNicQFn67m8w/hnL76tuyvRvgU1uG5eP2myr/KkH2k0FexXKNmstbF8uXBVgcyCDoRlZj50XsHJaslEuZc5lwr5ZO7WDNXW9yUwDLHyWyNIlVyH+ZYPvpNjPR3hD6hvW/u3Aw/rBPvoEd5oByu4/jYj+okVX8Rt0ajnZ70n3iKi2nsLmsauFv3StskZbmnqtOQkEwNRlPaDTzGf4ZZAVLK3GHZmnvLb/AH0FZXa91zltoGaCYgzAEzE9WtabIwj4i6bb3mt6FtQSDBEgCQBvqbbuMZryYhU5kgACSBOXSYPYY3bop3s6xkgs2ZjqSPLuqhgeTtqFC3LggAb1O4RrpUF7k0QOjdHcUj3g/CmlmKzEXiBUFVxmzbifVbuJ+IFK7hYb1Pn5VY8Zi6TX708KIWPc7KjLUY7GtsNh1Y61QBmryj8RhEDQK0+SDgagCq1bS0weGH7OfaSaQHBHhFWDbCZcLhgd4tLQV/Cev4GjSaDwqnNPCDRZoMBrWa9FaUB2GS3lGZiDrIDRx6orKjsMmUShJ11jtrKBttHlfirhnoiD21OvLe6UKuvDeDNZWVYKfi2zMzdZmhSaysoJsPvpvZEEHtFZWVB3XkzcmyvcKOxWJgVlZWVVnHXCWoDE282+srKoAx+CD23t/WUjxjQ+2udcmMRzWMt9Tk227n0H9WX2VlZVHUfkQPD3xWNhGUEi4QB41lZUCLF8sltNlDF4+zA9+tQvyvvXujahOs9Xn7hWVlUVblMrswLubj7p3RuIAnXieqgflTgdGF7QAD7d9ZWVUaAtcIDmRM09svurKygdYFpFEXrJIrysqKU4rCUBdw9ZWUAj26iyVlZRGZa3yVlZQbKKb8ov1Fj90vlWVlAmwh+bPf8AlXhrKyg8Fa1lZQHJfaB0TuG5yogDTQGsrKyg/9k="
  }, {
    title: "Socar Brașov",
    subtitle: "Benzinarie",
    link: "/",
    image: "https://storage0.dms.mpinteractiv.ro/media/1/1481/21330/16945839/1/poza-2.jpg",
    thumbnail: "https://storage0.dms.mpinteractiv.ro/media/1/1481/21330/16945839/1/poza-2.jpg"
  }, {
    title: "Filarmonica Brașov",
    subtitle: "Filarmonica",
    link: "/",
    image: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxMSEhUSExMVFhUXGBcXGBcXGBcWFxgXFRUXFhcVFRcaHiggGBolHhUVITEhJSkrLi4uFx8zODMtNygtLisBCgoKDg0OGhAQGy0mHyUtLy0tLS0vLS0tLi0tLS0tKy0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLf/AABEIALcBEwMBIgACEQEDEQH/xAAbAAABBQEBAAAAAAAAAAAAAAAFAAIDBAYBB//EAEEQAAIBAgQDBgMFBgQGAwEAAAECEQADBBIhMQVBUQYTImFxkTKBoUJSscHRFBUjYuHwM3KSolOCstLi8RZDwgf/xAAaAQADAQEBAQAAAAAAAAAAAAAAAQIDBAUG/8QAKBEAAgICAgICAQQDAQAAAAAAAAECEQMhEjETUSJBYRQygbGRofAE/9oADAMBAAIRAxEAPwAS1dFNc05TXz7PpESLXMQxiBudJ6Hka6tNV5b0/E/0n3poGWruCeyQlxWUwIDCDHI1BdQMIIBB61Nevs0ZiTAgTroOVRDehvegS1srYDBJYLFJGfSCZgDePeri60F7Wd6j2WtqxChg0CdTBIMeS03DccTJOYAn+5rScJNJ9mcZxi2ugzcblTJoP+9k+8PcVz97p99fcUKDBzXsLk00tQo8Yt/fX3FNPGLf319xRwfoOcfYTZqaGoWOLITAYEnzFEsMwOtJprsakn0TonWpK4DSqDQ7SArpAAk06y+YSAY89Pn6VSiS5HG0EgEnpTEssSCx22UbT59auW7JPpVq3aA/WrSIZXtYYnfT8atIgGwp4FPC00iWyq8kwBT7WG61K1wCo8xPpVpEtnLjBTp9KkbEryq9xdMOEt9yWLR48206bfX6UHK02iUx74gGmmoylcBigBxFcpwNcIoGcpUoroFAhsV1bZNS20o7wPiCWc0W0uMdBILR6AU0hNme7k12jz4G6xLdyddeQ+nKlQIw4uTUyNUNu3oKd3R5VyUdiLKmrGFS13RkP3pMgyMuWNmETm21mhwUkhWOUEgEmdBOpq7dhWKh1eDGZZg+YmDT6Qu2Imp8IAPEfl68qr21zGKtXDrpsNqS1srvQx0zAg89+R186yOL7IOCcrgCTGaToYiY259dhW/4Tgs5LN8I+p/SoOJrrWmOcobRnlhGemefjsld/wCIns1PPZF/+Ksf5T+tauaRar/UT9mX6bH6Mp/8RbX+MJ5eE/XWkvZI873snP8A1VqGakqzvR+on7Gv/Nj9Gat9kz/xuv2I15faqK1jHw9zurvybkw5Ef35Vrqq8QwKXlyuOsHmpIiRSWZy1PobwKO4aZzCXc4kVctRy15f0qlwzhxt2xbJOh3Gkj8qLYfCACIgdBU8V9FJv7IBYzEaTHsKuW8OBvqamVY0FPC9apITY0CpAnWmm5G1RliapIhsla6BtUTOTSC04LVCIwKcFp9NLUAcIpuWkXp9q5roJNAiweFXO7FwochMBo0mqV61G9bLhHC719AHcrbGyjX2nQUM7QcIso8C+ogaqIe4WkzJ1yjaqrVkct0ZR7sHT/3Utu6D69KJ4vs/3SLeKaP8LMZY/pQzJqNKTRSdiZ6q3caq6FhPTc+wq49sEEHnp71Hh7CW/gQA9dz70hsl4PbN54KOFicx0BOmgHPnW1wN7C4YeN1B6DxN7CTWLe8x0kx02FRRTsTVo3j9tsODAt3COsL+bUqwcUqrmyPFEr27NE8DgpOtVkq9h3rjO4m4hw4EbCg2N4aF2mjjXiKgxV0EGelKx0CMKuVPMk+21PFQEwfKnDEAUux9Bi1jcqgDlVDF3Zqm+K9aie6TVWRQ9mphaoyTXUNIZKq9akmowamS31pdj6OKJrtthmy7nn0HqeVTInSp7WHAq1Ehsp4PHqbr2vtLl+YZQfzq5cxltfidR8xQ7j3BO/Aa2Ql0aBtQCszlYj3H9aHYXseymXv/ACRfOd2P5V0RjBq2znlKadJBq3xyyxyq6k+u/p1qyL086EXey1kqAGcEfaOUk+ogTQ9uEYyxrafvF6f+Lfkaqo/TJ5SXaNUiazPy5VIBWWw/aNkOW9bZT6H6qdR9aNYPi9u58LA+XMeopOLQ1NMJBaawNEuA4tnJs2wDnIVvDnjXc/dA9RRDjHC7NrQ3gz/dEafIbfOitWHJXRl3uRTFHSfmZohiuz4Qo1wFlfxLJkRPIbDer95LVi8Cn8RBB1ET1EHaih2BbPDLt5glswT5SflOlEuE8KW1fy3CVYnKzOZjXn0FPvcRi8btsZNZUDlVXFYtrjFmMk6k09C2y9x3EuHa0t4tbGgynKp+Q3+c0GURT21psUmwSCdgd5bbPdVcg8KtLE+SjYUIdakmn2rJYxQBVNNBotj+Gi2YDq+kykn5bTQTF4hE3P8AfpvRQWTEVyKgsYnaRodj+tTs4pDORSqs3EbYMF1keYpUCsuqlW7K1dvcMZTBBFMFiKwaOlMguiqWIbQ1fvLVC/UUUUXFQslWylOWwTyoAHsK7lq9fwTSABqeVT/ua7GYo0Tl2O/SmlYroE5a4y1avYZlJBEEbg1GbdFDsfYSraWetLDDoKIpgmiYmrjGyJSoqqvSnCr1q2gnOrbGI0huROhkVWKitONGfKxkmp7t8FFXIoKz4hOZp+9ryqIimk0xCC1aTAXCmcKcsxMaTExVRSaO8FxFi3rfZm6IsmT58vc0ITdIAYq2pEOoI8wCB77UKfC2MP8AxwIDFQYMrrMHXl8603GsVavPK2QoG2bXf+UafjVWzhBdPdtkynSHgJprrOg2/CqT+hNXsiwPa/DWQyu4ZWUjKhI8R2Jy/nQ7Cces3DCtr0bQ+3Out2ew+csyZj5kkew0I9ZrmN7PYe6PgCHkyeE+2x+YqviR8+wsuKJjXbapsbfV2lUCCBoCSPXXWsi3C8XY1s3BdX7raN8pMfUelXeFcUuXJVrTIymCGkfMSNRSa9DUt7DaWidgT6U1lIol2e70HvLh7q1qrsD4oP2YUGZ6TVjibYRyFtBzyzNMeupn6UqHy3QAa4OtMN3oKKW+A2bd4C6HdNw4kk9GXNymu4fEWbYcMitIIUk6qevnRQWBC10khbZIH2pAG3v9KO8G4YShvXRKqfFlkgdBrFWuA4sOGsrmdGjMEygyNR4jtUvEuG4izaIVfCY8OfQ+uwp0K9k1/tNaCG3aw0ggg5iBoRGy/rVXheBtXbdz+DlcCVCBVXzzFtaCW7N4tqVUeWp29Ota7gHDbe9zxHoTIp22yaSWjHYnDRMkCqilTsw00r0bi/CMO50tAu2g58ogLty5VieJ4REYrCgjcDSCOopNUVGVg04VPuL7ClThA0BrtSM9ZuYy1cuAlARVJ+CI5uQYJ1Qch61nLPEINWW4wRsdayeRt7Rfgcf2OgXxWwEgBgzSQ6gEZSDG/Od9KFlZqbH35aeZqKxzqG7Noqji2KvYWxUKmrFu/FSWjtxwMRb8sn/VW1fjCARpuD8xzrzi7em7PmPpVh8UaabXRnPHGf7gt21x6XHhFWGyljAzZlnUHlM6+grMqtTXWnekoqm2+wjFRVImwyaitHhYrP2BqPUfjRi1cq4EzLmKsqRpQC9Z2o1cuaVQurMf3yNaGYMNsz5UiAKId3Uv7MDyooAdZRSRJgTqQJgdY50ntiTGo5VZv4QcqqOrCgB3cneDTTpRPh3FLdpSLgNzmFL5VBiJIG5+VD791HaQAJ5DWgVkQuD1o7w/ALct+Pu7UGc7tBP8sSBVXEcGuIveBSU5NGWfkdadgMJaZGNx0twfiJLHUaLlHpTSE3rQM4jh2DkW7iFesE/oPrVHi1i/lDWSM6z4W2YHlMiD66USZkVtHLL1VYn/AFURxvGbTrlFhixGrvcJbaNv60IGY9bvEhbI721BIJtbAx5xv86K4C3deBmynnpNdtW0AOgB0gliYHMa78varAsOENwE5QcpI0EkTE0N2CjRrsNw6ytn+K5uN95zt5KOlZ3F8OttLqFKqwE6QCdR+FCr90sczEseprivHKiwUTQ8O4nbw4UjxSJhYkQYgj7NT8U7UhjlVSV0kzB5SIj1FAMLiLevezGUxlKjxcpnlVG5dHX8aL0HFXYX/eoW7nCAoDIVtyOjEflVTFcTdmJDlQSfCpIAHTShxuio2xAHT5mlY6L9jFFWzhmDDYgmferdrCm6ty5K+HVszAMZ6A6k0DXFA7QfTWutiT1j2osKLJPlSqgcUPvj3pUhh4HWo5JM13NTLgkAa7jYkba8uVYHQRDrUlk6Go3rts6UhkpauB6ZXKAIvtVLNQrvUtMQqetcFOFAE1ncetEVNDrHxCr4rWHRlPsmzaU0jb++VNmnHlWhB0CpkNQipAaAJHANVrlmQanmu0gBF7CDWqnclToSPSjl2q1y0DTECb4c6lmb/MSfxqBcTl3gfKiVxKF41KQF0Y9chUrLEghtQQBMiNtdPaqpvjpQcsZOp96qW8cDd7sqdZMn+Wldj6NCcUB0964eIaRmHy1oRh7oJYR8Jj1/Sp81TZXEtNjfM+xqM4ryPzigGL43lLiIysFGxneZ10mPrU3DuIZ1B6aGYnTmYq3GSVkKUW6C5xB6D3/pTGvt5fX9arPiABmLAAb6bior98Ahp38IE6MTB/CI+dJJsptIts7Hn9BQXG8MuO0q4VfU/pRQwJGcMcxEAbaDbqPOoruICkAh9eiMfqBHuaE5J6FJRa2UcBwtrbZjcnQiNf1olkHSrd7CKqZ1zEsQRtpI2P1qslpj9n8qUm29jiklSOZaVS/s7dPqP1pVBZogaRNNmuk1makNw611NqiurJ5+8U0WvNv9R/WgCxFKKHYnGLbdUJaWE7naYqvgbZt4i4NStz+Ira781nbz9KriTYStbmpxVexz/vnU4qRjhT6jropgWMN8Q/vlV6qGF+Krtaw6Mp9klPqJzAPpWfxHEbuZEbu2DMRqk7Izdf5apuiKNNXaE4PHXGuKjZYIOwIOg9aKzQnYNUPWnA0wGnUwGOdahcU3F4lUkswHlz+QoPieOiSEHoW39hTEX8RQq6cxihl/iV12iWU9W0UgbBcvOqVt7hlgzzlM54mZ1FuBvtvRTFyQdGATfX3qFeEWg+eDmE/aPPfShqXrhDQ1wAQRnjOfJMunLn1prXLhzAM6qNRn+M6fCpUxy+tTwfsryR9BpcHbEnLuZOp1PXen/syfdFZ5brvKKzKPil80zoIzB/nFSYSzdvOLNpbvi+9mYjnOYOIGg/s0vG/YeVego3C7Gv8ABt6mTKgyddT1Op96dbwlpdFtovoqj8BV/h3ALVgTdY3bhEFc7G2D5knX0GnmahfCWw5IQD0mNuQqJS+rNIxvdGd7TIpFtdJLHQDllM/lVDFYQd5bSPCFX6T+grY/syfdHtUd/BWjq1tDA5qDoNacciQpY2zBcEFwYrMwcA59SDG/U+lbHvQeYq9w7CJeCi3bUzyyjSNJPICijYLD4eQlu294/E+RYXqBpqf78qeTJzd0TjxuCqzzrh5cX7mdmIBOXMxIgmdJOnKtEuIX7w96HcZwAN5iAoBg/Au5GtNXDkAar7R7AbVcvnsiL4aC37QvUVyhgQc219P/ACpVPjRXkZqwaRNRYa+rqGUyCJBqRjWB02QLzpxNct86p8Xwxu2mtKYZwAI15g7c9qFX2NKT1FWw1as4e/bC5VcgfGG1B31jl86CcQlHlvCttwFExmkhc0dIO1Zizx5MJ3lqznzmQXJjKy/ZgjyPzNDbvErlz+Jc/ixoDcJbUkEwZn2rq8Ojl826PQLTgAkkADckwPeq+L4xbTIBNzMSB3eVgIgksZAG4oZf4Bi8VYW5mti1q4ViQzLuDEbATHWaOWuG2Uw9qVMoQxAIzuxAJGWdiflpvWXBLtl8231osU4VQxPFbdsM10hMpWQMxAzbDqToapHtZhR/9h/0P+lSscn0inkiu2aPCfF8qe2OUXhZgyVzTpHPTeZ06UE4nxRreGa9aBzFVyypnxsonL1gkwaA4LtI6gXrilrk5VnwjJ9oNA2k6GJnyrWEXxM5yXKj0K8fC3ofwrNY1wty0SQFBckkwB/DYa+9Wx2lw7WS/eAE6ZYYsD8hqPOgnELBxyBbBDAg6zAnSJ5xI+lDjtWJS067DvCcUly4rW2VhDagzyFHgax3ZTs9ewRdroBzDTIZXQaSSBB1P0olxG7ibhPdjIp+yGGoMaEzyopRtIOTaTaDN/GokydQCY56UFvdpQ+ZFOQiAdBmBInwtPQjlQbH2Lqgl0A01JZPLXXehScHxRc3wjG2YJlZPwwPARt500rfYm9aQavsWmTmJ5zJ95qLLA2YeZB/GqD3Sgl0y/5kj8CKM2uzgxdpASttGhiROYjcQpkD5mqJpvogWw2//d9NKaUgiSI5zm/Sn8S7PXcIoIIe1MK+x11Accjy000+VVv2iCRqBrB7wzHKQf71oYFhmT74/wB36U1wv/EB+Z/Su4dy0Ad5vuLgI10nQTHvRjhLG28gkkn7YkjfUSNDUylxKjFyG4Hs+fivEou4Ag3G9AR4R5n2owHVFyW1CLzA3bzdt2/CmuxOpMnqazPHOLlb9pVZgqt/Ey/a20OnLXnzrL5TdGtRgrD9x6EYnFsHIAB2/CpU4kHuMiqYChs+kGY0jcHX6Gq18+Koars0TKuL4kwZI0gywnQqZ3mq/aLH3jhu9tqRb7xFNxSRvMA+pAB9fOr4wiPqSwMgeGNgCdZHmakxpP7K2HTS2rG4QdS7B88ttpoAANoHPWtocVTMMnJ2rAXYLiV8X76q7C1lIyySFJcZcs7GA2o6VqcVi1QQYLRoJH16VmeDv3WZ4UFlVQAkCZzZmK6sdTqZ+Ku4fGu7OblsyvTxEiekaR+dPPtuSJwaiky82JliXKkmNxMRy3pt/HAaALMbgf1obwu61rOpRmDszjL/ADdRBM1JcRXGVxcYGPCUDe4mqUfZLl6Kt3isExDDrIpU9uIpbJRLYCg6BkBOupnTzrlaV+DOza8K4S1q0lskSqgH1jX61cOBPX6UUVBTworlat2da0qRm8BZ722HRhB5FdQdiDDUHVbjYwW1YfHlJIOiiM5AnoCaM8CxFuw+KtuwAW6zCTtmPwgdAnde9ZbgHaHPebLkR2iDdBIJd9QIYQSY678qp4m3paLw54wi3J7apI9Q4ZwDBWmN1bKm6+puN4mJO8Tosxyisz267I27h/abBEoBnsEQtwBiSVK7MdQevlzJcL4ozfwroVX+yVPgYhZKidQ0S0HeD0IqTGYlEP8AEYKjA/EQJ5HzO4ra2jn0Z1e0uHnJft5dNQyDYjQaTK+Q32oH2q7W2jdjDWnViFYs0NBZQ8LZBCjfmdOlC04Ul+61m1eGdW8BYkgwTGZtTqNI3n6wYbh1/D3nLWO8uRC5WMDOHUtK6mI1+u9OGDGtsxnmm+v8lniGIbFMli9ft22XxFiuXOzAZRkJEEZiNJG+1W+G9iJCO92RoSuSJE7E5jvVe3hLf7R32Luh1BlLQaYYxo6k5lXQctdJOmuvweMJsoAB3hyJEyoZ9JJ00GsjTVSKc5NKoihFSdzNNgzbUAKqgxufiPv+VQ4yzZeSUGfrAM9JmsxdtXcpud88AEhYt5cu+vh0Mc+XnGsV3iZtlcwk5oJAiQULK0cvhIjqDWPE6uZrsTcVLZPhEKY2Gw0oJwVxZtLbkbZtBuX8Uz86D9n8NbF24Da0u+PxhWhizEEHowI+Y21q7x+5lYKhg5CxiPCqRoByJzAa8vSnx3SJU/thccROsH8/pQniGGt5WuAkLIZlTQyTByREAyDHrQ5MGRB725mJAPjJHiIUwp00mflV/B8CulAVvRBI2I1UlSQZ20PyNJrQ+Tugfw3AW7VwXSWcnKULwVyuFIYTqGGq/hWpbiGTxEhfPQVkMdxG3ZvIt6+jAM2YIc5BKn/EyiQJNcTi2EZi929bI8WVT4oGYgACJ2AO32vIRfBvZHkitBntFZ/aAuVbbiZeCudl8O2xmJG/TWrvCLu5ghd1kR4eWh2GhrzDjPF1e5cNlGCsQM3iB8M5YEwukD5VpuFcZt3LKIHAzZA4JGYEEZwZ5GD8jVPFJERzRbo1OO45Z0R/GjZgRlJViACsEjKdYOhoOnFuGOpY2ygBykkZYPT4qqcQNy62H7i5bzoC57x4G6HMDtmkEf2atve4hmYNZW5bAJUxbfMehAqZKi1Kya23D2IFu8UJEgRmkESCAyn6Vc4fYsA5lxVthI5Kp0npFZ5+Khf4l7hwVgcsiyVYabhl5cqhu4vhoPdvhzbNzKfA7iddPQyTUuN63/YKVb1/Rv0tIf8A7FPoR+tYjjnZ661267X7YTLcuDLmJ8ABCssAAmANCZiYpr4PA3YVMTftlBEAqYH82hJ+dSXeEalreMlSD/C+CdNgZpRqJUm5APBccsh1cMwgAQRtAgajlW8PA2cB0dCGAI3GhEjketeet2XxjBAbYuRCiGHhUToWnb0rT4XGcSs24NpmCgAKAjaCBplj+xW2ZRklRjhlJN2W2KW37trtvMNYDaxBHPnVDF8WthCsjMZkazDbRyNPbtRcAz38LEGPFbYHyI308xUtvtfYZA7WxlOk5vONmAiseNfRrzv7A1nFBEJkSFUxCsTuMvlyNPw+KKszDXNHiBAEchykeVGv3ng7gkWx65EYe4NDE4dhgxK4qATORrYyjWYAAAFU+EtSFGU4O4keIsodTeXrBVx9QCKrL4hAYATuzIBPMmWmtQMFgn0m3Pk5X6Zq43ZnDN8JcejT+M0JoTTsyWK4pZzHmdJ05wJpUA7QWhZxN23qQrGD5HUT560q7FhTRxSzSTaPd64bnnVbA4oXLaXMpXMoaDuJEwamL159HppmV47hrP7S990QhbLM/gViSmWTqCCcrKPzrJ/v6yl3vLaeANmAyIp3tHL72z/r6VrO01q4LeJcJIe24GskZ1tpAG5/w5+deZWGKtpKtuNwZ208zMV1YkmjiyyaYVt9r8UDmDrmkNOUbqTHqNTv1ofxXjV/EsGv3WcroJgAAkHQKANwPaobgKkjKAfMDnyg+tGcBwU5UZ8iK63vENSSpClBGmcSdPI76mtvitmPylqwXwnG5HgQFMyOsAxPzq8OKNnKO2a2TBHIdCPSlx7DkYxgGVjlBJUZRItwdCd9II68hVE2u8cKpJkbxEAbsfIa+1JqLd/gE5LX5LuOvWLTZUBYjRsxmCOgAUfU1ce9fv4cvbHdjDMtw8m1+Fl0GgKCBHPyoPjcTDPlVPEQwaJaGGbQnaQwqXs+Xu3HtlzBs34BY5Z7po0p1qwvdFm32txQTu5RlII1TXXeCI6mlhOMXLuJt3bpBhh4Vldp2VfEY3jmdOdGuymEtjCteuW7bKFzE3CdIa4dBBG2Ue1U+xmDlruJZNQp7sdS+dWKjyiB6mpbir0WlJ1vs2/ALiOCV1GSzoREEJGx1BkV57x+9dw+OvsrDMzE+ISCjgMAfIaD/lrY9n7wtko85jbs6TMMlsBx5HUHzk0H7ZYgLicNeUQUIzHTNBfwwDvHj5c6yhqbRrk3BP0CcV2iv3glq2iW3aFlSSzMfAInRZn+terYNVtW0RdFRQonooj8q8rx1nu8UMx/wUW6dpBbEZ2VQsZo701uL3Ei1om2VYsvhkEqZHPypZUqVDwt277PM8Ng2xV17k5Ve62sTBfPc1kgaBTuRuK7i+CFFZ86lBmjUBzldU1STlMsNJNajstgnw8K6rIZ7gYa/YVAD03aqnaRjcCAI5zPczZJgjvg2oGkwNCRyHQVt5PlS6MPFUbfZov/AOd2bdvBG44nO7uf8qeAD/YT86F9r+CJasIwCByB4goUlpQQQF1JLbk+dEeDKi4VbSZgCDIbUjMZYfiKscTwP7TkVycoMmDGgkjX/MFrHlU7N+FwS/BFw/suiSrZgyqglfGDodTz3nYAVN+5ob+HfTN0Mo34z9KMWSQxYncKPad/ep7hDCGAI6EAj61lLbs2iqVAXucbb2LH0bN9Gqpf4hdH+NYRh/Nb/MaUc/Y0HwF7f+RiB/pMr9KawvjZ0uDo65T/AKl0/wBtIZm0fBsWP7PkLAhjbbcHeRpVdeCYPKy27921mj4gTlI6GNPej+JdD/jYQj+ZIuD10gj2qoMJg7nwXsh6Exr6NTUmS4ooDs/f7tRYxNt3B+InUjXQ79R7Urv70sopCm42uYBpWJ0iavXOzj7q6sPP9RUBs4u0ZBeOitmHsaE16Bp+2Mv9qsRZRGu2yZAzLk1UxrtGlMbtThbiBrti2VbSSB9RB6Gpv3/eWA4U9c6QfpFMxPEsLc0vYZSOqwf0/GhUDbGoOG3UIW2URtCU0H+0+nKlh+A4QKy2r5AbkxmNI0mKYcBw+5bNtXe0p5a+vOQNqZhOyYWTaxPeAjQEho8xB0p9p7JqmtDLXZG6rBlxIuKPskeX3gaoY/huMskuVQpO6kyBP9alt9nsdbcHOHQHWDrHzH503iPEsZYYZUuFY10Ywfr5VW3KqTJ0o3tf9/Jk8ddz3GbqeZ16a0q1ljtPdZQSADzlROhjXSlW6zSSric7wwk75f6PVBaApFRUpFMK1xnoELoP/dZvj2d7lu3ayKfGzMRMLCoco5khyPnWpa3NUbvDELZ/tRlnXaZjfrTTomStHmfGuAlsQYJi4xljqAT4oA3AhT15VZt8IuA20klVYyRJMZToByUx7tW+ucItsysZlTI9cpXXroxqdLCrsAPpWnkdUZ+FXZ543Yu5euF2cIvLTMQB8wP/AHRdOxttUyC7c8/hAPrAmPKa17VE1J5JMaxRWzAX+wTlv8ZQun2SWgACImOXWrD9k7Vi25XOzspTNvGfwkgDbetoy00rR5ZC8MfRhW4Yy4Z8OAWUtmGbQgiI232mrXCDdFu3AiLartB02J961j26i7mk5tlLGl0AOF4O6js7vJeJ+QgaVFxrgovspIJ667ABoA57mtIbVNNmkpNbG4JqmY2/wVgxdVl9NSTsCp//ACKl4LYxCMVZItmYgiF5iNZjy9K1ndV0W6fN1TF40naKFuyedSJglAiP7OtXMlLLU2VRXt4YLoAB6VKlupIpRRYUdU08PTBXZoGPzUs1MmuGgRLnqDEYdLnxoreo19967NdmgAc3B1Uzae5aP8rEj5g/rTc2Mt7Ml0dCIb8vxNEs1ImgAW3HF2v2WTzIkfWKjNnBXfuqT/yGi2blVPE8Msv8SCeo8P4UBQPvdllOqXD5TqKGYns/iE+GD5gwfrRK7wR1M2LzKehmPdf0pv7bjbXxoLg6gT/0wfcUyWBlxWMs/auj18Y+sip7Pa28NHVHHplP029qKW+01s6XEKnnz+m9Tm5hL3ND6+E/Wn/BNemC/wD5WnPDf7h/20qvHsxhzqAfkxj8a5T+IfI9BNNNKlWZsNNMNKlQA1hUTClSpiORXCtKlSGMKUwrSpUAMYU2KVKgQiK5FKlQM4BXKVKgBhrkUqVAjsUprlKgBGkKVKgDk0ppUqBCpUqVMDsVwilSoAYTTSaVKgBpam5q7SpARX7CXNHRW9QD7HlQu/2etH4CyH/UPY6/Wu0qdg0mDLnZy7OjWyP+YfSKVKlT5Mjgj//Z",
    thumbnail: "data:image/jpeg;base64,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"
  }, {
    title: "Hotel Alinalex",
    link: "/hotel3",
    subtitle: "Brașov",
    image: "/images/parteneri/hotel3.jpg",
    thumbnail: "/images/parteneri/hotel3.jpg"
  }]
}, {
  name: "Hoteluri",
  "class": "hoteluri",
  items: [{
    title: "Piatra Mare",
    link: "/hotel1",
    subtitle: "Poiana Brașov",
    image: "/images/parteneri/hotel1.jpg",
    thumbnail: "/images/parteneri/hotel1.jpg"
  }, {
    title: "Hotel Stop",
    link: "/hotel2",
    subtitle: "Brașov",
    image: "/images/parteneri/hotel2.jpg",
    thumbnail: "/images/parteneri/hotel2.jpg"
  }, {
    title: "Hotel Alinalex",
    link: "/hotel3",
    subtitle: "Brașov",
    image: "/images/parteneri/hotel3.jpg",
    thumbnail: "/images/parteneri/hotel3.jpg"
  }, {
    title: "Hotel Esprit",
    link: "/hotel4",
    subtitle: "Brașov",
    image: "/images/parteneri/hotel4.jpg",
    thumbnail: "/images/parteneri/hotel4.jpg"
  }, {
    title: "Hotel Kolping",
    link: "/hotel5",
    subtitle: "Brașov",
    image: "/images/parteneri/hotel5.jpg",
    thumbnail: "/images/parteneri/hotel5.jpg"
  }]
}, {
  name: "Restaurante",
  "class": "restaurante",
  items: [{
    title: "Ceasul Rău",
    subtitle: "Restaurant Traditional",
    link: "/restaurant1",
    image: "/images/parteneri/restaurant1.jpg",
    thumbnail: "/images/parteneri/restaurant1.jpg"
  }, {
    title: "Pilvax",
    subtitle: "Restaurant Maghiar",
    link: "/restaurant1",
    image: "/images/parteneri/restaurant2.jpg",
    thumbnail: "/images/parteneri/restaurant2.jpg"
  }, {
    title: "Gaura Dulce",
    subtitle: "Restaurant ",
    link: "/restaurant1",
    image: "/images/parteneri/restaurant3.jpg",
    thumbnail: "/images/parteneri/restaurant3.jpg"
  }, {
    title: "Dei Fratti",
    subtitle: "Restaurant Italian",
    link: "/restaurant1",
    image: "/images/parteneri/restaurant4.jpg",
    thumbnail: "/images/parteneri/restaurant4.jpg"
  }, {
    title: "Le Pompon Rouge",
    subtitle: "Restaurant Franțuzesc",
    link: "/restaurant1",
    image: "/images/parteneri/restaurant5.jpg",
    thumbnail: "/images/parteneri/restaurant5.jpg"
  }, {
    title: "Prima Școală Românească",
    subtitle: "Muzeu",
    link: "/",
    image: "data:image/jpeg;base64,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",
    thumbnail: "data:image/jpeg;base64,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"
  }]
}, {
  name: "Baruri",
  "class": "baruri",
  items: [{
    title: "English Club",
    subtitle: "Bar englezesc",
    link: "/",
    image: "/images/parteneri/bar1.jpg",
    thumbnail: "/images/parteneri/bar1.jpg"
  }, {
    title: "Sculărie",
    subtitle: "Bar",
    link: "/",
    image: "/images/parteneri/bar2.jpg",
    thumbnail: "/images/parteneri/bar2.jpg"
  }, {
    title: "Deane's",
    subtitle: "Irish Bar",
    link: "/",
    image: "/images/parteneri/bar3.jpg",
    thumbnail: "/images/parteneri/bar3.jpg"
  }, {
    title: "Jamaica",
    subtitle: "Rasta Bar",
    link: "/",
    image: "/images/parteneri/bar4.jpg",
    thumbnail: "/images/parteneri/bar4.jpg"
  }, {
    title: "Cafe13",
    subtitle: "Cafenea",
    link: "/",
    image: "/images/parteneri/bar5.jpg",
    thumbnail: "/images/parteneri/bar5.jpg"
  }]
}, {
  name: "Cluburi",
  "class": "cluburi",
  items: [{
    title: "Four Rooms",
    subtitle: "Club",
    link: "/",
    image: "/images/parteneri/club1.jpg",
    thumbnail: "/images/parteneri/club1.jpg"
  }, {
    title: "MOVe",
    subtitle: "Club",
    link: "/",
    image: "/images/parteneri/club2.jpg",
    thumbnail: "/images/parteneri/club2.jpg"
  }, {
    title: "Arta",
    subtitle: "Sport Club",
    link: "/",
    image: "/images/parteneri/club3.jpg",
    thumbnail: "/images/parteneri/club3.jpg"
  }, {
    title: "Zao Planet",
    subtitle: "Children Club",
    link: "/",
    image: "/images/parteneri/club4.jpg",
    thumbnail: "/images/parteneri/club4.jpg"
  }, {
    title: "Malibu Brașov",
    subtitle: "Gentlemen Club",
    link: "/",
    image: "/images/parteneri/club5.jpg",
    thumbnail: "/images/parteneri/club5.jpg"
  }]
}, {
  name: "Fitness",
  "class": "fitness",
  items: [{
    title: "18gim",
    subtitle: "Fitness Club",
    link: "/",
    image: "/images/parteneri/fitness1.jpg",
    thumbnail: "/images/parteneri/fitness1.jpg"
  }, {
    title: "Gym puls Brasov",
    subtitle: "Fitness",
    link: "/",
    image: "https://upfit.world/data_files/clubs-gallery/752/gym-puls-brasov_752.jpg?cache=1532338519",
    thumbnail: "https://upfit.world/data_files/clubs-gallery/752/gym-puls-brasov_752.jpg?cache=1532338519"
  }, {
    title: "URSU",
    subtitle: "Gentlemen fitness",
    link: "/",
    image: "https://upfit.world/data_files/clubs-gallery/672/sala-fitness-brasov_672.jpg?cache=1531748162",
    thumbnail: "https://upfit.world/data_files/clubs-gallery/672/sala-fitness-brasov_672.jpg?cache=1531748162"
  }, {
    title: "Iron Will",
    subtitle: "fitness",
    link: "/",
    image: "data:image/jpeg;base64,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",
    thumbnail: "data:image/jpeg;base64,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"
  }, {
    title: "Belaqva",
    subtitle: "Gentlemen fitness",
    link: "/",
    image: "https://www.belaqva.com/data_files/gallery/group-fitness/9/group-fitness-image-clase-realryder-belaqva.jpg?cache=1564648290",
    thumbnail: "https://www.belaqva.com/data_files/gallery/group-fitness/9/group-fitness-image-clase-realryder-belaqva.jpg?cache=1564648290"
  }]
},, {
  name: "Circuite turistice",
  "class": "circuite",
  items: [{
    title: "Tur Privat Brașov",
    subtitle: "Transfer București Brașov",
    link: "/",
    image: "https://www.rentcarwithdriver.ro/wp-content/gallery/brasovvvv/Circuit-Turistic-Brasov.jpg",
    thumbnail: "https://www.rentcarwithdriver.ro/wp-content/gallery/brasovvvv/Circuit-Turistic-Brasov.jpg"
  }]
}, {
  name: "Benzinari",
  "class": "benzinari",
  items: [{
    title: "Socar Brașov",
    subtitle: "Benzinarie",
    link: "/",
    image: "https://storage0.dms.mpinteractiv.ro/media/1/1481/21330/16945839/1/poza-2.jpg",
    thumbnail: "https://storage0.dms.mpinteractiv.ro/media/1/1481/21330/16945839/1/poza-2.jpg"
  }]
}, {
  name: "Cultură și divertisment",
  "class": "cultura",
  items: [{
    title: "Muzeul Civilizatiei Urbane",
    subtitle: "Muzeu",
    link: "/",
    image: "data:image/jpeg;base64,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",
    thumbnail: "data:image/jpeg;base64,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"
  }, {
    title: "Prima Școală Românească",
    subtitle: "Muzeu",
    link: "/",
    image: "data:image/jpeg;base64,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",
    thumbnail: "data:image/jpeg;base64,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"
  }, {
    title: "Filarmonica Brașov",
    subtitle: "Filarmonica",
    link: "/",
    image: "data:image/jpeg;base64,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",
    thumbnail: "data:image/jpeg;base64,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"
  }]
}];
/* harmony default export */ __webpack_exports__["default"] = (parteneri_table);

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./components/page_components/parteneri.js":
/*!*************************************************!*\
  !*** ./components/page_components/parteneri.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _common_portofoliu_card__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/portofoliu/card */ "./components/common/portofoliu/card.js");
/* harmony import */ var react_grid_system__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-grid-system */ "./node_modules/react-grid-system/build/index.js");
/* harmony import */ var react_grid_system__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_grid_system__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _components_common_Headline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/common/Headline */ "./components/common/Headline.js");

var _jsxFileName = "G:\\MDMax\\go brasov\\site_nextjs\\gobv-site\\components\\page_components\\parteneri.js";

 // Components




function Parteneri() {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("section", {
    className: "section section-portfolio section-portfolio-1 bg-gradient-side overlay-color",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("span", {
      className: "bg-color bg-dark-60"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 14,
      columnNumber: 13
    }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "display-spacing",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_grid_system__WEBPACK_IMPORTED_MODULE_3__["Container"], {
        className: "container",
        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_common_Headline__WEBPACK_IMPORTED_MODULE_4__["default"], {
          label: "Portfolio",
          title: "Let's See Our portfolio",
          divider_1: true,
          position: "center"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 17,
          columnNumber: 21
        }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_common_portofoliu_card__WEBPACK_IMPORTED_MODULE_2__["default"], {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 18,
          columnNumber: 21
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 16,
        columnNumber: 17
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 15,
      columnNumber: 13
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 13,
    columnNumber: 9
  }, this);
}

_c = Parteneri;
/* harmony default export */ __webpack_exports__["default"] = (Parteneri);

var _c;

$RefreshReg$(_c, "Parteneri");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/clsx/dist/clsx.m.js":
/*!******************************************!*\
  !*** ./node_modules/clsx/dist/clsx.m.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function toVal(mix) {
	var k, y, str='';

	if (typeof mix === 'string' || typeof mix === 'number') {
		str += mix;
	} else if (typeof mix === 'object') {
		if (Array.isArray(mix)) {
			for (k=0; k < mix.length; k++) {
				if (mix[k]) {
					if (y = toVal(mix[k])) {
						str && (str += ' ');
						str += y;
					}
				}
			}
		} else {
			for (k in mix) {
				if (mix[k]) {
					str && (str += ' ');
					str += k;
				}
			}
		}
	}

	return str;
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
	var i=0, tmp, x, str='';
	while (i < arguments.length) {
		if (tmp = arguments[i++]) {
			if (x = toVal(tmp)) {
				str && (str += ' ');
				str += x
			}
		}
	}
	return str;
});


/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var assign=Object.assign.bind(Object);module.exports=assign;module.exports.default=module.exports;
//# sourceMappingURL=object-assign.js.map

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Fportfolio&absolutePagePath=G%3A%5CMDMax%5Cgo%20brasov%5Csite_nextjs%5Cgobv-site%5Cpages%5Cportfolio.js!./":
/*!*************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Fportfolio&absolutePagePath=G%3A%5CMDMax%5Cgo%20brasov%5Csite_nextjs%5Cgobv-site%5Cpages%5Cportfolio.js ***!
  \*************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


    (window.__NEXT_P = window.__NEXT_P || []).push([
      "/portfolio",
      function () {
        return __webpack_require__(/*! ./pages/portfolio.js */ "./pages/portfolio.js");
      }
    ]);
  

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js");

var _s = $RefreshSig$();

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

exports.__esModule = true;
exports["default"] = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js");

var _router2 = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

var cachedObserver;
var listeners = new Map();
var IntersectionObserver = true ? window.IntersectionObserver : undefined;
var prefetched = {};

function getObserver() {
  // Return shared instance of IntersectionObserver if already created
  if (cachedObserver) {
    return cachedObserver;
  } // Only create shared IntersectionObserver if supported in browser


  if (!IntersectionObserver) {
    return undefined;
  }

  return cachedObserver = new IntersectionObserver(function (entries) {
    entries.forEach(function (entry) {
      if (!listeners.has(entry.target)) {
        return;
      }

      var cb = listeners.get(entry.target);

      if (entry.isIntersecting || entry.intersectionRatio > 0) {
        cachedObserver.unobserve(entry.target);
        listeners["delete"](entry.target);
        cb();
      }
    });
  }, {
    rootMargin: '200px'
  });
}

var listenToIntersections = function listenToIntersections(el, cb) {
  var observer = getObserver();

  if (!observer) {
    return function () {};
  }

  observer.observe(el);
  listeners.set(el, cb);
  return function () {
    try {
      observer.unobserve(el);
    } catch (err) {
      console.error(err);
    }

    listeners["delete"](el);
  };
};

function prefetch(router, href, as, options) {
  if (false) {}
  if (!(0, _router.isLocalURL)(href)) return; // Prefetch the JSON page if asked (only in the client)
  // We need to handle a prefetch error here since we may be
  // loading with priority which can reject but we don't
  // want to force navigation since this is only a prefetch

  router.prefetch(href, as, options)["catch"](function (err) {
    if (true) {
      // rethrow to show invalid URL errors
      throw err;
    }
  }); // Join on an invalid URI character

  prefetched[href + '%' + as] = true;
}

function isModifiedEvent(event) {
  var target = event.currentTarget.target;
  return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
  event.nativeEvent && event.nativeEvent.which === 2;
}

function linkClicked(e, router, href, as, replace, shallow, scroll, locale) {
  var nodeName = e.currentTarget.nodeName;

  if (nodeName === 'A' && (isModifiedEvent(e) || !(0, _router.isLocalURL)(href))) {
    // ignore click for browser’s default behavior
    return;
  }

  e.preventDefault(); //  avoid scroll for urls with anchor refs

  if (scroll == null) {
    scroll = as.indexOf('#') < 0;
  } // replace state instead of push if prop is present


  router[replace ? 'replace' : 'push'](href, as, {
    shallow: shallow,
    locale: locale
  }).then(function (success) {
    if (!success) return;

    if (scroll) {
      window.scrollTo(0, 0);
      document.body.focus();
    }
  });
}

function Link(props) {
  _s();

  if (true) {
    var createPropError = function createPropError(args) {
      return new Error("Failed prop type: The prop `".concat(args.key, "` expects a ").concat(args.expected, " in `<Link>`, but got `").concat(args.actual, "` instead.") + (true ? "\nOpen your browser's console to view the Component stack trace." : undefined));
    }; // TypeScript trick for type-guarding:


    var requiredPropsGuard = {
      href: true
    };
    var requiredProps = Object.keys(requiredPropsGuard);
    requiredProps.forEach(function (key) {
      if (key === 'href') {
        if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {
          throw createPropError({
            key: key,
            expected: '`string` or `object`',
            actual: props[key] === null ? 'null' : typeof props[key]
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var _ = key;
      }
    }); // TypeScript trick for type-guarding:

    var optionalPropsGuard = {
      as: true,
      replace: true,
      scroll: true,
      shallow: true,
      passHref: true,
      prefetch: true,
      locale: true
    };
    var optionalProps = Object.keys(optionalPropsGuard);
    optionalProps.forEach(function (key) {
      var valType = typeof props[key];

      if (key === 'as') {
        if (props[key] && valType !== 'string' && valType !== 'object') {
          throw createPropError({
            key: key,
            expected: '`string` or `object`',
            actual: valType
          });
        }
      } else if (key === 'locale') {
        if (props[key] && valType !== 'string') {
          throw createPropError({
            key: key,
            expected: '`string`',
            actual: valType
          });
        }
      } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch') {
        if (props[key] != null && valType !== 'boolean') {
          throw createPropError({
            key: key,
            expected: '`boolean`',
            actual: valType
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var _ = key;
      }
    }); // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes
    // eslint-disable-next-line react-hooks/rules-of-hooks

    var hasWarned = _react["default"].useRef(false);

    if (props.prefetch && !hasWarned.current) {
      hasWarned.current = true;
      console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://err.sh/vercel/next.js/prefetch-true-deprecated');
    }
  }

  var p = props.prefetch !== false;

  var _react$default$useSta = _react["default"].useState(),
      _react$default$useSta2 = _slicedToArray(_react$default$useSta, 2),
      childElm = _react$default$useSta2[0],
      setChildElm = _react$default$useSta2[1];

  var router = (0, _router2.useRouter)();
  var pathname = router && router.pathname || '/';

  var _react$default$useMem = _react["default"].useMemo(function () {
    var _ref = (0, _router.resolveHref)(pathname, props.href, true),
        _ref2 = _slicedToArray(_ref, 2),
        resolvedHref = _ref2[0],
        resolvedAs = _ref2[1];

    return {
      href: resolvedHref,
      as: props.as ? (0, _router.resolveHref)(pathname, props.as) : resolvedAs || resolvedHref
    };
  }, [pathname, props.href, props.as]),
      href = _react$default$useMem.href,
      as = _react$default$useMem.as;

  _react["default"].useEffect(function () {
    if (p && IntersectionObserver && childElm && childElm.tagName && (0, _router.isLocalURL)(href)) {
      // Join on an invalid URI character
      var isPrefetched = prefetched[href + '%' + as];

      if (!isPrefetched) {
        return listenToIntersections(childElm, function () {
          prefetch(router, href, as);
        });
      }
    }
  }, [p, childElm, href, as, router]);

  var children = props.children,
      replace = props.replace,
      shallow = props.shallow,
      scroll = props.scroll,
      locale = props.locale; // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag

  if (typeof children === 'string') {
    children = /*#__PURE__*/_react["default"].createElement("a", null, children);
  } // This will return the first child, if multiple are provided it will throw an error


  var child = _react.Children.only(children);

  var childProps = {
    ref: function ref(el) {
      if (el) setChildElm(el);

      if (child && typeof child === 'object' && child.ref) {
        if (typeof child.ref === 'function') child.ref(el);else if (typeof child.ref === 'object') {
          child.ref.current = el;
        }
      }
    },
    onClick: function onClick(e) {
      if (child.props && typeof child.props.onClick === 'function') {
        child.props.onClick(e);
      }

      if (!e.defaultPrevented) {
        linkClicked(e, router, href, as, replace, shallow, scroll, locale);
      }
    }
  };

  if (p) {
    childProps.onMouseEnter = function (e) {
      if (!(0, _router.isLocalURL)(href)) return;

      if (child.props && typeof child.props.onMouseEnter === 'function') {
        child.props.onMouseEnter(e);
      }

      prefetch(router, href, as, {
        priority: true
      });
    };
  } // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
  // defined, we specify the current 'href', so that repetition is not needed by the user


  if (props.passHref || child.type === 'a' && !('href' in child.props)) {
    childProps.href = (0, _router.addBasePath)((0, _router.addLocale)(as, typeof locale !== 'undefined' ? locale : router && router.locale, router && router.defaultLocale));
  }

  return /*#__PURE__*/_react["default"].cloneElement(child, childProps);
}

_s(Link, "Yt4+dEXpDdcToH476p06kPk14D0=");

_c = Link;
var _default = Link;
exports["default"] = _default;

var _c;

$RefreshReg$(_c, "Link");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/normalize-trailing-slash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.removePathTrailingSlash = removePathTrailingSlash;
exports.normalizePathTrailingSlash = void 0;
/**
* Removes the trailing slash of a path if there is one. Preserves the root path `/`.
*/

function removePathTrailingSlash(path) {
  return path.endsWith('/') && path !== '/' ? path.slice(0, -1) : path;
}
/**
* Normalizes the trailing slash of a path according to the `trailingSlash` option
* in `next.config.js`.
*/


var normalizePathTrailingSlash =  false ? undefined : removePathTrailingSlash;
exports.normalizePathTrailingSlash = normalizePathTrailingSlash;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _construct = __webpack_require__(/*! @babel/runtime/helpers/construct */ "./node_modules/next/node_modules/@babel/runtime/helpers/construct.js");

var _s = $RefreshSig$();

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useRouter = useRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports.createRouter = exports.withRouter = exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js"));

exports.Router = _router2["default"];
exports.NextRouter = _router2.NextRouter;

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ "./node_modules/next/dist/client/with-router.js"));

exports.withRouter = _withRouter["default"];
/* global window */

var singletonRouter = {
  router: null,
  // holds the actual router instance
  readyCallbacks: [],
  ready: function ready(cb) {
    if (this.router) return cb();

    if (true) {
      this.readyCallbacks.push(cb);
    }
  }
}; // Create public properties and methods of the router in the singletonRouter

var urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath', 'locale', 'locales', 'defaultLocale'];
var routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
var coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it

Object.defineProperty(singletonRouter, 'events', {
  get: function get() {
    return _router2["default"].events;
  }
});
urlPropertyFields.forEach(function (field) {
  // Here we need to use Object.defineProperty because, we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  Object.defineProperty(singletonRouter, field, {
    get: function get() {
      var router = getRouter();
      return router[field];
    }
  });
});
coreMethodFields.forEach(function (field) {
  // We don't really know the types here, so we add them later instead
  ;

  singletonRouter[field] = function () {
    var router = getRouter();
    return router[field].apply(router, arguments);
  };
});
routerEvents.forEach(function (event) {
  singletonRouter.ready(function () {
    _router2["default"].events.on(event, function () {
      var eventField = "on".concat(event.charAt(0).toUpperCase()).concat(event.substring(1));
      var _singletonRouter = singletonRouter;

      if (_singletonRouter[eventField]) {
        try {
          _singletonRouter[eventField].apply(_singletonRouter, arguments);
        } catch (err) {
          console.error("Error when running the Router event: ".concat(eventField));
          console.error("".concat(err.message, "\n").concat(err.stack));
        }
      }
    });
  });
});

function getRouter() {
  if (!singletonRouter.router) {
    var message = 'No router instance found.\n' + 'You should only use "next/router" inside the client side of your app.\n';
    throw new Error(message);
  }

  return singletonRouter.router;
} // Export the singletonRouter and this is the public API.


var _default = singletonRouter; // Reexport the withRoute HOC

exports["default"] = _default;

function useRouter() {
  _s();

  return _react["default"].useContext(_routerContext.RouterContext);
} // INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.


_s(useRouter, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

var createRouter = function createRouter() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  singletonRouter.router = _construct(_router2["default"], args);
  singletonRouter.readyCallbacks.forEach(function (cb) {
    return cb();
  });
  singletonRouter.readyCallbacks = [];
  return singletonRouter.router;
}; // This function is used to create the `withRouter` router instance


exports.createRouter = createRouter;

function makePublicRouterInstance(router) {
  var _router = router;
  var instance = {};

  var _iterator = _createForOfIteratorHelper(urlPropertyFields),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var property = _step.value;

      if (typeof _router[property] === 'object') {
        instance[property] = Object.assign(Array.isArray(_router[property]) ? [] : {}, _router[property]); // makes sure query is not stateful

        continue;
      }

      instance[property] = _router[property];
    } // Events is a static property on the router, the router doesn't have to be initialized to use it

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  instance.events = _router2["default"].events;
  coreMethodFields.forEach(function (field) {
    instance[field] = function () {
      return _router[field].apply(_router, arguments);
    };
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = withRouter;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

function withRouter(ComposedComponent) {
  function WithRouterWrapper(props) {
    return /*#__PURE__*/_react["default"].createElement(ComposedComponent, Object.assign({
      router: (0, _router.useRouter)()
    }, props));
  }

  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app
  ;
  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;

  if (true) {
    var name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
    WithRouterWrapper.displayName = "withRouter(".concat(name, ")");
  }

  return WithRouterWrapper;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/compiled/path-to-regexp/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-to-regexp/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Tokenize input string.
 */
function lexer(str) {
    var tokens = [];
    var i = 0;
    while (i < str.length) {
        var char = str[i];
        if (char === "*" || char === "+" || char === "?") {
            tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
            continue;
        }
        if (char === "\\") {
            tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
            continue;
        }
        if (char === "{") {
            tokens.push({ type: "OPEN", index: i, value: str[i++] });
            continue;
        }
        if (char === "}") {
            tokens.push({ type: "CLOSE", index: i, value: str[i++] });
            continue;
        }
        if (char === ":") {
            var name = "";
            var j = i + 1;
            while (j < str.length) {
                var code = str.charCodeAt(j);
                if (
                // `0-9`
                (code >= 48 && code <= 57) ||
                    // `A-Z`
                    (code >= 65 && code <= 90) ||
                    // `a-z`
                    (code >= 97 && code <= 122) ||
                    // `_`
                    code === 95) {
                    name += str[j++];
                    continue;
                }
                break;
            }
            if (!name)
                throw new TypeError("Missing parameter name at " + i);
            tokens.push({ type: "NAME", index: i, value: name });
            i = j;
            continue;
        }
        if (char === "(") {
            var count = 1;
            var pattern = "";
            var j = i + 1;
            if (str[j] === "?") {
                throw new TypeError("Pattern cannot start with \"?\" at " + j);
            }
            while (j < str.length) {
                if (str[j] === "\\") {
                    pattern += str[j++] + str[j++];
                    continue;
                }
                if (str[j] === ")") {
                    count--;
                    if (count === 0) {
                        j++;
                        break;
                    }
                }
                else if (str[j] === "(") {
                    count++;
                    if (str[j + 1] !== "?") {
                        throw new TypeError("Capturing groups are not allowed at " + j);
                    }
                }
                pattern += str[j++];
            }
            if (count)
                throw new TypeError("Unbalanced pattern at " + i);
            if (!pattern)
                throw new TypeError("Missing pattern at " + i);
            tokens.push({ type: "PATTERN", index: i, value: pattern });
            i = j;
            continue;
        }
        tokens.push({ type: "CHAR", index: i, value: str[i++] });
    }
    tokens.push({ type: "END", index: i, value: "" });
    return tokens;
}
/**
 * Parse a string for the raw tokens.
 */
function parse(str, options) {
    if (options === void 0) { options = {}; }
    var tokens = lexer(str);
    var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
    var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
    var result = [];
    var key = 0;
    var i = 0;
    var path = "";
    var tryConsume = function (type) {
        if (i < tokens.length && tokens[i].type === type)
            return tokens[i++].value;
    };
    var mustConsume = function (type) {
        var value = tryConsume(type);
        if (value !== undefined)
            return value;
        var _a = tokens[i], nextType = _a.type, index = _a.index;
        throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
    };
    var consumeText = function () {
        var result = "";
        var value;
        // tslint:disable-next-line
        while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
            result += value;
        }
        return result;
    };
    while (i < tokens.length) {
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
            var prefix = char || "";
            if (prefixes.indexOf(prefix) === -1) {
                path += prefix;
                prefix = "";
            }
            if (path) {
                result.push(path);
                path = "";
            }
            result.push({
                name: name || key++,
                prefix: prefix,
                suffix: "",
                pattern: pattern || defaultPattern,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
            path += value;
            continue;
        }
        if (path) {
            result.push(path);
            path = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
            var prefix = consumeText();
            var name_1 = tryConsume("NAME") || "";
            var pattern_1 = tryConsume("PATTERN") || "";
            var suffix = consumeText();
            mustConsume("CLOSE");
            result.push({
                name: name_1 || (pattern_1 ? key++ : ""),
                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                prefix: prefix,
                suffix: suffix,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        mustConsume("END");
    }
    return result;
}
exports.parse = parse;
/**
 * Compile a string to a template function for the path.
 */
function compile(str, options) {
    return tokensToFunction(parse(str, options), options);
}
exports.compile = compile;
/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens, options) {
    if (options === void 0) { options = {}; }
    var reFlags = flags(options);
    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
    // Compile all the tokens into regexps.
    var matches = tokens.map(function (token) {
        if (typeof token === "object") {
            return new RegExp("^(?:" + token.pattern + ")$", reFlags);
        }
    });
    return function (data) {
        var path = "";
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (typeof token === "string") {
                path += token;
                continue;
            }
            var value = data ? data[token.name] : undefined;
            var optional = token.modifier === "?" || token.modifier === "*";
            var repeat = token.modifier === "*" || token.modifier === "+";
            if (Array.isArray(value)) {
                if (!repeat) {
                    throw new TypeError("Expected \"" + token.name + "\" to not repeat, but got an array");
                }
                if (value.length === 0) {
                    if (optional)
                        continue;
                    throw new TypeError("Expected \"" + token.name + "\" to not be empty");
                }
                for (var j = 0; j < value.length; j++) {
                    var segment = encode(value[j], token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError("Expected all \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                    }
                    path += token.prefix + segment + token.suffix;
                }
                continue;
            }
            if (typeof value === "string" || typeof value === "number") {
                var segment = encode(String(value), token);
                if (validate && !matches[i].test(segment)) {
                    throw new TypeError("Expected \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                }
                path += token.prefix + segment + token.suffix;
                continue;
            }
            if (optional)
                continue;
            var typeOfMessage = repeat ? "an array" : "a string";
            throw new TypeError("Expected \"" + token.name + "\" to be " + typeOfMessage);
        }
        return path;
    };
}
exports.tokensToFunction = tokensToFunction;
/**
 * Create path match function from `path-to-regexp` spec.
 */
function match(str, options) {
    var keys = [];
    var re = pathToRegexp(str, keys, options);
    return regexpToFunction(re, keys, options);
}
exports.match = match;
/**
 * Create a path match function from `path-to-regexp` output.
 */
function regexpToFunction(re, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;
    return function (pathname) {
        var m = re.exec(pathname);
        if (!m)
            return false;
        var path = m[0], index = m.index;
        var params = Object.create(null);
        var _loop_1 = function (i) {
            // tslint:disable-next-line
            if (m[i] === undefined)
                return "continue";
            var key = keys[i - 1];
            if (key.modifier === "*" || key.modifier === "+") {
                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {
                    return decode(value, key);
                });
            }
            else {
                params[key.name] = decode(m[i], key);
            }
        };
        for (var i = 1; i < m.length; i++) {
            _loop_1(i);
        }
        return { path: path, index: index, params: params };
    };
}
exports.regexpToFunction = regexpToFunction;
/**
 * Escape a regular expression string.
 */
function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
/**
 * Get the flags for a regexp from the options.
 */
function flags(options) {
    return options && options.sensitive ? "" : "i";
}
/**
 * Pull out keys from a regexp.
 */
function regexpToRegexp(path, keys) {
    if (!keys)
        return path;
    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g);
    if (groups) {
        for (var i = 0; i < groups.length; i++) {
            keys.push({
                name: i,
                prefix: "",
                suffix: "",
                modifier: "",
                pattern: ""
            });
        }
    }
    return path;
}
/**
 * Transform an array into a regexp.
 */
function arrayToRegexp(paths, keys, options) {
    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });
    return new RegExp("(?:" + parts.join("|") + ")", flags(options));
}
/**
 * Create a path regexp from string input.
 */
function stringToRegexp(path, keys, options) {
    return tokensToRegexp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 */
function tokensToRegexp(tokens, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;
    var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
    var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
    var route = start ? "^" : "";
    // Iterate over the tokens and create our regexp string.
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (typeof token === "string") {
            route += escapeString(encode(token));
        }
        else {
            var prefix = escapeString(encode(token.prefix));
            var suffix = escapeString(encode(token.suffix));
            if (token.pattern) {
                if (keys)
                    keys.push(token);
                if (prefix || suffix) {
                    if (token.modifier === "+" || token.modifier === "*") {
                        var mod = token.modifier === "*" ? "?" : "";
                        route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
                    }
                    else {
                        route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
                    }
                }
                else {
                    route += "(" + token.pattern + ")" + token.modifier;
                }
            }
            else {
                route += "(?:" + prefix + suffix + ")" + token.modifier;
            }
        }
    }
    if (end) {
        if (!strict)
            route += delimiter + "?";
        route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
    }
    else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string"
            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
            : // tslint:disable-next-line
                endToken === undefined;
        if (!strict) {
            route += "(?:" + delimiter + "(?=" + endsWith + "))?";
        }
        if (!isEndDelimited) {
            route += "(?=" + delimiter + "|" + endsWith + ")";
        }
    }
    return new RegExp(route, flags(options));
}
exports.tokensToRegexp = tokensToRegexp;
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 */
function pathToRegexp(path, keys, options) {
    if (path instanceof RegExp)
        return regexpToRegexp(path, keys);
    if (Array.isArray(path))
        return arrayToRegexp(path, keys, options);
    return stringToRegexp(path, keys, options);
}
exports.pathToRegexp = pathToRegexp;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/mitt.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/mitt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = mitt;
/*
MIT License
Copyright (c) Jason Miller (https://jasonformat.com/)
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// This file is based on https://github.com/developit/mitt/blob/v1.1.3/src/index.js
// It's been edited for the needs of this script
// See the LICENSE at the top of the file

function mitt() {
  var all = Object.create(null);
  return {
    on: function on(type, handler) {
      ;
      (all[type] || (all[type] = [])).push(handler);
    },
    off: function off(type, handler) {
      if (all[type]) {
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },
    emit: function emit(type) {
      for (var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        evts[_key - 1] = arguments[_key];
      }

      // eslint-disable-next-line array-callback-return
      ;
      (all[type] || []).slice().map(function (handler) {
        handler.apply(void 0, evts);
      });
    }
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router-context.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router-context.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.RouterContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var RouterContext = /*#__PURE__*/_react["default"].createContext(null);

exports.RouterContext = RouterContext;

if (true) {
  RouterContext.displayName = 'RouterContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/router.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js");

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/next/node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/next/node_modules/@babel/runtime/helpers/createClass.js");

exports.__esModule = true;
exports.addLocale = addLocale;
exports.delLocale = delLocale;
exports.hasBasePath = hasBasePath;
exports.addBasePath = addBasePath;
exports.delBasePath = delBasePath;
exports.isLocalURL = isLocalURL;
exports.interpolateAs = interpolateAs;
exports.resolveHref = resolveHref;
exports.markLoadingError = markLoadingError;
exports["default"] = void 0;

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

var _denormalizePagePath = __webpack_require__(/*! ../../server/denormalize-page-path */ "./node_modules/next/dist/next-server/server/denormalize-page-path.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var _querystring = __webpack_require__(/*! ./utils/querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _resolveRewrites = _interopRequireDefault(__webpack_require__(/*! ./utils/resolve-rewrites */ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js"));

var _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

var _escapePathDelimiters = _interopRequireDefault(__webpack_require__(/*! ./utils/escape-path-delimiters */ "./node_modules/next/dist/next-server/lib/router/utils/escape-path-delimiters.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/* global __NEXT_DATA__ */
// tslint:disable:no-console


var basePath =  false || '';

function buildCancellationError() {
  return Object.assign(new Error('Route Cancelled'), {
    cancelled: true
  });
}

function addPathPrefix(path, prefix) {
  return prefix && path.startsWith('/') ? path === '/' ? (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(prefix) : "".concat(prefix).concat(path) : path;
}

function addLocale(path, locale, defaultLocale) {
  if (false) {}

  return path;
}

function delLocale(path, locale) {
  if (false) {}

  return path;
}

function hasBasePath(path) {
  return path === basePath || path.startsWith(basePath + '/');
}

function addBasePath(path) {
  // we only add the basepath on relative urls
  return addPathPrefix(path, basePath);
}

function delBasePath(path) {
  return path.slice(basePath.length) || '/';
}
/**
* Detects whether a given url is routable by the Next.js router (browser only).
*/


function isLocalURL(url) {
  if (url.startsWith('/')) return true;

  try {
    // absolute urls can be local if they are on the same origin
    var locationOrigin = (0, _utils.getLocationOrigin)();
    var resolved = new URL(url, locationOrigin);
    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);
  } catch (_) {
    return false;
  }
}

function interpolateAs(route, asPathname, query) {
  var interpolatedRoute = '';
  var dynamicRegex = (0, _routeRegex.getRouteRegex)(route);
  var dynamicGroups = dynamicRegex.groups;
  var dynamicMatches = // Try to match the dynamic route against the asPath
  (asPathname !== route ? (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href
  // TODO: should this take priority; also need to change in the router.
  query;
  interpolatedRoute = route;
  var params = Object.keys(dynamicGroups);

  if (!params.every(function (param) {
    var value = dynamicMatches[param] || '';
    var _dynamicGroups$param = dynamicGroups[param],
        repeat = _dynamicGroups$param.repeat,
        optional = _dynamicGroups$param.optional; // support single-level catch-all
    // TODO: more robust handling for user-error (passing `/`)

    var replaced = "[".concat(repeat ? '...' : '').concat(param, "]");

    if (optional) {
      replaced = "".concat(!value ? '/' : '', "[").concat(replaced, "]");
    }

    if (repeat && !Array.isArray(value)) value = [value];
    return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present
    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(_escapePathDelimiters["default"]).join('/') : (0, _escapePathDelimiters["default"])(value)) || '/');
  })) {
    interpolatedRoute = ''; // did not satisfy all requirements
    // n.b. We ignore this error because we handle warning for this case in
    // development in the `<Link>` component directly.
  }

  return {
    params: params,
    result: interpolatedRoute
  };
}

function omitParmsFromQuery(query, params) {
  var filteredQuery = {};
  Object.keys(query).forEach(function (key) {
    if (!params.includes(key)) {
      filteredQuery[key] = query[key];
    }
  });
  return filteredQuery;
}
/**
* Resolves a given hyperlink with a certain router state (basePath not included).
* Preserves absolute urls.
*/


function resolveHref(currentPath, href, resolveAs) {
  // we use a dummy base url for relative urls
  var base = new URL(currentPath, 'http://n');
  var urlAsString = typeof href === 'string' ? href : (0, _utils.formatWithValidation)(href);

  try {
    var finalUrl = new URL(urlAsString, base);
    finalUrl.pathname = (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(finalUrl.pathname);
    var interpolatedAs = '';

    if ((0, _isDynamic.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
      var query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);

      var _interpolateAs = interpolateAs(finalUrl.pathname, finalUrl.pathname, query),
          result = _interpolateAs.result,
          params = _interpolateAs.params;

      if (result) {
        interpolatedAs = (0, _utils.formatWithValidation)({
          pathname: result,
          hash: finalUrl.hash,
          query: omitParmsFromQuery(query, params)
        });
      }
    } // if the origin didn't change, it means we received a relative href


    var resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;
  } catch (_) {
    return resolveAs ? [urlAsString] : urlAsString;
  }
}

var PAGE_LOAD_ERROR = Symbol('PAGE_LOAD_ERROR');

function markLoadingError(err) {
  return Object.defineProperty(err, PAGE_LOAD_ERROR, {});
}

function prepareUrlAs(router, url, as) {
  // If url and as provided as an object representation,
  // we'll format them into the string version here.
  return {
    url: addBasePath(resolveHref(router.pathname, url)),
    as: as ? addBasePath(resolveHref(router.pathname, as)) : as
  };
}

var manualScrollRestoration =  false && false;
var SSG_DATA_NOT_FOUND_ERROR = 'SSG Data NOT_FOUND';

function fetchRetry(url, attempts) {
  return fetch(url, {
    // Cookies are required to be present for Next.js' SSG "Preview Mode".
    // Cookies may also be required for `getServerSideProps`.
    //
    // > `fetch` won’t send cookies, unless you set the credentials init
    // > option.
    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
    //
    // > For maximum browser compatibility when it comes to sending &
    // > receiving cookies, always supply the `credentials: 'same-origin'`
    // > option instead of relying on the default.
    // https://github.com/github/fetch#caveats
    credentials: 'same-origin'
  }).then(function (res) {
    if (!res.ok) {
      if (attempts > 1 && res.status >= 500) {
        return fetchRetry(url, attempts - 1);
      }

      if (res.status === 404) {
        // TODO: handle reloading in development from fallback returning 200
        // to on-demand-entry-handler causing it to reload periodically
        throw new Error(SSG_DATA_NOT_FOUND_ERROR);
      }

      throw new Error("Failed to load static props");
    }

    return res.json();
  });
}

function fetchNextData(dataHref, isServerRender) {
  return fetchRetry(dataHref, isServerRender ? 3 : 1)["catch"](function (err) {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      markLoadingError(err);
    }

    throw err;
  });
}

var Router = /*#__PURE__*/function () {
  /**
  * Map of all components loaded in `Router`
  */
  // Static Data Cache
  function Router(_pathname, _query, _as, _ref) {
    var _this = this;

    var initialProps = _ref.initialProps,
        pageLoader = _ref.pageLoader,
        App = _ref.App,
        wrapApp = _ref.wrapApp,
        Component = _ref.Component,
        initialStyleSheets = _ref.initialStyleSheets,
        err = _ref.err,
        subscription = _ref.subscription,
        isFallback = _ref.isFallback,
        locale = _ref.locale,
        locales = _ref.locales,
        defaultLocale = _ref.defaultLocale;

    _classCallCheck(this, Router);

    this.route = void 0;
    this.pathname = void 0;
    this.query = void 0;
    this.asPath = void 0;
    this.basePath = void 0;
    this.components = void 0;
    this.sdc = {};
    this.sub = void 0;
    this.clc = void 0;
    this.pageLoader = void 0;
    this._bps = void 0;
    this.events = void 0;
    this._wrapApp = void 0;
    this.isSsr = void 0;
    this.isFallback = void 0;
    this._inFlightRoute = void 0;
    this._shallow = void 0;
    this.locale = void 0;
    this.locales = void 0;
    this.defaultLocale = void 0;

    this.onPopState = function (e) {
      var state = e.state;

      if (!state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        var _pathname2 = _this.pathname,
            query = _this.query;

        _this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname2),
          query: query
        }), (0, _utils.getURL)());

        return;
      }

      if (!state.__N) {
        return;
      }

      var url = state.url,
          as = state.as,
          options = state.options;

      var _ref2 = (0, _parseRelativeUrl.parseRelativeUrl)(url),
          pathname = _ref2.pathname; // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site


      if (_this.isSsr && as === _this.asPath && pathname === _this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (_this._bps && !_this._bps(state)) {
        return;
      }

      _this.change('replaceState', url, as, Object.assign({}, options, {
        shallow: options.shallow && _this._shallow,
        locale: options.locale || _this.defaultLocale
      }));
    }; // represents the current component key


    this.route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(_pathname); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (_pathname !== '/_error') {
      this.components[this.route] = {
        Component: Component,
        styleSheets: initialStyleSheets,
        props: initialProps,
        err: err,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components['/_app'] = {
      Component: App,
      styleSheets: [
        /* /_app does not need its stylesheets managed */
      ]
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = _pathname;
    this.query = _query; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    this.asPath = // @ts-ignore this is temporarily global (attached to window)
    (0, _isDynamic.isDynamicRoute)(_pathname) && __NEXT_DATA__.autoExport ? _pathname : _as;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;

    if (false) {}

    if (true) {
      // make sure "as" doesn't start with double slashes or else it can
      // throw an error as it's considered invalid
      if (_as.substr(0, 2) !== '//') {
        // in order for `e.state` to work on the `onpopstate` event
        // we have to register the initial route upon initialization
        this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname),
          query: _query
        }), (0, _utils.getURL)());
      }

      window.addEventListener('popstate', this.onPopState); // enable custom scroll restoration handling when available
      // otherwise fallback to browser's default handling

      if (false) { var debouncedScrollSave, scrollDebounceTimeout; }
    }
  }

  _createClass(Router, [{
    key: "reload",
    value: function reload() {
      window.location.reload();
    }
    /**
    * Go back in history
    */

  }, {
    key: "back",
    value: function back() {
      window.history.back();
    }
    /**
    * Performs a `pushState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "push",
    value: function push(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      ;

      var _prepareUrlAs = prepareUrlAs(this, url, as);

      url = _prepareUrlAs.url;
      as = _prepareUrlAs.as;
      return this.change('pushState', url, as, options);
    }
    /**
    * Performs a `replaceState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "replace",
    value: function replace(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      ;

      var _prepareUrlAs2 = prepareUrlAs(this, url, as);

      url = _prepareUrlAs2.url;
      as = _prepareUrlAs2.as;
      return this.change('replaceState', url, as, options);
    }
  }, {
    key: "change",
    value: function () {
      var _change = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(method, url, as, options) {
        var _this2 = this;

        var _require, normalizeLocalePath, localePathResult, cleanedAs, pages, _yield$this$pageLoade, rewrites, parsed, _parsed, pathname, query, route, _options$shallow, shallow, resolvedAs, potentialHref, parsedAs, asPathname, routeRegex, routeMatch, shouldInterpolate, interpolatedAs, missingParams, routeInfo, error, props, __N_SSG, __N_SSP, destination, parsedHref, appComp;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (isLocalURL(url)) {
                  _context.next = 3;
                  break;
                }

                window.location.href = url;
                return _context.abrupt("return", false);

              case 3:
                if (false) {}

                if (!options._h) {
                  this.isSsr = false;
                } // marking route changes as a navigation start entry


                if (_utils.ST) {
                  performance.mark('routeChange');
                }

                if (this._inFlightRoute) {
                  this.abortComponentLoad(this._inFlightRoute);
                }

                as = addLocale(as, options.locale, this.defaultLocale);
                cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);
                this._inFlightRoute = as; // If the url change is only related to a hash change
                // We should not proceed. We should only change the state.
                // WARNING: `_h` is an internal option for handing Next.js client-side
                // hydration. Your app should _never_ use this property. It may change at
                // any time without notice.

                if (!(!options._h && this.onlyAHashChange(cleanedAs))) {
                  _context.next = 18;
                  break;
                }

                this.asPath = cleanedAs;
                Router.events.emit('hashChangeStart', as); // TODO: do we need the resolved href when only a hash change?

                this.changeState(method, url, as, options);
                this.scrollToHash(cleanedAs);
                this.notify(this.components[this.route]);
                Router.events.emit('hashChangeComplete', as);
                return _context.abrupt("return", true);

              case 18:
                _context.next = 20;
                return this.pageLoader.getPageList();

              case 20:
                pages = _context.sent;
                _context.next = 23;
                return this.pageLoader.promisedBuildManifest;

              case 23:
                _yield$this$pageLoade = _context.sent;
                rewrites = _yield$this$pageLoade.__rewrites;
                parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
                _parsed = parsed, pathname = _parsed.pathname, query = _parsed.query;
                parsed = this._resolveHref(parsed, pages);

                if (parsed.pathname !== pathname) {
                  pathname = parsed.pathname;
                  url = (0, _utils.formatWithValidation)(parsed);
                } // url and as should always be prefixed with basePath by this
                // point by either next/link or router.push/replace so strip the
                // basePath from the pathname to match the pages dir 1-to-1


                pathname = pathname ? (0, _normalizeTrailingSlash.removePathTrailingSlash)(delBasePath(pathname)) : pathname; // If asked to change the current URL we should reload the current page
                // (not location.reload() but reload getInitialProps and other Next.js stuffs)
                // We also need to set the method = replaceState always
                // as this should not go into the history (That's how browsers work)
                // We should compare the new asPath to the current asPath, not the url

                if (!this.urlIsNew(cleanedAs)) {
                  method = 'replaceState';
                }

                route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);
                _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow; // we need to resolve the as value using rewrites for dynamic SSG
                // pages to allow building the data URL correctly

                resolvedAs = as;

                if (true) {
                  resolvedAs = (0, _resolveRewrites["default"])((0, _parseRelativeUrl.parseRelativeUrl)(as).pathname, pages, basePath, rewrites, query, function (p) {
                    return _this2._resolveHref({
                      pathname: p
                    }, pages).pathname;
                  });

                  if (resolvedAs !== as) {
                    potentialHref = (0, _normalizeTrailingSlash.removePathTrailingSlash)(this._resolveHref(Object.assign({}, parsed, {
                      pathname: resolvedAs
                    }), pages, false).pathname); // if this directly matches a page we need to update the href to
                    // allow the correct page chunk to be loaded

                    if (pages.includes(potentialHref)) {
                      route = potentialHref;
                      pathname = potentialHref;
                      parsed.pathname = pathname;
                      url = (0, _utils.formatWithValidation)(parsed);
                    }
                  }
                }

                resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);

                if (!(0, _isDynamic.isDynamicRoute)(route)) {
                  _context.next = 51;
                  break;
                }

                parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(resolvedAs);
                asPathname = parsedAs.pathname;
                routeRegex = (0, _routeRegex.getRouteRegex)(route);
                routeMatch = (0, _routeMatcher.getRouteMatcher)(routeRegex)(asPathname);
                shouldInterpolate = route === asPathname;
                interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};

                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {
                  _context.next = 50;
                  break;
                }

                missingParams = Object.keys(routeRegex.groups).filter(function (param) {
                  return !query[param];
                });

                if (!(missingParams.length > 0)) {
                  _context.next = 48;
                  break;
                }

                if (true) {
                  console.warn("".concat(shouldInterpolate ? "Interpolating href" : "Mismatching `as` and `href`", " failed to manually provide ") + "the params: ".concat(missingParams.join(', '), " in the `href`'s `query`"));
                }

                throw new Error((shouldInterpolate ? "The provided `href` (".concat(url, ") value is missing query values (").concat(missingParams.join(', '), ") to be interpolated properly. ") : "The provided `as` value (".concat(asPathname, ") is incompatible with the `href` value (").concat(route, "). ")) + "Read more: https://err.sh/vercel/next.js/".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));

              case 48:
                _context.next = 51;
                break;

              case 50:
                if (shouldInterpolate) {
                  as = (0, _utils.formatWithValidation)(Object.assign({}, parsedAs, {
                    pathname: interpolatedAs.result,
                    query: omitParmsFromQuery(query, interpolatedAs.params)
                  }));
                } else {
                  // Merge params into `query`, overwriting any specified in search
                  Object.assign(query, routeMatch);
                }

              case 51:
                Router.events.emit('routeChangeStart', as);
                _context.prev = 52;
                _context.next = 55;
                return this.getRouteInfo(route, pathname, query, as, shallow);

              case 55:
                routeInfo = _context.sent;
                error = routeInfo.error, props = routeInfo.props, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP; // handle redirect on client-transition

                if (!((__N_SSG || __N_SSP) && props && props.pageProps && props.pageProps.__N_REDIRECT)) {
                  _context.next = 66;
                  break;
                }

                destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt
                // client-navigation if it is falling back to hard navigation if
                // it's not

                if (!destination.startsWith('/')) {
                  _context.next = 64;
                  break;
                }

                parsedHref = (0, _parseRelativeUrl.parseRelativeUrl)(destination);

                this._resolveHref(parsedHref, pages);

                if (!pages.includes(parsedHref.pathname)) {
                  _context.next = 64;
                  break;
                }

                return _context.abrupt("return", this.change(method, destination, destination, options));

              case 64:
                window.location.href = destination;
                return _context.abrupt("return", new Promise(function () {}));

              case 66:
                Router.events.emit('beforeHistoryChange', as);
                this.changeState(method, url, addLocale(as, options.locale, this.defaultLocale), options);

                if (true) {
                  appComp = this.components['/_app'].Component;
                  window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;
                }

                _context.next = 71;
                return this.set(route, pathname, query, cleanedAs, routeInfo)["catch"](function (e) {
                  if (e.cancelled) error = error || e;else throw e;
                });

              case 71:
                if (!error) {
                  _context.next = 74;
                  break;
                }

                Router.events.emit('routeChangeError', error, cleanedAs);
                throw error;

              case 74:
                if (false) {}

                Router.events.emit('routeChangeComplete', as);
                return _context.abrupt("return", true);

              case 79:
                _context.prev = 79;
                _context.t0 = _context["catch"](52);

                if (!_context.t0.cancelled) {
                  _context.next = 83;
                  break;
                }

                return _context.abrupt("return", false);

              case 83:
                throw _context.t0;

              case 84:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[52, 79]]);
      }));

      function change(_x, _x2, _x3, _x4) {
        return _change.apply(this, arguments);
      }

      return change;
    }()
  }, {
    key: "changeState",
    value: function changeState(method, url, as) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (true) {
        if (typeof window.history === 'undefined') {
          console.error("Warning: window.history is not available.");
          return;
        }

        if (typeof window.history[method] === 'undefined') {
          console.error("Warning: window.history.".concat(method, " is not available"));
          return;
        }
      }

      if (method !== 'pushState' || (0, _utils.getURL)() !== as) {
        this._shallow = options.shallow;
        window.history[method]({
          url: url,
          as: as,
          options: options,
          __N: true
        }, // Most browsers currently ignores this parameter, although they may use it in the future.
        // Passing the empty string here should be safe against future changes to the method.
        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
        '', as);
      }
    }
  }, {
    key: "handleRouteInfoError",
    value: function () {
      var _handleRouteInfoError = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(err, pathname, query, as, loadErrorFail) {
        var Component, styleSheets, props, ssg404, mod, _yield$this$fetchComp, _yield$this$fetchComp2, routeInfo;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!err.cancelled) {
                  _context2.next = 2;
                  break;
                }

                throw err;

              case 2:
                if (!(PAGE_LOAD_ERROR in err || loadErrorFail)) {
                  _context2.next = 6;
                  break;
                }

                Router.events.emit('routeChangeError', err, as); // If we can't load the page it could be one of following reasons
                //  1. Page doesn't exists
                //  2. Page does exist in a different zone
                //  3. Internal error while loading the page
                // So, doing a hard reload is the proper way to deal with this.

                window.location.href = as; // Changing the URL doesn't block executing the current code path.
                // So let's throw a cancellation error stop the routing logic.

                throw buildCancellationError();

              case 6:
                _context2.prev = 6;
                ssg404 = err.message === SSG_DATA_NOT_FOUND_ERROR;

                if (!ssg404) {
                  _context2.next = 24;
                  break;
                }

                _context2.prev = 9;
                _context2.next = 12;
                return this.fetchComponent('/404');

              case 12:
                _yield$this$fetchComp = _context2.sent;
                Component = _yield$this$fetchComp.page;
                styleSheets = _yield$this$fetchComp.styleSheets;
                mod = _yield$this$fetchComp.mod;

                if (!(mod && mod.__N_SSG)) {
                  _context2.next = 20;
                  break;
                }

                _context2.next = 19;
                return this._getStaticData(this.pageLoader.getDataHref('/404', '/404', true, this.locale));

              case 19:
                props = _context2.sent;

              case 20:
                _context2.next = 24;
                break;

              case 22:
                _context2.prev = 22;
                _context2.t0 = _context2["catch"](9);

              case 24:
                if (!(typeof Component === 'undefined' || typeof styleSheets === 'undefined')) {
                  _context2.next = 31;
                  break;
                }

                ;
                _context2.next = 28;
                return this.fetchComponent('/_error');

              case 28:
                _yield$this$fetchComp2 = _context2.sent;
                Component = _yield$this$fetchComp2.page;
                styleSheets = _yield$this$fetchComp2.styleSheets;

              case 31:
                routeInfo = {
                  props: props,
                  Component: Component,
                  styleSheets: styleSheets,
                  err: ssg404 ? undefined : err,
                  error: ssg404 ? undefined : err
                };

                if (routeInfo.props) {
                  _context2.next = 43;
                  break;
                }

                _context2.prev = 33;
                _context2.next = 36;
                return this.getInitialProps(Component, {
                  err: err,
                  pathname: pathname,
                  query: query
                });

              case 36:
                routeInfo.props = _context2.sent;
                _context2.next = 43;
                break;

              case 39:
                _context2.prev = 39;
                _context2.t1 = _context2["catch"](33);
                console.error('Error in error page `getInitialProps`: ', _context2.t1);
                routeInfo.props = {};

              case 43:
                return _context2.abrupt("return", routeInfo);

              case 46:
                _context2.prev = 46;
                _context2.t2 = _context2["catch"](6);
                return _context2.abrupt("return", this.handleRouteInfoError(_context2.t2, pathname, query, as, true));

              case 49:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 46], [9, 22], [33, 39]]);
      }));

      function handleRouteInfoError(_x5, _x6, _x7, _x8, _x9) {
        return _handleRouteInfoError.apply(this, arguments);
      }

      return handleRouteInfoError;
    }()
  }, {
    key: "getRouteInfo",
    value: function () {
      var _getRouteInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(route, pathname, query, as) {
        var _this3 = this;

        var shallow,
            cachedRouteInfo,
            routeInfo,
            Component,
            __N_SSG,
            __N_SSP,
            _require2,
            isValidElementType,
            dataHref,
            props,
            _args3 = arguments;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                shallow = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : false;
                _context3.prev = 1;
                cachedRouteInfo = this.components[route];

                if (!(shallow && cachedRouteInfo && this.route === route)) {
                  _context3.next = 5;
                  break;
                }

                return _context3.abrupt("return", cachedRouteInfo);

              case 5:
                if (!cachedRouteInfo) {
                  _context3.next = 9;
                  break;
                }

                _context3.t0 = cachedRouteInfo;
                _context3.next = 12;
                break;

              case 9:
                _context3.next = 11;
                return this.fetchComponent(route).then(function (res) {
                  return {
                    Component: res.page,
                    styleSheets: res.styleSheets,
                    __N_SSG: res.mod.__N_SSG,
                    __N_SSP: res.mod.__N_SSP
                  };
                });

              case 11:
                _context3.t0 = _context3.sent;

              case 12:
                routeInfo = _context3.t0;
                Component = routeInfo.Component, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP;

                if (false) {}

                _require2 = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js"), isValidElementType = _require2.isValidElementType;

                if (isValidElementType(Component)) {
                  _context3.next = 18;
                  break;
                }

                throw new Error("The default export is not a React Component in page: \"".concat(pathname, "\""));

              case 18:
                if (__N_SSG || __N_SSP) {
                  dataHref = this.pageLoader.getDataHref((0, _utils.formatWithValidation)({
                    pathname: pathname,
                    query: query
                  }), delBasePath(as), __N_SSG, this.locale);
                }

                _context3.next = 21;
                return this._getData(function () {
                  return __N_SSG ? _this3._getStaticData(dataHref) : __N_SSP ? _this3._getServerData(dataHref) : _this3.getInitialProps(Component, // we provide AppTree later so this needs to be `any`
                  {
                    pathname: pathname,
                    query: query,
                    asPath: as
                  });
                });

              case 21:
                props = _context3.sent;
                routeInfo.props = props;
                this.components[route] = routeInfo;
                return _context3.abrupt("return", routeInfo);

              case 27:
                _context3.prev = 27;
                _context3.t1 = _context3["catch"](1);
                return _context3.abrupt("return", this.handleRouteInfoError(_context3.t1, pathname, query, as));

              case 30:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[1, 27]]);
      }));

      function getRouteInfo(_x10, _x11, _x12, _x13) {
        return _getRouteInfo.apply(this, arguments);
      }

      return getRouteInfo;
    }()
  }, {
    key: "set",
    value: function set(route, pathname, query, as, data) {
      this.isFallback = false;
      this.route = route;
      this.pathname = pathname;
      this.query = query;
      this.asPath = as;
      return this.notify(data);
    }
    /**
    * Callback to execute before replacing router state
    * @param cb callback to be executed
    */

  }, {
    key: "beforePopState",
    value: function beforePopState(cb) {
      this._bps = cb;
    }
  }, {
    key: "onlyAHashChange",
    value: function onlyAHashChange(as) {
      if (!this.asPath) return false;

      var _this$asPath$split = this.asPath.split('#'),
          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),
          oldUrlNoHash = _this$asPath$split2[0],
          oldHash = _this$asPath$split2[1];

      var _as$split = as.split('#'),
          _as$split2 = _slicedToArray(_as$split, 2),
          newUrlNoHash = _as$split2[0],
          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same


      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
        return true;
      } // If the urls are change, there's more than a hash change


      if (oldUrlNoHash !== newUrlNoHash) {
        return false;
      } // If the hash has changed, then it's a hash only change.
      // This check is necessary to handle both the enter and
      // leave hash === '' cases. The identity case falls through
      // and is treated as a next reload.


      return oldHash !== newHash;
    }
  }, {
    key: "scrollToHash",
    value: function scrollToHash(as) {
      var _as$split3 = as.split('#'),
          _as$split4 = _slicedToArray(_as$split3, 2),
          hash = _as$split4[1]; // Scroll to top if the hash is just `#` with no value


      if (hash === '') {
        window.scrollTo(0, 0);
        return;
      } // First we check if the element by id is found


      var idEl = document.getElementById(hash);

      if (idEl) {
        idEl.scrollIntoView();
        return;
      } // If there's no element with the id, we check the `name` property
      // To mirror browsers


      var nameEl = document.getElementsByName(hash)[0];

      if (nameEl) {
        nameEl.scrollIntoView();
      }
    }
  }, {
    key: "urlIsNew",
    value: function urlIsNew(asPath) {
      return this.asPath !== asPath;
    }
  }, {
    key: "_resolveHref",
    value: function _resolveHref(parsedHref, pages) {
      var applyBasePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var pathname = parsedHref.pathname;
      var cleanPathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)((0, _denormalizePagePath.denormalizePagePath)(applyBasePath ? delBasePath(pathname) : pathname));

      if (cleanPathname === '/404' || cleanPathname === '/_error') {
        return parsedHref;
      } // handle resolving href for dynamic routes


      if (!pages.includes(cleanPathname)) {
        // eslint-disable-next-line array-callback-return
        pages.some(function (page) {
          if ((0, _isDynamic.isDynamicRoute)(page) && (0, _routeRegex.getRouteRegex)(page).re.test(cleanPathname)) {
            parsedHref.pathname = applyBasePath ? addBasePath(page) : page;
            return true;
          }
        });
      }

      return parsedHref;
    }
    /**
    * Prefetch page code, you may wait for the data during page rendering.
    * This feature only works in production!
    * @param url the href of prefetched page
    * @param asPath the as path of the prefetched page
    */

  }, {
    key: "prefetch",
    value: function () {
      var _prefetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(url) {
        var asPath,
            options,
            parsed,
            _parsed2,
            pathname,
            pages,
            route,
            _args4 = arguments;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                asPath = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : url;
                options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
                parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
                _parsed2 = parsed, pathname = _parsed2.pathname;
                _context4.next = 6;
                return this.pageLoader.getPageList();

              case 6:
                pages = _context4.sent;
                parsed = this._resolveHref(parsed, pages);

                if (parsed.pathname !== pathname) {
                  pathname = parsed.pathname;
                  url = (0, _utils.formatWithValidation)(parsed);
                } // Prefetch is not supported in development mode because it would trigger on-demand-entries


                if (false) {}

                return _context4.abrupt("return");

              case 11:
                route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);
                _context4.next = 14;
                return Promise.all([this.pageLoader.prefetchData(url, asPath, this.locale, this.defaultLocale), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);

              case 14:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function prefetch(_x14) {
        return _prefetch.apply(this, arguments);
      }

      return prefetch;
    }()
  }, {
    key: "fetchComponent",
    value: function () {
      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(route) {
        var cancelled, cancel, componentResult, error;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                cancelled = false;

                cancel = this.clc = function () {
                  cancelled = true;
                };

                _context5.next = 4;
                return this.pageLoader.loadPage(route);

              case 4:
                componentResult = _context5.sent;

                if (!cancelled) {
                  _context5.next = 9;
                  break;
                }

                error = new Error("Abort fetching component for route: \"".concat(route, "\""));
                error.cancelled = true;
                throw error;

              case 9:
                if (cancel === this.clc) {
                  this.clc = null;
                }

                return _context5.abrupt("return", componentResult);

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function fetchComponent(_x15) {
        return _fetchComponent.apply(this, arguments);
      }

      return fetchComponent;
    }()
  }, {
    key: "_getData",
    value: function _getData(fn) {
      var _this4 = this;

      var cancelled = false;

      var cancel = function cancel() {
        cancelled = true;
      };

      this.clc = cancel;
      return fn().then(function (data) {
        if (cancel === _this4.clc) {
          _this4.clc = null;
        }

        if (cancelled) {
          var err = new Error('Loading initial props cancelled');
          err.cancelled = true;
          throw err;
        }

        return data;
      });
    }
  }, {
    key: "_getStaticData",
    value: function _getStaticData(dataHref) {
      var _this5 = this;

      var _URL = new URL(dataHref, window.location.href),
          cacheKey = _URL.href;

      if (false) {}

      return fetchNextData(dataHref, this.isSsr).then(function (data) {
        _this5.sdc[cacheKey] = data;
        return data;
      });
    }
  }, {
    key: "_getServerData",
    value: function _getServerData(dataHref) {
      return fetchNextData(dataHref, this.isSsr);
    }
  }, {
    key: "getInitialProps",
    value: function getInitialProps(Component, ctx) {
      var App = this.components['/_app'].Component;

      var AppTree = this._wrapApp(App);

      ctx.AppTree = AppTree;
      return (0, _utils.loadGetInitialProps)(App, {
        AppTree: AppTree,
        Component: Component,
        router: this,
        ctx: ctx
      });
    }
  }, {
    key: "abortComponentLoad",
    value: function abortComponentLoad(as) {
      if (this.clc) {
        Router.events.emit('routeChangeError', buildCancellationError(), as);
        this.clc();
        this.clc = null;
      }
    }
  }, {
    key: "notify",
    value: function notify(data) {
      return this.sub(data, this.components['/_app'].Component);
    }
  }]);

  return Router;
}();

exports["default"] = Router;
Router.events = (0, _mitt["default"])();

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/escape-path-delimiters.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/escape-path-delimiters.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = escapePathDelimiters; // escape delimiters used by path-to-regexp

function escapePathDelimiters(segment) {
  return segment.replace(/[/#?]/g, function (_char) {
    return encodeURIComponent(_char);
  });
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/format-url.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.formatUrl = formatUrl;

var querystring = _interopRequireWildcard(__webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
} // Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var slashedProtocols = /https?|ftp|gopher|file/;

function formatUrl(urlObj) {
  var auth = urlObj.auth,
      hostname = urlObj.hostname;
  var protocol = urlObj.protocol || '';
  var pathname = urlObj.pathname || '';
  var hash = urlObj.hash || '';
  var query = urlObj.query || '';
  var host = false;
  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';

  if (urlObj.host) {
    host = auth + urlObj.host;
  } else if (hostname) {
    host = auth + (~hostname.indexOf(':') ? "[".concat(hostname, "]") : hostname);

    if (urlObj.port) {
      host += ':' + urlObj.port;
    }
  }

  if (query && typeof query === 'object') {
    query = String(querystring.urlQueryToSearchParams(query));
  }

  var search = urlObj.search || query && "?".concat(query) || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash[0] !== '#') hash = '#' + hash;
  if (search && search[0] !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, encodeURIComponent);
  search = search.replace('#', '%23');
  return "".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.isDynamicRoute = isDynamicRoute; // Identify /[param]/ in route string

var TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;

function isDynamicRoute(route) {
  return TEST_ROUTE.test(route);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.parseRelativeUrl = parseRelativeUrl;

var _utils = __webpack_require__(/*! ../../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _querystring = __webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var DUMMY_BASE = new URL(false ? undefined : (0, _utils.getLocationOrigin)());
/**
* Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative
* (e.g. `./hello`) then at least base must be.
* Absolute urls are rejected with one exception, in the browser, absolute urls that are on
* the current origin will be parsed as relative
*/

function parseRelativeUrl(url, base) {
  var resolvedBase = base ? new URL(base, DUMMY_BASE) : DUMMY_BASE;

  var _URL = new URL(url, resolvedBase),
      pathname = _URL.pathname,
      searchParams = _URL.searchParams,
      search = _URL.search,
      hash = _URL.hash,
      href = _URL.href,
      origin = _URL.origin,
      protocol = _URL.protocol;

  if (origin !== DUMMY_BASE.origin || protocol !== 'http:' && protocol !== 'https:') {
    throw new Error('invariant: invalid relative URL');
  }

  return {
    pathname: pathname,
    query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
    search: search,
    hash: hash,
    href: href.slice(DUMMY_BASE.origin.length)
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/path-match.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/path-match.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty.js");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

exports.__esModule = true;
exports.pathToRegexp = exports["default"] = exports.customRouteMatcherOptions = exports.matcherOptions = void 0;

var pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ "./node_modules/next/dist/compiled/path-to-regexp/index.js"));

exports.pathToRegexp = pathToRegexp;

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var matcherOptions = {
  sensitive: false,
  delimiter: '/'
};
exports.matcherOptions = matcherOptions;

var customRouteMatcherOptions = _objectSpread(_objectSpread({}, matcherOptions), {}, {
  strict: true
});

exports.customRouteMatcherOptions = customRouteMatcherOptions;

var _default = function _default() {
  var customRoute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  return function (path) {
    var keys = [];
    var matcherRegex = pathToRegexp.pathToRegexp(path, keys, customRoute ? customRouteMatcherOptions : matcherOptions);
    var matcher = pathToRegexp.regexpToFunction(matcherRegex, keys);
    return function (pathname, params) {
      var res = pathname == null ? false : matcher(pathname);

      if (!res) {
        return false;
      }

      if (customRoute) {
        var _iterator = _createForOfIteratorHelper(keys),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var key = _step.value;

            // unnamed params should be removed as they
            // are not allowed to be used in the destination
            if (typeof key.name === 'number') {
              delete res.params[key.name];
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return _objectSpread(_objectSpread({}, params), res.params);
    };
  };
};

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

exports.__esModule = true;
exports["default"] = prepareDestination;

var _querystring = __webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _parseRelativeUrl = __webpack_require__(/*! ./parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ "./node_modules/next/dist/compiled/path-to-regexp/index.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function prepareDestination(destination, params, query, appendParamsToQuery, basePath) {
  var parsedDestination = {};

  if (destination.startsWith('/')) {
    parsedDestination = (0, _parseRelativeUrl.parseRelativeUrl)(destination);
  } else {
    var _URL = new URL(destination),
        pathname = _URL.pathname,
        searchParams = _URL.searchParams,
        hash = _URL.hash,
        hostname = _URL.hostname,
        port = _URL.port,
        protocol = _URL.protocol,
        search = _URL.search,
        href = _URL.href;

    parsedDestination = {
      pathname: pathname,
      query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
      hash: hash,
      protocol: protocol,
      hostname: hostname,
      port: port,
      search: search,
      href: href
    };
  }

  var destQuery = parsedDestination.query;
  var destPath = "".concat(parsedDestination.pathname).concat(parsedDestination.hash || '');
  var destPathParamKeys = [];
  pathToRegexp.pathToRegexp(destPath, destPathParamKeys);
  var destPathParams = destPathParamKeys.map(function (key) {
    return key.name;
  });
  var destinationCompiler = pathToRegexp.compile(destPath, // we don't validate while compiling the destination since we should
  // have already validated before we got to this point and validating
  // breaks compiling destinations with named pattern params from the source
  // e.g. /something:hello(.*) -> /another/:hello is broken with validation
  // since compile validation is meant for reversing and not for inserting
  // params from a separate path-regex into another
  {
    validate: false
  });
  var newUrl; // update any params in query values

  for (var _i = 0, _Object$entries = Object.entries(destQuery); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        key = _Object$entries$_i[0],
        strOrArray = _Object$entries$_i[1];

    var value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray;

    if (value) {
      // the value needs to start with a forward-slash to be compiled
      // correctly
      value = "/".concat(value);
      var queryCompiler = pathToRegexp.compile(value, {
        validate: false
      });
      value = queryCompiler(params).substr(1);
    }

    destQuery[key] = value;
  } // add path params to query if it's not a redirect and not
  // already defined in destination query or path


  var paramKeys = Object.keys(params);

  if (appendParamsToQuery && !paramKeys.some(function (key) {
    return destPathParams.includes(key);
  })) {
    var _iterator = _createForOfIteratorHelper(paramKeys),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _key = _step.value;

        if (!(_key in destQuery)) {
          destQuery[_key] = params[_key];
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  var shouldAddBasePath = destination.startsWith('/') && basePath;

  try {
    newUrl = "".concat(shouldAddBasePath ? basePath : '').concat(destinationCompiler(params));

    var _newUrl$split = newUrl.split('#'),
        _newUrl$split2 = _slicedToArray(_newUrl$split, 2),
        _pathname = _newUrl$split2[0],
        _hash = _newUrl$split2[1];

    parsedDestination.pathname = _pathname;
    parsedDestination.hash = "".concat(_hash ? '#' : '').concat(_hash || '');
    delete parsedDestination.search;
  } catch (err) {
    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {
      throw new Error("To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match");
    }

    throw err;
  } // Query merge order lowest priority to highest
  // 1. initial URL query values
  // 2. path segment values
  // 3. destination specified query values


  parsedDestination.query = _objectSpread(_objectSpread({}, query), parsedDestination.query);
  return {
    newUrl: newUrl,
    parsedDestination: parsedDestination
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/querystring.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js");

exports.__esModule = true;
exports.searchParamsToUrlQuery = searchParamsToUrlQuery;
exports.urlQueryToSearchParams = urlQueryToSearchParams;
exports.assign = assign;

function searchParamsToUrlQuery(searchParams) {
  var query = {};
  searchParams.forEach(function (value, key) {
    if (typeof query[key] === 'undefined') {
      query[key] = value;
    } else if (Array.isArray(query[key])) {
      ;
      query[key].push(value);
    } else {
      query[key] = [query[key], value];
    }
  });
  return query;
}

function stringifyUrlQueryParam(param) {
  if (typeof param === 'string' || typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
    return String(param);
  } else {
    return '';
  }
}

function urlQueryToSearchParams(urlQuery) {
  var result = new URLSearchParams();
  Object.entries(urlQuery).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    if (Array.isArray(value)) {
      value.forEach(function (item) {
        return result.append(key, stringifyUrlQueryParam(item));
      });
    } else {
      result.set(key, stringifyUrlQueryParam(value));
    }
  });
  return result;
}

function assign(target) {
  for (var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    searchParamsList[_key - 1] = arguments[_key];
  }

  searchParamsList.forEach(function (searchParams) {
    Array.from(searchParams.keys()).forEach(function (key) {
      return target["delete"](key);
    });
    searchParams.forEach(function (value, key) {
      return target.append(key, value);
    });
  });
  return target;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

exports.__esModule = true;
exports["default"] = resolveRewrites;

var _pathMatch = _interopRequireDefault(__webpack_require__(/*! ./path-match */ "./node_modules/next/dist/next-server/lib/router/utils/path-match.js"));

var _prepareDestination = _interopRequireDefault(__webpack_require__(/*! ./prepare-destination */ "./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js"));

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var customRouteMatcher = (0, _pathMatch["default"])(true);

function resolveRewrites(asPath, pages, basePath, rewrites, query, resolveHref) {
  if (!pages.includes(asPath)) {
    var _iterator = _createForOfIteratorHelper(rewrites),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var rewrite = _step.value;
        var matcher = customRouteMatcher(rewrite.source);
        var params = matcher(asPath);

        if (params) {
          if (!rewrite.destination) {
            // this is a proxied rewrite which isn't handled on the client
            break;
          }

          var destRes = (0, _prepareDestination["default"])(rewrite.destination, params, query, true, rewrite.basePath === false ? '' : basePath);
          asPath = destRes.parsedDestination.pathname;
          Object.assign(query, destRes.parsedDestination.query);

          if (pages.includes((0, _normalizeTrailingSlash.removePathTrailingSlash)(asPath))) {
            // check if we now match a page as this means we are done
            // resolving the rewrites
            break;
          } // check if we match a dynamic-route, if so we break the rewrites chain


          var resolvedHref = resolveHref(asPath);

          if (resolvedHref !== asPath && pages.includes(resolvedHref)) {
            break;
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  return asPath;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteMatcher = getRouteMatcher;

function getRouteMatcher(routeRegex) {
  var re = routeRegex.re,
      groups = routeRegex.groups;
  return function (pathname) {
    var routeMatch = re.exec(pathname);

    if (!routeMatch) {
      return false;
    }

    var decode = function decode(param) {
      try {
        return decodeURIComponent(param);
      } catch (_) {
        var err = new Error('failed to decode param');
        err.code = 'DECODE_FAILED';
        throw err;
      }
    };

    var params = {};
    Object.keys(groups).forEach(function (slugName) {
      var g = groups[slugName];
      var m = routeMatch[g.pos];

      if (m !== undefined) {
        params[slugName] = ~m.indexOf('/') ? m.split('/').map(function (entry) {
          return decode(entry);
        }) : g.repeat ? [decode(m)] : decode(m);
      }
    });
    return params;
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module
// to reduce bytes

function escapeRegex(str) {
  return str.replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&');
}

function parseParameter(param) {
  var optional = param.startsWith('[') && param.endsWith(']');

  if (optional) {
    param = param.slice(1, -1);
  }

  var repeat = param.startsWith('...');

  if (repeat) {
    param = param.slice(3);
  }

  return {
    key: param,
    repeat: repeat,
    optional: optional
  };
}

function getRouteRegex(normalizedRoute) {
  var segments = (normalizedRoute.replace(/\/$/, '') || '/').slice(1).split('/');
  var groups = {};
  var groupIndex = 1;
  var parameterizedRoute = segments.map(function (segment) {
    if (segment.startsWith('[') && segment.endsWith(']')) {
      var _parseParameter = parseParameter(segment.slice(1, -1)),
          key = _parseParameter.key,
          optional = _parseParameter.optional,
          repeat = _parseParameter.repeat;

      groups[key] = {
        pos: groupIndex++,
        repeat: repeat,
        optional: optional
      };
      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';
    } else {
      return "/".concat(escapeRegex(segment));
    }
  }).join(''); // dead code eliminate for browser since it's only needed
  // while generating routes-manifest

  if (false) { var namedParameterizedRoute, routeKeys, getSafeRouteKey, routeKeyCharLength, routeKeyCharCode; }

  return {
    re: new RegExp("^".concat(parameterizedRoute, "(?:/)?$")),
    groups: groups
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/next/node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator.js");

exports.__esModule = true;
exports.execOnce = execOnce;
exports.getLocationOrigin = getLocationOrigin;
exports.getURL = getURL;
exports.getDisplayName = getDisplayName;
exports.isResSent = isResSent;
exports.loadGetInitialProps = loadGetInitialProps;
exports.formatWithValidation = formatWithValidation;
exports.ST = exports.SP = exports.urlObjectKeys = void 0;

var _formatUrl = __webpack_require__(/*! ./router/utils/format-url */ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js");
/**
* Utils
*/


function execOnce(fn) {
  var used = false;
  var result;
  return function () {
    if (!used) {
      used = true;
      result = fn.apply(void 0, arguments);
    }

    return result;
  };
}

function getLocationOrigin() {
  var _window$location = window.location,
      protocol = _window$location.protocol,
      hostname = _window$location.hostname,
      port = _window$location.port;
  return "".concat(protocol, "//").concat(hostname).concat(port ? ':' + port : '');
}

function getURL() {
  var href = window.location.href;
  var origin = getLocationOrigin();
  return href.substring(origin.length);
}

function getDisplayName(Component) {
  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}

function isResSent(res) {
  return res.finished || res.headersSent;
}

function loadGetInitialProps(_x, _x2) {
  return _loadGetInitialProps.apply(this, arguments);
}

function _loadGetInitialProps() {
  _loadGetInitialProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(App, ctx) {
    var _App$prototype, message, res, props, _message;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (false) {}

            if (!((_App$prototype = App.prototype) == null ? void 0 : _App$prototype.getInitialProps)) {
              _context.next = 4;
              break;
            }

            message = "\"".concat(getDisplayName(App), ".getInitialProps()\" is defined as an instance method - visit https://err.sh/vercel/next.js/get-initial-props-as-an-instance-method for more information.");
            throw new Error(message);

          case 4:
            // when called from _app `ctx` is nested in `ctx`
            res = ctx.res || ctx.ctx && ctx.ctx.res;

            if (App.getInitialProps) {
              _context.next = 12;
              break;
            }

            if (!(ctx.ctx && ctx.Component)) {
              _context.next = 11;
              break;
            }

            _context.next = 9;
            return loadGetInitialProps(ctx.Component, ctx.ctx);

          case 9:
            _context.t0 = _context.sent;
            return _context.abrupt("return", {
              pageProps: _context.t0
            });

          case 11:
            return _context.abrupt("return", {});

          case 12:
            _context.next = 14;
            return App.getInitialProps(ctx);

          case 14:
            props = _context.sent;

            if (!(res && isResSent(res))) {
              _context.next = 17;
              break;
            }

            return _context.abrupt("return", props);

          case 17:
            if (props) {
              _context.next = 20;
              break;
            }

            _message = "\"".concat(getDisplayName(App), ".getInitialProps()\" should resolve to an object. But found \"").concat(props, "\" instead.");
            throw new Error(_message);

          case 20:
            if (true) {
              if (Object.keys(props).length === 0 && !ctx.ctx) {
                console.warn("".concat(getDisplayName(App), " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://err.sh/vercel/next.js/empty-object-getInitialProps"));
              }
            }

            return _context.abrupt("return", props);

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadGetInitialProps.apply(this, arguments);
}

var urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];
exports.urlObjectKeys = urlObjectKeys;

function formatWithValidation(url) {
  if (true) {
    if (url !== null && typeof url === 'object') {
      Object.keys(url).forEach(function (key) {
        if (urlObjectKeys.indexOf(key) === -1) {
          console.warn("Unknown key passed via urlObject into url.format: ".concat(key));
        }
      });
    }
  }

  return (0, _formatUrl.formatUrl)(url);
}

var SP = typeof performance !== 'undefined';
exports.SP = SP;
var ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';
exports.ST = ST;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/server/denormalize-page-path.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/server/denormalize-page-path.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
exports.__esModule=true;exports.normalizePathSep=normalizePathSep;exports.denormalizePagePath=denormalizePagePath;function normalizePathSep(path){return path.replace(/\\/g,'/');}function denormalizePagePath(page){page=normalizePathSep(page);if(page.startsWith('/index/')){page=page.slice(6);}else if(page==='/index'){page='/';}return page;}
//# sourceMappingURL=denormalize-page-path.js.map

/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/client/link */ "./node_modules/next/dist/client/link.js")


/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/construct.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/construct.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/next/node_modules/@babel/runtime/helpers/setPrototypeOf.js");

var isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct */ "./node_modules/next/node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/createClass.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/createClass.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/next/node_modules/@babel/runtime/helpers/typeof.js");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/next/node_modules/@babel/runtime/helpers/arrayWithHoles.js");

var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ "./node_modules/next/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/next/node_modules/@babel/runtime/helpers/nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/typeof.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/typeof.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/regenerator/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/regenerator/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/react-grid-system/build/config.js":
/*!********************************************************!*\
  !*** ./node_modules/react-grid-system/build/config.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setConfiguration = exports.getConfiguration = void 0;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var configuration = {
  breakpoints: [576, 768, 992, 1200, 1600],
  containerWidths: [540, 750, 960, 1140, 1540],
  gutterWidth: 30,
  gridColumns: 12,
  defaultScreenClass: 'xxl',
  maxScreenClass: 'xxl'
};

var getConfiguration = function getConfiguration() {
  return configuration;
};

exports.getConfiguration = getConfiguration;

var setConfiguration = function setConfiguration(newConfiguration) {
  configuration = _objectSpread(_objectSpread({}, configuration), newConfiguration);
};

exports.setConfiguration = setConfiguration;

/***/ }),

/***/ "./node_modules/react-grid-system/build/context/ScreenClassProvider/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/react-grid-system/build/context/ScreenClassProvider/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ScreenClassContext = exports.NO_PROVIDER_FLAG = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));

var _utils = __webpack_require__(/*! ../../utils */ "./node_modules/react-grid-system/build/utils.js");

var _config = __webpack_require__(/*! ../../config */ "./node_modules/react-grid-system/build/config.js");

var _primitives = __webpack_require__(/*! ../../primitives */ "./node_modules/react-grid-system/build/primitives/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var NO_PROVIDER_FLAG = 'NO_PROVIDER_FLAG';
exports.NO_PROVIDER_FLAG = NO_PROVIDER_FLAG;

var ScreenClassContext = /*#__PURE__*/_react.default.createContext(NO_PROVIDER_FLAG);

exports.ScreenClassContext = ScreenClassContext;

var ScreenClassProvider = function ScreenClassProvider(_ref) {
  var useOwnWidth = _ref.useOwnWidth,
      children = _ref.children,
      fallbackScreenClass = _ref.fallbackScreenClass;
  var screenClassRef = (0, _react.useRef)();

  var _useState = (0, _react.useState)(false),
      _useState2 = _slicedToArray(_useState, 2),
      mounted = _useState2[0],
      setMounted = _useState2[1];

  var detectedScreenClass = (0, _utils.useScreenClass)(screenClassRef, fallbackScreenClass);

  var _getConfiguration = (0, _config.getConfiguration)(),
      defaultScreenClass = _getConfiguration.defaultScreenClass;

  var screenClass = mounted ? detectedScreenClass : fallbackScreenClass || defaultScreenClass;
  (0, _react.useEffect)(function () {
    return setMounted(true);
  }, []);
  return /*#__PURE__*/_react.default.createElement(ScreenClassContext.Provider, {
    value: screenClass
  }, useOwnWidth ? /*#__PURE__*/_react.default.createElement(_primitives.Div, {
    ref: useOwnWidth ? screenClassRef : null
  }, children) : /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, children));
};

ScreenClassProvider.propTypes = {
  /**
   * Children of the ScreenClassProvider.
   * This should be all your child React nodes that are using `react-grid-system`.
   */
  children: _propTypes.default.node.isRequired,

  /**
   * Boolean to determine whether own width should be used as source.
   * When provided, the screen class is derived from own dimensions instead of the window.
   */
  useOwnWidth: _propTypes.default.bool,

  /**
   * Screen class to use when it cannot be determined otherwise.
   * Useful for server side rendering.
   */
  fallbackScreenClass: _propTypes.default.oneOf([null, 'xs', 'sm', 'md', 'lg', 'xl', 'xxl'])
};
ScreenClassProvider.defaultProps = {
  useOwnWidth: false,
  fallbackScreenClass: null
};
var _default = ScreenClassProvider;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/context/ScreenClassResolver/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/react-grid-system/build/context/ScreenClassResolver/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));

var _ScreenClassProvider = _interopRequireWildcard(__webpack_require__(/*! ../ScreenClassProvider */ "./node_modules/react-grid-system/build/context/ScreenClassProvider/index.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ScreenClassResolver = function ScreenClassResolver(_ref) {
  var children = _ref.children;
  return /*#__PURE__*/_react.default.createElement(_ScreenClassProvider.ScreenClassContext.Consumer, null, function (screenClassCheck) {
    if (screenClassCheck === _ScreenClassProvider.NO_PROVIDER_FLAG) {
      return /*#__PURE__*/_react.default.createElement(_ScreenClassProvider.default, null, /*#__PURE__*/_react.default.createElement(_ScreenClassProvider.ScreenClassContext.Consumer, null, function (screenClassResolved) {
        return children(screenClassResolved);
      }));
    }

    return children(screenClassCheck);
  });
};

ScreenClassResolver.propTypes = {
  children: _propTypes.default.func.isRequired
};
var _default = ScreenClassResolver;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/grid/Col/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-grid-system/build/grid/Col/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));

var _style = _interopRequireDefault(__webpack_require__(/*! ./style */ "./node_modules/react-grid-system/build/grid/Col/style.js"));

var _config = __webpack_require__(/*! ../../config */ "./node_modules/react-grid-system/build/config.js");

var _Row = __webpack_require__(/*! ../Row */ "./node_modules/react-grid-system/build/grid/Row/index.js");

var _ScreenClassResolver = _interopRequireDefault(__webpack_require__(/*! ../../context/ScreenClassResolver */ "./node_modules/react-grid-system/build/context/ScreenClassResolver/index.js"));

var _primitives = __webpack_require__(/*! ../../primitives */ "./node_modules/react-grid-system/build/primitives/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var Col = function Col(_ref) {
  var children = _ref.children,
      xs = _ref.xs,
      sm = _ref.sm,
      md = _ref.md,
      lg = _ref.lg,
      xl = _ref.xl,
      xxl = _ref.xxl,
      offset = _ref.offset,
      pull = _ref.pull,
      push = _ref.push,
      debug = _ref.debug,
      style = _ref.style,
      component = _ref.component,
      width = _ref.width,
      otherProps = _objectWithoutProperties(_ref, ["children", "xs", "sm", "md", "lg", "xl", "xxl", "offset", "pull", "push", "debug", "style", "component", "width"]);

  return /*#__PURE__*/_react.default.createElement(_ScreenClassResolver.default, null, function (screenClass) {
    return /*#__PURE__*/_react.default.createElement(_Row.GutterWidthContext.Consumer, null, function (gutterWidth) {
      var theStyle = (0, _style.default)({
        forceWidth: width,
        width: {
          xs: xs,
          sm: sm,
          md: md,
          lg: lg,
          xl: xl,
          xxl: xxl
        },
        offset: offset,
        pull: pull,
        push: push,
        debug: debug,
        screenClass: screenClass,
        gutterWidth: gutterWidth,
        gridColumns: (0, _config.getConfiguration)().gridColumns,
        moreStyle: style
      });
      return /*#__PURE__*/(0, _react.createElement)(component, _objectSpread(_objectSpread({
        style: theStyle
      }, otherProps), {}, {
        children: children
      }));
    });
  });
};

Col.propTypes = {
  /**
   * Content of the column
   */
  children: _propTypes.default.node,

  /**
   * The width of the column for screenclass `xs`, either a number between 0 and 12, or "content"
   */
  xs: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.oneOf(['content'])]),

  /**
   * The width of the column for screenclass `sm`, either a number between 0 and 12, or "content"
   */
  sm: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.oneOf(['content'])]),

  /**
   * The width of the column for screenclass `md`, either a number between 0 and 12, or "content"
   */
  md: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.oneOf(['content'])]),

  /**
   * The width of the column for screenclass `lg`, either a number between 0 and 12, or "content"
   */
  lg: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.oneOf(['content'])]),

  /**
   * The width of the column for screenclass `xl`, either a number between 0 and 12, or "content"
   */
  xl: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.oneOf(['content'])]),

  /**
   * The width of the column for screenclass `xxl`, either a number between 0 and 12, or "content"
   */
  xxl: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.oneOf(['content'])]),

  /**
   * A fixed width of the column for all screenclasses"
   */
  width: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),

  /**
   * The offset of this column for all screenclasses
   */
  offset: _propTypes.default.shape({
    xs: _propTypes.default.number,
    sm: _propTypes.default.number,
    md: _propTypes.default.number,
    lg: _propTypes.default.number,
    xl: _propTypes.default.number,
    xxl: _propTypes.default.number
  }),

  /**
   * The amount this column is pushed to the right for all screenclasses
   */
  push: _propTypes.default.shape({
    xs: _propTypes.default.number,
    sm: _propTypes.default.number,
    md: _propTypes.default.number,
    lg: _propTypes.default.number,
    xl: _propTypes.default.number,
    xxl: _propTypes.default.number
  }),

  /**
   * The amount this column is pulled to the left for all screenclasses
   */
  pull: _propTypes.default.shape({
    xs: _propTypes.default.number,
    sm: _propTypes.default.number,
    md: _propTypes.default.number,
    lg: _propTypes.default.number,
    xl: _propTypes.default.number,
    xxl: _propTypes.default.number
  }),

  /**
   * Optional styling
   */
  style: _propTypes.default.objectOf(_propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])),

  /**
   * Set to apply some debug styling
   */
  debug: _propTypes.default.bool,

  /**
   * Use your own component
   */
  component: _propTypes.default.elementType
};
Col.defaultProps = {
  children: null,
  xs: null,
  sm: null,
  md: null,
  lg: null,
  xl: null,
  xxl: null,
  width: null,
  offset: {},
  push: {},
  pull: {},
  style: {},
  debug: false,
  component: _primitives.Div
};
var _default = Col;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/grid/Col/style.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-grid-system/build/grid/Col/style.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utils = __webpack_require__(/*! ../../utils */ "./node_modules/react-grid-system/build/utils.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var hasWidth = function hasWidth(widths) {
  return Object.keys(widths).reduce(function (acc, cur) {
    return acc || widths[cur];
  }, false);
};

var getWidth = function getWidth(width, gridColumns) {
  if (typeof width !== 'number') return undefined;
  var normalizedWidth = Math.max(0, Math.min(gridColumns, width));
  return "".concat(100 / gridColumns * normalizedWidth, "%");
};

var _default = function _default(_ref) {
  var _ref$forceWidth = _ref.forceWidth,
      forceWidth = _ref$forceWidth === void 0 ? null : _ref$forceWidth,
      _ref$width = _ref.width,
      width = _ref$width === void 0 ? {} : _ref$width,
      _ref$offset = _ref.offset,
      offset = _ref$offset === void 0 ? {} : _ref$offset,
      _ref$pull = _ref.pull,
      pull = _ref$pull === void 0 ? {} : _ref$pull,
      _ref$push = _ref.push,
      push = _ref$push === void 0 ? {} : _ref$push,
      debug = _ref.debug,
      screenClass = _ref.screenClass,
      gutterWidth = _ref.gutterWidth,
      moreStyle = _ref.moreStyle,
      gridColumns = _ref.gridColumns;
  var styles = {
    boxSizing: 'border-box',
    minHeight: 1,
    position: 'relative',
    paddingLeft: gutterWidth / 2,
    paddingRight: gutterWidth / 2,
    width: '100%'
  };

  if (debug) {
    styles.outline = '1px solid silver';
    styles.background = 'rgba(0,0,0,.05)';
    styles.lineHeight = '32px';
  }

  styles.flexBasis = '100%';
  styles.flexGrow = 0;
  styles.flexShrink = 0;
  styles.maxWidth = '100%';
  styles.marginLeft = '0%';
  styles.right = 'auto';
  styles.left = 'auto';

  _utils.screenClasses.forEach(function (size, index) {
    if (_utils.screenClasses.indexOf(screenClass) >= index) {
      var currentWidth = getWidth(width[size], gridColumns);
      var isSizedToContent = width[size] === 'content';
      styles.flexBasis = isSizedToContent ? 'auto' : currentWidth || styles.flexBasis;
      styles.width = styles.flexBasis;
      styles.maxWidth = currentWidth || styles.maxWidth;
      styles.marginLeft = getWidth(offset[size], gridColumns) || styles.marginLeft;
      styles.right = getWidth(pull[size], gridColumns) || styles.right;
      styles.left = getWidth(push[size], gridColumns) || styles.left;
    }
  });

  if (!hasWidth(width)) {
    styles.flexBasis = 0;
    styles.flexGrow = 1;
  }

  if (forceWidth) {
    styles.flexBasis = 'unset';
    styles.flexGrow = 'unset';
    styles.flexShrink = 'unset';
    styles.width = forceWidth;
  }

  return _objectSpread(_objectSpread({}, styles), moreStyle);
};

exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/grid/Container/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-grid-system/build/grid/Container/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));

var _style = _interopRequireWildcard(__webpack_require__(/*! ./style */ "./node_modules/react-grid-system/build/grid/Container/style.js"));

var _config = __webpack_require__(/*! ../../config */ "./node_modules/react-grid-system/build/config.js");

var _ScreenClassResolver = _interopRequireDefault(__webpack_require__(/*! ../../context/ScreenClassResolver */ "./node_modules/react-grid-system/build/context/ScreenClassResolver/index.js"));

var _primitives = __webpack_require__(/*! ../../primitives */ "./node_modules/react-grid-system/build/primitives/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var Container = function Container(_ref) {
  var children = _ref.children,
      fluid = _ref.fluid,
      xs = _ref.xs,
      sm = _ref.sm,
      md = _ref.md,
      lg = _ref.lg,
      xl = _ref.xl,
      xxl = _ref.xxl,
      style = _ref.style,
      component = _ref.component,
      otherProps = _objectWithoutProperties(_ref, ["children", "fluid", "xs", "sm", "md", "lg", "xl", "xxl", "style", "component"]);

  return /*#__PURE__*/_react.default.createElement(_ScreenClassResolver.default, null, function (screenClass) {
    return /*#__PURE__*/(0, _react.createElement)(component, _objectSpread({
      style: (0, _style.default)({
        fluid: fluid,
        xs: xs,
        sm: sm,
        md: md,
        lg: lg,
        xl: xl,
        xxl: xxl,
        screenClass: screenClass,
        containerWidths: (0, _config.getConfiguration)().containerWidths,
        gutterWidth: (0, _config.getConfiguration)().gutterWidth,
        moreStyle: style
      })
    }, otherProps), /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, children, /*#__PURE__*/_react.default.createElement(_primitives.Span, {
      style: (0, _style.getAfterStyle)()
    })));
  });
};

Container.propTypes = {
  /**
   * Content of the component
   */
  children: _propTypes.default.node.isRequired,

  /**
   * True makes the container full-width, false fixed-width
   */
  fluid: _propTypes.default.bool,

  /**
   * This is in combination with fluid enabled
   * True makes container fluid only in xs, not present means fluid everywhere
   */
  xs: _propTypes.default.bool,

  /**
   * This is in combination with fluid enabled
   * True makes container fluid only in sm, not present means fluid everywhere
   */
  sm: _propTypes.default.bool,

  /**
   * This is in combination with fluid enabled
   * True makes container fluid only in md, not present means fluid everywhere
   */
  md: _propTypes.default.bool,

  /**
   * This is in combination with fluid enabled
   * True makes container fluid only in lg, not present means fluid everywhere
   */
  lg: _propTypes.default.bool,

  /**
   * This is in combination with fluid enabled
   * True makes container fluid only in xl, not present means fluid everywhere
   */
  xl: _propTypes.default.bool,

  /**
   * This is in combination with fluid enabled
   * True makes container fluid only in xxl, not present means fluid everywhere
   */
  xxl: _propTypes.default.bool,

  /**
   * Optional styling
   */
  style: _propTypes.default.objectOf(_propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])),

  /**
   * Use your own component
   */
  component: _propTypes.default.elementType
};
Container.defaultProps = {
  fluid: false,
  xs: false,
  sm: false,
  md: false,
  lg: false,
  xl: false,
  xxl: false,
  style: {},
  component: _primitives.Div
};
var _default = Container;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/grid/Container/style.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-grid-system/build/grid/Container/style.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAfterStyle = exports.default = void 0;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = function _default(_ref) {
  var fluid = _ref.fluid,
      xs = _ref.xs,
      sm = _ref.sm,
      md = _ref.md,
      lg = _ref.lg,
      xl = _ref.xl,
      xxl = _ref.xxl,
      screenClass = _ref.screenClass,
      containerWidths = _ref.containerWidths,
      gutterWidth = _ref.gutterWidth,
      moreStyle = _ref.moreStyle;
  var styles = {
    boxSizing: 'border-box',
    position: 'relative',
    marginLeft: 'auto',
    marginRight: 'auto',
    paddingLeft: gutterWidth / 2,
    paddingRight: gutterWidth / 2
  };

  if (fluid && !sm && !md && !lg && !xl) {
    return _objectSpread(_objectSpread({}, styles), moreStyle);
  }

  if (screenClass === 'sm' && containerWidths[0] && !sm && !xs) {
    styles.maxWidth = containerWidths[0];
  }

  if (screenClass === 'md' && containerWidths[1] && !md) {
    styles.maxWidth = containerWidths[1];
  }

  if (screenClass === 'lg' && containerWidths[2] && !lg) {
    styles.maxWidth = containerWidths[2];
  }

  if (screenClass === 'xl' && containerWidths[3] && !xl) {
    styles.maxWidth = containerWidths[3];
  }

  if (screenClass === 'xxl' && containerWidths[4] && !xxl) {
    styles.maxWidth = containerWidths[4];
  }

  return _objectSpread(_objectSpread({}, styles), moreStyle);
};

exports.default = _default;

var getAfterStyle = function getAfterStyle() {
  return {
    display: 'table',
    clear: 'both'
  };
};

exports.getAfterStyle = getAfterStyle;

/***/ }),

/***/ "./node_modules/react-grid-system/build/grid/Row/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-grid-system/build/grid/Row/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.GutterWidthContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));

var _config = __webpack_require__(/*! ../../config */ "./node_modules/react-grid-system/build/config.js");

var _style = _interopRequireDefault(__webpack_require__(/*! ./style */ "./node_modules/react-grid-system/build/grid/Row/style.js"));

var _primitives = __webpack_require__(/*! ../../primitives */ "./node_modules/react-grid-system/build/primitives/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var GutterWidthContext = /*#__PURE__*/_react.default.createContext(false);

exports.GutterWidthContext = GutterWidthContext;

var Row = function Row(_ref) {
  var children = _ref.children,
      style = _ref.style,
      align = _ref.align,
      justify = _ref.justify,
      debug = _ref.debug,
      nogutter = _ref.nogutter,
      gutterWidth = _ref.gutterWidth,
      component = _ref.component,
      nowrap = _ref.nowrap,
      otherProps = _objectWithoutProperties(_ref, ["children", "style", "align", "justify", "debug", "nogutter", "gutterWidth", "component", "nowrap"]);

  var theGutterWidth = (0, _config.getConfiguration)().gutterWidth;
  if (nogutter) theGutterWidth = 0;
  if (typeof gutterWidth === 'number') theGutterWidth = gutterWidth;
  var theStyle = (0, _style.default)({
    gutterWidth: theGutterWidth,
    align: align,
    justify: justify,
    debug: debug,
    moreStyle: style,
    nowrap: nowrap
  });
  return /*#__PURE__*/_react.default.createElement(component, _objectSpread({
    style: theStyle
  }, otherProps), /*#__PURE__*/_react.default.createElement(GutterWidthContext.Provider, {
    value: theGutterWidth
  }, children));
};

Row.propTypes = {
  /**
   * Content of the element
   */
  children: _propTypes.default.node.isRequired,

  /**
   * Vertical column alignment
   */
  align: _propTypes.default.oneOf(['normal', 'start', 'center', 'end', 'stretch']),

  /**
   * Horizontal column alignment
   */
  justify: _propTypes.default.oneOf(['start', 'center', 'end', 'between', 'around', 'initial', 'inherit']),

  /**
   * No gutter for this row
   */
  nogutter: _propTypes.default.bool,

  /**
   * Custom gutter width for this row
   */
  gutterWidth: _propTypes.default.number,

  /**
   * Optional styling
   */
  style: _propTypes.default.objectOf(_propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])),

  /**
   * Set to apply some debug styling
   */
  debug: _propTypes.default.bool,

  /**
   * Use your own component
   */
  component: _propTypes.default.elementType,

  /**
   * Whether the cols should not wrap
   */
  nowrap: _propTypes.default.bool
};
Row.defaultProps = {
  align: 'normal',
  justify: 'start',
  nogutter: false,
  gutterWidth: null,
  style: {},
  debug: false,
  component: _primitives.Div,
  nowrap: false
};
var _default = Row;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/grid/Row/style.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-grid-system/build/grid/Row/style.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = function _default(_ref) {
  var gutterWidth = _ref.gutterWidth,
      align = _ref.align,
      justify = _ref.justify,
      debug = _ref.debug,
      moreStyle = _ref.moreStyle,
      nowrap = _ref.nowrap;
  // Vertical alignment
  var alignItems = align;
  if (align === 'start') alignItems = 'flex-start';
  if (align === 'end') alignItems = 'flex-end'; // Horizontal alignment

  var justifyContent = justify;
  if (justify === 'start') justifyContent = 'flex-start';
  if (justify === 'end') justifyContent = 'flex-end';
  if (justify === 'between') justifyContent = 'space-between';
  if (justify === 'around') justifyContent = 'space-around';
  if (justify === 'center') justifyContent = 'center';
  if (justify === 'initial') justifyContent = 'initial';
  if (justify === 'inherit') justifyContent = 'inherit';
  var styles = {
    marginLeft: -gutterWidth / 2,
    marginRight: -gutterWidth / 2,
    display: 'flex',
    flexWrap: nowrap ? 'nowrap' : 'wrap',
    flexGrow: 0,
    flexShrink: 0,
    alignItems: alignItems,
    justifyContent: justifyContent
  };

  if (debug) {
    styles.background = 'rgba(128,128,128,.05)';
  }

  return _objectSpread(_objectSpread({}, styles), moreStyle);
};

exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-grid-system/build/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Col", {
  enumerable: true,
  get: function get() {
    return _Col.default;
  }
});
Object.defineProperty(exports, "Container", {
  enumerable: true,
  get: function get() {
    return _Container.default;
  }
});
Object.defineProperty(exports, "Row", {
  enumerable: true,
  get: function get() {
    return _Row.default;
  }
});
Object.defineProperty(exports, "Hidden", {
  enumerable: true,
  get: function get() {
    return _Hidden.default;
  }
});
Object.defineProperty(exports, "Visible", {
  enumerable: true,
  get: function get() {
    return _Visible.default;
  }
});
Object.defineProperty(exports, "ScreenClassRender", {
  enumerable: true,
  get: function get() {
    return _ScreenClassRender.default;
  }
});
Object.defineProperty(exports, "ScreenClassProvider", {
  enumerable: true,
  get: function get() {
    return _ScreenClassProvider.default;
  }
});
Object.defineProperty(exports, "ScreenClassContext", {
  enumerable: true,
  get: function get() {
    return _ScreenClassProvider.ScreenClassContext;
  }
});
Object.defineProperty(exports, "setConfiguration", {
  enumerable: true,
  get: function get() {
    return _config.setConfiguration;
  }
});
Object.defineProperty(exports, "useScreenClass", {
  enumerable: true,
  get: function get() {
    return _utils.useScreenClass;
  }
});

var _Col = _interopRequireDefault(__webpack_require__(/*! ./grid/Col */ "./node_modules/react-grid-system/build/grid/Col/index.js"));

var _Container = _interopRequireDefault(__webpack_require__(/*! ./grid/Container */ "./node_modules/react-grid-system/build/grid/Container/index.js"));

var _Row = _interopRequireDefault(__webpack_require__(/*! ./grid/Row */ "./node_modules/react-grid-system/build/grid/Row/index.js"));

var _Hidden = _interopRequireDefault(__webpack_require__(/*! ./utilities/Hidden */ "./node_modules/react-grid-system/build/utilities/Hidden/index.js"));

var _Visible = _interopRequireDefault(__webpack_require__(/*! ./utilities/Visible */ "./node_modules/react-grid-system/build/utilities/Visible/index.js"));

var _ScreenClassRender = _interopRequireDefault(__webpack_require__(/*! ./utilities/ScreenClassRender */ "./node_modules/react-grid-system/build/utilities/ScreenClassRender/index.js"));

var _ScreenClassProvider = _interopRequireWildcard(__webpack_require__(/*! ./context/ScreenClassProvider */ "./node_modules/react-grid-system/build/context/ScreenClassProvider/index.js"));

var _config = __webpack_require__(/*! ./config */ "./node_modules/react-grid-system/build/config.js");

var _utils = __webpack_require__(/*! ./utils */ "./node_modules/react-grid-system/build/utils.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "./node_modules/react-grid-system/build/primitives/Div/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-grid-system/build/primitives/Div/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = 'div';
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/primitives/Span/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-grid-system/build/primitives/Span/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = 'span';
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/primitives/Window/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-grid-system/build/primitives/Window/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/* global window */
var _default = typeof window !== 'undefined' ? window : undefined;

exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/primitives/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/react-grid-system/build/primitives/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Div", {
  enumerable: true,
  get: function get() {
    return _Div.default;
  }
});
Object.defineProperty(exports, "Span", {
  enumerable: true,
  get: function get() {
    return _Span.default;
  }
});
Object.defineProperty(exports, "Window", {
  enumerable: true,
  get: function get() {
    return _Window.default;
  }
});

var _Div = _interopRequireDefault(__webpack_require__(/*! ./Div */ "./node_modules/react-grid-system/build/primitives/Div/index.js"));

var _Span = _interopRequireDefault(__webpack_require__(/*! ./Span */ "./node_modules/react-grid-system/build/primitives/Span/index.js"));

var _Window = _interopRequireDefault(__webpack_require__(/*! ./Window */ "./node_modules/react-grid-system/build/primitives/Window/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "./node_modules/react-grid-system/build/utilities/Hidden/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-grid-system/build/utilities/Hidden/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));

var style = _interopRequireWildcard(__webpack_require__(/*! ./style */ "./node_modules/react-grid-system/build/utilities/Hidden/style.js"));

var _ScreenClassResolver = _interopRequireDefault(__webpack_require__(/*! ../../context/ScreenClassResolver */ "./node_modules/react-grid-system/build/context/ScreenClassResolver/index.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Hidden = function Hidden(_ref) {
  var children = _ref.children,
      xs = _ref.xs,
      sm = _ref.sm,
      md = _ref.md,
      lg = _ref.lg,
      xl = _ref.xl,
      xxl = _ref.xxl;
  return /*#__PURE__*/_react.default.createElement(_ScreenClassResolver.default, null, function (screenClass) {
    return style.hidden({
      screenClass: screenClass,
      xs: xs,
      sm: sm,
      md: md,
      lg: lg,
      xl: xl,
      xxl: xxl
    }) ? null : children;
  });
};

Hidden.propTypes = {
  /**
   * Content of the component
   */
  children: _propTypes.default.node.isRequired,

  /**
   * Hide on extra small devices
   */
  xs: _propTypes.default.bool,

  /**
   * Hide on small devices
   */
  sm: _propTypes.default.bool,

  /**
   * Hide on medium devices
   */
  md: _propTypes.default.bool,

  /**
   * Hide on large devices
   */
  lg: _propTypes.default.bool,

  /**
   * Hide on xlarge devices
   */
  xl: _propTypes.default.bool,

  /**
   * Hide on xxlarge devices
   */
  xxl: _propTypes.default.bool
};
Hidden.defaultProps = {
  xs: false,
  sm: false,
  md: false,
  lg: false,
  xl: false,
  xxl: false
};
var _default = Hidden;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/utilities/Hidden/style.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-grid-system/build/utilities/Hidden/style.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.hidden = void 0;

var hidden = function hidden(_ref) {
  var screenClass = _ref.screenClass,
      xs = _ref.xs,
      sm = _ref.sm,
      md = _ref.md,
      lg = _ref.lg,
      xl = _ref.xl,
      xxl = _ref.xxl;
  if (screenClass === 'xxl') return xxl;
  if (screenClass === 'xl') return xl;
  if (screenClass === 'lg') return lg;
  if (screenClass === 'md') return md;
  if (screenClass === 'sm') return sm;
  return xs;
};

exports.hidden = hidden;
var _default = hidden;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/utilities/ScreenClassRender/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/react-grid-system/build/utilities/ScreenClassRender/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));

var _ScreenClassResolver = _interopRequireDefault(__webpack_require__(/*! ../../context/ScreenClassResolver */ "./node_modules/react-grid-system/build/context/ScreenClassResolver/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ScreenClassRender = function ScreenClassRender(_ref) {
  var render = _ref.render;
  return /*#__PURE__*/_react.default.createElement(_ScreenClassResolver.default, null, function (screenClass) {
    return render(screenClass);
  });
};

ScreenClassRender.propTypes = {
  /**
   * The function which return value will be rendered.
   * Will be called with one argument: the screen class.
   */
  render: _propTypes.default.func.isRequired
};
var _default = ScreenClassRender;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/utilities/Visible/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-grid-system/build/utilities/Visible/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));

var style = _interopRequireWildcard(__webpack_require__(/*! ./style */ "./node_modules/react-grid-system/build/utilities/Visible/style.js"));

var _ScreenClassResolver = _interopRequireDefault(__webpack_require__(/*! ../../context/ScreenClassResolver */ "./node_modules/react-grid-system/build/context/ScreenClassResolver/index.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Visible = function Visible(_ref) {
  var children = _ref.children,
      xs = _ref.xs,
      sm = _ref.sm,
      md = _ref.md,
      lg = _ref.lg,
      xl = _ref.xl,
      xxl = _ref.xxl;
  return /*#__PURE__*/_react.default.createElement(_ScreenClassResolver.default, null, function (screenClass) {
    return !style.visible({
      screenClass: screenClass,
      xs: xs,
      sm: sm,
      md: md,
      lg: lg,
      xl: xl,
      xxl: xxl
    }) ? null : children;
  });
};

Visible.propTypes = {
  /**
   * Content of the component
   */
  children: _propTypes.default.node.isRequired,

  /**
   * Show on extra small devices
   */
  xs: _propTypes.default.bool,

  /**
   * Show on small devices
   */
  sm: _propTypes.default.bool,

  /**
   * Show on medium devices
   */
  md: _propTypes.default.bool,

  /**
   * Show on large devices
   */
  lg: _propTypes.default.bool,

  /**
   * Show on xlarge devices
   */
  xl: _propTypes.default.bool,

  /**
   * Show on xxlarge devices
   */
  xxl: _propTypes.default.bool
};
Visible.defaultProps = {
  xs: false,
  sm: false,
  md: false,
  lg: false,
  xl: false,
  xxl: false
};
var _default = Visible;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/utilities/Visible/style.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-grid-system/build/utilities/Visible/style.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.visible = void 0;

var visible = function visible(_ref) {
  var screenClass = _ref.screenClass,
      xs = _ref.xs,
      sm = _ref.sm,
      md = _ref.md,
      lg = _ref.lg,
      xl = _ref.xl,
      xxl = _ref.xxl;
  if (screenClass === 'xxl') return xxl;
  if (screenClass === 'xl') return xl;
  if (screenClass === 'lg') return lg;
  if (screenClass === 'md') return md;
  if (screenClass === 'sm') return sm;
  return xs;
};

exports.visible = visible;
var _default = visible;
exports.default = _default;

/***/ }),

/***/ "./node_modules/react-grid-system/build/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-grid-system/build/utils.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useScreenClass = exports.screenClasses = void 0;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var _config = __webpack_require__(/*! ./config */ "./node_modules/react-grid-system/build/config.js");

var _primitives = __webpack_require__(/*! ./primitives */ "./node_modules/react-grid-system/build/primitives/index.js");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var getViewPort = function getViewPort(source) {
  if (source && source.current && source.current.clientWidth) {
    return source.current.clientWidth;
  }

  if (typeof _primitives.Window !== 'undefined' && _primitives.Window.innerWidth) {
    return _primitives.Window.innerWidth;
  }

  return null;
};

var screenClasses = ['xs', 'sm', 'md', 'lg', 'xl', 'xxl'];
exports.screenClasses = screenClasses;

var useScreenClass = function useScreenClass(source, fallbackScreenClass) {
  var getScreenClass = function getScreenClass() {
    var _getConfiguration = (0, _config.getConfiguration)(),
        breakpoints = _getConfiguration.breakpoints,
        defaultScreenClass = _getConfiguration.defaultScreenClass,
        maxScreenClass = _getConfiguration.maxScreenClass;

    var newScreenClass = defaultScreenClass;
    var viewport = getViewPort(source);

    if (viewport) {
      newScreenClass = 'xs';
      if (breakpoints[0] && viewport >= breakpoints[0]) newScreenClass = 'sm';
      if (breakpoints[1] && viewport >= breakpoints[1]) newScreenClass = 'md';
      if (breakpoints[2] && viewport >= breakpoints[2]) newScreenClass = 'lg';
      if (breakpoints[3] && viewport >= breakpoints[3]) newScreenClass = 'xl';
      if (breakpoints[4] && viewport >= breakpoints[4]) newScreenClass = 'xxl';
    } else if (fallbackScreenClass) {
      newScreenClass = fallbackScreenClass;
    }

    var newScreenClassIndex = screenClasses.indexOf(newScreenClass);
    var maxScreenClassIndex = screenClasses.indexOf(maxScreenClass);

    if (maxScreenClassIndex >= 0 && newScreenClassIndex > maxScreenClassIndex) {
      newScreenClass = screenClasses[maxScreenClassIndex];
    }

    return newScreenClass;
  };

  var _useState = (0, _react.useState)(getScreenClass()),
      _useState2 = _slicedToArray(_useState, 2),
      screenClass = _useState2[0],
      setScreenClass = _useState2[1];

  (0, _react.useEffect)(function () {
    var handleWindowResized = function handleWindowResized() {
      return setScreenClass(getScreenClass());
    };

    _primitives.Window.addEventListener('resize', handleWindowResized, false);

    return function () {
      _primitives.Window.removeEventListener('resize', handleWindowResized, false);
    };
  }, []);
  return screenClass;
};

exports.useScreenClass = useScreenClass;

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react-tabs/esm/components/Tab.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-tabs/esm/components/Tab.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Tab; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }




var DEFAULT_CLASS = 'react-tabs__tab';

var Tab = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Tab, _Component);

  function Tab() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = Tab.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.checkFocus();
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    this.checkFocus();
  };

  _proto.checkFocus = function checkFocus() {
    var _this$props = this.props,
        selected = _this$props.selected,
        focus = _this$props.focus;

    if (selected && focus) {
      this.node.focus();
    }
  };

  _proto.render = function render() {
    var _cx,
        _this = this;

    var _this$props2 = this.props,
        children = _this$props2.children,
        className = _this$props2.className,
        disabled = _this$props2.disabled,
        disabledClassName = _this$props2.disabledClassName,
        focus = _this$props2.focus,
        id = _this$props2.id,
        panelId = _this$props2.panelId,
        selected = _this$props2.selected,
        selectedClassName = _this$props2.selectedClassName,
        tabIndex = _this$props2.tabIndex,
        tabRef = _this$props2.tabRef,
        attributes = _objectWithoutPropertiesLoose(_this$props2, ["children", "className", "disabled", "disabledClassName", "focus", "id", "panelId", "selected", "selectedClassName", "tabIndex", "tabRef"]);

    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("li", _extends({}, attributes, {
      className: Object(clsx__WEBPACK_IMPORTED_MODULE_2__["default"])(className, (_cx = {}, _cx[selectedClassName] = selected, _cx[disabledClassName] = disabled, _cx)),
      ref: function ref(node) {
        _this.node = node;
        if (tabRef) tabRef(node);
      },
      role: "tab",
      id: id,
      "aria-selected": selected ? 'true' : 'false',
      "aria-disabled": disabled ? 'true' : 'false',
      "aria-controls": panelId,
      tabIndex: tabIndex || (selected ? '0' : null)
    }), children);
  };

  return Tab;
}(react__WEBPACK_IMPORTED_MODULE_1__["Component"]);

Tab.defaultProps = {
  className: DEFAULT_CLASS,
  disabledClassName: DEFAULT_CLASS + "--disabled",
  focus: false,
  id: null,
  panelId: null,
  selected: false,
  selectedClassName: DEFAULT_CLASS + "--selected"
};

Tab.propTypes =  true ? {
  children: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.array, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string]),
  className: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.array, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object]),
  disabled: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  tabIndex: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  disabledClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  focus: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  // private
  id: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  // private
  panelId: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  // private
  selected: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  // private
  selectedClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  tabRef: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func // private

} : undefined;
Tab.tabsRole = 'Tab';

/***/ }),

/***/ "./node_modules/react-tabs/esm/components/TabList.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-tabs/esm/components/TabList.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TabList; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }





var TabList = /*#__PURE__*/function (_Component) {
  _inheritsLoose(TabList, _Component);

  function TabList() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = TabList.prototype;

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        className = _this$props.className,
        attributes = _objectWithoutPropertiesLoose(_this$props, ["children", "className"]);

    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("ul", _extends({}, attributes, {
      className: Object(clsx__WEBPACK_IMPORTED_MODULE_2__["default"])(className),
      role: "tablist"
    }), children);
  };

  return TabList;
}(react__WEBPACK_IMPORTED_MODULE_1__["Component"]);

TabList.defaultProps = {
  className: 'react-tabs__tab-list'
};

TabList.propTypes =  true ? {
  children: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.array]),
  className: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.array, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object])
} : undefined;
TabList.tabsRole = 'TabList';

/***/ }),

/***/ "./node_modules/react-tabs/esm/components/TabPanel.js":
/*!************************************************************!*\
  !*** ./node_modules/react-tabs/esm/components/TabPanel.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TabPanel; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }




var DEFAULT_CLASS = 'react-tabs__tab-panel';

var TabPanel = /*#__PURE__*/function (_Component) {
  _inheritsLoose(TabPanel, _Component);

  function TabPanel() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = TabPanel.prototype;

  _proto.render = function render() {
    var _cx;

    var _this$props = this.props,
        children = _this$props.children,
        className = _this$props.className,
        forceRender = _this$props.forceRender,
        id = _this$props.id,
        selected = _this$props.selected,
        selectedClassName = _this$props.selectedClassName,
        tabId = _this$props.tabId,
        attributes = _objectWithoutPropertiesLoose(_this$props, ["children", "className", "forceRender", "id", "selected", "selectedClassName", "tabId"]);

    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", _extends({}, attributes, {
      className: Object(clsx__WEBPACK_IMPORTED_MODULE_2__["default"])(className, (_cx = {}, _cx[selectedClassName] = selected, _cx)),
      role: "tabpanel",
      id: id,
      "aria-labelledby": tabId
    }), forceRender || selected ? children : null);
  };

  return TabPanel;
}(react__WEBPACK_IMPORTED_MODULE_1__["Component"]);

TabPanel.defaultProps = {
  className: DEFAULT_CLASS,
  forceRender: false,
  selectedClassName: DEFAULT_CLASS + "--selected"
};

TabPanel.propTypes =  true ? {
  children: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.node,
  className: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.array, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object]),
  forceRender: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  id: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  // private
  selected: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  // private
  selectedClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  tabId: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string // private

} : undefined;
TabPanel.tabsRole = 'TabPanel';

/***/ }),

/***/ "./node_modules/react-tabs/esm/components/Tabs.js":
/*!********************************************************!*\
  !*** ./node_modules/react-tabs/esm/components/Tabs.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Tabs; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _helpers_propTypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/propTypes */ "./node_modules/react-tabs/esm/helpers/propTypes.js");
/* harmony import */ var _UncontrolledTabs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./UncontrolledTabs */ "./node_modules/react-tabs/esm/components/UncontrolledTabs.js");
/* harmony import */ var _helpers_count__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/count */ "./node_modules/react-tabs/esm/helpers/count.js");
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }






var MODE_CONTROLLED = 0;
var MODE_UNCONTROLLED = 1;

var Tabs = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Tabs, _Component);

  function Tabs(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.handleSelected = function (index, last, event) {
      var onSelect = _this.props.onSelect;
      var mode = _this.state.mode; // Call change event handler

      if (typeof onSelect === 'function') {
        // Check if the change event handler cancels the tab change
        if (onSelect(index, last, event) === false) return;
      }

      var state = {
        // Set focus if the change was triggered from the keyboard
        focus: event.type === 'keydown'
      };

      if (mode === MODE_UNCONTROLLED) {
        // Update selected index
        state.selectedIndex = index;
      }

      _this.setState(state);
    };

    _this.state = Tabs.copyPropsToState(_this.props, {}, props.defaultFocus);
    return _this;
  }

  Tabs.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    return Tabs.copyPropsToState(props, state);
  };

  Tabs.getModeFromProps = function getModeFromProps(props) {
    return props.selectedIndex === null ? MODE_UNCONTROLLED : MODE_CONTROLLED;
  };

  // preserve the existing selectedIndex from state.
  // If the state has not selectedIndex, default to the defaultIndex or 0
  Tabs.copyPropsToState = function copyPropsToState(props, state, focus) {
    if (focus === void 0) {
      focus = false;
    }

    if ( true && state.mode !== undefined && state.mode !== Tabs.getModeFromProps(props)) {
      throw new Error("Switching between controlled mode (by using `selectedIndex`) and uncontrolled mode is not supported in `Tabs`.\nFor more information about controlled and uncontrolled mode of react-tabs see the README.");
    }

    var newState = {
      focus: focus,
      mode: Tabs.getModeFromProps(props)
    };

    if (newState.mode === MODE_UNCONTROLLED) {
      var maxTabIndex = Object(_helpers_count__WEBPACK_IMPORTED_MODULE_4__["getTabsCount"])(props.children) - 1;
      var selectedIndex = null;

      if (state.selectedIndex != null) {
        selectedIndex = Math.min(state.selectedIndex, maxTabIndex);
      } else {
        selectedIndex = props.defaultIndex || 0;
      }

      newState.selectedIndex = selectedIndex;
    }

    return newState;
  };

  var _proto = Tabs.prototype;

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        defaultIndex = _this$props.defaultIndex,
        defaultFocus = _this$props.defaultFocus,
        props = _objectWithoutPropertiesLoose(_this$props, ["children", "defaultIndex", "defaultFocus"]);

    var _this$state = this.state,
        focus = _this$state.focus,
        selectedIndex = _this$state.selectedIndex;
    props.focus = focus;
    props.onSelect = this.handleSelected;

    if (selectedIndex != null) {
      props.selectedIndex = selectedIndex;
    }

    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_UncontrolledTabs__WEBPACK_IMPORTED_MODULE_3__["default"], props, children);
  };

  return Tabs;
}(react__WEBPACK_IMPORTED_MODULE_1__["Component"]);

Tabs.defaultProps = {
  defaultFocus: false,
  forceRenderTabPanel: false,
  selectedIndex: null,
  defaultIndex: null
};

Tabs.propTypes =  true ? {
  children: _helpers_propTypes__WEBPACK_IMPORTED_MODULE_2__["childrenPropType"],
  direction: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOf(['rtl', 'ltr']),
  className: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.array, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object]),
  defaultFocus: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  defaultIndex: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,
  disabledTabClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  domRef: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,
  forceRenderTabPanel: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  onSelect: _helpers_propTypes__WEBPACK_IMPORTED_MODULE_2__["onSelectPropType"],
  selectedIndex: _helpers_propTypes__WEBPACK_IMPORTED_MODULE_2__["selectedIndexPropType"],
  selectedTabClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  selectedTabPanelClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string
} : undefined;
Tabs.tabsRole = 'Tabs';

/***/ }),

/***/ "./node_modules/react-tabs/esm/components/UncontrolledTabs.js":
/*!********************************************************************!*\
  !*** ./node_modules/react-tabs/esm/components/UncontrolledTabs.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UncontrolledTabs; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
/* harmony import */ var _helpers_uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/uuid */ "./node_modules/react-tabs/esm/helpers/uuid.js");
/* harmony import */ var _helpers_propTypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/propTypes */ "./node_modules/react-tabs/esm/helpers/propTypes.js");
/* harmony import */ var _helpers_count__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/count */ "./node_modules/react-tabs/esm/helpers/count.js");
/* harmony import */ var _helpers_childrenDeepMap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/childrenDeepMap */ "./node_modules/react-tabs/esm/helpers/childrenDeepMap.js");
/* harmony import */ var _helpers_elementTypes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/elementTypes */ "./node_modules/react-tabs/esm/helpers/elementTypes.js");
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }










function isNode(node) {
  return node && 'getAttribute' in node;
} // Determine if a node from event.target is a Tab element


function isTabNode(node) {
  return isNode(node) && node.getAttribute('role') === 'tab';
} // Determine if a tab node is disabled


function isTabDisabled(node) {
  return isNode(node) && node.getAttribute('aria-disabled') === 'true';
}

var canUseActiveElement;

try {
  canUseActiveElement = !!(typeof window !== 'undefined' && window.document && window.document.activeElement);
} catch (e) {
  // Work around for IE bug when accessing document.activeElement in an iframe
  // Refer to the following resources:
  // http://stackoverflow.com/a/10982960/369687
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12733599
  canUseActiveElement = false;
}

var UncontrolledTabs = /*#__PURE__*/function (_Component) {
  _inheritsLoose(UncontrolledTabs, _Component);

  function UncontrolledTabs() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.tabNodes = [];

    _this.handleKeyDown = function (e) {
      var direction = _this.props.direction;

      if (_this.isTabFromContainer(e.target)) {
        var index = _this.props.selectedIndex;
        var preventDefault = false;
        var useSelectedIndex = false;

        if (e.keyCode === 32 || e.keyCode === 13) {
          preventDefault = true;
          useSelectedIndex = false;

          _this.handleClick(e);
        }

        if (e.keyCode === 37 || e.keyCode === 38) {
          // Select next tab to the left
          if (direction === 'rtl') {
            index = _this.getNextTab(index);
          } else {
            index = _this.getPrevTab(index);
          }

          preventDefault = true;
          useSelectedIndex = true;
        } else if (e.keyCode === 39 || e.keyCode === 40) {
          // Select next tab to the right
          if (direction === 'rtl') {
            index = _this.getPrevTab(index);
          } else {
            index = _this.getNextTab(index);
          }

          preventDefault = true;
          useSelectedIndex = true;
        } else if (e.keyCode === 35) {
          // Select last tab (End key)
          index = _this.getLastTab();
          preventDefault = true;
          useSelectedIndex = true;
        } else if (e.keyCode === 36) {
          // Select first tab (Home key)
          index = _this.getFirstTab();
          preventDefault = true;
          useSelectedIndex = true;
        } // This prevents scrollbars from moving around


        if (preventDefault) {
          e.preventDefault();
        } // Only use the selected index in the state if we're not using the tabbed index


        if (useSelectedIndex) {
          _this.setSelected(index, e);
        }
      }
    };

    _this.handleClick = function (e) {
      var node = e.target;

      do {
        if (_this.isTabFromContainer(node)) {
          if (isTabDisabled(node)) {
            return;
          }

          var index = [].slice.call(node.parentNode.children).filter(isTabNode).indexOf(node);

          _this.setSelected(index, e);

          return;
        } // eslint-disable-next-line no-cond-assign

      } while ((node = node.parentNode) != null);
    };

    return _this;
  }

  var _proto = UncontrolledTabs.prototype;

  _proto.setSelected = function setSelected(index, event) {
    // Check index boundary
    if (index < 0 || index >= this.getTabsCount()) return;
    var _this$props = this.props,
        onSelect = _this$props.onSelect,
        selectedIndex = _this$props.selectedIndex; // Call change event handler

    onSelect(index, selectedIndex, event);
  };

  _proto.getNextTab = function getNextTab(index) {
    var count = this.getTabsCount(); // Look for non-disabled tab from index to the last tab on the right

    for (var i = index + 1; i < count; i++) {
      if (!isTabDisabled(this.getTab(i))) {
        return i;
      }
    } // If no tab found, continue searching from first on left to index


    for (var _i = 0; _i < index; _i++) {
      if (!isTabDisabled(this.getTab(_i))) {
        return _i;
      }
    } // No tabs are disabled, return index


    return index;
  };

  _proto.getPrevTab = function getPrevTab(index) {
    var i = index; // Look for non-disabled tab from index to first tab on the left

    while (i--) {
      if (!isTabDisabled(this.getTab(i))) {
        return i;
      }
    } // If no tab found, continue searching from last tab on right to index


    i = this.getTabsCount();

    while (i-- > index) {
      if (!isTabDisabled(this.getTab(i))) {
        return i;
      }
    } // No tabs are disabled, return index


    return index;
  };

  _proto.getFirstTab = function getFirstTab() {
    var count = this.getTabsCount(); // Look for non disabled tab from the first tab

    for (var i = 0; i < count; i++) {
      if (!isTabDisabled(this.getTab(i))) {
        return i;
      }
    }

    return null;
  };

  _proto.getLastTab = function getLastTab() {
    var i = this.getTabsCount(); // Look for non disabled tab from the last tab

    while (i--) {
      if (!isTabDisabled(this.getTab(i))) {
        return i;
      }
    }

    return null;
  };

  _proto.getTabsCount = function getTabsCount() {
    var children = this.props.children;
    return Object(_helpers_count__WEBPACK_IMPORTED_MODULE_5__["getTabsCount"])(children);
  };

  _proto.getPanelsCount = function getPanelsCount() {
    var children = this.props.children;
    return Object(_helpers_count__WEBPACK_IMPORTED_MODULE_5__["getPanelsCount"])(children);
  };

  _proto.getTab = function getTab(index) {
    return this.tabNodes["tabs-" + index];
  };

  _proto.getChildren = function getChildren() {
    var _this2 = this;

    var index = 0;
    var _this$props2 = this.props,
        children = _this$props2.children,
        disabledTabClassName = _this$props2.disabledTabClassName,
        focus = _this$props2.focus,
        forceRenderTabPanel = _this$props2.forceRenderTabPanel,
        selectedIndex = _this$props2.selectedIndex,
        selectedTabClassName = _this$props2.selectedTabClassName,
        selectedTabPanelClassName = _this$props2.selectedTabPanelClassName;
    this.tabIds = this.tabIds || [];
    this.panelIds = this.panelIds || [];
    var diff = this.tabIds.length - this.getTabsCount(); // Add ids if new tabs have been added
    // Don't bother removing ids, just keep them in case they are added again
    // This is more efficient, and keeps the uuid counter under control

    while (diff++ < 0) {
      this.tabIds.push(Object(_helpers_uuid__WEBPACK_IMPORTED_MODULE_3__["default"])());
      this.panelIds.push(Object(_helpers_uuid__WEBPACK_IMPORTED_MODULE_3__["default"])());
    } // Map children to dynamically setup refs


    return Object(_helpers_childrenDeepMap__WEBPACK_IMPORTED_MODULE_6__["deepMap"])(children, function (child) {
      var result = child; // Clone TabList and Tab components to have refs

      if (Object(_helpers_elementTypes__WEBPACK_IMPORTED_MODULE_7__["isTabList"])(child)) {
        var listIndex = 0; // Figure out if the current focus in the DOM is set on a Tab
        // If it is we should keep the focus on the next selected tab

        var wasTabFocused = false;

        if (canUseActiveElement) {
          wasTabFocused = react__WEBPACK_IMPORTED_MODULE_1___default.a.Children.toArray(child.props.children).filter(_helpers_elementTypes__WEBPACK_IMPORTED_MODULE_7__["isTab"]).some(function (tab, i) {
            return document.activeElement === _this2.getTab(i);
          });
        }

        result = Object(react__WEBPACK_IMPORTED_MODULE_1__["cloneElement"])(child, {
          children: Object(_helpers_childrenDeepMap__WEBPACK_IMPORTED_MODULE_6__["deepMap"])(child.props.children, function (tab) {
            var key = "tabs-" + listIndex;
            var selected = selectedIndex === listIndex;
            var props = {
              tabRef: function tabRef(node) {
                _this2.tabNodes[key] = node;
              },
              id: _this2.tabIds[listIndex],
              panelId: _this2.panelIds[listIndex],
              selected: selected,
              focus: selected && (focus || wasTabFocused)
            };
            if (selectedTabClassName) props.selectedClassName = selectedTabClassName;
            if (disabledTabClassName) props.disabledClassName = disabledTabClassName;
            listIndex++;
            return Object(react__WEBPACK_IMPORTED_MODULE_1__["cloneElement"])(tab, props);
          })
        });
      } else if (Object(_helpers_elementTypes__WEBPACK_IMPORTED_MODULE_7__["isTabPanel"])(child)) {
        var props = {
          id: _this2.panelIds[index],
          tabId: _this2.tabIds[index],
          selected: selectedIndex === index
        };
        if (forceRenderTabPanel) props.forceRender = forceRenderTabPanel;
        if (selectedTabPanelClassName) props.selectedClassName = selectedTabPanelClassName;
        index++;
        result = Object(react__WEBPACK_IMPORTED_MODULE_1__["cloneElement"])(child, props);
      }

      return result;
    });
  };

  /**
   * Determine if a node from event.target is a Tab element for the current Tabs container.
   * If the clicked element is not a Tab, it returns false.
   * If it finds another Tabs container between the Tab and `this`, it returns false.
   */
  _proto.isTabFromContainer = function isTabFromContainer(node) {
    // return immediately if the clicked element is not a Tab.
    if (!isTabNode(node)) {
      return false;
    } // Check if the first occurrence of a Tabs container is `this` one.


    var nodeAncestor = node.parentElement;

    do {
      if (nodeAncestor === this.node) return true;
      if (nodeAncestor.getAttribute('data-tabs')) break;
      nodeAncestor = nodeAncestor.parentElement;
    } while (nodeAncestor);

    return false;
  };

  _proto.render = function render() {
    var _this3 = this;

    // Delete all known props, so they don't get added to DOM
    var _this$props3 = this.props,
        children = _this$props3.children,
        className = _this$props3.className,
        disabledTabClassName = _this$props3.disabledTabClassName,
        domRef = _this$props3.domRef,
        focus = _this$props3.focus,
        forceRenderTabPanel = _this$props3.forceRenderTabPanel,
        onSelect = _this$props3.onSelect,
        selectedIndex = _this$props3.selectedIndex,
        selectedTabClassName = _this$props3.selectedTabClassName,
        selectedTabPanelClassName = _this$props3.selectedTabPanelClassName,
        attributes = _objectWithoutPropertiesLoose(_this$props3, ["children", "className", "disabledTabClassName", "domRef", "focus", "forceRenderTabPanel", "onSelect", "selectedIndex", "selectedTabClassName", "selectedTabPanelClassName"]);

    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", _extends({}, attributes, {
      className: Object(clsx__WEBPACK_IMPORTED_MODULE_2__["default"])(className),
      onClick: this.handleClick,
      onKeyDown: this.handleKeyDown,
      ref: function ref(node) {
        _this3.node = node;
        if (domRef) domRef(node);
      },
      "data-tabs": true
    }), this.getChildren());
  };

  return UncontrolledTabs;
}(react__WEBPACK_IMPORTED_MODULE_1__["Component"]);

UncontrolledTabs.defaultProps = {
  className: 'react-tabs',
  focus: false
};

UncontrolledTabs.propTypes =  true ? {
  children: _helpers_propTypes__WEBPACK_IMPORTED_MODULE_4__["childrenPropType"],
  direction: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOf(['rtl', 'ltr']),
  className: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.array, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object]),
  disabledTabClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  domRef: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,
  focus: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  forceRenderTabPanel: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,
  onSelect: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func.isRequired,
  selectedIndex: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,
  selectedTabClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  selectedTabPanelClassName: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string
} : undefined;

/***/ }),

/***/ "./node_modules/react-tabs/esm/helpers/childrenDeepMap.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-tabs/esm/helpers/childrenDeepMap.js ***!
  \****************************************************************/
/*! exports provided: deepMap, deepForEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepMap", function() { return deepMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepForEach", function() { return deepForEach; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _elementTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elementTypes */ "./node_modules/react-tabs/esm/helpers/elementTypes.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




function isTabChild(child) {
  return Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTab"])(child) || Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTabList"])(child) || Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTabPanel"])(child);
}

function deepMap(children, callback) {
  return react__WEBPACK_IMPORTED_MODULE_0__["Children"].map(children, function (child) {
    // null happens when conditionally rendering TabPanel/Tab
    // see https://github.com/reactjs/react-tabs/issues/37
    if (child === null) return null;

    if (isTabChild(child)) {
      return callback(child);
    }

    if (child.props && child.props.children && typeof child.props.children === 'object') {
      // Clone the child that has children and map them too
      return Object(react__WEBPACK_IMPORTED_MODULE_0__["cloneElement"])(child, _objectSpread(_objectSpread({}, child.props), {}, {
        children: deepMap(child.props.children, callback)
      }));
    }

    return child;
  });
}
function deepForEach(children, callback) {
  return react__WEBPACK_IMPORTED_MODULE_0__["Children"].forEach(children, function (child) {
    // null happens when conditionally rendering TabPanel/Tab
    // see https://github.com/reactjs/react-tabs/issues/37
    if (child === null) return;

    if (Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTab"])(child) || Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTabPanel"])(child)) {
      callback(child);
    } else if (child.props && child.props.children && typeof child.props.children === 'object') {
      if (Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTabList"])(child)) callback(child);
      deepForEach(child.props.children, callback);
    }
  });
}

/***/ }),

/***/ "./node_modules/react-tabs/esm/helpers/count.js":
/*!******************************************************!*\
  !*** ./node_modules/react-tabs/esm/helpers/count.js ***!
  \******************************************************/
/*! exports provided: getTabsCount, getPanelsCount */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTabsCount", function() { return getTabsCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPanelsCount", function() { return getPanelsCount; });
/* harmony import */ var _childrenDeepMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./childrenDeepMap */ "./node_modules/react-tabs/esm/helpers/childrenDeepMap.js");
/* harmony import */ var _elementTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elementTypes */ "./node_modules/react-tabs/esm/helpers/elementTypes.js");


function getTabsCount(children) {
  var tabCount = 0;
  Object(_childrenDeepMap__WEBPACK_IMPORTED_MODULE_0__["deepForEach"])(children, function (child) {
    if (Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTab"])(child)) tabCount++;
  });
  return tabCount;
}
function getPanelsCount(children) {
  var panelCount = 0;
  Object(_childrenDeepMap__WEBPACK_IMPORTED_MODULE_0__["deepForEach"])(children, function (child) {
    if (Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTabPanel"])(child)) panelCount++;
  });
  return panelCount;
}

/***/ }),

/***/ "./node_modules/react-tabs/esm/helpers/elementTypes.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-tabs/esm/helpers/elementTypes.js ***!
  \*************************************************************/
/*! exports provided: isTab, isTabList, isTabPanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTab", function() { return isTab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTabList", function() { return isTabList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTabPanel", function() { return isTabPanel; });
function makeTypeChecker(tabsRole) {
  return function (element) {
    return !!element.type && element.type.tabsRole === tabsRole;
  };
}

var isTab = makeTypeChecker('Tab');
var isTabList = makeTypeChecker('TabList');
var isTabPanel = makeTypeChecker('TabPanel');

/***/ }),

/***/ "./node_modules/react-tabs/esm/helpers/propTypes.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-tabs/esm/helpers/propTypes.js ***!
  \**********************************************************/
/*! exports provided: childrenPropType, onSelectPropType, selectedIndexPropType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "childrenPropType", function() { return childrenPropType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onSelectPropType", function() { return onSelectPropType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectedIndexPropType", function() { return selectedIndexPropType; });
/* harmony import */ var _childrenDeepMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./childrenDeepMap */ "./node_modules/react-tabs/esm/helpers/childrenDeepMap.js");
/* harmony import */ var _elementTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elementTypes */ "./node_modules/react-tabs/esm/helpers/elementTypes.js");


function childrenPropType(props, propName, componentName) {
  var error;
  var tabsCount = 0;
  var panelsCount = 0;
  var tabListFound = false;
  var listTabs = [];
  var children = props[propName];
  Object(_childrenDeepMap__WEBPACK_IMPORTED_MODULE_0__["deepForEach"])(children, function (child) {
    if (Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTabList"])(child)) {
      if (child.props && child.props.children && typeof child.props.children === 'object') {
        Object(_childrenDeepMap__WEBPACK_IMPORTED_MODULE_0__["deepForEach"])(child.props.children, function (listChild) {
          return listTabs.push(listChild);
        });
      }

      if (tabListFound) {
        error = new Error("Found multiple 'TabList' components inside 'Tabs'. Only one is allowed.");
      }

      tabListFound = true;
    }

    if (Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTab"])(child)) {
      if (!tabListFound || listTabs.indexOf(child) === -1) {
        error = new Error("Found a 'Tab' component outside of the 'TabList' component. 'Tab' components " + "have to be inside the 'TabList' component.");
      }

      tabsCount++;
    } else if (Object(_elementTypes__WEBPACK_IMPORTED_MODULE_1__["isTabPanel"])(child)) {
      panelsCount++;
    }
  });

  if (!error && tabsCount !== panelsCount) {
    error = new Error("There should be an equal number of 'Tab' and 'TabPanel' in `" + componentName + "`. " + ("Received " + tabsCount + " 'Tab' and " + panelsCount + " 'TabPanel'."));
  }

  return error;
}
function onSelectPropType(props, propName, componentName, location, propFullName) {
  var prop = props[propName];
  var name = propFullName || propName;
  var error = null;

  if (prop && typeof prop !== 'function') {
    error = new Error("Invalid " + location + " `" + name + "` of type `" + typeof prop + "` supplied " + ("to `" + componentName + "`, expected `function`."));
  } else if (props.selectedIndex != null && prop == null) {
    error = new Error("The " + location + " `" + name + "` is marked as required in `" + componentName + "`, but " + "its value is `undefined` or `null`.\n" + "`onSelect` is required when `selectedIndex` is also set. Not doing so will " + "make the tabs not do anything, as `selectedIndex` indicates that you want to " + "handle the selected tab yourself.\n" + "If you only want to set the inital tab replace `selectedIndex` with `defaultIndex`.");
  }

  return error;
}
function selectedIndexPropType(props, propName, componentName, location, propFullName) {
  var prop = props[propName];
  var name = propFullName || propName;
  var error = null;

  if (prop != null && typeof prop !== 'number') {
    error = new Error("Invalid " + location + " `" + name + "` of type `" + typeof prop + "` supplied to " + ("`" + componentName + "`, expected `number`."));
  } else if (props.defaultIndex != null && prop != null) {
    return new Error("The " + location + " `" + name + "` cannot be used together with `defaultIndex` " + ("in `" + componentName + "`.\n") + ("Either remove `" + name + "` to let `" + componentName + "` handle the selected ") + "tab internally or remove `defaultIndex` to handle it yourself.");
  }

  return error;
}

/***/ }),

/***/ "./node_modules/react-tabs/esm/helpers/uuid.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-tabs/esm/helpers/uuid.js ***!
  \*****************************************************/
/*! exports provided: default, reset */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return uuid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reset", function() { return reset; });
// Get a universally unique identifier
var count = 0;
function uuid() {
  return "react-tabs-" + count++;
}
function reset() {
  count = 0;
}

/***/ }),

/***/ "./node_modules/react-tabs/esm/index.js":
/*!**********************************************!*\
  !*** ./node_modules/react-tabs/esm/index.js ***!
  \**********************************************/
/*! exports provided: Tabs, TabList, Tab, TabPanel, resetIdCounter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _components_Tabs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/Tabs */ "./node_modules/react-tabs/esm/components/Tabs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tabs", function() { return _components_Tabs__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _components_TabList__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/TabList */ "./node_modules/react-tabs/esm/components/TabList.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TabList", function() { return _components_TabList__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _components_Tab__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/Tab */ "./node_modules/react-tabs/esm/components/Tab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tab", function() { return _components_Tab__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _components_TabPanel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/TabPanel */ "./node_modules/react-tabs/esm/components/TabPanel.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TabPanel", function() { return _components_TabPanel__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _helpers_uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers/uuid */ "./node_modules/react-tabs/esm/helpers/uuid.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resetIdCounter", function() { return _helpers_uuid__WEBPACK_IMPORTED_MODULE_4__["reset"]; });







/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentName(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (Array.isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (Array.isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    if (type === exports.Fragment) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev

var jsxDEV$1 =  jsxWithValidation ;

exports.jsxDEV = jsxDEV$1;
  })();
}


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.1';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
exports.StrictMode = 0xeacc;
exports.Profiler = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
exports.Suspense = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  exports.StrictMode = symbolFor('react.strict_mode');
  exports.Profiler = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  exports.Suspense = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  transition: 0
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var ReactDebugCurrentFrame = {};
var currentExtraStackFrame = null;
function setExtraStackFrame(stack) {
  {
    currentExtraStackFrame = stack;
  }
}

{
  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
    {
      currentExtraStackFrame = stack;
    }
  }; // Stack implementation injected by the current renderer.


  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentExtraStackFrame) {
      stack += currentExtraStackFrame;
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

/**
 * Used by act() to track whether you're inside an act() scope.
 */
var IsSomeRendererActing = {
  current: false
};

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner,
  IsSomeRendererActing: IsSomeRendererActing,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
}

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
    }
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

_assign(pureComponentPrototype, Component.prototype);

pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case exports.Profiler:
      return 'Profiler';

    case exports.StrictMode:
      return 'StrictMode';

    case exports.Suspense:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

function warnIfStringRefCannotBeAutoConverted(config) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (!!(element === null || element === undefined)) {
    {
      throw Error( "React.cloneElement(...): The argument must be a React element, but you passed " + element + "." );
    }
  }

  var propName; // Original props are copied

  var props = _assign({}, element.props); // Reserved names are extracted


  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = key.replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return text.replace(userProvidedKeyEscapeRegex, '$&/');
}
/**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getElementKey(element, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof element === 'object' && element !== null && element.key != null) {
    // Explicit key
    return escape('' + element.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    var _child = children;
    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows:

    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

    if (Array.isArray(mappedChild)) {
      var escapedChildKey = '';

      if (childKey != null) {
        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
      }

      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
        return c;
      });
    } else if (mappedChild != null) {
      if (isValidElement(mappedChild)) {
        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
      }

      array.push(mappedChild);
    }

    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getElementKey(child, i);
      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {
      var iterableChildren = children;

      {
        // Warn about using Maps as children
        if (iteratorFn === iterableChildren.entries) {
          if (!didWarnAboutMaps) {
            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
          }

          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(iterableChildren);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getElementKey(child, ii++);
        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
      }
    } else if (type === 'object') {
      var childrenString = '' + children;

      {
        {
          throw Error( "Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead." );
        }
      }
    }
  }

  return subtreeCount;
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  var count = 0;
  mapIntoArray(children, result, '', '', function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  var n = 0;
  mapChildren(children, function () {
    n++; // Don't return anything
  });
  return n;
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  mapChildren(children, function () {
    forEachFunc.apply(this, arguments); // Don't return anything.
  }, forEachContext);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  return mapChildren(children, function (child) {
    return child;
  }) || [];
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    {
      throw Error( "React.Children.only expected to receive a single React element child." );
    }
  }

  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
      }
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;
  var hasWarnedAboutDisplayNameOnConsumer = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;

            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;

            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      },
      displayName: {
        get: function () {
          return context.displayName;
        },
        set: function (displayName) {
          if (!hasWarnedAboutDisplayNameOnConsumer) {
            warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

            hasWarnedAboutDisplayNameOnConsumer = true;
          }
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

var Uninitialized = -1;
var Pending = 0;
var Resolved = 1;
var Rejected = 2;

function lazyInitializer(payload) {
  if (payload._status === Uninitialized) {
    var ctor = payload._result;
    var thenable = ctor(); // Transition to the next state.

    var pending = payload;
    pending._status = Pending;
    pending._result = thenable;
    thenable.then(function (moduleObject) {
      if (payload._status === Pending) {
        var defaultExport = moduleObject.default;

        {
          if (defaultExport === undefined) {
            error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
          }
        } // Transition to the next state.


        var resolved = payload;
        resolved._status = Resolved;
        resolved._result = defaultExport;
      }
    }, function (error) {
      if (payload._status === Pending) {
        // Transition to the next state.
        var rejected = payload;
        rejected._status = Rejected;
        rejected._result = error;
      }
    });
  }

  if (payload._status === Resolved) {
    return payload._result;
  } else {
    throw payload._result;
  }
}

function lazy(ctor) {
  var payload = {
    // We use these fields to store the result.
    _status: -1,
    _result: ctor
  };
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _payload: payload,
    _init: lazyInitializer
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes; // $FlowFixMe

    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          defaultProps = newDefaultProps; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          propTypes = newPropTypes; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      if (render.length !== 0 && render.length !== 2) {
        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
      }
    }

    if (render != null) {
      if (render.defaultProps != null || render.propTypes != null) {
        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
      }
    }
  }

  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (render.displayName == null) {
          render.displayName = name;
        }
      }
    });
  }

  return elementType;
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  var elementType = {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (type.displayName == null) {
          type.displayName = name;
        }
      }
    });
  }

  return elementType;
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  if (!(dispatcher !== null)) {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }

  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();

  {
    if (unstable_observedBits !== undefined) {
      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');
    } // TODO: add a more generic warning for invalid values.


    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context, unstable_observedBits);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
function useLayoutEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
function useCallback(callback, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, deps);
}
function useMemo(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
function useImperativeHandle(ref, create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, deps);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher$1.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher$1.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case exports.Suspense:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      setExtraStackFrame(stack);
    } else {
      setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
  }

  {
    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    {
      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === exports.Fragment) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
var didWarnAboutDeprecatedCreateFactory = false;
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;

  {
    if (!didWarnAboutDeprecatedCreateFactory) {
      didWarnAboutDeprecatedCreateFactory = true;

      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
    } // Legacy hook: remove it


    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

{

  try {
    var frozenObject = Object.freeze({});
    /* eslint-disable no-new */

    new Map([[frozenObject, null]]);
    new Set([frozenObject]);
    /* eslint-enable no-new */
  } catch (e) {
  }
}

var createElement$1 =  createElementWithValidation ;
var cloneElement$1 =  cloneElementWithValidation ;
var createFactory =  createFactoryWithValidation ;
var Children = {
  map: mapChildren,
  forEach: forEachChildren,
  count: countChildren,
  toArray: toArray,
  only: onlyChild
};

exports.Children = Children;
exports.Component = Component;
exports.PureComponent = PureComponent;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
exports.cloneElement = cloneElement$1;
exports.createContext = createContext;
exports.createElement = createElement$1;
exports.createFactory = createFactory;
exports.createRef = createRef;
exports.forwardRef = forwardRef;
exports.isValidElement = isValidElement;
exports.lazy = lazy;
exports.memo = memo;
exports.useCallback = useCallback;
exports.useContext = useContext;
exports.useDebugValue = useDebugValue;
exports.useEffect = useEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemo = useMemo;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useState = useState;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js");
}


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./pages/portfolio.js":
/*!****************************!*\
  !*** ./pages/portfolio.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Despre; });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _components_page_components_parteneri__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/page_components/parteneri */ "./components/page_components/parteneri.js");


var _jsxFileName = "G:\\MDMax\\go brasov\\site_nextjs\\gobv-site\\pages\\portfolio.js";

function Despre() {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["Fragment"], {
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_components_page_components_parteneri__WEBPACK_IMPORTED_MODULE_1__["default"], {}, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 5,
      columnNumber: 9
    }, this)
  }, void 0, false);
}
_c = Despre;

var _c;

$RefreshReg$(_c, "Despre");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ })

},[["./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2Fportfolio&absolutePagePath=G%3A%5CMDMax%5Cgo%20brasov%5Csite_nextjs%5Cgobv-site%5Cpages%5Cportfolio.js!./","webpack"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9jb21tb24vSGVhZGxpbmUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvY29tbW9uL3BvcnRvZm9saXUvY2FyZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9jb21tb24vdGFibGVzL3BhcnRlbmVyaV90YWJsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9wYWdlX2NvbXBvbmVudHMvcGFydGVuZXJpLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvb2JqZWN0LWFzc2lnbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1jbGllbnQtcGFnZXMtbG9hZGVyLmpzIiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L2xpbmsudHN4Iiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvd2l0aC1yb3V0ZXIudHN4Iiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL21pdHQudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyLWNvbnRleHQudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlci50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvZXNjYXBlLXBhdGgtZGVsaW1pdGVycy50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9wYXRoLW1hdGNoLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9wcmVwYXJlLWRlc3RpbmF0aW9uLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZy50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcmVzb2x2ZS1yZXdyaXRlcy50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXgudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvdXRpbHMudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvc2VydmVyL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbGluay5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtc3lzdGVtL2J1aWxkL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtc3lzdGVtL2J1aWxkL2NvbnRleHQvU2NyZWVuQ2xhc3NQcm92aWRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtc3lzdGVtL2J1aWxkL2NvbnRleHQvU2NyZWVuQ2xhc3NSZXNvbHZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtc3lzdGVtL2J1aWxkL2dyaWQvQ29sL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1zeXN0ZW0vYnVpbGQvZ3JpZC9Db2wvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLXN5c3RlbS9idWlsZC9ncmlkL0NvbnRhaW5lci9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtc3lzdGVtL2J1aWxkL2dyaWQvQ29udGFpbmVyL3N0eWxlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1zeXN0ZW0vYnVpbGQvZ3JpZC9Sb3cvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLXN5c3RlbS9idWlsZC9ncmlkL1Jvdy9zdHlsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtc3lzdGVtL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1zeXN0ZW0vYnVpbGQvcHJpbWl0aXZlcy9EaXYvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLXN5c3RlbS9idWlsZC9wcmltaXRpdmVzL1NwYW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLXN5c3RlbS9idWlsZC9wcmltaXRpdmVzL1dpbmRvdy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtc3lzdGVtL2J1aWxkL3ByaW1pdGl2ZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLXN5c3RlbS9idWlsZC91dGlsaXRpZXMvSGlkZGVuL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1zeXN0ZW0vYnVpbGQvdXRpbGl0aWVzL0hpZGRlbi9zdHlsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtc3lzdGVtL2J1aWxkL3V0aWxpdGllcy9TY3JlZW5DbGFzc1JlbmRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtc3lzdGVtL2J1aWxkL3V0aWxpdGllcy9WaXNpYmxlL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1zeXN0ZW0vYnVpbGQvdXRpbGl0aWVzL1Zpc2libGUvc3R5bGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLXN5c3RlbS9idWlsZC91dGlscy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFicy9lc20vY29tcG9uZW50cy9UYWIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC10YWJzL2VzbS9jb21wb25lbnRzL1RhYkxpc3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC10YWJzL2VzbS9jb21wb25lbnRzL1RhYlBhbmVsLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFicy9lc20vY29tcG9uZW50cy9UYWJzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFicy9lc20vY29tcG9uZW50cy9VbmNvbnRyb2xsZWRUYWJzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFicy9lc20vaGVscGVycy9jaGlsZHJlbkRlZXBNYXAuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC10YWJzL2VzbS9oZWxwZXJzL2NvdW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFicy9lc20vaGVscGVycy9lbGVtZW50VHlwZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC10YWJzL2VzbS9oZWxwZXJzL3Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRhYnMvZXNtL2hlbHBlcnMvdXVpZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRhYnMvZXNtL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovL19OX0UvKHdlYnBhY2spL2J1aWxkaW4vaGFybW9ueS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL3BvcnRmb2xpby5qcyJdLCJuYW1lcyI6WyJIZWFkbGluZSIsInByb3BzIiwibGFiZWwiLCJ0aXRsZSIsInN1YnRpdGxlIiwiZGl2aWRlcl8xIiwiZGl2aWRlcl8yIiwicG9zaXRpb24iLCJjbGFzc05hbWUiLCJDYXJkcyIsInBvcnRmb2xpbyIsIm1hcCIsImNhdGVnb3J5IiwiY2F0ZWdvcnlJbmRleCIsIm5hbWUiLCJpdGVtcyIsIml0ZW0iLCJpbmRleCIsImxpbmsiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJpbWFnZSIsInBhcnRlbmVyaV90YWJsZSIsInRodW1ibmFpbCIsIlBhcnRlbmVyaSIsImxpc3RlbmVycyIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwid2luZG93IiwicHJlZmV0Y2hlZCIsImNhY2hlZE9ic2VydmVyIiwiZW50cmllcyIsImVudHJ5IiwiY2IiLCJyb290TWFyZ2luIiwibGlzdGVuVG9JbnRlcnNlY3Rpb25zIiwib2JzZXJ2ZXIiLCJnZXRPYnNlcnZlciIsImNvbnNvbGUiLCJyb3V0ZXIiLCJlcnIiLCJocmVmIiwiZXZlbnQiLCJ0YXJnZXQiLCJlIiwibm9kZU5hbWUiLCJpc01vZGlmaWVkRXZlbnQiLCJzY3JvbGwiLCJhcyIsInJlcGxhY2UiLCJzaGFsbG93IiwibG9jYWxlIiwic3VjY2VzcyIsImRvY3VtZW50IiwiYXJncyIsImtleSIsImV4cGVjdGVkIiwicmVxdWlyZWRQcm9wc0d1YXJkIiwicmVxdWlyZWRQcm9wcyIsIk9iamVjdCIsImNyZWF0ZVByb3BFcnJvciIsImFjdHVhbCIsIl8iLCJvcHRpb25hbFByb3BzR3VhcmQiLCJwYXNzSHJlZiIsInByZWZldGNoIiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJoYXNXYXJuZWQiLCJSZWFjdCIsInAiLCJwYXRobmFtZSIsInJlc29sdmVkQXMiLCJjaGlsZEVsbSIsImlzUHJlZmV0Y2hlZCIsImNoaWxkcmVuIiwiY2hpbGQiLCJDaGlsZHJlbiIsImNoaWxkUHJvcHMiLCJyZWYiLCJlbCIsInNldENoaWxkRWxtIiwib25DbGljayIsImxpbmtDbGlja2VkIiwicHJpb3JpdHkiLCJMaW5rIiwicGF0aCIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwicHJvY2VzcyIsInNpbmdsZXRvblJvdXRlciIsInJlYWR5Q2FsbGJhY2tzIiwicmVhZHkiLCJ1cmxQcm9wZXJ0eUZpZWxkcyIsInJvdXRlckV2ZW50cyIsImNvcmVNZXRob2RGaWVsZHMiLCJnZXQiLCJSb3V0ZXIiLCJmaWVsZCIsImdldFJvdXRlciIsImV2ZW50RmllbGQiLCJfc2luZ2xldG9uUm91dGVyIiwibWVzc2FnZSIsIlJvdXRlckNvbnRleHQiLCJjcmVhdGVSb3V0ZXIiLCJfcm91dGVyIiwiaW5zdGFuY2UiLCJBcnJheSIsIkNvbXBvc2VkQ29tcG9uZW50IiwiZ2V0SW5pdGlhbFByb3BzIiwiV2l0aFJvdXRlcldyYXBwZXIiLCJhbGwiLCJvbiIsIm9mZiIsImVtaXQiLCJoYW5kbGVyIiwiYmFzZVBhdGgiLCJjYW5jZWxsZWQiLCJwcmVmaXgiLCJhZGRQYXRoUHJlZml4IiwidXJsIiwibG9jYXRpb25PcmlnaW4iLCJyZXNvbHZlZCIsImhhc0Jhc2VQYXRoIiwiaW50ZXJwb2xhdGVkUm91dGUiLCJkeW5hbWljUmVnZXgiLCJkeW5hbWljR3JvdXBzIiwiZHluYW1pY01hdGNoZXMiLCJhc1BhdGhuYW1lIiwicGFyYW1zIiwicGFyYW0iLCJ2YWx1ZSIsInJlcGxhY2VkIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJlc2NhcGVQYXRoRGVsaW1pdGVycyIsInJlc3VsdCIsImZpbHRlcmVkUXVlcnkiLCJxdWVyeSIsImJhc2UiLCJ1cmxBc1N0cmluZyIsImZpbmFsVXJsIiwiaW50ZXJwb2xhdGVkQXMiLCJpbnRlcnBvbGF0ZUFzIiwiaGFzaCIsIm9taXRQYXJtc0Zyb21RdWVyeSIsInJlc29sdmVkSHJlZiIsInJlc29sdmVBcyIsIlBBR0VfTE9BRF9FUlJPUiIsIlN5bWJvbCIsImFkZEJhc2VQYXRoIiwicmVzb2x2ZUhyZWYiLCJtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiIsIlNTR19EQVRBX05PVF9GT1VORF9FUlJPUiIsImNyZWRlbnRpYWxzIiwicmVzIiwiYXR0ZW1wdHMiLCJmZXRjaFJldHJ5IiwiaXNTZXJ2ZXJSZW5kZXIiLCJtYXJrTG9hZGluZ0Vycm9yIiwiY29uc3RydWN0b3IiLCJyb3V0ZSIsImFzUGF0aCIsImNvbXBvbmVudHMiLCJzZGMiLCJzdWIiLCJjbGMiLCJwYWdlTG9hZGVyIiwiX2JwcyIsImV2ZW50cyIsIl93cmFwQXBwIiwiaXNTc3IiLCJpc0ZhbGxiYWNrIiwiX2luRmxpZ2h0Um91dGUiLCJfc2hhbGxvdyIsImxvY2FsZXMiLCJkZWZhdWx0TG9jYWxlIiwic3RhdGUiLCJvcHRpb25zIiwiQ29tcG9uZW50Iiwic3R5bGVTaGVldHMiLCJfX05fU1NHIiwiaW5pdGlhbFByb3BzIiwiX19OX1NTUCIsIl9fTkVYVF9EQVRBX18iLCJyZWxvYWQiLCJiYWNrIiwicHVzaCIsInByZXBhcmVVcmxBcyIsImlzTG9jYWxVUkwiLCJTVCIsInBlcmZvcm1hbmNlIiwiYWRkTG9jYWxlIiwiY2xlYW5lZEFzIiwiZGVsTG9jYWxlIiwiZGVsQmFzZVBhdGgiLCJwYWdlcyIsIl9fcmV3cml0ZXMiLCJwYXJzZWQiLCJtZXRob2QiLCJwb3RlbnRpYWxIcmVmIiwicGFyc2VkQXMiLCJyb3V0ZVJlZ2V4Iiwicm91dGVNYXRjaCIsInNob3VsZEludGVycG9sYXRlIiwibWlzc2luZ1BhcmFtcyIsInJvdXRlSW5mbyIsImRlc3RpbmF0aW9uIiwicGFyc2VkSHJlZiIsImFwcENvbXAiLCJlcnJvciIsIl9fTiIsImJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IiLCJzc2c0MDQiLCJwYWdlIiwibW9kIiwiY2FjaGVkUm91dGVJbmZvIiwicmVxdWlyZSIsImlzVmFsaWRFbGVtZW50VHlwZSIsImRhdGFIcmVmIiwiYmVmb3JlUG9wU3RhdGUiLCJvbmx5QUhhc2hDaGFuZ2UiLCJuZXdIYXNoIiwib2xkVXJsTm9IYXNoIiwib2xkSGFzaCIsInNjcm9sbFRvSGFzaCIsImlkRWwiLCJuYW1lRWwiLCJ1cmxJc05ldyIsIl9yZXNvbHZlSHJlZiIsImFwcGx5QmFzZVBhdGgiLCJjbGVhblBhdGhuYW1lIiwiUHJvbWlzZSIsImNhbmNlbCIsImNvbXBvbmVudFJlc3VsdCIsImZuIiwiZGF0YSIsIl9nZXRTdGF0aWNEYXRhIiwiZmV0Y2hOZXh0RGF0YSIsIl9nZXRTZXJ2ZXJEYXRhIiwiQXBwVHJlZSIsImN0eCIsImFib3J0Q29tcG9uZW50TG9hZCIsIm5vdGlmeSIsInNlZ21lbnQiLCJjaGFyIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2xhc2hlZFByb3RvY29scyIsInByb3RvY29sIiwidXJsT2JqIiwiaG9zdCIsImF1dGgiLCJob3N0bmFtZSIsIlN0cmluZyIsInF1ZXJ5c3RyaW5nIiwic2VhcmNoIiwiVEVTVF9ST1VURSIsIkRVTU1ZX0JBU0UiLCJyZXNvbHZlZEJhc2UiLCJvcmlnaW4iLCJtYXRjaGVyT3B0aW9ucyIsInNlbnNpdGl2ZSIsImRlbGltaXRlciIsImN1c3RvbVJvdXRlTWF0Y2hlck9wdGlvbnMiLCJzdHJpY3QiLCJjdXN0b21Sb3V0ZSIsImtleXMiLCJtYXRjaGVyUmVnZXgiLCJwYXRoVG9SZWdleHAiLCJtYXRjaGVyIiwicGFyc2VkRGVzdGluYXRpb24iLCJwb3J0IiwiZGVzdFF1ZXJ5IiwiZGVzdFBhdGgiLCJkZXN0UGF0aFBhcmFtS2V5cyIsImRlc3RQYXRoUGFyYW1zIiwiZGVzdGluYXRpb25Db21waWxlciIsInZhbGlkYXRlIiwic3RyT3JBcnJheSIsInF1ZXJ5Q29tcGlsZXIiLCJwYXJhbUtleXMiLCJhcHBlbmRQYXJhbXNUb1F1ZXJ5Iiwic2hvdWxkQWRkQmFzZVBhdGgiLCJuZXdVcmwiLCJzZWFyY2hQYXJhbXMiLCJpc05hTiIsInN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0iLCJzZWFyY2hQYXJhbXNMaXN0IiwiY3VzdG9tUm91dGVNYXRjaGVyIiwicmV3cml0ZSIsImRlc3RSZXMiLCJyZSIsImRlY29kZSIsImRlY29kZVVSSUNvbXBvbmVudCIsInNsdWdOYW1lIiwiZyIsImdyb3VwcyIsIm0iLCJzdHIiLCJzZWdtZW50cyIsIm5vcm1hbGl6ZWRSb3V0ZSIsImdyb3VwSW5kZXgiLCJwYXJhbWV0ZXJpemVkUm91dGUiLCJwYXJzZVBhcmFtZXRlciIsInBvcyIsImVzY2FwZVJlZ2V4IiwidXNlZCIsImdldExvY2F0aW9uT3JpZ2luIiwiQXBwIiwiZ2V0RGlzcGxheU5hbWUiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwicGFnZVByb3BzIiwiaXNSZXNTZW50IiwidXJsT2JqZWN0S2V5cyIsIlNQIiwiRGVzcHJlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQSxTQUFTQSxRQUFULENBQWtCQyxLQUFsQixFQUF5QjtBQUFBLE1BQ2JDLEtBRGEsR0FDeURELEtBRHpELENBQ2JDLEtBRGE7QUFBQSxNQUNOQyxLQURNLEdBQ3lERixLQUR6RCxDQUNORSxLQURNO0FBQUEsTUFDQ0MsUUFERCxHQUN5REgsS0FEekQsQ0FDQ0csUUFERDtBQUFBLE1BQ1dDLFNBRFgsR0FDeURKLEtBRHpELENBQ1dJLFNBRFg7QUFBQSxNQUNzQkMsU0FEdEIsR0FDeURMLEtBRHpELENBQ3NCSyxTQUR0QjtBQUFBLE1BQ2lDQyxRQURqQyxHQUN5RE4sS0FEekQsQ0FDaUNNLFFBRGpDO0FBQUEsTUFDMkNDLFNBRDNDLEdBQ3lEUCxLQUR6RCxDQUMyQ08sU0FEM0M7QUFFckIsc0JBQ0k7QUFBUSxhQUFTLHdCQUFpQkQsUUFBUSxJQUFJLE1BQTdCLGNBQXVDQyxTQUF2QyxDQUFqQjtBQUFBLGVBQ0tOLEtBQUssaUJBQ0Y7QUFBSyxlQUFTLEVBQUMsbUJBQWY7QUFBQSw2QkFDSTtBQUFBLGtCQUFPQTtBQUFQO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFESjtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBRlIsRUFNS0MsS0FBSyxpQkFDRjtBQUFJLGVBQVMsRUFBQyxtQkFBZDtBQUFBLDZCQUNJO0FBQUEsa0JBQU9BO0FBQVA7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURKO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFQUixFQVdLRSxTQUFTLGlCQUNOO0FBQUEsOEJBQ0k7QUFBSyxpQkFBUyxFQUFDO0FBQWY7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQURKLGVBRUk7QUFBSyxpQkFBUyxFQUFDO0FBQWY7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUZKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQVpSLEVBaUJLQyxTQUFTLGlCQUNOO0FBQUEsNkJBQ0k7QUFBSyxpQkFBUyxFQUFDO0FBQWY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURKO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFsQlIsRUFzQktGLFFBQVEsaUJBQUk7QUFBQSxnQkFBSUE7QUFBSjtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBdEJqQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFESjtBQTBCSDs7S0E1QlFKLFE7QUE4Qk1BLHVFQUFmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUdBLFNBQVNTLEtBQVQsR0FBaUI7QUFBQTs7QUFDYixzQkFHSSxxRUFBQywrQ0FBRDtBQUFNLGFBQVMsOEJBQXVCQywrREFBUyxTQUFoQyxDQUFmO0FBQXdELHdCQUFvQixFQUFDLFFBQTdFO0FBQUEsNEJBQ0EscUVBQUMsa0RBQUQ7QUFBUyxlQUFTLDBCQUFtQkEsK0RBQVMsU0FBNUIsQ0FBbEI7QUFBQSxnQkFDS0EsK0RBQVMsQ0FBQ0MsR0FBVixDQUFjLFVBQUNDLFFBQUQsRUFBV0MsYUFBWDtBQUFBLDRCQUNYLHFFQUFDLDhDQUFEO0FBQUEsb0JBQTBCRCxRQUFRLENBQUNFO0FBQW5DLFdBQVVELGFBQVY7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFEVztBQUFBLE9BQWQ7QUFETDtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBREEsRUFNQ0gsK0RBQVMsQ0FBQ0MsR0FBVixDQUFjLFVBQUNDLFFBQUQsRUFBV0MsYUFBWDtBQUFBLDBCQUNYLHFFQUFDLG1EQUFEO0FBQUEsK0JBQ0kscUVBQUMscURBQUQ7QUFBSyxtQkFBUyxFQUFDLG1CQUFmO0FBQUEsb0JBQ0tELFFBQVEsQ0FBQ0csS0FBVCxDQUFlSixHQUFmLENBQW1CLFVBQUNLLElBQUQsRUFBT0MsS0FBUDtBQUFBLGdDQUNoQixxRUFBQyxxREFBRDtBQUFpQixnQkFBRSxFQUFFLENBQXJCO0FBQXdCLGdCQUFFLEVBQUUsQ0FBNUI7QUFBK0IsZ0JBQUUsRUFBRSxDQUFuQztBQUFzQyxnQkFBRSxFQUFFLENBQTFDO0FBQTZDLGdCQUFFLEVBQUUsQ0FBakQ7QUFBQSxxQ0FDSTtBQUFLLHlCQUFTLEVBQUMsZ0JBQWY7QUFBQSx1Q0FDSSxxRUFBQyxnREFBRDtBQUFNLHNCQUFJLDhCQUF1QkQsSUFBSSxDQUFDRSxJQUE1QixDQUFWO0FBQUEseUNBQ0k7QUFBSyw2QkFBUyxFQUFDLGdCQUFmO0FBQUEsNENBQ0k7QUFBSywrQkFBUyxFQUFDLHFCQUFmO0FBQXFDLDJCQUFLLEVBQUU7QUFBRUMsdUNBQWUsZ0JBQVNILElBQUksQ0FBQ0ksS0FBZDtBQUFqQjtBQUE1QztBQUFBO0FBQUE7QUFBQTtBQUFBLDZCQURKLGVBRUk7QUFBSywrQkFBUyxFQUFDLFNBQWY7QUFBQSw4Q0FDSTtBQUFBLGtDQUFPSixJQUFJLENBQUNiO0FBQVo7QUFBQTtBQUFBO0FBQUE7QUFBQSwrQkFESixlQUVJO0FBQUEsa0NBQUthLElBQUksQ0FBQ1o7QUFBVjtBQUFBO0FBQUE7QUFBQTtBQUFBLCtCQUZKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSw2QkFGSixlQU1JO0FBQUcsK0JBQVMsRUFBSVEsUUFBUSxTQUF4QjtBQUFBLGdDQUFpQ0ksSUFBSSxDQUFDYjtBQUF0QztBQUFBO0FBQUE7QUFBQTtBQUFBLDZCQU5KO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFESjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREosZUFBVWMsS0FBVjtBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQURnQjtBQUFBLFdBQW5CO0FBREw7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURKLFNBQWVKLGFBQWY7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQURXO0FBQUEsS0FBZCxDQU5EO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUhKO0FBa0NIOztLQW5DUUosSztBQXFDTUEsb0VBQWY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6Q0E7QUFBQSxrREFBTVksZUFBZSxHQUFHLENBRXBCO0FBQ0lQLE1BQUksRUFBRSxrQkFEVjtBQUVJLFdBQU8sa0JBRlg7QUFHSUMsT0FBSyxFQUFFLENBQUU7QUFDTFosU0FBSyxFQUFFLFlBREY7QUFFTGUsUUFBSSxFQUFFLFNBRkQ7QUFHTGQsWUFBUSxFQUFFLFFBSEw7QUFJTGdCLFNBQUssRUFBRSw4QkFKRjtBQUtMRSxhQUFTLEVBQUU7QUFMTixHQUFGLEVBT1A7QUFDSW5CLFNBQUssRUFBRSxpQkFEWDtBQUVJQyxZQUFRLEVBQUUsdUJBRmQ7QUFHSWMsUUFBSSxFQUFFLGNBSFY7QUFJSUUsU0FBSyxFQUFFLG1DQUpYO0FBS0lFLGFBQVMsRUFBRTtBQUxmLEdBUE8sRUFhTDtBQUNFbkIsU0FBSyxFQUFFLGNBRFQ7QUFFRUMsWUFBUSxFQUFFLGVBRlo7QUFHRWMsUUFBSSxFQUFFLEdBSFI7QUFJRUUsU0FBSyxFQUFFLDRCQUpUO0FBS0VFLGFBQVMsRUFBRTtBQUxiLEdBYkssRUFtQkw7QUFDRW5CLFNBQUssRUFBRSxXQURUO0FBRUVDLFlBQVEsRUFBRSxTQUZaO0FBR0VjLFFBQUksRUFBRSxHQUhSO0FBSUVFLFNBQUssRUFBRSxxOVlBSlQ7QUFLRUUsYUFBUyxFQUFFO0FBTGIsR0FuQkssRUF5Qko7QUFDQ25CLFNBQUssRUFBRSxjQURSO0FBRUNDLFlBQVEsRUFBRSxZQUZYO0FBR0NjLFFBQUksRUFBRSxHQUhQO0FBSUNFLFNBQUssRUFBRSwrRUFKUjtBQUtDRSxhQUFTLEVBQUU7QUFMWixHQXpCSSxFQStCSjtBQUNDbkIsU0FBSyxFQUFFLG9CQURSO0FBRUNDLFlBQVEsRUFBRSxhQUZYO0FBR0NjLFFBQUksRUFBRSxHQUhQO0FBSUNFLFNBQUssRUFBRSxxMldBSlI7QUFLQ0UsYUFBUyxFQUFFO0FBTFosR0EvQkksRUFxQ0w7QUFDRW5CLFNBQUssRUFBRSxnQkFEVDtBQUVFZSxRQUFJLEVBQUUsU0FGUjtBQUdFZCxZQUFRLEVBQUUsUUFIWjtBQUlFZ0IsU0FBSyxFQUFFLDhCQUpUO0FBS0VFLGFBQVMsRUFBRTtBQUxiLEdBckNLO0FBSFgsQ0FGb0IsRUF1RHBCO0FBQ0lSLE1BQUksRUFBRyxVQURYO0FBRUksV0FBTyxVQUZYO0FBR0lDLE9BQUssRUFBRSxDQUNIO0FBQ0laLFNBQUssRUFBRSxhQURYO0FBRUllLFFBQUksRUFBRSxTQUZWO0FBR0lkLFlBQVEsRUFBRSxlQUhkO0FBSUlnQixTQUFLLEVBQUUsOEJBSlg7QUFLSUUsYUFBUyxFQUFFO0FBTGYsR0FERyxFQVNIO0FBQ0luQixTQUFLLEVBQUUsWUFEWDtBQUVJZSxRQUFJLEVBQUUsU0FGVjtBQUdJZCxZQUFRLEVBQUUsUUFIZDtBQUlJZ0IsU0FBSyxFQUFFLDhCQUpYO0FBS0lFLGFBQVMsRUFBRTtBQUxmLEdBVEcsRUFnQkg7QUFDSW5CLFNBQUssRUFBRSxnQkFEWDtBQUVJZSxRQUFJLEVBQUUsU0FGVjtBQUdJZCxZQUFRLEVBQUUsUUFIZDtBQUlJZ0IsU0FBSyxFQUFFLDhCQUpYO0FBS0lFLGFBQVMsRUFBRTtBQUxmLEdBaEJHLEVBc0JHO0FBQ0ZuQixTQUFLLEVBQUUsY0FETDtBQUVGZSxRQUFJLEVBQUUsU0FGSjtBQUdGZCxZQUFRLEVBQUUsUUFIUjtBQUlGZ0IsU0FBSyxFQUFFLDhCQUpMO0FBS0ZFLGFBQVMsRUFBRTtBQUxULEdBdEJILEVBNEJEO0FBQ0VuQixTQUFLLEVBQUUsZUFEVDtBQUVFZSxRQUFJLEVBQUUsU0FGUjtBQUdFZCxZQUFRLEVBQUUsUUFIWjtBQUlFZ0IsU0FBSyxFQUFFLDhCQUpUO0FBS0VFLGFBQVMsRUFBRTtBQUxiLEdBNUJDO0FBSFgsQ0F2RG9CLEVBa0dwQjtBQUNJUixNQUFJLEVBQUUsYUFEVjtBQUVJLFdBQU8sYUFGWDtBQUlJQyxPQUFLLEVBQUUsQ0FDSDtBQUNJWixTQUFLLEVBQUUsWUFEWDtBQUVJQyxZQUFRLEVBQUUsd0JBRmQ7QUFHSWMsUUFBSSxFQUFFLGNBSFY7QUFJSUUsU0FBSyxFQUFFLG1DQUpYO0FBS0lFLGFBQVMsRUFBRTtBQUxmLEdBREcsRUFRSDtBQUNJbkIsU0FBSyxFQUFFLFFBRFg7QUFFSUMsWUFBUSxFQUFFLG9CQUZkO0FBR0ljLFFBQUksRUFBRSxjQUhWO0FBSUlFLFNBQUssRUFBRSxtQ0FKWDtBQUtJRSxhQUFTLEVBQUU7QUFMZixHQVJHLEVBZUg7QUFDSW5CLFNBQUssRUFBRSxhQURYO0FBRUlDLFlBQVEsRUFBRSxhQUZkO0FBR0ljLFFBQUksRUFBRSxjQUhWO0FBSUlFLFNBQUssRUFBRSxtQ0FKWDtBQUtJRSxhQUFTLEVBQUU7QUFMZixHQWZHLEVBcUJDO0FBQ0FuQixTQUFLLEVBQUUsWUFEUDtBQUVBQyxZQUFRLEVBQUUsb0JBRlY7QUFHQWMsUUFBSSxFQUFFLGNBSE47QUFJQUUsU0FBSyxFQUFFLG1DQUpQO0FBS0FFLGFBQVMsRUFBRTtBQUxYLEdBckJELEVBMkJDO0FBQ0FuQixTQUFLLEVBQUUsaUJBRFA7QUFFQUMsWUFBUSxFQUFFLHVCQUZWO0FBR0FjLFFBQUksRUFBRSxjQUhOO0FBSUFFLFNBQUssRUFBRSxtQ0FKUDtBQUtBRSxhQUFTLEVBQUU7QUFMWCxHQTNCRCxFQWlDQTtBQUNDbkIsU0FBSyxFQUFFLHlCQURSO0FBRUNDLFlBQVEsRUFBRSxPQUZYO0FBR0NjLFFBQUksRUFBRSxHQUhQO0FBSUNFLFNBQUssRUFBRSw2N2NBSlI7QUFLQ0UsYUFBUyxFQUFFO0FBTFosR0FqQ0E7QUFKWCxDQWxHb0IsRUFnSnBCO0FBQ0lSLE1BQUksRUFBRSxRQURWO0FBRUksV0FBTyxRQUZYO0FBR0lDLE9BQUssRUFBRSxDQUNIO0FBQ0laLFNBQUssRUFBRSxjQURYO0FBRUlDLFlBQVEsRUFBRSxlQUZkO0FBR0ljLFFBQUksRUFBRSxHQUhWO0FBSUlFLFNBQUssRUFBRSw0QkFKWDtBQUtJRSxhQUFTLEVBQUU7QUFMZixHQURHLEVBUUg7QUFDSW5CLFNBQUssRUFBRSxVQURYO0FBRUlDLFlBQVEsRUFBRSxLQUZkO0FBR0ljLFFBQUksRUFBRSxHQUhWO0FBSUlFLFNBQUssRUFBRSw0QkFKWDtBQUtJRSxhQUFTLEVBQUU7QUFMZixHQVJHLEVBZUg7QUFDSW5CLFNBQUssRUFBRSxTQURYO0FBRUlDLFlBQVEsRUFBRSxXQUZkO0FBR0ljLFFBQUksRUFBRSxHQUhWO0FBSUlFLFNBQUssRUFBRSw0QkFKWDtBQUtJRSxhQUFTLEVBQUU7QUFMZixHQWZHLEVBc0JIO0FBQ0luQixTQUFLLEVBQUUsU0FEWDtBQUVJQyxZQUFRLEVBQUUsV0FGZDtBQUdJYyxRQUFJLEVBQUUsR0FIVjtBQUlJRSxTQUFLLEVBQUUsNEJBSlg7QUFLSUUsYUFBUyxFQUFFO0FBTGYsR0F0QkcsRUE0QkE7QUFDQ25CLFNBQUssRUFBRSxRQURSO0FBRUNDLFlBQVEsRUFBRSxTQUZYO0FBR0NjLFFBQUksRUFBRSxHQUhQO0FBSUNFLFNBQUssRUFBRSw0QkFKUjtBQUtDRSxhQUFTLEVBQUU7QUFMWixHQTVCQTtBQUhYLENBaEpvQixFQTZMcEI7QUFDSVIsTUFBSSxFQUFFLFNBRFY7QUFFSSxXQUFPLFNBRlg7QUFHSUMsT0FBSyxFQUFFLENBQ0g7QUFDSVosU0FBSyxFQUFFLFlBRFg7QUFFSUMsWUFBUSxFQUFFLE1BRmQ7QUFHSWMsUUFBSSxFQUFFLEdBSFY7QUFJSUUsU0FBSyxFQUFFLDZCQUpYO0FBS0lFLGFBQVMsRUFBRTtBQUxmLEdBREcsRUFRSDtBQUNJbkIsU0FBSyxFQUFFLE1BRFg7QUFFSUMsWUFBUSxFQUFFLE1BRmQ7QUFHSWMsUUFBSSxFQUFFLEdBSFY7QUFJSUUsU0FBSyxFQUFFLDZCQUpYO0FBS0lFLGFBQVMsRUFBRTtBQUxmLEdBUkcsRUFjQTtBQUNDbkIsU0FBSyxFQUFFLE1BRFI7QUFFQ0MsWUFBUSxFQUFFLFlBRlg7QUFHQ2MsUUFBSSxFQUFFLEdBSFA7QUFJQ0UsU0FBSyxFQUFFLDZCQUpSO0FBS0NFLGFBQVMsRUFBRTtBQUxaLEdBZEEsRUFvQkE7QUFDQ25CLFNBQUssRUFBRSxZQURSO0FBRUNDLFlBQVEsRUFBRSxlQUZYO0FBR0NjLFFBQUksRUFBRSxHQUhQO0FBSUNFLFNBQUssRUFBRSw2QkFKUjtBQUtDRSxhQUFTLEVBQUU7QUFMWixHQXBCQSxFQTBCQTtBQUNDbkIsU0FBSyxFQUFFLGVBRFI7QUFFQ0MsWUFBUSxFQUFFLGdCQUZYO0FBR0NjLFFBQUksRUFBRSxHQUhQO0FBSUNFLFNBQUssRUFBRSw2QkFKUjtBQUtDRSxhQUFTLEVBQUU7QUFMWixHQTFCQTtBQUhYLENBN0xvQixFQXVPcEI7QUFDSVIsTUFBSSxFQUFFLFNBRFY7QUFFSSxXQUFPLFNBRlg7QUFHSUMsT0FBSyxFQUFFLENBQ0g7QUFDSVosU0FBSyxFQUFFLE9BRFg7QUFFSUMsWUFBUSxFQUFFLGNBRmQ7QUFHSWMsUUFBSSxFQUFFLEdBSFY7QUFJSUUsU0FBSyxFQUFFLGdDQUpYO0FBS0lFLGFBQVMsRUFBRTtBQUxmLEdBREcsRUFRSDtBQUNJbkIsU0FBSyxFQUFFLGlCQURYO0FBRUlDLFlBQVEsRUFBRSxTQUZkO0FBR0ljLFFBQUksRUFBRSxHQUhWO0FBSUlFLFNBQUssRUFBRSwyRkFKWDtBQUtJRSxhQUFTLEVBQUU7QUFMZixHQVJHLEVBY0Q7QUFDRW5CLFNBQUssRUFBRSxNQURUO0FBRUVDLFlBQVEsRUFBRSxtQkFGWjtBQUdFYyxRQUFJLEVBQUUsR0FIUjtBQUlFRSxTQUFLLEVBQUUsK0ZBSlQ7QUFLRUUsYUFBUyxFQUFFO0FBTGIsR0FkQyxFQW9CRDtBQUNFbkIsU0FBSyxFQUFFLFdBRFQ7QUFFRUMsWUFBUSxFQUFFLFNBRlo7QUFHRWMsUUFBSSxFQUFFLEdBSFI7QUFJRUUsU0FBSyxFQUFFLHE5WUFKVDtBQUtFRSxhQUFTLEVBQUU7QUFMYixHQXBCQyxFQTBCRDtBQUNFbkIsU0FBSyxFQUFFLFNBRFQ7QUFFRUMsWUFBUSxFQUFFLG1CQUZaO0FBR0VjLFFBQUksRUFBRSxHQUhSO0FBSUVFLFNBQUssRUFBRSw2SEFKVDtBQUtFRSxhQUFTLEVBQUU7QUFMYixHQTFCQztBQUhYLENBdk9vQixHQTZRcEI7QUFDSVIsTUFBSSxFQUFFLG9CQURWO0FBRUksV0FBTyxVQUZYO0FBR0lDLE9BQUssRUFBRSxDQUNIO0FBQ0laLFNBQUssRUFBRSxtQkFEWDtBQUVJQyxZQUFRLEVBQUUsMkJBRmQ7QUFHSWMsUUFBSSxFQUFFLEdBSFY7QUFJSUUsU0FBSyxFQUFFLDJGQUpYO0FBS0lFLGFBQVMsRUFBRTtBQUxmLEdBREc7QUFIWCxDQTdRb0IsRUFnU3BCO0FBQ0lSLE1BQUksRUFBRSxXQURWO0FBRUksV0FBTyxXQUZYO0FBR0lDLE9BQUssRUFBRSxDQUNIO0FBQ0laLFNBQUssRUFBRSxjQURYO0FBRUlDLFlBQVEsRUFBRSxZQUZkO0FBR0ljLFFBQUksRUFBRSxHQUhWO0FBSUlFLFNBQUssRUFBRSwrRUFKWDtBQUtJRSxhQUFTLEVBQUU7QUFMZixHQURHO0FBSFgsQ0FoU29CLEVBa1RwQjtBQUNJUixNQUFJLEVBQUUseUJBRFY7QUFFSSxXQUFPLFNBRlg7QUFHSUMsT0FBSyxFQUFFLENBQ0g7QUFDSVosU0FBSyxFQUFFLDRCQURYO0FBRUlDLFlBQVEsRUFBRSxPQUZkO0FBR0ljLFFBQUksRUFBRSxHQUhWO0FBSUlFLFNBQUssRUFBRSw2bllBSlg7QUFLSUUsYUFBUyxFQUFFO0FBTGYsR0FERyxFQVFIO0FBQ0luQixTQUFLLEVBQUUseUJBRFg7QUFFSUMsWUFBUSxFQUFFLE9BRmQ7QUFHSWMsUUFBSSxFQUFFLEdBSFY7QUFJSUUsU0FBSyxFQUFFLDY3Y0FKWDtBQUtJRSxhQUFTLEVBQUU7QUFMZixHQVJHLEVBZUg7QUFDSW5CLFNBQUssRUFBRSxvQkFEWDtBQUVJQyxZQUFRLEVBQUUsYUFGZDtBQUdJYyxRQUFJLEVBQUUsR0FIVjtBQUlJRSxTQUFLLEVBQUUscTJXQUpYO0FBS0lFLGFBQVMsRUFBRTtBQUxmLEdBZkc7QUFIWCxDQWxUb0IsQ0FBeEI7QUFnVmVELDhFQUFmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JWQTtDQUlBOztBQUNBO0FBQ0E7O0FBSUEsU0FBU0UsU0FBVCxHQUFxQjtBQUNqQixzQkFDSTtBQUFTLGFBQVMsRUFBQyw4RUFBbkI7QUFBQSw0QkFDSTtBQUFNLGVBQVMsRUFBQztBQUFoQjtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBREosZUFFSTtBQUFLLGVBQVMsRUFBQyxpQkFBZjtBQUFBLDZCQUNJLHFFQUFDLDJEQUFEO0FBQVcsaUJBQVMsRUFBQyxXQUFyQjtBQUFBLGdDQUNJLHFFQUFDLG1FQUFEO0FBQVUsZUFBSyxFQUFDLFdBQWhCO0FBQTRCLGVBQUssRUFBQyx5QkFBbEM7QUFBNEQsbUJBQVMsRUFBRSxJQUF2RTtBQUE2RSxrQkFBUSxFQUFDO0FBQXRGO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBREosZUFFSSxxRUFBQywrREFBRDtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUZKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURKO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFGSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFESjtBQVlIOztLQWJRQSxTO0FBZU1BLHdFQUFmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekJBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDdkNZLHNDQUFzQyxzQkFBc0I7QUFDekUseUM7Ozs7Ozs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxrREFBbUU7QUFDMUY7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTkE7O0FBRUE7O0FBUUE7O0FBdUJBO0FBQ0EsSUFBTUMsU0FBUyxHQUFHLElBQWxCLEdBQWtCLEVBQWxCO0FBQ0EsSUFBTUMsb0JBQW9CLEdBQ3hCLE9BQWdDQyxNQUFNLENBQXRDLHVCQURGO0FBRUEsSUFBTUMsVUFBMkMsR0FBakQ7O0FBRUEsdUJBQXlEO0FBQ3ZEO0FBQ0Esc0JBQW9CO0FBQ2xCO0FBR0YsR0FOdUQsQ0FNdkQ7OztBQUNBLE1BQUksQ0FBSixzQkFBMkI7QUFDekI7QUFHRjs7QUFBQSxTQUFRQyxjQUFjLEdBQUcseUJBQ3RCQyxpQkFBRCxFQUFhO0FBQ1hBLFdBQU8sQ0FBUEEsUUFBaUJDLGVBQUQsRUFBVztBQUN6QixVQUFJLENBQUNOLFNBQVMsQ0FBVEEsSUFBY00sS0FBSyxDQUF4QixNQUFLTixDQUFMLEVBQWtDO0FBQ2hDO0FBR0Y7O0FBQUEsVUFBTU8sRUFBRSxHQUFHUCxTQUFTLENBQVRBLElBQWNNLEtBQUssQ0FBOUIsTUFBV04sQ0FBWDs7QUFDQSxVQUFJTSxLQUFLLENBQUxBLGtCQUF3QkEsS0FBSyxDQUFMQSxvQkFBNUIsR0FBeUQ7QUFDdkRGLHNCQUFjLENBQWRBLFVBQXlCRSxLQUFLLENBQTlCRjtBQUNBSiw0QkFBaUJNLEtBQUssQ0FBdEJOO0FBQ0FPLFVBQUU7QUFFTDtBQVhERjtBQUZxQixLQWV2QjtBQUFFRyxjQUFVLEVBZmQ7QUFlRSxHQWZ1QixDQUF6QjtBQW1CRjs7QUFBQSxJQUFNQyxxQkFBcUIsR0FBRyxTQUF4QkEscUJBQXdCLFNBQWlDO0FBQzdELE1BQU1DLFFBQVEsR0FBR0MsV0FBakI7O0FBQ0EsTUFBSSxDQUFKLFVBQWU7QUFDYixXQUFPLFlBQU0sQ0FBYjtBQUdGRDs7QUFBQUEsVUFBUSxDQUFSQTtBQUNBVixXQUFTLENBQVRBO0FBQ0EsU0FBTyxZQUFNO0FBQ1gsUUFBSTtBQUNGVSxjQUFRLENBQVJBO0FBQ0EsS0FGRixDQUVFLFlBQVk7QUFDWkUsYUFBTyxDQUFQQTtBQUVGWjs7QUFBQUE7QUFORjtBQVJGOztBQWtCQSw2Q0FLUTtBQUNOLGFBQW1DO0FBQ25DLE1BQUksQ0FBQyx3QkFBTCxJQUFLLENBQUwsRUFBdUIsT0FGakIsQ0FHTjtBQUNBO0FBQ0E7QUFDQTs7QUFDQWEsUUFBTSxDQUFOQSxxQ0FBMENDLGFBQUQsRUFBUztBQUNoRCxjQUEyQztBQUN6QztBQUNBO0FBRUg7QUFMREQsS0FQTSxDQWFOOztBQUNBVixZQUFVLENBQUNZLElBQUksR0FBSkEsTUFBWFosRUFBVSxDQUFWQTtBQUdGOztBQUFBLGdDQUFrRDtBQUFBLE1BQzFDLE1BRDBDLEdBQzdCYSxLQUFLLENBQXhCLGFBRGdELENBQzFDLE1BRDBDO0FBRWhELFNBQ0dDLE1BQU0sSUFBSUEsTUFBTSxLQUFqQixPQUFDQSxJQUNERCxLQUFLLENBREwsT0FBQ0MsSUFFREQsS0FBSyxDQUZMLE9BQUNDLElBR0RELEtBQUssQ0FITCxRQUFDQyxJQUlERCxLQUFLLENBSkwsTUFBQ0MsSUFJZTtBQUNmRCxPQUFLLENBQUxBLGVBQXFCQSxLQUFLLENBQUxBLHNCQU54QjtBQVVGOztBQUFBLDRFQVNRO0FBQUEsTUFDQSxRQURBLEdBQ2VFLENBQUMsQ0FBdEIsYUFETSxDQUNBLFFBREE7O0FBR04sTUFBSUMsUUFBUSxLQUFSQSxRQUFxQkMsZUFBZSxDQUFmQSxDQUFlLENBQWZBLElBQXNCLENBQUMsd0JBQWhELElBQWdELENBQTVDRCxDQUFKLEVBQW1FO0FBQ2pFO0FBQ0E7QUFHRkQ7O0FBQUFBLEdBQUMsQ0FBREEsaUJBUk0sQ0FVTjs7QUFDQSxNQUFJRyxNQUFNLElBQVYsTUFBb0I7QUFDbEJBLFVBQU0sR0FBR0MsRUFBRSxDQUFGQSxlQUFURDtBQUdGLEdBZk0sQ0FlTjs7O0FBQ0FSLFFBQU0sQ0FBQ1UsT0FBTyxlQUFkVixNQUFNLENBQU5BLFdBQStDO0FBQUVXLFdBQUYsRUFBRUEsT0FBRjtBQUFXQyxVQUExRFosRUFBMERZO0FBQVgsR0FBL0NaLE9BQ0dhLGlCQUFELEVBQXNCO0FBQ3BCLFFBQUksQ0FBSixTQUFjOztBQUNkLGdCQUFZO0FBQ1Z4QixZQUFNLENBQU5BO0FBQ0F5QixjQUFRLENBQVJBO0FBRUg7QUFQSGQ7QUFXRjs7QUFBQSxxQkFBeUQ7QUFBQTs7QUFDdkQsWUFBMkM7QUFBQSxRQUN6QyxlQUR5QyxHQUN6QywrQkFJRztBQUNELGFBQU8sVUFDSixzQ0FBK0JlLElBQUksQ0FBQ0MsR0FBcEMseUJBQXVERCxJQUFJLENBQUNFLFFBQTVELG9DQUFpR0YsSUFBSSxDQUF0RyxNQUFDLG1CQUNFLDRFQUZMLFNBQ0csQ0FESSxDQUFQO0FBUUYsS0FkeUMsRUFjekM7OztBQUNBLFFBQU1HLGtCQUFtRCxHQUFHO0FBQzFEaEIsVUFBSSxFQUROO0FBQTRELEtBQTVEO0FBR0EsUUFBTWlCLGFBQWtDLEdBQUdDLE1BQU0sQ0FBTkEsS0FBM0Msa0JBQTJDQSxDQUEzQztBQUdBLGlCQUFhLENBQWIsUUFBdUJKLGFBQUQsRUFBNEI7QUFDaEQsVUFBSUEsR0FBRyxLQUFQLFFBQW9CO0FBQ2xCLFlBQ0VwRCxLQUFLLENBQUxBLEdBQUssQ0FBTEEsWUFDQyxPQUFPQSxLQUFLLENBQVosR0FBWSxDQUFaLGlCQUFrQyxPQUFPQSxLQUFLLENBQVosR0FBWSxDQUFaLEtBRnJDLFVBR0U7QUFDQSxnQkFBTXlELGVBQWUsQ0FBQztBQUNwQkwsZUFEb0IsRUFDcEJBLEdBRG9CO0FBRXBCQyxvQkFBUSxFQUZZO0FBR3BCSyxrQkFBTSxFQUFFMUQsS0FBSyxDQUFMQSxHQUFLLENBQUxBLHFCQUErQixPQUFPQSxLQUFLLENBSHJELEdBR3FEO0FBSC9CLFdBQUQsQ0FBckI7QUFNSDtBQVhELGFBV087QUFDTDtBQUNBO0FBQ0EsWUFBTTJELENBQVEsR0FBZDtBQUVIO0FBakJELE9BckJ5QyxDQXdDekM7O0FBQ0EsUUFBTUMsa0JBQW1ELEdBQUc7QUFDMURmLFFBQUUsRUFEd0Q7QUFFMURDLGFBQU8sRUFGbUQ7QUFHMURGLFlBQU0sRUFIb0Q7QUFJMURHLGFBQU8sRUFKbUQ7QUFLMURjLGNBQVEsRUFMa0Q7QUFNMURDLGNBQVEsRUFOa0Q7QUFPMURkLFlBQU0sRUFQUjtBQUE0RCxLQUE1RDtBQVNBLFFBQU1lLGFBQWtDLEdBQUdQLE1BQU0sQ0FBTkEsS0FBM0Msa0JBQTJDQSxDQUEzQztBQUdBLGlCQUFhLENBQWIsUUFBdUJKLGFBQUQsRUFBNEI7QUFDaEQsVUFBTVksT0FBTyxHQUFHLE9BQU9oRSxLQUFLLENBQTVCLEdBQTRCLENBQTVCOztBQUVBLFVBQUlvRCxHQUFHLEtBQVAsTUFBa0I7QUFDaEIsWUFBSXBELEtBQUssQ0FBTEEsR0FBSyxDQUFMQSxJQUFjZ0UsT0FBTyxLQUFyQmhFLFlBQXNDZ0UsT0FBTyxLQUFqRCxVQUFnRTtBQUM5RCxnQkFBTVAsZUFBZSxDQUFDO0FBQ3BCTCxlQURvQixFQUNwQkEsR0FEb0I7QUFFcEJDLG9CQUFRLEVBRlk7QUFHcEJLLGtCQUFNLEVBSFI7QUFBc0IsV0FBRCxDQUFyQjtBQU1IO0FBUkQsYUFRTyxJQUFJTixHQUFHLEtBQVAsVUFBc0I7QUFDM0IsWUFBSXBELEtBQUssQ0FBTEEsR0FBSyxDQUFMQSxJQUFjZ0UsT0FBTyxLQUF6QixVQUF3QztBQUN0QyxnQkFBTVAsZUFBZSxDQUFDO0FBQ3BCTCxlQURvQixFQUNwQkEsR0FEb0I7QUFFcEJDLG9CQUFRLEVBRlk7QUFHcEJLLGtCQUFNLEVBSFI7QUFBc0IsV0FBRCxDQUFyQjtBQU1IO0FBUk0sYUFRQSxJQUNMTixHQUFHLEtBQUhBLGFBQ0FBLEdBQUcsS0FESEEsWUFFQUEsR0FBRyxLQUZIQSxhQUdBQSxHQUFHLEtBSEhBLGNBSUFBLEdBQUcsS0FMRSxZQU1MO0FBQ0EsWUFBSXBELEtBQUssQ0FBTEEsR0FBSyxDQUFMQSxZQUFzQmdFLE9BQU8sS0FBakMsV0FBaUQ7QUFDL0MsZ0JBQU1QLGVBQWUsQ0FBQztBQUNwQkwsZUFEb0IsRUFDcEJBLEdBRG9CO0FBRXBCQyxvQkFBUSxFQUZZO0FBR3BCSyxrQkFBTSxFQUhSO0FBQXNCLFdBQUQsQ0FBckI7QUFNSDtBQWRNLGFBY0E7QUFDTDtBQUNBO0FBQ0EsWUFBTUMsQ0FBUSxHQUFkO0FBRUg7QUF0Q0QsT0FyRHlDLENBNkZ6QztBQUNBOztBQUNBLFFBQU1NLFNBQVMsR0FBR0MseUJBQWxCLEtBQWtCQSxDQUFsQjs7QUFDQSxRQUFJbEUsS0FBSyxDQUFMQSxZQUFrQixDQUFDaUUsU0FBUyxDQUFoQyxTQUEwQztBQUN4Q0EsZUFBUyxDQUFUQTtBQUNBOUIsYUFBTyxDQUFQQTtBQUlIO0FBQ0Q7O0FBQUEsTUFBTWdDLENBQUMsR0FBR25FLEtBQUssQ0FBTEEsYUFBVjs7QUF4R3VELDhCQTBHdkJrRSxrQkFBaEMsUUFBZ0NBLEVBMUd1QjtBQUFBO0FBQUEsTUEwR2pELFFBMUdpRDtBQUFBLE1BMEdqRCxXQTFHaUQ7O0FBNEd2RCxNQUFNOUIsTUFBTSxHQUFHLGFBQWYsU0FBZSxHQUFmO0FBQ0EsTUFBTWdDLFFBQVEsR0FBSWhDLE1BQU0sSUFBSUEsTUFBTSxDQUFqQixRQUFDQSxJQUFsQjs7QUE3R3VELDhCQStHbEM4QiwwQkFBYyxZQUFNO0FBQUEsZUFDSixtQ0FBc0JsRSxLQUFLLENBQTNCLE1BQW5DLElBQW1DLENBREk7QUFBQTtBQUFBLFFBQ2pDLFlBRGlDO0FBQUEsUUFDakMsVUFEaUM7O0FBRXZDLFdBQU87QUFDTHNDLFVBQUksRUFEQztBQUVMTyxRQUFFLEVBQUU3QyxLQUFLLENBQUxBLEtBQ0EsbUNBQXNCQSxLQUFLLENBRDNCQSxFQUNBLENBREFBLEdBRUFxRSxVQUFVLElBSmhCO0FBQU8sS0FBUDtBQUZtQkgsS0FRbEIsV0FBV2xFLEtBQUssQ0FBaEIsTUFBdUJBLEtBQUssQ0FSL0IsRUFRRyxDQVJrQmtFLENBL0drQztBQUFBLE1BK0dqRCxJQS9HaUQseUJBK0dqRCxJQS9HaUQ7QUFBQSxNQStHakQsRUEvR2lELHlCQStHakQsRUEvR2lEOztBQXlIdkQsOEJBQWdCLFlBQU07QUFDcEIsUUFDRUMsQ0FBQyxJQUFEQSxvQ0FHQUcsUUFBUSxDQUhSSCxXQUlBLHdCQUxGLElBS0UsQ0FMRixFQU1FO0FBQ0E7QUFDQSxVQUFNSSxZQUFZLEdBQUc3QyxVQUFVLENBQUNZLElBQUksR0FBSkEsTUFBaEMsRUFBK0IsQ0FBL0I7O0FBQ0EsVUFBSSxDQUFKLGNBQW1CO0FBQ2pCLGVBQU9OLHFCQUFxQixXQUFXLFlBQU07QUFDM0M4QixrQkFBUSxlQUFSQSxFQUFRLENBQVJBO0FBREYsU0FBNEIsQ0FBNUI7QUFJSDtBQUNGO0FBaEJELEtBZ0JHLHdCQWhCSCxNQWdCRyxDQWhCSDs7QUF6SHVELE1BMkluRCxRQTNJbUQsR0EySXZELEtBM0l1RCxDQTJJbkQsUUEzSW1EO0FBQUEsTUEySW5ELE9BM0ltRCxHQTJJdkQsS0EzSXVELENBMkluRCxPQTNJbUQ7QUFBQSxNQTJJbkQsT0EzSW1ELEdBMkl2RCxLQTNJdUQsQ0EySW5ELE9BM0ltRDtBQUFBLE1BMkluRCxNQTNJbUQsR0EySXZELEtBM0l1RCxDQTJJbkQsTUEzSW1EO0FBQUEsTUEySW5ELE1BM0ltRCxHQTJJdkQsS0EzSXVELENBMkluRCxNQTNJbUQsRUE0SXZEOztBQUNBLE1BQUksb0JBQUosVUFBa0M7QUFDaENVLFlBQVEsZ0JBQUcsMkNBQVhBLFFBQVcsQ0FBWEE7QUFHRixHQWpKdUQsQ0FpSnZEOzs7QUFDQSxNQUFNQyxLQUFVLEdBQUdDLHFCQUFuQixRQUFtQkEsQ0FBbkI7O0FBQ0EsTUFBTUMsVUFLTCxHQUFHO0FBQ0ZDLE9BQUcsRUFBR0MsZUFBRCxFQUFhO0FBQ2hCLGNBQVFDLFdBQVcsQ0FBWEEsRUFBVyxDQUFYQTs7QUFFUixVQUFJTCxLQUFLLElBQUksaUJBQVRBLFlBQXNDQSxLQUFLLENBQS9DLEtBQXFEO0FBQ25ELFlBQUksT0FBT0EsS0FBSyxDQUFaLFFBQUosWUFBcUNBLEtBQUssQ0FBTEEsSUFBckMsRUFBcUNBLEVBQXJDLEtBQ0ssSUFBSSxPQUFPQSxLQUFLLENBQVosUUFBSixVQUFtQztBQUN0Q0EsZUFBSyxDQUFMQTtBQUVIO0FBQ0Y7QUFWQztBQVdGTSxXQUFPLEVBQUd0QyxrQkFBRCxFQUF5QjtBQUNoQyxVQUFJZ0MsS0FBSyxDQUFMQSxTQUFlLE9BQU9BLEtBQUssQ0FBTEEsTUFBUCxZQUFuQixZQUE4RDtBQUM1REEsYUFBSyxDQUFMQTtBQUVGOztBQUFBLFVBQUksQ0FBQ2hDLENBQUMsQ0FBTixrQkFBeUI7QUFDdkJ1QyxtQkFBVyxnREFBWEEsTUFBVyxDQUFYQTtBQUVIO0FBdkJIO0FBS0ksR0FMSjs7QUEwQkEsU0FBTztBQUNMTCxjQUFVLENBQVZBLGVBQTJCbEMsV0FBRCxFQUF5QjtBQUNqRCxVQUFJLENBQUMsd0JBQUwsSUFBSyxDQUFMLEVBQXVCOztBQUN2QixVQUFJZ0MsS0FBSyxDQUFMQSxTQUFlLE9BQU9BLEtBQUssQ0FBTEEsTUFBUCxpQkFBbkIsWUFBbUU7QUFDakVBLGFBQUssQ0FBTEE7QUFFRlg7O0FBQUFBLGNBQVEsbUJBQW1CO0FBQUVtQixnQkFBUSxFQUFyQ25CO0FBQTJCLE9BQW5CLENBQVJBO0FBTEZhO0FBU0YsR0F2THVELENBdUx2RDtBQUNBOzs7QUFDQSxNQUFJM0UsS0FBSyxDQUFMQSxZQUFtQnlFLEtBQUssQ0FBTEEsZ0JBQXNCLEVBQUUsVUFBVUEsS0FBSyxDQUE5RCxLQUE2QyxDQUE3QyxFQUF3RTtBQUN0RUUsY0FBVSxDQUFWQSxPQUFrQix5QkFDaEIsMkJBRUUseUNBQXlDdkMsTUFBTSxJQUFJQSxNQUFNLENBRjNELFFBR0VBLE1BQU0sSUFBSUEsTUFBTSxDQUpwQnVDLGFBQ0UsQ0FEZ0IsQ0FBbEJBO0FBU0Y7O0FBQUEsc0JBQU9ULHNDQUFQLFVBQU9BLENBQVA7OztHQW5NRixJOztLQUFBLEk7ZUFzTWVnQixJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbldmOzs7O0FBR08sdUNBQXVEO0FBQzVELFNBQU9DLElBQUksQ0FBSkEsaUJBQXNCQSxJQUFJLEtBQTFCQSxNQUFxQ0EsSUFBSSxDQUFKQSxTQUFjLENBQW5EQSxDQUFxQ0EsQ0FBckNBLEdBQVA7QUFHRjtBQUFBOzs7Ozs7QUFJTyxJQUFNQywwQkFBMEIsR0FBR0MsU0FDckNGLFNBRHFDRSxHQUFuQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1ZQOztBQUNBOzs7OztBQUNBOztBQXNIQTs7O0FBekhBOztBQW1CQSxJQUFNQyxlQUFvQyxHQUFHO0FBQzNDbEQsUUFBTSxFQURxQztBQUM3QjtBQUNkbUQsZ0JBQWMsRUFGNkI7QUFHM0NDLE9BSDJDLGlCQUd0QyxFQUhzQyxFQUdyQjtBQUNwQixRQUFJLEtBQUosUUFBaUIsT0FBTzFELEVBQVA7O0FBQ2pCLGNBQW1DO0FBQ2pDO0FBRUg7QUFSSDtBQUE2QyxDQUE3QyxDLENBV0E7O0FBQ0EsSUFBTTJELGlCQUFpQixHQUFHLHNHQUExQixlQUEwQixDQUExQjtBQVlBLElBQU1DLFlBQVksR0FBRywwR0FBckIsb0JBQXFCLENBQXJCO0FBUUEsSUFBTUMsZ0JBQWdCLEdBQUcsa0RBQXpCLGdCQUF5QixDQUF6QixDLENBU0E7O0FBQ0FuQyxNQUFNLENBQU5BLDBDQUFpRDtBQUMvQ29DLEtBRCtDLGlCQUN6QztBQUNKLFdBQU9DLG9CQUFQO0FBRkpyQztBQUFpRCxDQUFqREE7QUFNQWlDLGlCQUFpQixDQUFqQkEsUUFBMkJLLGVBQUQsRUFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBdEMsUUFBTSxDQUFOQSx1Q0FBOEM7QUFDNUNvQyxPQUQ0QyxpQkFDdEM7QUFDSixVQUFNeEQsTUFBTSxHQUFHMkQsU0FBZjtBQUNBLGFBQU8zRCxNQUFNLENBQWIsS0FBYSxDQUFiO0FBSEpvQjtBQUE4QyxHQUE5Q0E7QUFMRmlDO0FBYUEsZ0JBQWdCLENBQWhCLFFBQTBCSyxlQUFELEVBQVc7QUFDbEM7QUFDQTs7QUFBRVIsaUJBQUQsT0FBQ0EsR0FBaUMsWUFBb0I7QUFDckQsUUFBTWxELE1BQU0sR0FBRzJELFNBQWY7QUFDQSxXQUFPM0QsTUFBTSxDQUFiLEtBQWEsQ0FBTkEsYUFBTSxZQUFiO0FBRkQsR0FBQ2tEO0FBRko7QUFRQUksWUFBWSxDQUFaQSxRQUFzQm5ELGVBQUQsRUFBVztBQUM5QitDLGlCQUFlLENBQWZBLE1BQXNCLFlBQU07QUFDMUJPLHlDQUF3QixZQUFhO0FBQ25DLFVBQU1HLFVBQVUsZUFBUXpELEtBQUssQ0FBTEEsdUJBQVIsU0FBd0NBLEtBQUssQ0FBTEEsVUFBeEQsQ0FBd0RBLENBQXhDLENBQWhCO0FBR0EsVUFBTTBELGdCQUFnQixHQUF0Qjs7QUFDQSxVQUFJQSxnQkFBZ0IsQ0FBcEIsVUFBb0IsQ0FBcEIsRUFBa0M7QUFDaEMsWUFBSTtBQUNGQSwwQkFBZ0IsQ0FBaEJBLFVBQWdCLENBQWhCQSx1QkFBZ0IsWUFBaEJBO0FBQ0EsU0FGRixDQUVFLFlBQVk7QUFDWjlELGlCQUFPLENBQVBBO0FBQ0FBLGlCQUFPLENBQVBBLGdCQUFpQkUsR0FBRyxDQUFDNkQsT0FBckIvRCxlQUFpQ0UsR0FBRyxDQUFwQ0Y7QUFFSDtBQUNGO0FBYkQwRDtBQURGUDtBQURGSTs7QUFtQkEscUJBQTZCO0FBQzNCLE1BQUksQ0FBQ0osZUFBZSxDQUFwQixRQUE2QjtBQUMzQixRQUFNWSxPQUFPLEdBQ1gsZ0NBREY7QUFHQSxVQUFNLFVBQU4sT0FBTSxDQUFOO0FBRUY7O0FBQUEsU0FBT1osZUFBZSxDQUF0QjtBQUdGLEMsQ0FBQTs7O2VBQ2VBLGUsRUFFZjs7OztBQUdPLHFCQUFpQztBQUFBOztBQUN0QyxTQUFPcEIsNkJBQWlCaUMsZUFBeEIsYUFBT2pDLENBQVA7QUFHRixDLENBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7R0FWTyxTOztBQVdBLElBQU1rQyxZQUFZLEdBQUcsU0FBZkEsWUFBZSxHQUFpQztBQUFBLG9DQUFqQyxJQUFpQztBQUFqQyxRQUFpQztBQUFBOztBQUMzRGQsaUJBQWUsQ0FBZkEsb0JBQTZCTyxRQUFKLFdBQXpCUDtBQUNBQSxpQkFBZSxDQUFmQSx1QkFBd0N4RCxZQUFEO0FBQUEsV0FBUUEsRUFBL0N3RCxFQUF1QztBQUFBLEdBQXZDQTtBQUNBQSxpQkFBZSxDQUFmQTtBQUVBLFNBQU9BLGVBQWUsQ0FBdEI7QUFMSyxFLENBUVA7Ozs7O0FBQ08sMENBQThEO0FBQ25FLE1BQU1lLE9BQU8sR0FBYjtBQUNBLE1BQU1DLFFBQVEsR0FBZDs7QUFGbUUsNkNBSW5FLGlCQUptRTtBQUFBOztBQUFBO0FBSW5FLHdEQUEwQztBQUFBLFVBQTFDLFFBQTBDOztBQUN4QyxVQUFJLE9BQU9ELE9BQU8sQ0FBZCxRQUFjLENBQWQsS0FBSixVQUEyQztBQUN6Q0MsZ0JBQVEsQ0FBUkEsUUFBUSxDQUFSQSxHQUFxQjlDLE1BQU0sQ0FBTkEsT0FDbkIrQyxLQUFLLENBQUxBLFFBQWNGLE9BQU8sQ0FBckJFLFFBQXFCLENBQXJCQSxTQURtQi9DLElBRW5CNkMsT0FBTyxDQUZUQyxRQUVTLENBRlk5QyxDQUFyQjhDLENBRHlDLENBSXZDOztBQUNGO0FBR0ZBOztBQUFBQSxjQUFRLENBQVJBLFFBQVEsQ0FBUkEsR0FBcUJELE9BQU8sQ0FBNUJDLFFBQTRCLENBQTVCQTtBQUdGLEtBaEJtRSxDQWdCbkU7O0FBaEJtRTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQWlCbkVBLFVBQVEsQ0FBUkEsU0FBa0JULG9CQUFsQlM7QUFFQVgsa0JBQWdCLENBQWhCQSxRQUEwQkcsZUFBRCxFQUFXO0FBQ2xDUSxZQUFRLENBQVJBLEtBQVEsQ0FBUkEsR0FBa0IsWUFBb0I7QUFDcEMsYUFBT0QsT0FBTyxDQUFkLEtBQWMsQ0FBUEEsY0FBTyxZQUFkO0FBREZDO0FBREZYO0FBTUE7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pLRDs7QUFFQTs7QUFXZSx1Q0FLK0I7QUFDNUMsb0NBQXVDO0FBQ3JDLHdCQUFPO0FBQW1CLFlBQU0sRUFBRSxZQUEzQixTQUEyQjtBQUEzQixPQUFQLEtBQU8sRUFBUDtBQUdGOztBQUFBLG1CQUFpQixDQUFqQixrQkFBb0NhLGlCQUFpQixDQUFDQyxlQUF0RCxDQUNBO0FBREE7QUFFRUMsbUJBQUQsb0JBQUNBLEdBQWlERixpQkFBRCxDQUFqRCxtQkFBQ0U7O0FBQ0YsWUFBMkM7QUFDekMsUUFBTTdGLElBQUksR0FDUjJGLGlCQUFpQixDQUFqQkEsZUFBaUNBLGlCQUFpQixDQUFsREEsUUFERjtBQUVBRSxxQkFBaUIsQ0FBakJBO0FBR0Y7O0FBQUE7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakNZO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhDQUE4QztBQUN2RTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQW9EO0FBQzdFO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIseUJBQXlCLDBDQUEwQztBQUNuRTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHlCQUF5QiwyQ0FBMkM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzQ0FBc0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQTRDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBMEM7QUFDL0Q7QUFDQSxpQkFBaUIsbUNBQW1DO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0Esb0VBQW9FLFVBQVUsRUFBRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQyxvRUFBb0UsVUFBVSxFQUFFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlEQUFpRCxFQUFFO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDLHdPQUF3TyxVQUFVLEVBQUU7QUFDcFA7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsc0JBQXNCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkRBQTZEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7Ozs7Ozs7Ozs7O0FDclpBOzs7Ozs7O0FBWUE7QUFDQTtBQUNBOztBQVVlLGdCQUE2QjtBQUMxQyxNQUFNQyxHQUErQixHQUFHbkQsTUFBTSxDQUFOQSxPQUF4QyxJQUF3Q0EsQ0FBeEM7QUFFQSxTQUFPO0FBQ0xvRCxNQURLLGNBQ0gsSUFERyxFQUNILE9BREcsRUFDOEI7QUFDakM7QUFBQyxPQUFDRCxHQUFHLENBQUhBLElBQUcsQ0FBSEEsS0FBY0EsR0FBRyxDQUFIQSxJQUFHLENBQUhBLEdBQWYsRUFBQ0EsQ0FBRDtBQUZFO0FBS0xFLE9BTEssZUFLRixJQUxFLEVBS0YsT0FMRSxFQUsrQjtBQUNsQyxVQUFJRixHQUFHLENBQVAsSUFBTyxDQUFQLEVBQWU7QUFDYkEsV0FBRyxDQUFIQSxJQUFHLENBQUhBLFFBQWlCQSxHQUFHLENBQUhBLElBQUcsQ0FBSEEsc0JBQWpCQTtBQUVIO0FBVEk7QUFXTEcsUUFYSyxnQkFXRCxJQVhDLEVBVzhCO0FBQUEsd0NBQS9CLElBQStCO0FBQS9CLFlBQStCO0FBQUE7O0FBQ2pDO0FBQ0E7QUFBQyxPQUFDSCxHQUFHLENBQUhBLElBQUcsQ0FBSEEsSUFBRCxnQkFBK0JJLGlCQUFELEVBQXNCO0FBQ25EQSxlQUFPLE1BQVBBO0FBREQ7QUFiTDtBQUFPLEdBQVA7QUFrQkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0NEOzs7Ozs7QUFHTzs7QUFBQSxJQUFNWixhQUFhLGdCQUFHakMsZ0NBQXRCLElBQXNCQSxDQUF0Qjs7OztBQUVQLFVBQTJDO0FBQ3pDaUMsZUFBYSxDQUFiQTtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGRDs7QUFLQTs7QUFDQTs7QUFDQTs7QUFTQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBM0JBO0FBQUE7QUFDQTs7O0FBeUNBLElBQU1hLFFBQVEsR0FBSTNCLFVBQWxCOztBQUVBLGtDQUFrQztBQUNoQyxTQUFPN0IsTUFBTSxDQUFOQSxPQUFjLFVBQWRBLGlCQUFjLENBQWRBLEVBQTRDO0FBQ2pEeUQsYUFBUyxFQURYO0FBQW1ELEdBQTVDekQsQ0FBUDtBQUtGOztBQUFBLHFDQUFzRDtBQUNwRCxTQUFPMEQsTUFBTSxJQUFJL0IsSUFBSSxDQUFKQSxXQUFWK0IsR0FBVS9CLENBQVYrQixHQUNIL0IsSUFBSSxLQUFKQSxNQUNFLHdEQURGQSxNQUNFLENBREZBLGFBRUsrQixNQUZML0IsU0FERytCLElBQ0gvQixDQURHK0IsR0FBUDtBQU9LOztBQUFBLGdEQUlMO0FBQ0EsTUFBSTdCLEtBQUosRUFBcUMsRUFLckM7O0FBQUE7QUFHSzs7QUFBQSxpQ0FBa0Q7QUFDdkQsTUFBSUEsS0FBSixFQUFxQyxFQUtyQzs7QUFBQTtBQUdLOztBQUFBLDJCQUE0QztBQUNqRCxTQUFPRixJQUFJLEtBQUpBLFlBQXFCQSxJQUFJLENBQUpBLFdBQWdCNkIsUUFBUSxHQUFwRCxHQUE0QjdCLENBQTVCO0FBR0s7O0FBQUEsMkJBQTJDO0FBQ2hEO0FBQ0EsU0FBT2dDLGFBQWEsT0FBcEIsUUFBb0IsQ0FBcEI7QUFHSzs7QUFBQSwyQkFBMkM7QUFDaEQsU0FBT2hDLElBQUksQ0FBSkEsTUFBVzZCLFFBQVEsQ0FBbkI3QixXQUFQO0FBR0Y7QUFBQTs7Ozs7QUFHTyx5QkFBMEM7QUFDL0MsTUFBSWlDLEdBQUcsQ0FBSEEsV0FBSixHQUFJQSxDQUFKLEVBQXlCOztBQUN6QixNQUFJO0FBQ0Y7QUFDQSxRQUFNQyxjQUFjLEdBQUcsV0FBdkIsaUJBQXVCLEdBQXZCO0FBQ0EsUUFBTUMsUUFBUSxHQUFHLGFBQWpCLGNBQWlCLENBQWpCO0FBQ0EsV0FBT0EsUUFBUSxDQUFSQSw2QkFBc0NDLFdBQVcsQ0FBQ0QsUUFBUSxDQUFqRSxRQUF3RCxDQUF4RDtBQUNBLEdBTEYsQ0FLRSxVQUFVO0FBQ1Y7QUFFSDtBQUlNOztBQUFBLGlEQUlMO0FBQ0EsTUFBSUUsaUJBQWlCLEdBQXJCO0FBRUEsTUFBTUMsWUFBWSxHQUFHLCtCQUFyQixLQUFxQixDQUFyQjtBQUNBLE1BQU1DLGFBQWEsR0FBR0QsWUFBWSxDQUFsQztBQUNBLE1BQU1FLGNBQWMsR0FDbEI7QUFDQSxHQUFDQyxVQUFVLEtBQVZBLFFBQXVCLGlEQUF2QkEsVUFBdUIsQ0FBdkJBLEdBQUQsT0FDQTtBQUNBO0FBSkY7QUFPQUosbUJBQWlCLEdBQWpCQTtBQUNBLE1BQU1LLE1BQU0sR0FBR3JFLE1BQU0sQ0FBTkEsS0FBZixhQUFlQSxDQUFmOztBQUVBLE1BQ0UsQ0FBQ3FFLE1BQU0sQ0FBTkEsTUFBY0MsZUFBRCxFQUFXO0FBQ3ZCLFFBQUlDLEtBQUssR0FBR0osY0FBYyxDQUFkQSxLQUFjLENBQWRBLElBQVo7QUFEdUIsK0JBRU1ELGFBQWEsQ0FBMUMsS0FBMEMsQ0FGbkI7QUFBQSxRQUVqQixNQUZpQix3QkFFakIsTUFGaUI7QUFBQSxRQUVqQixRQUZpQix3QkFFakIsUUFGaUIsRUFJdkI7QUFDQTs7QUFDQSxRQUFJTSxRQUFRLGNBQU9DLE1BQU0sV0FBVyxFQUF4QixTQUFaLEtBQVksTUFBWjs7QUFDQSxrQkFBYztBQUNaRCxjQUFRLGFBQU0sZUFBZSxFQUFyQixjQUFSQSxRQUFRLE1BQVJBO0FBRUY7O0FBQUEsUUFBSUMsTUFBTSxJQUFJLENBQUMxQixLQUFLLENBQUxBLFFBQWYsS0FBZUEsQ0FBZixFQUFxQ3dCLEtBQUssR0FBRyxDQUFSQSxLQUFRLENBQVJBO0FBRXJDLFdBQ0UsQ0FBQ0csUUFBUSxJQUFJSixLQUFLLElBQWxCLHFCQUNBO0FBQ0NOLHFCQUFpQixHQUNoQkEsaUJBQWlCLENBQWpCQSxrQkFFRVMsTUFBTSxHQUNERixLQUFELElBQUNBLENBQXVCSSxxQkFBeEIsV0FBQ0osRUFBRCxJQUFDQSxDQURDLEdBQ0RBLENBREMsR0FFRixzQ0FKTlAsS0FJTSxDQUpOQSxLQUpKLEdBQ0UsQ0FERjtBQWJKLEdBQ0dLLENBREgsRUF5QkU7QUFDQUwscUJBQWlCLEdBQWpCQSxHQURBLENBQ3VCO0FBRXZCO0FBQ0E7QUFFRjs7QUFBQSxTQUFPO0FBQ0xLLFVBREssRUFDTEEsTUFESztBQUVMTyxVQUFNLEVBRlI7QUFBTyxHQUFQO0FBTUY7O0FBQUEsMkNBQXFFO0FBQ25FLE1BQU1DLGFBQTZCLEdBQW5DO0FBRUE3RSxRQUFNLENBQU5BLG9CQUE0QkosYUFBRCxFQUFTO0FBQ2xDLFFBQUksQ0FBQ3lFLE1BQU0sQ0FBTkEsU0FBTCxHQUFLQSxDQUFMLEVBQTJCO0FBQ3pCUSxtQkFBYSxDQUFiQSxHQUFhLENBQWJBLEdBQXFCQyxLQUFLLENBQTFCRCxHQUEwQixDQUExQkE7QUFFSDtBQUpEN0U7QUFLQTtBQUdGO0FBQUE7Ozs7OztBQUlPLG1EQUlHO0FBQ1I7QUFDQSxNQUFNK0UsSUFBSSxHQUFHLHFCQUFiLFVBQWEsQ0FBYjtBQUNBLE1BQU1DLFdBQVcsR0FDZixrQ0FBa0MsaUNBRHBDLElBQ29DLENBRHBDOztBQUVBLE1BQUk7QUFDRixRQUFNQyxRQUFRLEdBQUcscUJBQWpCLElBQWlCLENBQWpCO0FBQ0FBLFlBQVEsQ0FBUkEsV0FBb0Isd0RBQTJCQSxRQUFRLENBQXZEQSxRQUFvQixDQUFwQkE7QUFDQSxRQUFJQyxjQUFjLEdBQWxCOztBQUVBLFFBQ0UsK0JBQWVELFFBQVEsQ0FBdkIsYUFDQUEsUUFBUSxDQURSLGdCQURGLFdBSUU7QUFDQSxVQUFNSCxLQUFLLEdBQUcseUNBQXVCRyxRQUFRLENBQTdDLFlBQWMsQ0FBZDs7QUFEQSwyQkFHMkJFLGFBQWEsQ0FDdENGLFFBQVEsQ0FEOEIsVUFFdENBLFFBQVEsQ0FGOEIsVUFBeEMsS0FBd0MsQ0FIeEM7QUFBQSxVQUdNLE1BSE4sa0JBR00sTUFITjtBQUFBLFVBR00sTUFITixrQkFHTSxNQUhOOztBQVNBLGtCQUFZO0FBQ1ZDLHNCQUFjLEdBQUcsaUNBQXFCO0FBQ3BDdEUsa0JBQVEsRUFENEI7QUFFcEN3RSxjQUFJLEVBQUVILFFBQVEsQ0FGc0I7QUFHcENILGVBQUssRUFBRU8sa0JBQWtCLFFBSDNCSCxNQUcyQjtBQUhXLFNBQXJCLENBQWpCQTtBQU1IO0FBRUQsS0EzQkUsQ0EyQkY7OztBQUNBLFFBQU1JLFlBQVksR0FDaEJMLFFBQVEsQ0FBUkEsV0FBb0JGLElBQUksQ0FBeEJFLFNBQ0lBLFFBQVEsQ0FBUkEsV0FBb0JBLFFBQVEsQ0FBUkEsT0FEeEJBLE1BQ0lBLENBREpBLEdBRUlBLFFBQVEsQ0FIZDtBQUtBLFdBQVFNLFNBQVMsR0FDYixlQUFlTCxjQUFjLElBRGhCLFlBQ2IsQ0FEYSxHQUFqQjtBQUdBLEdBcENGLENBb0NFLFVBQVU7QUFDVixXQUFRSyxTQUFTLEdBQUcsQ0FBSCxXQUFHLENBQUgsR0FBakI7QUFFSDtBQUVEOztBQUFBLElBQU1DLGVBQWUsR0FBR0MsTUFBTSxDQUE5QixpQkFBOEIsQ0FBOUI7O0FBQ08sK0JBQTZDO0FBQ2xELFNBQU96RixNQUFNLENBQU5BLHFDQUFQLEVBQU9BLENBQVA7QUFHRjs7QUFBQSx1Q0FBNkQ7QUFDM0Q7QUFDQTtBQUNBLFNBQU87QUFDTDRELE9BQUcsRUFBRThCLFdBQVcsQ0FBQ0MsV0FBVyxDQUFDL0csTUFBTSxDQUFQLFVBRHZCLEdBQ3VCLENBQVosQ0FEWDtBQUVMUyxNQUFFLEVBQUVBLEVBQUUsR0FBR3FHLFdBQVcsQ0FBQ0MsV0FBVyxDQUFDL0csTUFBTSxDQUFQLFVBQTFCLEVBQTBCLENBQVosQ0FBZCxHQUZSO0FBQU8sR0FBUDtBQXlERjs7QUFBQSxJQUFNZ0gsdUJBQXVCLEdBQzNCL0QsVUFFQSxLQUhGO0FBS0EsSUFBTWdFLHdCQUF3QixHQUE5Qjs7QUFFQSxtQ0FBaUU7QUFDL0QsU0FBTyxLQUFLLE1BQU07QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBQyxlQUFXLEVBWk47QUFBVyxHQUFOLENBQUwsTUFhRUMsYUFBRCxFQUFTO0FBQ2YsUUFBSSxDQUFDQSxHQUFHLENBQVIsSUFBYTtBQUNYLFVBQUlDLFFBQVEsR0FBUkEsS0FBZ0JELEdBQUcsQ0FBSEEsVUFBcEIsS0FBdUM7QUFDckMsZUFBT0UsVUFBVSxNQUFNRCxRQUFRLEdBQS9CLENBQWlCLENBQWpCO0FBRUY7O0FBQUEsVUFBSUQsR0FBRyxDQUFIQSxXQUFKLEtBQXdCO0FBQ3RCO0FBQ0E7QUFDQSxjQUFNLFVBQU4sd0JBQU0sQ0FBTjtBQUVGOztBQUFBLFlBQU0sSUFBTixLQUFNLCtCQUFOO0FBRUY7O0FBQUEsV0FBT0EsR0FBRyxDQUFWLElBQU9BLEVBQVA7QUF6QkYsR0FBTyxDQUFQO0FBNkJGOztBQUFBLGlEQUFrRTtBQUNoRSxTQUFPLFVBQVUsV0FBV0csY0FBYyxPQUFuQyxDQUFVLENBQVYsVUFBb0RySCxhQUFELEVBQWdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUVBLFFBQUksQ0FBSixnQkFBcUI7QUFDbkJzSCxzQkFBZ0IsQ0FBaEJBLEdBQWdCLENBQWhCQTtBQUVGOztBQUFBO0FBUkYsR0FBTyxDQUFQO0FBWWE7O0lBQU05RCxNO0FBT25COztBQVBnRDtBQVdoRDtBQWtCQStELGtCQUFXLFNBQVhBLEVBQVcsTUFBWEEsRUFBVyxHQUFYQSxRQStCRTtBQUFBOztBQUFBLFFBM0JBLFlBMkJBLFFBM0JBLFlBMkJBO0FBQUEsUUEzQkEsVUEyQkEsUUEzQkEsVUEyQkE7QUFBQSxRQTNCQSxHQTJCQSxRQTNCQSxHQTJCQTtBQUFBLFFBM0JBLE9BMkJBLFFBM0JBLE9BMkJBO0FBQUEsUUEzQkEsU0EyQkEsUUEzQkEsU0EyQkE7QUFBQSxRQTNCQSxrQkEyQkEsUUEzQkEsa0JBMkJBO0FBQUEsUUEzQkEsR0EyQkEsUUEzQkEsR0EyQkE7QUFBQSxRQTNCQSxZQTJCQSxRQTNCQSxZQTJCQTtBQUFBLFFBM0JBLFVBMkJBLFFBM0JBLFVBMkJBO0FBQUEsUUEzQkEsTUEyQkEsUUEzQkEsTUEyQkE7QUFBQSxRQTNCQSxPQTJCQSxRQTNCQSxPQTJCQTtBQUFBLFFBL0JTLGFBK0JULFFBL0JTLGFBK0JUOztBQUFBOztBQUFBLFNBM0RGQyxLQTJERTtBQUFBLFNBMURGekYsUUEwREU7QUFBQSxTQXpERmtFLEtBeURFO0FBQUEsU0F4REZ3QixNQXdERTtBQUFBLFNBdkRGOUMsUUF1REU7QUFBQSxTQWxERitDLFVBa0RFO0FBQUEsU0FoREZDLEdBZ0RFLEdBaERrQyxFQWdEbEM7QUFBQSxTQS9DRkMsR0ErQ0U7QUFBQSxTQTlDRkMsR0E4Q0U7QUFBQSxTQTdDRkMsVUE2Q0U7QUFBQSxTQTVDRkMsSUE0Q0U7QUFBQSxTQTNDRkMsTUEyQ0U7QUFBQSxTQTFDRkMsUUEwQ0U7QUFBQSxTQXpDRkMsS0F5Q0U7QUFBQSxTQXhDRkMsVUF3Q0U7QUFBQSxTQXZDRkMsY0F1Q0U7QUFBQSxTQXRDRkMsUUFzQ0U7QUFBQSxTQXJDRjFILE1BcUNFO0FBQUEsU0FwQ0YySCxPQW9DRTtBQUFBLFNBbkNGQyxhQW1DRTs7QUFBQSxzQkFxR1luSSxXQUFELEVBQTRCO0FBQ3ZDLFVBQU1vSSxLQUFLLEdBQUdwSSxDQUFDLENBQWY7O0FBRUEsVUFBSSxDQUFKLE9BQVk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUVSxZQVVKLFVBVkksR0FVVixLQVZVLENBVUosUUFWSTtBQUFBLFlBVUosS0FWSSxHQVVWLEtBVlUsQ0FVSixLQVZJOztBQVdWLDBDQUVFLGlDQUFxQjtBQUFFMkIsa0JBQVEsRUFBRThFLFdBQVcsQ0FBdkIsVUFBdUIsQ0FBdkI7QUFBbUNaLGVBRjFELEVBRTBEQTtBQUFuQyxTQUFyQixDQUZGLEVBR0UsV0FIRixNQUdFLEdBSEY7O0FBS0E7QUFHRjs7QUFBQSxVQUFJLENBQUN1QyxLQUFLLENBQVYsS0FBZ0I7QUFDZDtBQUdGOztBQTFCdUMsVUEwQmpDLEdBMUJpQyxHQTBCdkMsS0ExQnVDLENBMEJqQyxHQTFCaUM7QUFBQSxVQTBCakMsRUExQmlDLEdBMEJ2QyxLQTFCdUMsQ0EwQmpDLEVBMUJpQztBQUFBLFVBMEJqQyxPQTFCaUMsR0EwQnZDLEtBMUJ1QyxDQTBCakMsT0ExQmlDOztBQUFBLGtCQTRCbEIsd0NBQXJCLEdBQXFCLENBNUJrQjtBQUFBLFVBNEJqQyxRQTVCaUMsU0E0QmpDLFFBNUJpQyxFQThCdkM7QUFDQTs7O0FBQ0EsVUFBSSxlQUFjaEksRUFBRSxLQUFLLE1BQXJCLFVBQW9DdUIsUUFBUSxLQUFLLE1BQXJELFVBQW9FO0FBQ2xFO0FBR0YsT0FwQ3VDLENBb0N2QztBQUNBOzs7QUFDQSxVQUFJLGNBQWEsQ0FBQyxXQUFsQixLQUFrQixDQUFsQixFQUFvQztBQUNsQztBQUdGOztBQUFBLDRDQUlFWixNQUFNLENBQU5BLG9CQUEyQjtBQUN6QlQsZUFBTyxFQUFFK0gsT0FBTyxDQUFQQSxXQUFtQixNQURIO0FBRXpCOUgsY0FBTSxFQUFFOEgsT0FBTyxDQUFQQSxVQUFrQixNQU45QjtBQUk2QixPQUEzQnRILENBSkY7QUEvSUEsT0FDQTs7O0FBQ0EsaUJBQWEscURBQWIsU0FBYSxDQUFiLENBRkEsQ0FJQTs7QUFDQSx5QkFMQSxDQU1BO0FBQ0E7QUFDQTs7QUFDQSxRQUFJWSxTQUFRLEtBQVosV0FBNEI7QUFDMUIsc0JBQWdCLEtBQWhCLFNBQThCO0FBQzVCMkcsaUJBRDRCLEVBQzVCQSxTQUQ0QjtBQUU1QkMsbUJBQVcsRUFGaUI7QUFHNUJoTCxhQUFLLEVBSHVCO0FBSTVCcUMsV0FKNEIsRUFJNUJBLEdBSjRCO0FBSzVCNEksZUFBTyxFQUFFQyxZQUFZLElBQUlBLFlBQVksQ0FMVDtBQU01QkMsZUFBTyxFQUFFRCxZQUFZLElBQUlBLFlBQVksQ0FOdkM7QUFBOEIsT0FBOUI7QUFVRjs7QUFBQSwrQkFBMkI7QUFDekJILGVBQVMsRUFEZ0I7QUFFekJDLGlCQUFXLEVBQUU7QUFGZjtBQUVlO0FBRlksS0FBM0IsQ0FwQkEsQ0EyQkE7QUFDQTs7QUFDQSxrQkFBY25GLE1BQU0sQ0FBcEI7QUFFQTtBQUNBO0FBQ0Esd0JBakNBLENBa0NBO0FBQ0E7O0FBQ0Esa0JBQ0U7QUFDQSxpREFBNEJ1RixhQUFhLENBQXpDLHlCQUZGO0FBR0E7QUFDQTtBQUNBO0FBQ0EsNEJBMUNBLENBMkNBO0FBQ0E7O0FBQ0E7QUFFQTs7QUFFQSxRQUFJL0YsS0FBSixFQUFxQyxFQU1yQzs7QUFBQSxjQUFtQztBQUNqQztBQUNBO0FBQ0EsVUFBSXhDLEdBQUUsQ0FBRkEsaUJBQUosTUFBOEI7QUFDNUI7QUFDQTtBQUNBLHlDQUVFLGlDQUFxQjtBQUFFdUIsa0JBQVEsRUFBRThFLFdBQVcsQ0FBdkIsU0FBdUIsQ0FBdkI7QUFBbUNaLGVBQUssRUFGL0Q7QUFFdUIsU0FBckIsQ0FGRixFQUdFLFdBSEYsTUFHRSxHQUhGO0FBT0Y3Rzs7QUFBQUEsWUFBTSxDQUFOQSw2QkFBb0MsS0FBcENBLFlBYmlDLENBZWpDO0FBQ0E7O0FBQ0EsVUFBSTRELEtBQUosRUFBMkMsbURBMEI1QztBQUNGO0FBdUREZ0c7Ozs7NkJBQWU7QUFDYjVKLFlBQU0sQ0FBTkE7QUFHRjtBQUFBOztBQUdBNko7Ozs7MkJBQU87QUFDTDdKLFlBQU0sQ0FBTkE7QUFHRjtBQUFBOzs7OztBQU1BOEo7Ozs7eUJBQUksRyxFQUEyRDtBQUFBLFVBQWhEMUksRUFBZ0QsdUVBQTNELEdBQTJEO0FBQUEsVUFBakNpSSxPQUFpQyx1RUFBM0QsRUFBMkQ7QUFDN0Q7O0FBRDZELDBCQUM3Q1UsWUFBWSxZQUEzQixFQUEyQixDQURpQzs7QUFDM0QsU0FEMkQsaUJBQzNELEdBRDJEO0FBQzNELFFBRDJELGlCQUMzRCxFQUQyRDtBQUU3RCxhQUFPLGtDQUFQLE9BQU8sQ0FBUDtBQUdGO0FBQUE7Ozs7O0FBTUExSTs7Ozs0QkFBTyxHLEVBQTJEO0FBQUEsVUFBaERELEVBQWdELHVFQUEzRCxHQUEyRDtBQUFBLFVBQWpDaUksT0FBaUMsdUVBQTNELEVBQTJEO0FBQ2hFOztBQURnRSwyQkFDaERVLFlBQVksWUFBM0IsRUFBMkIsQ0FEb0M7O0FBQzlELFNBRDhELGtCQUM5RCxHQUQ4RDtBQUM5RCxRQUQ4RCxrQkFDOUQsRUFEOEQ7QUFFaEUsYUFBTyxxQ0FBUCxPQUFPLENBQVA7QUFHRjs7Ozs4RkFBQSxNLEVBQUEsRyxFQUFBLEUsRUFBQSxPOzs7Ozs7Ozs7b0JBTU9DLFVBQVUsQ0FBZixHQUFlLEM7Ozs7O0FBQ2JoSyxzQkFBTSxDQUFOQTtpREFDQSxLOzs7QUFHRixvQkFBSTRELEtBQUosRUFBcUMsRUFtQnJDOztBQUFBLG9CQUFJLENBQUV5RixPQUFELENBQUwsSUFBMEI7QUFDeEI7QUFFRixpQixDQUFBOzs7QUFDQSxvQkFBSVksT0FBSixJQUFRO0FBQ05DLDZCQUFXLENBQVhBO0FBR0Y7O0FBQUEsb0JBQUksS0FBSixnQkFBeUI7QUFDdkIsMENBQXdCLEtBQXhCO0FBR0Y5STs7QUFBQUEsa0JBQUUsR0FBRytJLFNBQVMsS0FBS2QsT0FBTyxDQUFaLFFBQXFCLEtBQW5DakksYUFBYyxDQUFkQTtBQUNNZ0oseUIsR0FBWUMsU0FBUyxDQUN6QnZFLFdBQVcsQ0FBWEEsRUFBVyxDQUFYQSxHQUFrQndFLFdBQVcsQ0FBN0J4RSxFQUE2QixDQUE3QkEsR0FEeUIsSUFFekIsS0FGRixNQUEyQixDO0FBSTNCLHlDLENBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7c0JBQ0ksQ0FBRXVELE9BQUQsQ0FBRCxNQUF3QixxQkFBNUIsU0FBNEIsQzs7Ozs7QUFDMUI7QUFDQWpGLHNCQUFNLENBQU5BLG1DLENBQ0E7O0FBQ0E7QUFDQTtBQUNBLDRCQUFZLGdCQUFnQixLQUE1QixLQUFZLENBQVo7QUFDQUEsc0JBQU0sQ0FBTkE7aURBQ0EsSTs7Ozt1QkFNa0IsZ0JBQXBCLFdBQW9CLEU7OztBQUFkbUcscUI7O3VCQUNpQyxnQkFBdkMscUI7Ozs7QUFBTSx3Qix5QkFBRUMsVTtBQUVKQyxzQixHQUFTLHdDQUFiLEdBQWEsQzswQkFFYixNLEVBQUksUSxXQUFBLFEsRUFBQSxLLFdBQUEsSztBQUVKQSxzQkFBTSxHQUFHLDBCQUFUQSxLQUFTLENBQVRBOztBQUVBLG9CQUFJQSxNQUFNLENBQU5BLGFBQUosVUFBa0M7QUFDaEM5SCwwQkFBUSxHQUFHOEgsTUFBTSxDQUFqQjlIO0FBQ0FnRCxxQkFBRyxHQUFHLGlDQUFOQSxNQUFNLENBQU5BO0FBR0YsaUIsQ0FBQTtBQUNBO0FBQ0E7OztBQUNBaEQsd0JBQVEsR0FBR0EsUUFBUSxHQUNmLHFEQUF3QjJILFdBQVcsQ0FEcEIsUUFDb0IsQ0FBbkMsQ0FEZSxHQUFuQjNILFMsQ0FJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLG9CQUFJLENBQUMsY0FBTCxTQUFLLENBQUwsRUFBK0I7QUFDN0IrSCx3QkFBTSxHQUFOQTtBQUdGOztBQUFJdEMscUIsR0FBUSxxREFBWixRQUFZLEM7bUNBQ1osTyxDQUFROUcsTyxFQUFBQSxPLGlDQUFGLEsscUJBRU47QUFDQTs7QUFDSXNCLDBCLEdBQUosRTs7QUFFQSxvQkFBSWdCLElBQUosRUFBcUM7QUFDbkNoQiw0QkFBVSxHQUFHLGlDQUNYLDRDQURXLDRDQU1WRixXQUFEO0FBQUEsMkJBQWUsb0JBQWtCO0FBQUVDLDhCQUFRLEVBQTVCO0FBQWtCLHFCQUFsQixTQU5qQkMsUUFNRTtBQUFBLG1CQU5XLENBQWJBOztBQVNBLHNCQUFJQSxVQUFVLEtBQWQsSUFBdUI7QUFDZitILGlDQURlLEdBQ0MscURBQ3BCLGtCQUNFNUksTUFBTSxDQUFOQSxtQkFBMEI7QUFBRVksOEJBQVEsRUFEdEM7QUFDNEIscUJBQTFCWixDQURGLGdCQURGLFFBQXNCLENBREQsRUFTckI7QUFDQTs7QUFDQSx3QkFBSXdJLEtBQUssQ0FBTEEsU0FBSixhQUFJQSxDQUFKLEVBQW1DO0FBQ2pDbkMsMkJBQUssR0FBTEE7QUFDQXpGLDhCQUFRLEdBQVJBO0FBQ0E4SCw0QkFBTSxDQUFOQTtBQUNBOUUseUJBQUcsR0FBRyxpQ0FBTkEsTUFBTSxDQUFOQTtBQUVIO0FBQ0Y7QUFDRC9DOztBQUFBQSwwQkFBVSxHQUFHeUgsU0FBUyxDQUFDQyxXQUFXLENBQVosVUFBWSxDQUFaLEVBQTBCLEtBQWhEMUgsTUFBc0IsQ0FBdEJBOztxQkFFSSwrQkFBSixLQUFJLEM7Ozs7O0FBQ0lnSSx3QixHQUFXLHdDQUFqQixVQUFpQixDO0FBQ1h6RSwwQixHQUFheUUsUUFBUSxDQUEzQixRO0FBRU1DLDBCLEdBQWEsK0JBQW5CLEtBQW1CLEM7QUFDYkMsMEIsR0FBYSwrQ0FBbkIsVUFBbUIsQztBQUNiQyxpQyxHQUFvQjNDLEtBQUssS0FBL0IsVTtBQUNNbkIsOEIsR0FBaUI4RCxpQkFBaUIsR0FDcEM3RCxhQUFhLG9CQUR1QixLQUN2QixDQUR1QixHQUF4QyxFOztzQkFJSSxlQUFnQjZELGlCQUFpQixJQUFJLENBQUM5RCxjQUFjLENBQXhELE07Ozs7O0FBQ1ErRCw2QixHQUFnQmpKLE1BQU0sQ0FBTkEsS0FBWThJLFVBQVUsQ0FBdEI5SSxlQUNuQnNFLGVBQUQ7QUFBQSx5QkFBVyxDQUFDUSxLQUFLLENBRG5CLEtBQ21CLENBQWpCO0FBQUEsaUJBRG9COUUsQzs7c0JBSWxCaUosYUFBYSxDQUFiQSxTQUFKLEM7Ozs7O0FBQ0UsMEJBQTJDO0FBQ3pDdEsseUJBQU8sQ0FBUEEsS0FDRyxVQUNDcUssaUJBREYsdURBQUMsMERBS2dCQyxhQUFhLENBQWJBLEtBTm5CdEssSUFNbUJzSyxDQUxoQiw2QkFESHRLO0FBWUY7O3NCQUFNLFVBQ0osQ0FBQ3FLLGlCQUFpQixrQ0FDWXBGLEdBRFosOENBQ21EcUYsYUFBYSxDQUFiQSxLQURuRCxJQUNtREEsQ0FEbkQsMEVBSWdCN0UsVUFKaEIsc0RBQWxCLEtBQWtCLFFBQWxCLHVEQU1JNEUsaUJBQWlCLGlDQTFCM0Isc0JBb0JNLENBREksQzs7Ozs7OztBQWFILHVDQUF1QjtBQUM1QjNKLG9CQUFFLEdBQUcsaUNBQ0hXLE1BQU0sQ0FBTkEscUJBQTRCO0FBQzFCWSw0QkFBUSxFQUFFc0UsY0FBYyxDQURFO0FBRTFCSix5QkFBSyxFQUFFTyxrQkFBa0IsUUFBUUgsY0FBYyxDQUhuRDdGLE1BRzZCO0FBRkMsbUJBQTVCVyxDQURHLENBQUxYO0FBREssdUJBT0E7QUFDTDtBQUNBVyx3QkFBTSxDQUFOQTtBQUVIOzs7QUFFRHFDLHNCQUFNLENBQU5BOzs7dUJBRzBCLDhDQUF4QixPQUF3QixDOzs7QUFBbEI2Ryx5QjtBQU9GLHFCLEdBQUosUyxDQUFJLEssRUFBQSxLLEdBQUosUyxDQUFJLEssRUFBQSxPLEdBQUosUyxDQUFJLE8sRUFBQSxPLEdBQUosUyxDQUFJLE8sRUFFSjs7c0JBRUUsQ0FBQ3pCLE9BQU8sSUFBUixxQkFFQ2pMLEtBQUQsQ0FGQSxhQUdDQSxLQUFELFVBQUNBLENBSkgsWTs7Ozs7QUFNUTJNLDJCLEdBQWUzTSxLQUFELFVBQUNBLENBQXJCLFksRUFFQTtBQUNBO0FBQ0E7O3FCQUNJMk0sV0FBVyxDQUFYQSxXQUFKLEdBQUlBLEM7Ozs7O0FBQ0lDLDBCLEdBQWEsd0NBQW5CLFdBQW1CLEM7O0FBQ25COztxQkFFSVosS0FBSyxDQUFMQSxTQUFlWSxVQUFVLENBQTdCLFFBQUlaLEM7Ozs7O2lEQUNLLDhDQUFQLE9BQU8sQzs7O0FBSVh2SyxzQkFBTSxDQUFOQTtpREFDTyxZQUFZLFlBQU0sQ0FBekIsQ0FBTyxDOzs7QUFHVG9FLHNCQUFNLENBQU5BO0FBQ0EsOENBR0UrRixTQUFTLEtBQUtkLE9BQU8sQ0FBWixRQUFxQixLQUhoQyxhQUdXLENBSFg7O0FBT0EsMEJBQTJDO0FBQ25DK0IseUJBRG1DLEdBQ3BCLHlCQUFyQixTQUR5QztBQUV2Q3BMLHdCQUFELEtBQUNBLENBQUQsYUFBQ0EsR0FDQW9MLE9BQU8sQ0FBUEEsb0JBQTRCQSxPQUFPLENBQW5DQSx1QkFDQSxDQUFFSCxTQUFTLENBQVYsU0FBQ0EsQ0FGSCxlQUFDakw7QUFLSjs7O3VCQUFNLGdFQUNIZ0IsV0FBRCxFQUFPO0FBQ0wsc0JBQUlBLENBQUMsQ0FBTCxXQUFpQnFLLEtBQUssR0FBR0EsS0FBSyxJQUE5QixDQUFpQkEsQ0FBakIsS0FDSztBQUhULGlCQUFNLEM7OztxQkFPTixLOzs7OztBQUNFakgsc0JBQU0sQ0FBTkE7c0JBQ0EsSzs7O0FBR0Ysb0JBQUlSLEtBQUosRUFBMkMsRUFLM0NROztBQUFBQSxzQkFBTSxDQUFOQTtpREFFQSxJOzs7Ozs7cUJBRUl4RCxZQUFKLFM7Ozs7O2lEQUNFLEs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQ0FNSyxNLEVBQUEsRyxFQUFBLEUsRUFLSDtBQUFBLFVBRE55SSxPQUNNLHVFQUxHLEVBS0g7O0FBQ04sZ0JBQTJDO0FBQ3pDLFlBQUksT0FBT3JKLE1BQU0sQ0FBYixZQUFKLGFBQTJDO0FBQ3pDVSxpQkFBTyxDQUFQQTtBQUNBO0FBR0Y7O0FBQUEsWUFBSSxPQUFPVixNQUFNLENBQU5BLFFBQVAsTUFBT0EsQ0FBUCxLQUFKLGFBQW1EO0FBQ2pEVSxpQkFBTyxDQUFQQTtBQUNBO0FBRUg7QUFFRDs7QUFBQSxVQUFJZ0ssTUFBTSxLQUFOQSxlQUEwQix5QkFBOUIsSUFBK0M7QUFDN0Msd0JBQWdCckIsT0FBTyxDQUF2QjtBQUNBLGNBQU0sQ0FBTixnQkFDRTtBQUNFMUQsYUFERixFQUNFQSxHQURGO0FBRUV2RSxZQUZGLEVBRUVBLEVBRkY7QUFHRWlJLGlCQUhGLEVBR0VBLE9BSEY7QUFJRWlDLGFBQUcsRUFMUDtBQUNFLFNBREYsRUFPRTtBQUNBO0FBQ0E7QUFURjtBQWNIO0FBRUQ7Ozs7NkdBQUEsRyxFQUFBLFEsRUFBQSxLLEVBQUEsRSxFQUFBLGE7Ozs7Ozs7cUJBT00xSyxHQUFHLENBQVAsUzs7Ozs7c0JBRUUsRzs7O3NCQUdFMkcsZUFBZSxJQUFmQSxPQUFKLGE7Ozs7O0FBQ0VuRCxzQkFBTSxDQUFOQSx5QyxDQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0FwRSxzQkFBTSxDQUFOQSxtQixDQUVBO0FBQ0E7O3NCQUNNdUwsc0JBQU4sRTs7OztBQU9NQyxzQixHQUFTNUssR0FBRyxDQUFIQSxZQUFmLHdCOztxQkFFQSxNOzs7Ozs7O3VCQUdvRCxvQkFBL0MsTUFBK0MsQzs7OztBQUE5Qyx5Qix5QkFBRTZLLEk7QUFBRiwyQix5QkFBQSxXO0FBQUEsbUIseUJBQUEsRzs7c0JBTUVDLEdBQUcsSUFBSUEsR0FBRyxDQUFkLE87Ozs7Ozt1QkFDZ0Isb0JBQ1osa0RBQWtELEtBRHBEbk4sTUFDRSxDQURZLEM7OztBQUFkQSxxQjs7Ozs7Ozs7Ozs7c0JBVUosb0NBQ0EsdUJBRkYsVzs7Ozs7QUFJRTs7dUJBQTJDLG9CQUExQyxTQUEwQyxDOzs7O0FBQXpDLHlCLDBCQUFFa04sSTtBQUFGLDJCLDBCQUFBLFc7OztBQUtFUix5QixHQUE4QjtBQUNsQzFNLHVCQURrQyxFQUNsQ0EsS0FEa0M7QUFFbEMrSywyQkFGa0MsRUFFbENBLFNBRmtDO0FBR2xDQyw2QkFIa0MsRUFHbENBLFdBSGtDO0FBSWxDM0kscUJBQUcsRUFBRTRLLE1BQU0sZUFKdUI7QUFLbENILHVCQUFLLEVBQUVHLE1BQU0sZUFMZjtBQUFvQyxpQjs7b0JBUS9CUCxTQUFTLENBQWQsSzs7Ozs7Ozt1QkFFNEIsZ0NBQWdDO0FBQ3REcksscUJBRHNELEVBQ3REQSxHQURzRDtBQUV0RCtCLDBCQUZzRCxFQUV0REEsUUFGc0Q7QUFHdERrRSx1QkFIRm9FLEVBR0VwRTtBQUhzRCxpQkFBaEMsQzs7O0FBQXhCb0UseUJBQVMsQ0FBVEEsSzs7Ozs7OztBQU1BdkssdUJBQU8sQ0FBUEE7QUFDQXVLLHlCQUFTLENBQVRBOzs7a0RBSUosUzs7Ozs7a0RBRU8sNkRBQVAsSUFBTyxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FHQUlYLEssRUFBQSxRLEVBQUEsSyxFQUFBLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLRTNKLHVCLDhEQUxGLEs7O0FBUVVxSywrQixHQUFrQixnQkFBeEIsS0FBd0IsQzs7c0JBRXBCckssT0FBTyxJQUFQQSxtQkFBOEIsZUFBbEMsSzs7Ozs7a0RBQ0UsZTs7O3FCQUdrQ3FLLGU7Ozs7OytCQUFlLGU7Ozs7Ozt1QkFFekMsZ0NBQWlDN0QsYUFBRDtBQUFBLHlCQUFVO0FBQzlDd0IsNkJBQVMsRUFBRXhCLEdBQUcsQ0FEZ0M7QUFFOUN5QiwrQkFBVyxFQUFFekIsR0FBRyxDQUY4QjtBQUc5QzBCLDJCQUFPLEVBQUUxQixHQUFHLENBQUhBLElBSHFDO0FBSTlDNEIsMkJBQU8sRUFBRTVCLEdBQUcsQ0FBSEEsSUFOZjtBQUVvRCxtQkFBVjtBQUFBLGlCQUFoQyxDOzs7Ozs7QUFGSm1ELHlCO0FBU0EseUIsR0FBTixTLENBQU0sUyxFQUFBLE8sR0FBTixTLENBQU0sTyxFQUFBLE8sR0FBTixTLENBQU0sTzs7Ozs0QkFHMkJXLG1CQUFPLENBQXRDLGtEQUFzQyxDLEVBQWhDLGtCLGFBQUEsa0I7O29CQUNEQyxrQkFBa0IsQ0FBdkIsU0FBdUIsQzs7Ozs7c0JBQ2YsMkVBQU4sUUFBTSxROzs7QUFRVixvQkFBSXJDLE9BQU8sSUFBWCxTQUF3QjtBQUN0QnNDLDBCQUFRLEdBQUcsNEJBQ1QsaUNBQXFCO0FBQUVuSiw0QkFBRixFQUFFQSxRQUFGO0FBQVlrRSx5QkFEeEIsRUFDd0JBO0FBQVosbUJBQXJCLENBRFMsRUFFVHlELFdBQVcsQ0FGRixFQUVFLENBRkYsV0FJVCxLQUpGd0IsTUFBVyxDQUFYQTtBQVFGOzs7dUJBQW9CLGNBQWdDO0FBQUEseUJBQ2xEdEMsT0FBTyxHQUNILHNCQURHLFFBQ0gsQ0FERyxHQUVIRSxPQUFPLEdBQ1Asc0JBRE8sUUFDUCxDQURPLEdBRVAsa0NBRUU7QUFDQTtBQUNFL0csNEJBREYsRUFDRUEsUUFERjtBQUVFa0UseUJBRkYsRUFFRUEsS0FGRjtBQUdFd0IsMEJBQU0sRUFYaEI7QUFRUSxtQkFIRixDQUw4QztBQUFBLGlCQUFoQyxDOzs7QUFBZDlKLHFCO0FBZ0JOME0seUJBQVMsQ0FBVEE7QUFDQTtrREFDQSxTOzs7OztrREFFTyx5REFBUCxFQUFPLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFJUixLLEVBQUEsUSxFQUFBLEssRUFBQSxFLEVBQUEsSSxFQU1jO0FBQ2Y7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQU8sWUFBUCxJQUFPLENBQVA7QUFHRjtBQUFBOzs7QUFJQWM7Ozs7bUNBQWMsRSxFQUE2QjtBQUN6QztBQUdGQzs7O29DQUFlLEUsRUFBc0I7QUFDbkMsVUFBSSxDQUFDLEtBQUwsUUFBa0I7O0FBRGlCLCtCQUVILGtCQUFoQyxHQUFnQyxDQUZHO0FBQUE7QUFBQSxVQUU3QixZQUY2QjtBQUFBLFVBRTdCLE9BRjZCOztBQUFBLHNCQUdINUssRUFBRSxDQUFGQSxNQUFoQyxHQUFnQ0EsQ0FIRztBQUFBO0FBQUEsVUFHN0IsWUFINkI7QUFBQSxVQUc3QixPQUg2QixrQkFLbkM7OztBQUNBLFVBQUk2SyxPQUFPLElBQUlDLFlBQVksS0FBdkJELGdCQUE0Q0UsT0FBTyxLQUF2RCxTQUFxRTtBQUNuRTtBQUdGLE9BVm1DLENBVW5DOzs7QUFDQSxVQUFJRCxZQUFZLEtBQWhCLGNBQW1DO0FBQ2pDO0FBR0YsT0FmbUMsQ0FlbkM7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLGFBQU9DLE9BQU8sS0FBZDtBQUdGQzs7O2lDQUFZLEUsRUFBbUI7QUFBQSx1QkFDWmhMLEVBQUUsQ0FBRkEsTUFBakIsR0FBaUJBLENBRFk7QUFBQTtBQUFBLFVBQ3ZCLElBRHVCLGtCQUU3Qjs7O0FBQ0EsVUFBSStGLElBQUksS0FBUixJQUFpQjtBQUNmbkgsY0FBTSxDQUFOQTtBQUNBO0FBR0YsT0FSNkIsQ0FRN0I7OztBQUNBLFVBQU1xTSxJQUFJLEdBQUc1SyxRQUFRLENBQVJBLGVBQWIsSUFBYUEsQ0FBYjs7QUFDQSxnQkFBVTtBQUNSNEssWUFBSSxDQUFKQTtBQUNBO0FBRUYsT0FkNkIsQ0FjN0I7QUFDQTs7O0FBQ0EsVUFBTUMsTUFBTSxHQUFHN0ssUUFBUSxDQUFSQSx3QkFBZixDQUFlQSxDQUFmOztBQUNBLGtCQUFZO0FBQ1Y2SyxjQUFNLENBQU5BO0FBRUg7QUFFREM7Ozs2QkFBUSxNLEVBQTBCO0FBQ2hDLGFBQU8sZ0JBQVA7QUFHRkM7OztpQ0FBWSxVLEVBQUEsSyxFQUErRDtBQUFBLFVBQXRCQyxhQUFzQix1RUFBL0QsSUFBK0Q7QUFBQSxVQUNuRSxRQURtRSxHQUN6RSxVQUR5RSxDQUNuRSxRQURtRTtBQUV6RSxVQUFNQyxhQUFhLEdBQUcscURBQ3BCLDhDQUFvQkQsYUFBYSxHQUFHbkMsV0FBVyxDQUFkLFFBQWMsQ0FBZCxHQURuQyxRQUNFLENBRG9CLENBQXRCOztBQUlBLFVBQUlvQyxhQUFhLEtBQWJBLFVBQTRCQSxhQUFhLEtBQTdDLFdBQTZEO0FBQzNEO0FBR0YsT0FWeUUsQ0FVekU7OztBQUNBLFVBQUksQ0FBQ25DLEtBQUssQ0FBTEEsU0FBTCxhQUFLQSxDQUFMLEVBQXFDO0FBQ25DO0FBQ0FBLGFBQUssQ0FBTEEsS0FBWWtCLGNBQUQsRUFBVTtBQUNuQixjQUNFLHdDQUNBLDZDQUZGLGFBRUUsQ0FGRixFQUdFO0FBQ0FOLHNCQUFVLENBQVZBLFdBQXNCc0IsYUFBYSxHQUFHaEYsV0FBVyxDQUFkLElBQWMsQ0FBZCxHQUFuQzBEO0FBQ0E7QUFFSDtBQVJEWjtBQVVGOztBQUFBO0FBR0Y7QUFBQTs7Ozs7QUFNQTs7Ozs7aUdBQUEsRzs7Ozs7Ozs7Ozs7Ozs7QUFFRWxDLHNCLDhEQUZGLEc7QUFHRWdCLHVCLDhEQUhGLEU7QUFLTW9CLHNCLEdBQVMsd0NBQWIsR0FBYSxDOzJCQUViLE0sRUFBSSxRLFlBQUEsUTs7dUJBRWdCLGdCQUFwQixXQUFvQixFOzs7QUFBZEYscUI7QUFFTkUsc0JBQU0sR0FBRywwQkFBVEEsS0FBUyxDQUFUQTs7QUFFQSxvQkFBSUEsTUFBTSxDQUFOQSxhQUFKLFVBQWtDO0FBQ2hDOUgsMEJBQVEsR0FBRzhILE1BQU0sQ0FBakI5SDtBQUNBZ0QscUJBQUcsR0FBRyxpQ0FBTkEsTUFBTSxDQUFOQTtBQUdGLGlCLENBQUE7Ozs7Ozs7O0FBS015QyxxQixHQUFRLHFEQUFkLFFBQWMsQzs7dUJBQ1J1RSxPQUFPLENBQVBBLElBQVksQ0FDaEIsMENBR0UsS0FIRixRQUlFLEtBTGMsYUFDaEIsQ0FEZ0IsRUFPaEIsZ0JBQWdCdEQsT0FBTyxDQUFQQSx3QkFBaEIsWUFQRixLQU9FLENBUGdCLENBQVpzRCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VHQVdSLEs7Ozs7OztBQUNNbkgseUIsR0FBSixLOztBQUNNb0gsc0IsR0FBVSxXQUFXLFlBQU07QUFDL0JwSCwyQkFBUyxHQUFUQTtBQURGLGlCOzs7dUJBSThCLHlCQUE5QixLQUE4QixDOzs7QUFBeEJxSCwrQjs7cUJBRU4sUzs7Ozs7QUFDUXhCLHFCLEdBQWEsMERBQW5CLEtBQW1CLFE7QUFHbkJBLHFCQUFLLENBQUxBO3NCQUNBLEs7OztBQUdGLG9CQUFJdUIsTUFBTSxLQUFLLEtBQWYsS0FBeUI7QUFDdkI7QUFHRjs7a0RBQUEsZTs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQUdNLEUsRUFBc0M7QUFBQTs7QUFDNUMsVUFBSXBILFNBQVMsR0FBYjs7QUFDQSxVQUFNb0gsTUFBTSxHQUFHLFNBQVRBLE1BQVMsR0FBTTtBQUNuQnBILGlCQUFTLEdBQVRBO0FBREY7O0FBR0E7QUFDQSxhQUFPc0gsRUFBRSxHQUFGQSxLQUFXQyxjQUFELEVBQVU7QUFDekIsWUFBSUgsTUFBTSxLQUFLLE9BQWYsS0FBeUI7QUFDdkI7QUFHRjs7QUFBQSx1QkFBZTtBQUNiLGNBQU1oTSxHQUFRLEdBQUcsVUFBakIsaUNBQWlCLENBQWpCO0FBQ0FBLGFBQUcsQ0FBSEE7QUFDQTtBQUdGOztBQUFBO0FBWEYsT0FBT2tNLENBQVA7QUFlRkU7OzttQ0FBYyxRLEVBQW9DO0FBQUE7O0FBQUEsaUJBQ3JCLGtCQUFrQmhOLE1BQU0sQ0FBTkEsU0FBN0MsSUFBMkIsQ0FEcUI7QUFBQSxVQUMxQyxRQUQwQyxRQUN4Q2EsSUFEd0M7O0FBRWhELFVBQUkrQyxLQUFKLEVBQWlFLEVBR2pFOztBQUFBLGFBQU9xSixhQUFhLFdBQVcsS0FBeEJBLEtBQWEsQ0FBYkEsTUFBMENGLGNBQUQsRUFBVTtBQUN4RDtBQUNBO0FBRkYsT0FBT0UsQ0FBUDtBQU1GQzs7O21DQUFjLFEsRUFBb0M7QUFDaEQsYUFBT0QsYUFBYSxXQUFXLEtBQS9CLEtBQW9CLENBQXBCO0FBR0ZqSTs7O29DQUFlLFMsRUFBQSxHLEVBR0M7QUFBQSxVQUNSLEdBRFEsR0FDYSxnQkFBM0IsT0FBMkIsQ0FEYixDQUNOc0UsU0FETTs7QUFFZCxVQUFNNkQsT0FBTyxHQUFHLGNBQWhCLEdBQWdCLENBQWhCOztBQUNBQyxTQUFHLENBQUhBO0FBQ0EsYUFBTyxxQ0FBaUQ7QUFDdERELGVBRHNELEVBQ3REQSxPQURzRDtBQUV0RDdELGlCQUZzRCxFQUV0REEsU0FGc0Q7QUFHdEQzSSxjQUFNLEVBSGdEO0FBSXREeU0sV0FKRixFQUlFQTtBQUpzRCxPQUFqRCxDQUFQO0FBUUZDOzs7dUNBQWtCLEUsRUFBbUI7QUFDbkMsVUFBSSxLQUFKLEtBQWM7QUFDWmpKLGNBQU0sQ0FBTkEsZ0NBQXVDbUgsc0JBQXZDbkg7QUFDQTtBQUNBO0FBRUg7QUFFRGtKOzs7MkJBQU0sSSxFQUF3QztBQUM1QyxhQUFPLGVBQWUseUJBQXRCLFNBQU8sQ0FBUDtBQXg2QjhDOzs7Ozs7O0FBQTdCbEosTSxDQTJCWndFLE1BM0JZeEUsR0EyQlUsdUJBM0JWQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJDQzFWckI7O0FBQ2UsdUNBQXVEO0FBQ3BFLFNBQU9tSixPQUFPLENBQVBBLGtCQUEyQkMsZUFBRDtBQUFBLFdBQWtCQyxrQkFBa0IsQ0FBckUsS0FBcUUsQ0FBcEM7QUFBQSxHQUExQkYsQ0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3FCRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXhCQSxDLENBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFNQSxJQUFNRyxnQkFBZ0IsR0FBdEI7O0FBRU8sMkJBQXNDO0FBQUEsTUFDdkMsSUFEdUMsR0FDM0MsTUFEMkMsQ0FDdkMsSUFEdUM7QUFBQSxNQUN2QyxRQUR1QyxHQUMzQyxNQUQyQyxDQUN2QyxRQUR1QztBQUUzQyxNQUFJQyxRQUFRLEdBQUdDLE1BQU0sQ0FBTkEsWUFBZjtBQUNBLE1BQUlqTCxRQUFRLEdBQUdpTCxNQUFNLENBQU5BLFlBQWY7QUFDQSxNQUFJekcsSUFBSSxHQUFHeUcsTUFBTSxDQUFOQSxRQUFYO0FBQ0EsTUFBSS9HLEtBQUssR0FBRytHLE1BQU0sQ0FBTkEsU0FBWjtBQUNBLE1BQUlDLElBQW9CLEdBQXhCO0FBRUFDLE1BQUksR0FBR0EsSUFBSSxHQUFHTCxrQkFBa0IsQ0FBbEJBLElBQWtCLENBQWxCQSx3QkFBSCxNQUFYSzs7QUFFQSxNQUFJRixNQUFNLENBQVYsTUFBaUI7QUFDZkMsUUFBSSxHQUFHQyxJQUFJLEdBQUdGLE1BQU0sQ0FBcEJDO0FBREYsU0FFTyxjQUFjO0FBQ25CQSxRQUFJLEdBQUdDLElBQUksSUFBSSxDQUFDQyxRQUFRLENBQVJBLFFBQUQsR0FBQ0EsQ0FBRCwrQkFBZkYsUUFBVyxDQUFYQTs7QUFDQSxRQUFJRCxNQUFNLENBQVYsTUFBaUI7QUFDZkMsVUFBSSxJQUFJLE1BQU1ELE1BQU0sQ0FBcEJDO0FBRUg7QUFFRDs7QUFBQSxNQUFJaEgsS0FBSyxJQUFJLGlCQUFiLFVBQXdDO0FBQ3RDQSxTQUFLLEdBQUdtSCxNQUFNLENBQUNDLFdBQVcsQ0FBWEEsdUJBQWZwSCxLQUFlb0gsQ0FBRCxDQUFkcEg7QUFHRjs7QUFBQSxNQUFJcUgsTUFBTSxHQUFHTixNQUFNLENBQU5BLFVBQWtCL0csS0FBSyxlQUF2QitHLEtBQXVCLENBQXZCQSxJQUFiO0FBRUEsTUFBSUQsUUFBUSxJQUFJQSxRQUFRLENBQVJBLE9BQWdCLENBQWhCQSxPQUFoQixLQUE2Q0EsUUFBUSxJQUFSQTs7QUFFN0MsTUFDRUMsTUFBTSxDQUFOQSxXQUNDLENBQUMsYUFBYUYsZ0JBQWdCLENBQWhCQSxLQUFkLFFBQWNBLENBQWQsS0FBa0RHLElBQUksS0FGekQsT0FHRTtBQUNBQSxRQUFJLEdBQUcsUUFBUUEsSUFBSSxJQUFuQkEsRUFBTyxDQUFQQTtBQUNBLFFBQUlsTCxRQUFRLElBQUlBLFFBQVEsQ0FBUkEsQ0FBUSxDQUFSQSxLQUFoQixLQUFxQ0EsUUFBUSxHQUFHLE1BQVhBO0FBTHZDLFNBTU8sSUFBSSxDQUFKLE1BQVc7QUFDaEJrTCxRQUFJLEdBQUpBO0FBR0Y7O0FBQUEsTUFBSTFHLElBQUksSUFBSUEsSUFBSSxDQUFKQSxDQUFJLENBQUpBLEtBQVosS0FBNkJBLElBQUksR0FBRyxNQUFQQTtBQUM3QixNQUFJK0csTUFBTSxJQUFJQSxNQUFNLENBQU5BLENBQU0sQ0FBTkEsS0FBZCxLQUFpQ0EsTUFBTSxHQUFHLE1BQVRBO0FBRWpDdkwsVUFBUSxHQUFHQSxRQUFRLENBQVJBLGlCQUFYQSxrQkFBV0EsQ0FBWEE7QUFDQXVMLFFBQU0sR0FBR0EsTUFBTSxDQUFOQSxhQUFUQSxLQUFTQSxDQUFUQTtBQUVBLG1CQUFVUCxRQUFWLFNBQXFCRSxJQUFyQixTQUE0QmxMLFFBQTVCLFNBQXVDdUwsTUFBdkM7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lDQ3hFRDs7QUFDQSxJQUFNQyxVQUFVLEdBQWhCOztBQUVPLCtCQUFnRDtBQUNyRCxTQUFPQSxVQUFVLENBQVZBLEtBQVAsS0FBT0EsQ0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0xEOztBQUNBOztBQUVBLElBQU1DLFVBQVUsR0FBRyxRQUNqQixvQkFBNkMsV0FEL0MsaUJBQytDLEdBRDVCLENBQW5CO0FBSUE7Ozs7Ozs7QUFNTyxxQ0FBc0Q7QUFDM0QsTUFBTUMsWUFBWSxHQUFHdkgsSUFBSSxHQUFHLGNBQUgsVUFBRyxDQUFILEdBQXpCOztBQUQyRCxhQVV2RCxhQVJKLFlBUUksQ0FWdUQ7QUFBQSxNQUVyRCxRQUZxRCxRQUVyRCxRQUZxRDtBQUFBLE1BRXJELFlBRnFELFFBRXJELFlBRnFEO0FBQUEsTUFFckQsTUFGcUQsUUFFckQsTUFGcUQ7QUFBQSxNQUVyRCxJQUZxRCxRQUVyRCxJQUZxRDtBQUFBLE1BRXJELElBRnFELFFBRXJELElBRnFEO0FBQUEsTUFFckQsTUFGcUQsUUFFckQsTUFGcUQ7QUFBQSxNQUVyRCxRQUZxRCxRQUVyRCxRQUZxRDs7QUFXM0QsTUFDRXdILE1BQU0sS0FBS0YsVUFBVSxDQUFyQkUsVUFDQ1gsUUFBUSxLQUFSQSxXQUF3QkEsUUFBUSxLQUZuQyxVQUdFO0FBQ0EsVUFBTSxVQUFOLGlDQUFNLENBQU47QUFFRjs7QUFBQSxTQUFPO0FBQ0xoTCxZQURLLEVBQ0xBLFFBREs7QUFFTGtFLFNBQUssRUFBRSx5Q0FGRixZQUVFLENBRkY7QUFHTHFILFVBSEssRUFHTEEsTUFISztBQUlML0csUUFKSyxFQUlMQSxJQUpLO0FBS0x0RyxRQUFJLEVBQUVBLElBQUksQ0FBSkEsTUFBV3VOLFVBQVUsQ0FBVkEsT0FMbkIsTUFLUXZOO0FBTEQsR0FBUDtBQU9EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSU87O0FBQUEsSUFBTTBOLGNBQ2MsR0FBRztBQUM1QkMsV0FBUyxFQURtQjtBQUU1QkMsV0FBUyxFQUhKO0FBQ3VCLENBRHZCOzs7QUFNQSxJQUFNQyx5QkFDYyxtQ0FBRyxjQUFIO0FBRXpCQyxRQUFNLEVBSEQ7QUFDb0IsRUFEcEI7Ozs7ZUFNUSxTLFFBQUEsR0FBeUI7QUFBQSxNQUF4QkMsV0FBd0IsdUVBQXpCLEtBQXlCO0FBQ3RDLFNBQVFsTCxjQUFELEVBQWtCO0FBQ3ZCLFFBQU1tTCxJQUF3QixHQUE5QjtBQUNBLFFBQU1DLFlBQVksR0FBR0MsWUFBWSxDQUFaQSx5QkFHbkJILFdBQVcsK0JBSGIsY0FBcUJHLENBQXJCO0FBS0EsUUFBTUMsT0FBTyxHQUFHRCxZQUFZLENBQVpBLCtCQUFoQixJQUFnQkEsQ0FBaEI7QUFFQSxXQUFPLDRCQUF1RDtBQUM1RCxVQUFNakgsR0FBRyxHQUFHbkYsUUFBUSxJQUFSQSxlQUEyQnFNLE9BQU8sQ0FBOUMsUUFBOEMsQ0FBOUM7O0FBQ0EsVUFBSSxDQUFKLEtBQVU7QUFDUjtBQUdGOztBQUFBLHVCQUFpQjtBQUFBLG1EQUNmLElBRGU7QUFBQTs7QUFBQTtBQUNmLDhEQUF3QjtBQUFBLGdCQUF4QixHQUF3Qjs7QUFDdEI7QUFDQTtBQUNBLGdCQUFJLE9BQU9yTixHQUFHLENBQVYsU0FBSixVQUFrQztBQUNoQyxxQkFBUW1HLEdBQUcsQ0FBSixNQUFDQSxDQUFtQm5HLEdBQUcsQ0FBOUIsSUFBUW1HLENBQVI7QUFFSDtBQUNGO0FBUmdCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFVakI7O0FBQUEsNkNBQU8sTUFBUCxHQUF1QkEsR0FBRyxDQUExQjtBQWhCRjtBQVRGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEJGOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSWU7O0FBQUEsdUZBTWI7QUFDQSxNQUFJbUgsaUJBS21DLEdBTHZDOztBQU9BLE1BQUkvRCxXQUFXLENBQVhBLFdBQUosR0FBSUEsQ0FBSixFQUFpQztBQUMvQitELHFCQUFpQixHQUFHLHdDQUFwQkEsV0FBb0IsQ0FBcEJBO0FBREYsU0FFTztBQUFBLGVBVUQsUUFUSixXQVNJLENBVkM7QUFBQSxRQUNDLFFBREQsUUFDQyxRQUREO0FBQUEsUUFDQyxZQURELFFBQ0MsWUFERDtBQUFBLFFBQ0MsSUFERCxRQUNDLElBREQ7QUFBQSxRQUNDLFFBREQsUUFDQyxRQUREO0FBQUEsUUFDQyxJQURELFFBQ0MsSUFERDtBQUFBLFFBQ0MsUUFERCxRQUNDLFFBREQ7QUFBQSxRQUNDLE1BREQsUUFDQyxNQUREO0FBQUEsUUFDQyxJQURELFFBQ0MsSUFERDs7QUFZTEEscUJBQWlCLEdBQUc7QUFDbEJ0TSxjQURrQixFQUNsQkEsUUFEa0I7QUFFbEJrRSxXQUFLLEVBQUUseUNBRlcsWUFFWCxDQUZXO0FBR2xCTSxVQUhrQixFQUdsQkEsSUFIa0I7QUFJbEJ3RyxjQUprQixFQUlsQkEsUUFKa0I7QUFLbEJJLGNBTGtCLEVBS2xCQSxRQUxrQjtBQU1sQm1CLFVBTmtCLEVBTWxCQSxJQU5rQjtBQU9sQmhCLFlBUGtCLEVBT2xCQSxNQVBrQjtBQVFsQnJOLFVBUkZvTyxFQVFFcE87QUFSa0IsS0FBcEJvTztBQVlGOztBQUFBLE1BQU1FLFNBQVMsR0FBR0YsaUJBQWlCLENBQW5DO0FBQ0EsTUFBTUcsUUFBUSxhQUFNSCxpQkFBaUIsQ0FBQ3RNLFFBQXhCLFNBQ1pzTSxpQkFBaUIsQ0FBakJBLFFBREYsRUFBYyxDQUFkO0FBR0EsTUFBTUksaUJBQXFDLEdBQTNDO0FBQ0FOLGNBQVksQ0FBWkE7QUFFQSxNQUFNTyxjQUFjLEdBQUdELGlCQUFpQixDQUFqQkEsSUFBdUIxTixhQUFEO0FBQUEsV0FBU0EsR0FBRyxDQUF6RCxJQUE2QztBQUFBLEdBQXRCME4sQ0FBdkI7QUFFQSxNQUFJRSxtQkFBbUIsR0FBRyxZQUFZLENBQVosa0JBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUVDLFlBQVEsRUFSWjtBQVFFLEdBUndCLENBQTFCO0FBVUEsYUFyREEsQ0F1REE7O0FBQ0EscUNBQWdDek4sTUFBTSxDQUFOQSxRQUFoQyxTQUFnQ0EsQ0FBaEMscUNBQTJEO0FBQUE7QUFBQSxRQUFoRCxHQUFnRDtBQUFBLFFBQTNELFVBQTJEOztBQUN6RCxRQUFJdUUsS0FBSyxHQUFHeEIsS0FBSyxDQUFMQSxzQkFBNEIySyxVQUFVLENBQXRDM0ssQ0FBc0MsQ0FBdENBLEdBQVo7O0FBQ0EsZUFBVztBQUNUO0FBQ0E7QUFDQXdCLFdBQUssY0FBTEEsS0FBSyxDQUFMQTtBQUNBLFVBQU1vSixhQUFhLEdBQUdYLFlBQVksQ0FBWkEsZUFBNEI7QUFBRVMsZ0JBQVEsRUFBNUQ7QUFBa0QsT0FBNUJULENBQXRCO0FBQ0F6SSxXQUFLLEdBQUdvSixhQUFhLENBQWJBLE1BQWEsQ0FBYkEsUUFBUnBKLENBQVFvSixDQUFScEo7QUFFRjZJOztBQUFBQSxhQUFTLENBQVRBLEdBQVMsQ0FBVEE7QUFHRixHQXBFQSxDQW9FQTtBQUNBOzs7QUFDQSxNQUFNUSxTQUFTLEdBQUc1TixNQUFNLENBQU5BLEtBQWxCLE1BQWtCQSxDQUFsQjs7QUFFQSxNQUNFNk4sbUJBQW1CLElBQ25CLENBQUNELFNBQVMsQ0FBVEEsS0FBZ0JoTyxhQUFEO0FBQUEsV0FBUzJOLGNBQWMsQ0FBZEEsU0FGM0IsR0FFMkJBLENBQVQ7QUFBQSxHQUFmSyxDQUZILEVBR0U7QUFBQSwrQ0FDQSxTQURBO0FBQUE7O0FBQUE7QUFDQSwwREFBNkI7QUFBQSxZQUE3QixJQUE2Qjs7QUFDM0IsWUFBSSxFQUFFaE8sSUFBRyxJQUFULFNBQUksQ0FBSixFQUF5QjtBQUN2QndOLG1CQUFTLENBQVRBLElBQVMsQ0FBVEEsR0FBaUIvSSxNQUFNLENBQXZCK0ksSUFBdUIsQ0FBdkJBO0FBRUg7QUFDRjtBQU5DO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRRjs7QUFBQSxNQUFNVSxpQkFBaUIsR0FBRzNFLFdBQVcsQ0FBWEEsbUJBQTFCOztBQUVBLE1BQUk7QUFDRjRFLFVBQU0sYUFBTUQsaUJBQWlCLGNBQWMsRUFBckMsU0FBMENOLG1CQUFtQixDQUFuRU8sTUFBbUUsQ0FBN0QsQ0FBTkE7O0FBREUsd0JBS3VCQSxNQUFNLENBQU5BLE1BQXpCLEdBQXlCQSxDQUx2QjtBQUFBO0FBQUEsUUFLSSxTQUxKO0FBQUEsUUFLSSxLQUxKOztBQU1GYixxQkFBaUIsQ0FBakJBO0FBQ0FBLHFCQUFpQixDQUFqQkEsaUJBQTRCOUgsS0FBSSxTQUFTLEVBQXpDOEgsU0FBOEM5SCxLQUFJLElBQWxEOEg7QUFDQSxXQUFPQSxpQkFBaUIsQ0FBeEI7QUFDQSxHQVRGLENBU0UsWUFBWTtBQUNaLFFBQUlyTyxHQUFHLENBQUhBLGNBQUosOENBQUlBLENBQUosRUFBdUU7QUFDckUsWUFBTSxJQUFOLEtBQU0sd0tBQU47QUFJRjs7QUFBQTtBQUdGLEdBdkdBLENBdUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQXFPLG1CQUFpQixDQUFqQkEsd0NBQTBCLEtBQTFCQSxHQUVLQSxpQkFBaUIsQ0FGdEJBO0FBS0EsU0FBTztBQUNMYSxVQURLLEVBQ0xBLE1BREs7QUFFTGIscUJBRkYsRUFFRUE7QUFGSyxHQUFQO0FBSUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9ITSw4Q0FFVztBQUNoQixNQUFNcEksS0FBcUIsR0FBM0I7QUFDQWtKLGNBQVksQ0FBWkEsUUFBcUIsc0JBQWdCO0FBQ25DLFFBQUksT0FBT2xKLEtBQUssQ0FBWixHQUFZLENBQVosS0FBSixhQUF1QztBQUNyQ0EsV0FBSyxDQUFMQSxHQUFLLENBQUxBO0FBREYsV0FFTyxJQUFJL0IsS0FBSyxDQUFMQSxRQUFjK0IsS0FBSyxDQUF2QixHQUF1QixDQUFuQi9CLENBQUosRUFBK0I7QUFDcEM7QUFBRStCLFdBQUssQ0FBTixHQUFNLENBQUxBLENBQUQsSUFBQ0EsQ0FBRCxLQUFDQTtBQURHLFdBRUE7QUFDTEEsV0FBSyxDQUFMQSxHQUFLLENBQUxBLEdBQWEsQ0FBQ0EsS0FBSyxDQUFOLEdBQU0sQ0FBTixFQUFiQSxLQUFhLENBQWJBO0FBRUg7QUFSRGtKO0FBU0E7QUFHRjs7QUFBQSx1Q0FBdUQ7QUFDckQsTUFDRSw2QkFDQyw2QkFBNkIsQ0FBQ0MsS0FBSyxDQURwQyxLQUNvQyxDQURwQyxJQUVBLGlCQUhGLFdBSUU7QUFDQSxXQUFPaEMsTUFBTSxDQUFiLEtBQWEsQ0FBYjtBQUxGLFNBTU87QUFDTDtBQUVIO0FBRU07O0FBQUEsMENBRVk7QUFDakIsTUFBTXJILE1BQU0sR0FBRyxJQUFmLGVBQWUsRUFBZjtBQUNBNUUsUUFBTSxDQUFOQSwwQkFBaUMsZ0JBQWtCO0FBQUE7QUFBQSxRQUFqQixHQUFpQjtBQUFBLFFBQWxCLEtBQWtCOztBQUNqRCxRQUFJK0MsS0FBSyxDQUFMQSxRQUFKLEtBQUlBLENBQUosRUFBMEI7QUFDeEJ3QixXQUFLLENBQUxBLFFBQWVoSCxjQUFEO0FBQUEsZUFBVXFILE1BQU0sQ0FBTkEsWUFBbUJzSixzQkFBc0IsQ0FBakUzSixJQUFpRSxDQUF6Q0ssQ0FBVjtBQUFBLE9BQWRMO0FBREYsV0FFTztBQUNMSyxZQUFNLENBQU5BLFNBQWdCc0osc0JBQXNCLENBQXRDdEosS0FBc0MsQ0FBdENBO0FBRUg7QUFORDVFO0FBT0E7QUFHSzs7QUFBQSx3QkFHWTtBQUFBLG9DQUhaLGdCQUdZO0FBSFosb0JBR1k7QUFBQTs7QUFDakJtTyxrQkFBZ0IsQ0FBaEJBLFFBQTBCSCxzQkFBRCxFQUFrQjtBQUN6Q2pMLFNBQUssQ0FBTEEsS0FBV2lMLFlBQVksQ0FBdkJqTCxJQUFXaUwsRUFBWGpMLFVBQXlDbkQsYUFBRDtBQUFBLGFBQVNaLGlCQUFqRCtELEdBQWlEL0QsQ0FBVDtBQUFBLEtBQXhDK0Q7QUFDQWlMLGdCQUFZLENBQVpBLFFBQXFCO0FBQUEsYUFBZ0JoUCxNQUFNLENBQU5BLFlBQXJDZ1AsS0FBcUNoUCxDQUFoQjtBQUFBLEtBQXJCZ1A7QUFGRkc7QUFJQTtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BERDs7QUFDQTs7QUFFQTs7Ozs7O0FBRUE7O0FBQUEsSUFBTUMsa0JBQWtCLEdBQUcsMkJBQTNCLElBQTJCLENBQTNCOztBQUVlLGdGQU9iO0FBQ0EsTUFBSSxDQUFDNUYsS0FBSyxDQUFMQSxTQUFMLE1BQUtBLENBQUwsRUFBNkI7QUFBQSwrQ0FDM0IsUUFEMkI7QUFBQTs7QUFBQTtBQUMzQiwwREFBZ0M7QUFBQSxZQUFoQyxPQUFnQztBQUM5QixZQUFNeUUsT0FBTyxHQUFHbUIsa0JBQWtCLENBQUNDLE9BQU8sQ0FBMUMsTUFBa0MsQ0FBbEM7QUFDQSxZQUFNaEssTUFBTSxHQUFHNEksT0FBTyxDQUF0QixNQUFzQixDQUF0Qjs7QUFFQSxvQkFBWTtBQUNWLGNBQUksQ0FBQ29CLE9BQU8sQ0FBWixhQUEwQjtBQUN4QjtBQUNBO0FBRUY7O0FBQUEsY0FBTUMsT0FBTyxHQUFHLG9DQUNkRCxPQUFPLENBRE8sa0NBS2RBLE9BQU8sQ0FBUEEsMEJBTEYsUUFBZ0IsQ0FBaEI7QUFPQS9ILGdCQUFNLEdBQUdnSSxPQUFPLENBQVBBLGtCQUFUaEk7QUFDQXRHLGdCQUFNLENBQU5BLGNBQXFCc08sT0FBTyxDQUFQQSxrQkFBckJ0Tzs7QUFFQSxjQUFJd0ksS0FBSyxDQUFMQSxTQUFlLHFEQUFuQixNQUFtQixDQUFmQSxDQUFKLEVBQXFEO0FBQ25EO0FBQ0E7QUFDQTtBQUdGLFdBckJVLENBcUJWOzs7QUFDQSxjQUFNbEQsWUFBWSxHQUFHSyxXQUFXLENBQWhDLE1BQWdDLENBQWhDOztBQUVBLGNBQUlMLFlBQVksS0FBWkEsVUFBMkJrRCxLQUFLLENBQUxBLFNBQS9CLFlBQStCQSxDQUEvQixFQUE2RDtBQUMzRDtBQUVIO0FBQ0Y7QUFDRjtBQWxDNEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQW1DN0I7O0FBQUE7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsRE0scUNBQXVFO0FBQUEsTUFDdEUsRUFEc0UsR0FDNUUsVUFENEUsQ0FDdEUsRUFEc0U7QUFBQSxNQUN0RSxNQURzRSxHQUM1RSxVQUQ0RSxDQUN0RSxNQURzRTtBQUU1RSxTQUFRNUgsa0JBQUQsRUFBeUM7QUFDOUMsUUFBTW1JLFVBQVUsR0FBR3dGLEVBQUUsQ0FBRkEsS0FBbkIsUUFBbUJBLENBQW5COztBQUNBLFFBQUksQ0FBSixZQUFpQjtBQUNmO0FBR0Y7O0FBQUEsUUFBTUMsTUFBTSxHQUFJbEssU0FBVmtLLE1BQVVsSyxNQUFELEVBQW1CO0FBQ2hDLFVBQUk7QUFDRixlQUFPbUssa0JBQWtCLENBQXpCLEtBQXlCLENBQXpCO0FBQ0EsT0FGRixDQUVFLFVBQVU7QUFDVixZQUFNNVAsR0FBOEIsR0FBRyxVQUF2Qyx3QkFBdUMsQ0FBdkM7QUFHQUEsV0FBRyxDQUFIQTtBQUNBO0FBRUg7QUFWRDs7QUFXQSxRQUFNd0YsTUFBa0QsR0FBeEQ7QUFFQXJFLFVBQU0sQ0FBTkEscUJBQTZCME8sa0JBQUQsRUFBc0I7QUFDaEQsVUFBTUMsQ0FBQyxHQUFHQyxNQUFNLENBQWhCLFFBQWdCLENBQWhCO0FBQ0EsVUFBTUMsQ0FBQyxHQUFHOUYsVUFBVSxDQUFDNEYsQ0FBQyxDQUF0QixHQUFvQixDQUFwQjs7QUFDQSxVQUFJRSxDQUFDLEtBQUwsV0FBcUI7QUFDbkJ4SyxjQUFNLENBQU5BLFFBQU0sQ0FBTkEsR0FBbUIsQ0FBQ3dLLENBQUMsQ0FBREEsUUFBRCxHQUFDQSxDQUFELEdBQ2ZBLENBQUMsQ0FBREEsZUFBa0J4USxlQUFEO0FBQUEsaUJBQVdtUSxNQUFNLENBRG5CLEtBQ21CLENBQWpCO0FBQUEsU0FBakJLLENBRGUsR0FFZkYsQ0FBQyxDQUFEQSxTQUNBLENBQUNILE1BQU0sQ0FEUEcsQ0FDTyxDQUFQLENBREFBLEdBRUFILE1BQU0sQ0FKVm5LLENBSVUsQ0FKVkE7QUFNSDtBQVZEckU7QUFXQTtBQTlCRjtBQWdDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VDQzlCRDtBQUNBOztBQUNBLDBCQUFrQztBQUNoQyxTQUFPOE8sR0FBRyxDQUFIQSxnQ0FBUCxNQUFPQSxDQUFQO0FBR0Y7O0FBQUEsK0JBQXVDO0FBQ3JDLE1BQU1wSyxRQUFRLEdBQUdKLEtBQUssQ0FBTEEsbUJBQXlCQSxLQUFLLENBQUxBLFNBQTFDLEdBQTBDQSxDQUExQzs7QUFDQSxnQkFBYztBQUNaQSxTQUFLLEdBQUdBLEtBQUssQ0FBTEEsU0FBZSxDQUF2QkEsQ0FBUUEsQ0FBUkE7QUFFRjs7QUFBQSxNQUFNRyxNQUFNLEdBQUdILEtBQUssQ0FBTEEsV0FBZixLQUFlQSxDQUFmOztBQUNBLGNBQVk7QUFDVkEsU0FBSyxHQUFHQSxLQUFLLENBQUxBLE1BQVJBLENBQVFBLENBQVJBO0FBRUY7O0FBQUEsU0FBTztBQUFFMUUsT0FBRyxFQUFMO0FBQWM2RSxVQUFkLEVBQWNBLE1BQWQ7QUFBc0JDLFlBQTdCLEVBQTZCQTtBQUF0QixHQUFQO0FBR0s7O0FBQUEsd0NBT0w7QUFDQSxNQUFNcUssUUFBUSxHQUFHLENBQUNDLGVBQWUsQ0FBZkEsc0JBQUQsb0JBQWpCLEdBQWlCLENBQWpCO0FBSUEsTUFBTUosTUFBc0MsR0FBNUM7QUFDQSxNQUFJSyxVQUFVLEdBQWQ7QUFDQSxNQUFNQyxrQkFBa0IsR0FBR0gsUUFBUSxDQUFSQSxJQUNuQnZELGlCQUFELEVBQWE7QUFDaEIsUUFBSUEsT0FBTyxDQUFQQSxtQkFBMkJBLE9BQU8sQ0FBUEEsU0FBL0IsR0FBK0JBLENBQS9CLEVBQXNEO0FBQUEsNEJBQ2xCMkQsY0FBYyxDQUFDM0QsT0FBTyxDQUFQQSxTQUFpQixDQUFsRSxDQUFpREEsQ0FBRCxDQURJO0FBQUEsVUFDOUMsR0FEOEMsbUJBQzlDLEdBRDhDO0FBQUEsVUFDOUMsUUFEOEMsbUJBQzlDLFFBRDhDO0FBQUEsVUFDOUMsTUFEOEMsbUJBQzlDLE1BRDhDOztBQUVwRG9ELFlBQU0sQ0FBTkEsR0FBTSxDQUFOQSxHQUFjO0FBQUVRLFdBQUcsRUFBRUgsVUFBUDtBQUFxQnhLLGNBQXJCLEVBQXFCQSxNQUFyQjtBQUE2QkMsZ0JBQTNDa0ssRUFBMkNsSztBQUE3QixPQUFka0s7QUFDQSxhQUFPbkssTUFBTSxHQUFJQyxRQUFRLG1CQUFaLFdBQWI7QUFIRixXQUlPO0FBQ0wsd0JBQVcySyxXQUFXLENBQXRCLE9BQXNCLENBQXRCO0FBRUg7QUFUd0JOLFVBQTNCLEVBQTJCQSxDQUEzQixDQVBBLENBbUJBO0FBQ0E7O0FBQ0EsYUFBbUMsa0dBZ0VuQzs7QUFBQSxTQUFPO0FBQ0xSLE1BQUUsRUFBRSxzQkFEQyxrQkFDRCxhQURDO0FBRUxLLFVBRkYsRUFFRUE7QUFGSyxHQUFQO0FBSUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwSEQ7QUF5UUE7Ozs7O0FBR08sc0JBRUY7QUFDSCxNQUFJVSxJQUFJLEdBQVI7QUFDQTtBQUVBLFNBQVEsWUFBb0I7QUFDMUIsUUFBSSxDQUFKLE1BQVc7QUFDVEEsVUFBSSxHQUFKQTtBQUNBMUssWUFBTSxHQUFHbUcsRUFBVG5HLE1BQVNtRyxtQkFBVG5HO0FBRUY7O0FBQUE7QUFMRjtBQVNLOztBQUFBLDZCQUE2QjtBQUFBLHlCQUNHM0csTUFBTSxDQUEzQyxRQURrQztBQUFBLE1BQzVCLFFBRDRCLG9CQUM1QixRQUQ0QjtBQUFBLE1BQzVCLFFBRDRCLG9CQUM1QixRQUQ0QjtBQUFBLE1BQzVCLElBRDRCLG9CQUM1QixJQUQ0QjtBQUVsQyxtQkFBVTJOLFFBQVYsZUFBdUJJLFFBQXZCLFNBQWtDbUIsSUFBSSxHQUFHLE1BQUgsT0FBdEM7QUFHSzs7QUFBQSxrQkFBa0I7QUFBQSxNQUNqQixJQURpQixHQUNObFAsTUFBTSxDQUF2QixRQUR1QixDQUNqQixJQURpQjtBQUV2QixNQUFNc08sTUFBTSxHQUFHZ0QsaUJBQWY7QUFDQSxTQUFPelEsSUFBSSxDQUFKQSxVQUFleU4sTUFBTSxDQUE1QixNQUFPek4sQ0FBUDtBQUdLOztBQUFBLG1DQUF3RDtBQUM3RCxTQUFPLDRDQUVIeUksU0FBUyxDQUFUQSxlQUF5QkEsU0FBUyxDQUFsQ0EsUUFGSjtBQUtLOztBQUFBLHdCQUF3QztBQUM3QyxTQUFPeEIsR0FBRyxDQUFIQSxZQUFnQkEsR0FBRyxDQUExQjtBQUdLOztTQUFBLG1COzs7OztrRkFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUEsa0JBTUgsa0JBQUl5SixHQUFHLENBQVAsOEJBQUlBLGVBQUosZUFORztBQUFBO0FBQUE7QUFBQTs7QUFPSzlNLG1CQVBMLGVBT21CK00sY0FBYyxDQUFsQyxHQUFrQyxDQVBqQztBQUFBLGtCQVVLLFVBQU4sT0FBTSxDQVZMOztBQUFBO0FBYUw7QUFDTTFKLGVBZEQsR0FjT3NGLEdBQUcsQ0FBSEEsT0FBWUEsR0FBRyxDQUFIQSxPQUFXQSxHQUFHLENBQUhBLElBQW5DLEdBZEs7O0FBQUEsZ0JBZ0JBbUUsR0FBRyxDQUFSLGVBaEJLO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtCQWlCQ25FLEdBQUcsQ0FBSEEsT0FBV0EsR0FBRyxDQUFsQixTQWpCRztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLG1CQW9Ca0JxRSxtQkFBbUIsQ0FBQ3JFLEdBQUcsQ0FBSixXQUFnQkEsR0FBRyxDQUR6RCxHQUNzQyxDQXBCckM7O0FBQUE7QUFBQTtBQUFBO0FBb0JDc0UsdUJBcEJEO0FBQUE7O0FBQUE7QUFBQSw2Q0F1QkgsRUF2Qkc7O0FBQUE7QUFBQTtBQUFBLG1CQTBCZUgsR0FBRyxDQUFIQSxnQkFBcEIsR0FBb0JBLENBMUJmOztBQUFBO0FBMEJDaFQsaUJBMUJEOztBQUFBLGtCQTRCRHVKLEdBQUcsSUFBSTZKLFNBQVMsQ0FBcEIsR0FBb0IsQ0E1QmY7QUFBQTtBQUFBO0FBQUE7O0FBQUEsNkNBNkJILEtBN0JHOztBQUFBO0FBQUEsZ0JBZ0NMLEtBaENLO0FBQUE7QUFBQTtBQUFBOztBQWlDR2xOLG9CQWpDSCxlQWlDaUIrTSxjQUFjLEtBakMvQiwyRUFpQ0gsS0FqQ0c7QUFBQSxrQkFvQ0csVUFBTixRQUFNLENBcENIOztBQUFBO0FBdUNMLHNCQUEyQztBQUN6QyxrQkFBSXpQLE1BQU0sQ0FBTkEsNEJBQW1DLENBQUNxTCxHQUFHLENBQTNDLEtBQWlEO0FBQy9DMU0sdUJBQU8sQ0FBUEEsZUFDSzhRLGNBQWMsQ0FEbkI5USxHQUNtQixDQURuQkE7QUFNSDtBQUVEOztBQWpESyw2Q0FpREwsS0FqREs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRzs7OztBQW9EQSxJQUFNa1IsYUFBYSxHQUFHLHdHQUF0QixTQUFzQixDQUF0Qjs7O0FBZUEsbUNBQXNEO0FBQzNELFlBQTRDO0FBQzFDLFFBQUlqTSxHQUFHLEtBQUhBLFFBQWdCLGVBQXBCLFVBQTZDO0FBQzNDNUQsWUFBTSxDQUFOQSxrQkFBMEJKLGFBQUQsRUFBUztBQUNoQyxZQUFJaVEsYUFBYSxDQUFiQSxpQkFBK0IsQ0FBbkMsR0FBdUM7QUFDckNsUixpQkFBTyxDQUFQQTtBQUlIO0FBTkRxQjtBQVFIO0FBRUQ7O0FBQUEsU0FBTywwQkFBUCxHQUFPLENBQVA7QUFHSzs7QUFBQSxJQUFNOFAsRUFBRSxHQUFHLHVCQUFYOztBQUNBLElBQU01SCxFQUFFLEdBQ2I0SCxFQUFFLElBQ0YsT0FBTzNILFdBQVcsQ0FBbEIsU0FEQTJILGNBRUEsT0FBTzNILFdBQVcsQ0FBbEIsWUFISzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hZTSx3QkFBd0IsMENBQTBDLGdEQUFnRCxnQ0FBZ0MsZ0NBQWdDLG1DQUFtQyw0QkFBNEIsK0JBQStCLG9CQUFvQix5QkFBeUIsVUFBVTtBQUNwVixpRDs7Ozs7Ozs7Ozs7QUNEQSxpQkFBaUIsbUJBQU8sQ0FBQyxtRUFBb0I7Ozs7Ozs7Ozs7OztBQ0E3QztBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQzs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7O0FBRUEsaUM7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUM7Ozs7Ozs7Ozs7O0FDTkEscUJBQXFCLG1CQUFPLENBQUMsbUdBQWtCOztBQUUvQywrQkFBK0IsbUJBQU8sQ0FBQyx1SEFBNEI7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0Qjs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEI7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUM7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Qzs7Ozs7Ozs7Ozs7QUNOQSxjQUFjLG1CQUFPLENBQUMsNEZBQW1COztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Qzs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLDJDOzs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QywrQkFBK0I7QUFDNUU7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUM7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTs7QUFFQSxrQzs7Ozs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUM7Ozs7Ozs7Ozs7O0FDVEEscUJBQXFCLG1CQUFPLENBQUMsbUdBQWtCOztBQUUvQywyQkFBMkIsbUJBQU8sQ0FBQywrR0FBd0I7O0FBRTNELGlDQUFpQyxtQkFBTyxDQUFDLDJIQUE4Qjs7QUFFdkUsc0JBQXNCLG1CQUFPLENBQUMscUdBQW1COztBQUVqRDtBQUNBO0FBQ0E7O0FBRUEsZ0M7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCOzs7Ozs7Ozs7OztBQ2hCQSx1QkFBdUIsbUJBQU8sQ0FBQyx1R0FBb0I7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkM7Ozs7Ozs7Ozs7O0FDWEEsaUJBQWlCLG1CQUFPLENBQUMsMEVBQXFCOzs7Ozs7Ozs7Ozs7O0FDQTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDLDZCQUE2QixtQkFBTyxDQUFDLHlGQUE0QjtBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsa0RBQVU7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLGdGQUFlOztBQUVwQywyQkFBMkIsbUJBQU8sQ0FBQyx5RkFBNEI7QUFDL0QscUJBQXFCLG1CQUFPLENBQUMscUVBQWtCOztBQUUvQztBQUNBOztBQUVBLElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkJBQTZCO0FBQzdCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxVQUFVLEtBQXFDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QWU7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4RkFBOEYsZUFBZTtBQUM3RztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUCxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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Q0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUVBQW1FOztBQUVuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsY0FBYztBQUN6QixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUFtRDs7QUFFbkQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FB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R0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUVBQW1FOztBQUVuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLEVBQUU7QUFDYjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBEO0FBQzFEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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MkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUEwQixvQkFBb0IsU0FBRTtBQUNsRDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzN1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyQkE7QUFFZSxTQUFTNEgsTUFBVCxHQUFrQjtBQUM3QixzQkFDRTtBQUFBLDJCQUFFLHFFQUFDLDZFQUFEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBRixtQkFERjtBQUdEO0tBSnFCQSxNIiwiZmlsZSI6InN0YXRpYy9jaHVua3MvcGFnZXMvcG9ydGZvbGlvLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuZnVuY3Rpb24gSGVhZGxpbmUocHJvcHMpIHtcclxuICAgIGNvbnN0IHsgbGFiZWwsIHRpdGxlLCBzdWJ0aXRsZSwgZGl2aWRlcl8xLCBkaXZpZGVyXzIsIHBvc2l0aW9uLCBjbGFzc05hbWUgfSA9IHByb3BzO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8aGVhZGVyIGNsYXNzTmFtZT17YGVsLWhlYWRsaW5lICR7cG9zaXRpb24gfHwgXCJzaWRlXCJ9ICR7Y2xhc3NOYW1lfWB9PlxyXG4gICAgICAgICAgICB7bGFiZWwgJiYgKFxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJlbC1oZWFkbGluZS1sYWJlbFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPntsYWJlbH08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAge3RpdGxlICYmIChcclxuICAgICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJlbC1oZWFkbGluZS10aXRsZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPnt0aXRsZX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8L2gzPlxyXG4gICAgICAgICAgICApfVxyXG4gICAgICAgICAgICB7ZGl2aWRlcl8xICYmIChcclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkaXZpZGVyIGRpdmlkZXItMS1yZXZlcnNlIGRpdmlkZXItMS0xXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkaXZpZGVyIGRpdmlkZXItMS1yZXZlcnNlIGRpdmlkZXItMS0yXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAge2RpdmlkZXJfMiAmJiAoXHJcbiAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGl2aWRlciBkaXZpZGVyLTEtcmV2ZXJzZSBkaXZpZGVyLTEtMiBkaXZpZGVyLXNpbmdsZVwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgIHtzdWJ0aXRsZSAmJiA8cD57c3VidGl0bGV9PC9wPn1cclxuICAgICAgICA8L2hlYWRlcj5cclxuICAgICk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEhlYWRsaW5lOyIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJztcclxuaW1wb3J0IHsgQ29udGFpbmVyLCBSb3csIENvbCB9IGZyb20gXCJyZWFjdC1ncmlkLXN5c3RlbVwiO1xyXG5pbXBvcnQgeyBUYWIsIFRhYnMsIFRhYkxpc3QsIFRhYlBhbmVsIH0gZnJvbSBcInJlYWN0LXRhYnNcIjtcclxuXHJcblxyXG5pbXBvcnQgcG9ydGZvbGlvIGZyb20gXCIuLi90YWJsZXMvcGFydGVuZXJpX3RhYmxlXCI7XHJcblxyXG5cclxuZnVuY3Rpb24gQ2FyZHMoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIDxUYWJzIGNsYXNzTmFtZT17YGVsLXRhYnMgZWwtdGFicy0xICR7cG9ydGZvbGlvLmNsYXNzfWB9c2VsZWN0ZWRUYWJDbGFzc05hbWU9XCJhY3RpdmVcIj5cclxuICAgICAgICA8VGFiTGlzdCBjbGFzc05hbWU9e2BlbC10YWJzLWxpbmtzICR7cG9ydGZvbGlvLmNsYXNzfWB9PlxyXG4gICAgICAgICAgICB7cG9ydGZvbGlvLm1hcCgoY2F0ZWdvcnksIGNhdGVnb3J5SW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgIDxUYWIga2V5PXtjYXRlZ29yeUluZGV4fT57Y2F0ZWdvcnkubmFtZX08L1RhYj5cclxuICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgPC9UYWJMaXN0PlxyXG4gICAgICAgIHtwb3J0Zm9saW8ubWFwKChjYXRlZ29yeSwgY2F0ZWdvcnlJbmRleCkgPT4gKFxyXG4gICAgICAgICAgICA8VGFiUGFuZWwga2V5PXtjYXRlZ29yeUluZGV4fT5cclxuICAgICAgICAgICAgICAgIDxSb3cgY2xhc3NOYW1lPVwicm93LWNlbnRlciBtYi0tMzBcIj5cclxuICAgICAgICAgICAgICAgICAgICB7Y2F0ZWdvcnkuaXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Q29sIGtleT17aW5kZXh9IHhzPXs2fSBzbT17Nn0gbWQ9ezZ9IGxnPXszfSB4bD17M30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInBvcnRmb2xpby1pdGVtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPExpbmsgaHJlZj17YC9wYXJ0ZW5lcmlfZGV0YWlscyR7aXRlbS5saW5rfWB9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInBvcnRmb2xpby1jYXJkXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImltYWdlIG92ZXJsYXktaW1hZ2VcIiBzdHlsZT17eyBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoJHtpdGVtLmltYWdlfSlgIH19IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRlbnRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj57aXRlbS50aXRsZX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGgzPntpdGVtLnN1YnRpdGxlfTwvaDM+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZSA9IHtjYXRlZ29yeS5jbGFzc30+e2l0ZW0udGl0bGV9PC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0xpbms+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9Db2w+XHJcbiAgICAgICAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgICAgICA8L1Jvdz5cclxuICAgICAgICAgICAgPC9UYWJQYW5lbD5cclxuICAgICAgICApKX1cclxuICAgIDwvVGFicz5cclxuICAgICAgICAgICAgIFxyXG4gICAgKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2FyZHM7IiwiXHJcblxyXG5cclxuXHJcblxyXG5jb25zdCBwYXJ0ZW5lcmlfdGFibGUgPSBbXHJcblxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6IFwiQ3VsZXNlIGRpbiB0b2F0ZVwiLFxyXG4gICAgICAgIGNsYXNzOiBcIkN1bGVzZV9kaW5fdG9hdGVcIixcclxuICAgICAgICBpdGVtczogWyB7XHJcbiAgICAgICAgICAgIHRpdGxlOiBcIkhvdGVsIFN0b3BcIixcclxuICAgICAgICAgICAgbGluazogXCIvaG90ZWwyXCIsXHJcbiAgICAgICAgICAgIHN1YnRpdGxlOiBcIkJyYciZb3ZcIixcclxuICAgICAgICAgICAgaW1hZ2U6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvaG90ZWwyLmpwZ1wiLFxyXG4gICAgICAgICAgICB0aHVtYm5haWw6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvaG90ZWwyLmpwZ1wiLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aXRsZTogXCJMZSBQb21wb24gUm91Z2VcIixcclxuICAgICAgICAgICAgc3VidGl0bGU6IFwiUmVzdGF1cmFudCBGcmFuyJt1emVzY1wiLFxyXG4gICAgICAgICAgICBsaW5rOiBcIi9yZXN0YXVyYW50MVwiLFxyXG4gICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9yZXN0YXVyYW50NS5qcGdcIixcclxuICAgICAgICAgICAgdGh1bWJuYWlsOiBcIi9pbWFnZXMvcGFydGVuZXJpL3Jlc3RhdXJhbnQ1LmpwZ1wiLFxyXG4gICAgICAgIH0se1xyXG4gICAgICAgICAgICB0aXRsZTogXCJFbmdsaXNoIENsdWJcIixcclxuICAgICAgICAgICAgc3VidGl0bGU6IFwiQmFyIGVuZ2xlemVzY1wiLFxyXG4gICAgICAgICAgICBsaW5rOiBcIi9cIixcclxuICAgICAgICAgICAgaW1hZ2U6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvYmFyMS5qcGdcIixcclxuICAgICAgICAgICAgdGh1bWJuYWlsOiBcIi9pbWFnZXMvcGFydGVuZXJpL2JhcjEuanBnXCIsXHJcbiAgICAgICAgfSx7XHJcbiAgICAgICAgICAgIHRpdGxlOiBcIklyb24gV2lsbFwiLFxyXG4gICAgICAgICAgICBzdWJ0aXRsZTogXCJmaXRuZXNzXCIsXHJcbiAgICAgICAgICAgIGxpbms6IFwiL1wiLFxyXG4gICAgICAgICAgICBpbWFnZTogXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8yd0NFQUFrR0J4TVRFaFVURXhNVkZSVVhGeFVZRnhjWUZ4Y1ZGeGNYRlJZV0Z4Z1ZGUmNZSFNnZ0doMGxIUmNYSVRFaEpTa3JMaTR1R0I4ek9ETXROeWd0TGlzQkNnb0tEUTBORlE4UEZTc1pGUmtyS3lzdExTMHJLeTByTFNzckt5c3JLeTByS3pjdEt6YzNMUzByS3pjM0t5c3RMUzB0S3lzckt5c3JMUzByS3lzcksvL0FBQkVJQUxjQkV3TUJJZ0FDRVFFREVRSC94QUFjQUFBQ0FnTUJBUUFBQUFBQUFBQUFBQUFFQlFNR0FBSUhBUWoveEFCSkVBQUNBUUlEQXdnRkNBZ0ZCQUlEQUFBQkFoRUFBd1FTSVFVeFFRWVRJbEZoY1lHeEJ6S1JvY0VVSTBKU1luS3kwU1F6WTNPQ2txTHdGVU96d3VFbFU4UFNSUEUwZzVQL3hBQVhBUUVCQVFFQUFBQUFBQUFBQUFBQUFBQUFBUUlELzhRQUdSRUJBUUVBQXdBQUFBQUFBQUFBQUFBQUFCRUJJVEZCLzlvQURBTUJBQUlSQXhFQVB3RG1ibW9XTk5zUnNTNEQ2eSs4ZkNoVHNtNTluMm44cTZJQ3pWNW5vbzdNdS9WQi9pSHhyVC9EYnYxRDdWL09nQnZIV3ZGcVRHMkdRZ01NdmZXaVVIb3JZVmdGYlJVSGdhdmMxZVJYbEI3TlpOWUt5S0RDYTlVMTRSV0NnbFZxS3RZaVA3LzVvS3RsYWdZTmllUFo1bjM2MEhkdUU4ZXorelhoYnc4Zk0xRzlCNHoxb1dyMGl0WW9QQzFiMjdrR2EwSXJBS0N5YksybmsxQmoyYW4yUkc3dDlwb25hMjFtY1NkWjA3QnhNbldPNFZXVnV4Qkh4TlN2ZG4rL0dnZ3hEMFJnam9LRHVVYmd4MFJWQzB0dnJBMWVOdlBmWGdvSlVhcFZlb0VxWmFDVVhLMlY2akZiZ1VCdUd2Vlk5bTRpQ05mR3F0Wk1mM3JSMXJFUi93RGU3dDBxQzUvNGgyaitZL0FWbFZoTVlZL09UOGF5aW4yMHJPcHBZeVUreHl6U3U1Ym9Bd2xUMnJOYnBib3UwbEE0NUxjajJ4bk9GYnh0Wk1nZ1RyT2ZYUTlsYThxdVJUNFMySGU5emdPNFFlc0RXZStyaDZMUC9rRDl6LzVmeW9uMG9wT0dIWWY5eVZMeU9MWE5uYWtEV0Nmb3FmaFVaMllPei84QW12NVYxVDBWMmxON0VobEI2TnNpUUR4YnI3NnQ3M0xRZlhEaUFTUFVUWGhTajUxdTdLSDJmWkhsU3JINGZJeWlCclBYd2p0N2ErbmVVT3pMUHlkbUZwRmFVMUNxQ0pkWkVqc0pGZk5tMlZtNmc3RDdTZGZJVmMwRFdzTUNPM1Q0ejhLbFhCQTlkR3RoeXF6Mmp5UDVWdll0RmpvS0k4d1d3T2NCZ1hHaUpLd1ltZCtuWldZams4VjRYQjNxUHpGZFo5Q1lnWXIvQVBSLzVxazlLZHVYdG43dy9vRlNxNHgvaGYzL0FPUWYrMVJ2czZPSjhWSThwcnVISi9rRmhyK0d0WFdOd002S3hnaUpPK05LbDJoNk5NTXFNd3VYZEFURXJ3OEtVY0F1SUFZbjNOK1ZZdUhadlZFOTMvTk10dDRjREVHMkI2dVllQVlnZVZGYkt3NWt3T0lING9xb1IvSkgrcWFtR3pMa0E1UkgzazhwbXJTY0ZjR2FVZ0F4SklNOVVDYXYyTjVPWWRkazJyNjJnTHB3OXBpMnM1amJrbmZHK2xWeFU3T3VmVVk5d0o4cTFPQmY2amorRWo0VjFIWUhJRjhaYmE2aldsQWRsaGdaNk1kUTdhMDI5Nk43dUh0TmRkclJWUVNjdWFkQVR4QTZxVkhMK1lJM2oyZzFtVThQNzdxSnQyNVo0M0JtQTdwTk5iR0RtSlhTQnFBcE83cUpIblZGZXVXajIrTkY0Vk9pUDc0bW1HMzltWE1PTGVkVlhuTXhBNkphRnk2a0RkNndpbFdkbEFnd0luM2tmQ2dCYTNxYTFLMWZiWG82MmhjUFJ3UnluVU0xNjBvSU81dlduVWEwYnMvMFVZcDhRTEYxN1ZvbE9jSlZtdXd1YkxxSVVUUGJVbzV2YVdwd3RkYnRlaGpNck5ieGVvWjFoN2NTVVlydlZ0QVNKM0dKNDB1dmVpREhxZEJoM0hXTHpBK3hyUTg2WEJ6bFZxVzJsV1RGY2tIczNlYnV2bFlIcEFBTkd1NE5NSHZpbzhKeWR2a25KTDVRQ1N0Z1hQYUpQdkZBaENSVzRvdmEyQnZXaUJjSVdkd05ubXllN29WdHNiWVdMeFJJc0liaFdKaGxTTTA1ZFhLalhLZlpRUWhmN212YWJQeVUyZ2h5dFp1QWpoblhqcndhT05aVGdXREVOUVZ3MFJkYWhXcUs5UVZNTHFydklIZVlxRkswMmd1Zzd6NVZSMG4wVjNWTFlqS1FkTE83dnUwMTlJNnpoajNIOFNWVmZRMENNUml3ZU52RG4yRzZ2d3E0OHZsbkROM041VDhLejZLMTZMOU1SZUhYYXRuOFA1MTBxdWFlamJURjNSK3dYM2MxK2RkTHBvQjIyczJYL2g5ekxYekR0cEl2Mi80dnhDdnFIYWcrYWJ3OHhYelR5aXN4ZnQ5Ny9pRlhBWnREb1dzMEdDeWcrL1V6WHVBdzczRlowQzVFSFNMUGJYZXJFUkxhbUViZE9vN2FZWXZIV3JlR3Vod1h6MjhneUZTeVB6bHRsZUNlQlhkVnhYSFdNWnNuNWFiTmtYVlYxdUVJaU5uUU1NdVlDUUNjcDhSVkRyMGFiQ3Y0VnNRTDZCTTRzbFlaV25LYnMrcVQxaW9QU1piazIrL3pWdnlxd2NsOFZoYmt0aGxWUTF1MldDcmw0dEVqZDliZFNmMGtKK3BQMng1UFdmUTk1RmYvQUlPSCs1OFRUUGFBK2FmN3JlUnBYeUpQNkRZKzZmYzdVMnhnK2JmN3JlUnFENW4yNWIvNmd3KzAvd0RxUFRGTFdRZ2dUMDFuaEF5dnJRbktBZjhBVVcrL2MvMUdxMFliQUk5cHlmMWdhM3pXcEF6RVhDMGpqMFZPL3ZyWVNZbkczQ3pIbW55aEZhVElHbGtQQjAwNnUrcjVzZmJ3eHV3M0l0NURaQnNsYzJhZWJ0Q0dtQnZCR2xPdmtscHNOdEJiVEJnNjNFbk9IRUREcmxPbmVmR3VlK2l1NlRzN2FWdmdDSC9tdE9wL0FLZzZQNkx4K2kzUDM5enlTbUhMeFp3Vjc3ai9BSUdvSDBaajlHdS92My9CYnBueXpXY0hlL2R2K0Jxbm8rYzlpV2N4dUQ3YmVacDBpdW1vVU5HV0JtQUowR29rZGZiUVBKZTNMM2Z2dCtJMTBYYXV5N1NZVzFmR0hXNlJZWm5XV1VzRVZ1cnc5bGFIT2VYVzBUZU5nbFdVcXR3RU1JNG9OQ05ENnZDcS9mOEFWVDdoL0c5TitWdUxGeGNPUlp0MnRMcCtiWjJEQmpiSUJWeWNwWFhVSFdkd2lrK0pib3ArNy8zdlZIZWZTTnlpdllYQVdId3Q0SThvclFMYmtBMmlkUTRNYmh3NDFKeUs1UzIydzV4bUp1ZzNPWnNxNWpwRTJyZWU0MlZCcExPVG9JM1ZRTnZiQ3ZwZ2NSZXVFS291b0Z0NUZCYlBEYzZibTg2RUNKTzhuU2FyQ2JWYTNoTEsyM0lMOC96dVpuTnNBRElxaTJEbHpFSU5UTzllcXN3ZCs1RTdidFgwdkZTWUQ4NW1JSUJXN0pEQ2RZbFdIZ2FiN08yN2g3OGMxZVI4MmFCTUU1UXJNTXAxMERxVDNpdm1XenlpeEpWYkNNZ1htMVNPYlNjcXRuRXZHZjFpZHpEZlZ0NUZZZTlpTVhhdDI4VmlMUTV2TXh0dVBteVN5RUtyU3U2M2JHb21JN0tRV3piMnlyMS9GM2JscTJ6b0hLbGhFQXFZWlo2d2F0SEpYQW0xY1ZXUUkzeVczbkdrNWhjdVNURzg2NzZtNUc0WjdWaTlidU8xeGx4R0lCZG96UDB5UXpScEpCQjBwcGJYOUpKL1pEL1Vhb09jZW1YQVo3MkZJK3E0OTRJK05KZVRlMlA4TncrTXhCVkdjQ3dxSTMwM1pyZ0VHUVFCSkpqV0JWdjlKZHFjUmhEOW05L3NxcWJld2FteVErdnpsczVkTllGeldJMTN4djhBcFZjNkZIeDNwRjJqY2RuT0lDendXMWF5aUJFRE1wTWQ1TlpRT00yRXdkb0FqczNkb0haV1ZvVytlaU80VkdUVzEwNlVQemxRVGh3QVNkQU5UNFVGdERhRnRndVYwT3AzT2s3dTFxTXROV20xRDBWNy9oUVhiMFEzRk9JdkZRUURhVWE2emtmckJJK251bWZhS3UvTFJKdzUvaS8wM3FoK2lHNlRpcmdKSitaYmVaL3pMZGRDNVZMTmcveGY2YjFuZXhWZVErRUZ2RWk0Vy9Xb2JRWHFLaFdudWkyUjN4WFFxb25KRncxOUZJOVZXWWQ4UjhUVjdwb0gyaCtyYnU4cStmdHZZV2NaWlhydU1QNjFyNkJ4NCtiZjdyZVZjVDIzYWpIV1QxWEx4L2xHYjRVd2MvMnFodVl4OG9rbDM0RS9XTzRBbXI5eU53bjZGaXNJN0VNeUxpSUdZWlFDRk9aQ1FkUnpaMUc2ZW9UenA3ekM4N0t4VWlla09BWmdwUDhBVlhUZGhZQkxESmRRRE5sS25VOU5YWEtRNStrVE84enJXaFlQUXBpU1V1b1loRlNOMGpNOTNNQ1FKUFNCT3N4T2xQOEEwZ1c4d3NqN2ErK1JWWjlEdDM5SnhhNlRsdHMwZldaN2hJOS92cTI4dFVrVy92TDVtcDZEdVNOc0poMXRDVHpjZ0UvU0RFdFB0Skg4TThhYTRyMUcrNjNrYVZja25uREl4OVk1cDhIWUNtdUkxUnZ1dDVHc2pnVzE5bG8rT3VPMkpzMlN0MjZBajg0V2Jwa3lvUlRwckhoVEhGWGVhQ2hieUhwQnBWYjRKeXBjVWhTMW9BZEc0eGtuaFN6bGpaamFRN1h1ZmlxZmI1S29wQmoxNTdzaDMxc0p2UlliZ3gxMTdkazNSekYxWGdsTWl0RFppdys1RUhmSjQxNXlLMjIyRnU0ckRpeTEwNGlMUUFZTERBM05USU9rWmoyUWFmZWhXeTNONDY1YlpFY2hFelhKeWlGWXhvZENTL2I2dTZnZVFGdGY4VnhLc0FUekdJZER2aHVqREwvQTdqdU5RZE81SFg4UmJ0RmJlRUJ6TVhKTjlSMHN0c0dPaWVHWDMwWHlseGVMYkRYUTJGUlZLUEpGOE1RTWpTUU1vblRoTkhjakI4eTg4SC84ZHVqdVVhemg3byt4Yy8wMnFENSs1Tm9SY3U1QVdPZHB6QUxCazZBaGpOV3pHOHZoWUZxeTl0SE50Q3JLcHpHR2taWERRQVkxZ0U2RWRZcEZ5WXRSZXZqOW8zNGpWZjViWVlMaURjVWFFdzUrM0xRUDVBUFlLMElkbzM4UGNDWm51ckU3clNHWmo5cnB1OTlEM3JlR0tyTjI5NnBBK1pVNlptL2E5OUxieDBIaldYRG9PNzRtcWpvKzNPVkh5dkNYTENxUnpmU1l4RW0ydVg2eGdkRThLb3VCc0c4cVdvSUFMUVZoaVNXM1pTVjRrY2FzUEo2NW0rV3JCSDZMZU84R1dVazVob0kwZ1JydW1kWUFmSWpDYzR6U3hWVUw1b01Gc3lvRlFuZUJNblRmcUtpcGJkcXpiQVZyempMS2o5SFVuZWZwQy9yTTlRcHR5Y3hpWU85emxtNjVjNVZ5M01OQVAwd05NUXU4ZjNOSjlzNEZMVGdxSUFPYU9ISGg3Nm41Vk9YdUpseUFoRXpFa2dsZ0dqY09wdktndVcxT1VHUFNMb2ZJTGpYd3FyWlhKY3VQYURFTkdLSmxWRXFkSUpNNXR3NlpzTEZOZEZxNDBabnc5dG1qY0N4SklIalhFTG1PdXVMRmkzYVJpZzV4cm5PTGZRQzZtWFNWQlJwUmcwZGNkdFBkdTh0NzlxeUZzdmJ0RVcwdEVyTFhBQVNTeW4xVjZ0eHFRVzcwbVl0TFZ6RHRjWUtvVzZTVDJaTjNFOXdybG0zK1dYT0FwWlNGK3MyckdDQ0NBTkJxQnhOSWNYdGJubkRYcmx5NjI3TmNkbklrOE14TURzb20zaGNySzNOeUFRWU80anFxd0FOdE82VEpZK3dmbFdVOVRFMm8xdyt2OFA4QTYxbEJCZzlzdmV6VGJ0SUJIcUt3SkpuZVdZMXMxd3pRT3kwQ3FSSWtrdG9RZE5CR2g4NkpuV2dZNFpxOTJxL1JYdjhBaFZWMnRqN3FYWVZ5b2dRQnUzYW4yelhscmJWLy91ZTBLZmhRZFU5RDkzOU9JNjdGejNQYU5kVDVRa2MxcVFCSjNrRDZEZGRjWTlET1BlNXRNWjJKK1l1amNGRzlENm80NmI2dG5LajBWSmlMalhXeExkSzVjYnBXMWNqblhaOHVaajZvbUFLbTloanlieFZsTVFwTjIyT2d3UFRYdDdhczJJNVQ0Skp6WTNETDMzclE4MnJtR3ovUTloMmNLK0l1d1puS2xwVHBPNlZicXF3MmZRM2dWL3pjVWY0N1kvRGJGVGdXY2NxY0ZlVzZsckYySElSaWN0eFNJamZNd2ZDdVljb3NWWk44c3QyMDVVWWs5RjFZNnBBM0hyTlhpeDZOTm4yczdsSHV5cEFXNi9PSUNOY3dCK2wyMXp2bHR5WnNXR3ZPbHBWWExOdUpBVWwwQkE0Y2RPdzFjSFBMUUJXLzlZaEFCeE0zRlkrNWFiN0EyemVSN2EzSGJtVlBHREFBTWF4bWpzb1RaK0Z6WVRGWElsaGN3NnFRSkkxY3RIRVRJbWdzTTV0M0Zad3d5bVlpRHUwMFBoV2tkTDlHVzNzTmhjWGlybDI2eFc2QmxPUzQ1SkZ4aUFBcWtnQlNOOVhIbEJ5Mnd0d0RLdUpmVUhURDNSdUorc0JTYjBWRWY0amZLN253dHQrd2t1RkovcDk5ZEsyc05QQWVkWTN0VkgyTnkwUkxkdFZ3TzByaEJPcVlRbGRXSjlZc0J4cHZjNVkzV1ZndXl0b2JqNnlXazhkYmxOOEhkVlFvMTZKTzZPM3JQYlJGN2FJeWtRZFoza0RmUWNUNVFOaWIrT0REQTNRd1c2L05GMERFU296U05OR2RKRzh6NDBtMjd0cThWZTFjd3h0RmN3SnpoaURxcEJBQXErY29NUy95OE5aYUcrUzRtU09sRXZoNFB0QTlocXE4djdRRnByazlObUtudDFrazl1NnRCUHlJNVRZakIyM1d4elk1NTVZc3FPWVFCUU9sY1FMdmJlVFBVT08rekx0eTFqTTF0bVRFdGJJRTgzbFpHdGlRb0MzQVRrRStCcXQ0TEc4MHFuTU0wemxLaHhCNndmNzd0OU9OamJlRGJTd043S0VDUGg3YkVrS0NQMWJQMUlJYmRKaU45RVhma2g2V0xlR1c0bUw1eTZTd0tHMjJHYUFGZ2dtYmZVTklQSFhoVG5IZW1qQVhFWkJaeE1rTVAvamNWSS83L2JUcCtVV0ZFNW5zSHIrZHc3Nng5bHlhVTdTNVQ3UGpVNGJ4UzYzNGJCSHZyS3VlYkw1VDJiZDI2K1M2UTdsaEhOU0FUT3Z6bStrL0tESEcvY1lvR0NGODhOa21jb1hnVHdIWFVYSzAyVGZEV25SMFpwSlJDaXJMSG81VHZnUnJBMzBtUlZuVlJIZFcwRjM3TFFORHBRejN1SHhINTE0OXRRWWdiK29UQkEwbXZTQkc0VURiWTIyYnFPeHRXYythM2NSd291UEszSmxpRkc4QTkyZ3JUWSsxWHNDNlVnZ2xRUWVNNWpvZUI2STk5TkxXTXc5bnAycmpJM05sV0RnL3JUYmlWSUV4dkc0NmtIdHF0MnRjNEc3b24yU1BqUVA5djRyUFpSOTJheXA3dWpCSHVOQzROcnIyMVlzU1lneU0waFFGVW1RZHdVYTFvQm53eUtENm91SVQxRTNIY0QyTUtnMm5kSnQ0Y1pla3R1MnV2SHBQRUhxMGp3aW9xNTdTeGIyc0hoMUFQTzNiU0Zva2tBam9vc2trRFVtTzJrbGpaOTNtcjNPSkx1RnlhZ2tRU1RKNGNQWlZ4eFFVNHBnZDlxMmlyMmFRZkwzMHZ1M2VtdzBnR0k0eGxuTlBWT2xCV3RpM0xhZEIxVlgzRWxBVzlwL0ttdUZ4L1JnbE5OQk84eHA4UGZTZmxXQUdSbDBZeVBaQi9Pb2R1cjBNTTIvNXRaN2Q5QlpQbHEvcy9kK2RaVkp5ZGNUMkd2S29OUm9PaHBuaDdaTlY3bnRhc1d6Y1dNdEVTNHZBQzRoUTlXaDRnOERWV2ExbFRLZEdra2p0QnlnVC9ON2F1SUN2eEk4WXBOdFhZbkZLS3NIb1hiSnRPMldJRXBkRy9YMUMybzRlclgwQmpNVUN1Z0pnZzZDZDNkWHl6c25hbHpEc1d0c1ZaSktzck1wR1pZSWtRZVBuUmQvbGxqSDMzblBmY3V0NXZXZHdkLzhBbGJBL3FyNDdlYXVEMzVZckx1MlFQV2tmZXUyMC9HNHI1d3ZiWXZOcVdFOXdQNHBxUC9FcnYxejRCUjVDa0gwSmUyL2FQMDdQamZzdCtCbXFsOHY5b2g4SytWN1RETWdoR2Rvbk1kY3lLT0hBbXVXTmpycDMzSC9tYjg2WVc3NStSUEpKTFhnTlRQcVd3ZVAzNlFOK1NlSlczZ3Iwc3VjM3N3VXlKVkVVUk1SSjFwdGhjVGJ2S3dkY3ZSQUtzQkFJVEt3dHpPa2thZTg4T2ZiT0FMYXhFTnFlNDEwSEM5RENtOGRVdDJ5NlRxSkdvN3lMZ2dkaVJ1YldnTGtmeTBYQXNqaTJibnpUMm1CdUZTZzV5Vk9pR2RGSEFiNmY3UTlMb2NRTU92aTkwK1JTdVRacEpna2daUUpBRWRrRFRTVDU2VFdUU0k2QmM5Sjl6Nk5tMk8vblcvSGZJOTFBMy9TUGlUNnFXVjdyTmlmYTFzbjMxVEt3Q1RBQkpNQUFha2s3Z0J4TklMSy9Mdkdra2k1bExieW9WQ1kzVHpZV29OcTdYdlg4SUd2WEdjODh3QlptYlFJaCtrVHhKcURGN0t0MnJVdTd0ZGd1VVJSbFZBUXVabVAwY3h5NW8xUHFoaERtTGFHbUZzQ0NKNXhvSWc2c1FEM1FCUUNKWUtybnlwMFlKSmJWZzBBQUE5WGR4NDZWcGVZbkswRUxtRUhXUG9uUW44Nmt2M3dJNXRWNmhtQWU1UDNXMEhZUXZqVU4xTGpocmpGbXk1UVN4SmpNR0lYWDdwMDdLbzhlNHgzc1Qza21vaUsyWTFvYURhNGVoNC9sV3R0dDFiQkpWdXlEN0ptbzdXN3hvQ3IvQUszZ0szVFJXZUFjb0VBN2l6R0JQWHhNY2NzVnBmRXdSd0VIczE0OVZUT3NXQnBxOXcreTJvQTk5MXZaUUhjbk5tVzdsOUZ1a3RKRWlZSjZMR0NkL0FibzMxQmhjR0d4TDIxS29Qbk5UT1VCRFBrdmxSZUU1UUd5b0ZvU3dJSk1MR2FBTldJazl3cFpoTHg1OE13MU9lUnFvaGxhUjE4ZE8yS0NYQjU3YmtNT2l4eXQ5bGxJRXh2MExRZSttMnpTRGZ0MjJVSE9MZG5kTU1NU0xnWVF3alF3VHJ4ME0wTGlRSUlNbk9FNlhWb0NKN1RHdmQxekpISk8vbnhtRkJFa01DZEQvbDIyYWUvbzFBeDVUN1ZhM2pIZGVzZ2pnUk83M1VUWng5dTRBUmZ0S1NOVll2S25xYUVJOWswajJrNHVZcHlkUVMzdU5laFFOMjZpcGRwWVFzU1M5cCtySVhJQTR6bVVkbEwzdzl3d0d1U0FJQU02QVVjbkh1clVtaUFma1RmV0ZaUjAxNVFWclBSZHJFUlE0dHpSVm5BRTFRWmhjYVJ4cDNoY1VHRUdrZ3dCb214YksxQkp0VEJnS3hHK1BDTlorSHZxdmlya3E1MElQVWFxZUxzNUhJb3FLc0ZlVFdUUkhzMHl4V21EdGZhZTYzdkNmN0tXVFRIYXhpeGgxL1prL3dBN3UzKzRVQXV5eExxSXpTRHBKRTlFOFJWNXZLVHN1N3FWQ20yTWcxa0M3YVZpRHYwQ01JNHpOVUxBazV4bEVuV0FCSkpnNkFjYXV0dmFUaloxMVNqSXloTXpScFBPV3dvWWNEcjVmV29xblloQUYwVnhydllRUERTaFpwbGFTN2lHRnBkU1R4TUtJQkpKSjNBQ2FhM3NQaHNNaFVIbnJwRVo0Z0tUL3dCdGVIZlJGZDVoL3FOL0tmeW83WlYxc1BlVzZ3aGx6RlFTb1lFcVFHS0hwYVRPbzRDZ0xxYXpyVVVBRFFWUWZ0amJWeTlmdU1IS0srUlFvOVVMYlhLZ0EreU4zVVNTS041VzRvTzFzaFZWY2dLcXVpcXYwVkE2Z0FLUVc3Y21OY3hJalNRWlBFenA3NnRHSTJBMklqbXJpTTZxcW0xTVhBRlVhcURvL2daN0tDcW1TSjNkVURqVGJGc0JoYllBam5iclA0VzdhSUIvTTF5Z3IrQVpHQ3VDdXZySFJkRHJ3MFBZUlBaUkcySVUyN1kzVzdTRHhlYnAvd0JRZXlnQ05hbXNyeWdud24waDlrK1gvTmIzTU0yVllCK2NaZ3VtK05JSHNQdHJiQVhrVldtMldZa1EwdENnYWtaVjN6MWs2UnBXeVlxNU5zQWtpMW5aUndXWUxOUUFYb3pFRFFDUVBENDFNU2ViRWtrRGQzdHc5eG9mUERTWU9wUHRvekg0cG5WVk9VWkFxNkFEMVFScjFudE5CbUJ2b0grY01MRTVocVJ4alNpOXFPcHZRdWloUUJ3SjZPa3h1T29vSEFtV1VBZEtSSEdETzhqcXFYUG1lNGQ4azl1bWFSNUNnYllqR0Y3RnBRUG9rYnRjd015VDFFTVIvRHcxcHR5SndvbjVST3RzWDRHbkN5QUQxNzNJOERTbXdyTmh5MENFdVEybXVWOVluaHg3NWpxb3prZ0dOeTZmb2l5Mm5WTElmTlJVQUgrZWU0MFZRVnRwdm51YWpDYURkT1BkV2hyMUR2N3ExSm9OcXlzRlpRQWJQd0hFMDBXQlhpNkNLMVpxQ1hQWG9xRE5VcVVCR0h1d2FRYmJNdk5PVFFPT3dtZmN5OXVabFFEeGNpZkNhS1JUVDdBYk1YNUhkeEpDdXdZS3F0bXlxTlFYT1VpVE9nbVI0N2xkL0JoUWZuclRFZlJYbldKN201dkovVlR6RmJRWk5uSWpsYzl3cmtRQUFpeWl3cnZIRmpxT0ozbWlLMng0ajJkUnBodDFTT2JUNnRxMFBaYldhV1dydVhlQXc0Z3pCOFJxRDJpbTIwb2ZFTEpJVm1RU05TRk1EVHdxaGRZZ05xWUd1dlNId3EyYkpmQ3BoK1phNGx6TVZKUlh5am90blVPU1FTUVowSFdZTkxObzRmRGd4Ynp6OS9NQjNtTlQyQ2dEaFFlUHRBTkFadE1YUmNOeEZkVm5SUXJCQUlpQU54SHNwYllkaVNXR25FbWE4YkJpZEk3NGlPMG1kS2l0NFRNV2hnU29uY2RkUU5KNzZBaTdlUmp2Q2lOK3JUMndLSGhQcm53VWt4MXcwRDMwd3Q3SlZGRFgyWlo5VzJJNXh1OFIwUjMwRGVhMnBib0VRRzBtU0RCeTVpM2JFZ2NKM0dnOXQ0aEVJS2htTU1OU0YzcVJJVUJ0MHp2NFY3Y3hyRitjQXl0dkJFNmRSRW1yR2NHbHZEQzJxcTk1d2MyOGszQW5PdHUzSlpSbFhLdnIzRzFuS0FVRjhNVTZYcjIyWkc3Q0NmOEFrZUZCSmV4OS9GTWx1N2RlNW1aVkVtZDVDekFHK09PL1N0YjJIdVlpL2NOcEdlWGFJR2dFOUVUdUhSamZXMnhuaGkrZzV0SGJ4QzVWL3FZR2diYlFwRTZIZU5QN05CWnNENk85b1hCbUZwRUhXMTIzL3NMSDIxSHRIa0ZqYklseFpqOS9iWDMzQ29wSloyamNRRVczWkorcXhYeXFUWnUyNzluT2JkeGxaNHpQUFRNYnVrZGZmVTVFdUgyVmpGSkZ0THdrYW0wV1pXQUIwTDJTVlBIU2VQYlVOelpsem5DQ2pXNFVtU3JMRUF6RTc5TklwNWhlVldOQ0hOZnpMcExzVXVzQ1pnUVphVDFidEtTYlUyamNZOUs4enNmV0dVSkhVRGxnVDFnU0IxMVFKZzhNV3VLckNKTW1SSFJVRm05d05SdkJKSmtTVHJ2SDk3Nk4yY2RMcm5YTGFZZU54bFR5WnFEc29KblBsUGo1MEJXelZDdG0zd0dhZnVxU1BlQlVXRkpBSkcrUnUwTzdUWDIxTmg3WUF1c0d6ZENOMGFzeWo4NmdjRUlzRGZQaWQva3dvSEd6WFpyVjFSdUpUTkpKRUZicXlmRXI0Z1U2NUhpTE9MWS9VdER3SmJUK21xenN2VU9yRWlVSkVINmFubzkyOXRlMnJMc0Ivd0JEeExkYm92ZkNrK2JWQlg4TWZuajNOUnhOTDhIK3NQY2FQb05sTy91clFtdGw0OTFhR2drQnJLanJLQ2ZQVUR2WGhhb2Job0lteEJKMG96QjNUUysxYk0wMnMyZ0JWRXpOUWVOT2xUTTlCNHg5S2dVUHhvM2FXSzU5a081c2x0STNBbEZDQ08rQlFlUW5nYWx3MWc1MTFBNlM4WjRqcXFpZkJZZGJkMWVlQWlDWU9vTytKamVKRzdqUkcybURnWEYzSHUwZzlsTWNUeWR2WGJpc3dOdTJVREJtSENUdUJJUGJPN2RKRWlvTVpoTFMyMnQyM0w1VEpiZU5RTkFZN1BmUUNxd3lodXNUV2pzZW85d0VzZnlIYWFFdFlrS0lNeU54aVk3aFVUNGduZko3eVRRVDMyWWpMQVViNGtlL1dUVzJ5MnlYVllOR3NhVHgwblhxTUh3b05yaDd1NnZEbVBXYUF5OWRZTXhZa3RPcEoxUHQxOWxMdzJ1dTRrRTlzSGpUREhKbVlINndCOFNOUjdacUY4QzRVOUNRWU9iaXNUT25iUHVvQzdlMXphY1hFVU13VjhoWWs4Mjd2bUYxUUNBV1hlczZBd1lNQ2hObXRPWlQ5SVQ0aWh5bW9MU0ZtTTBhZHNHdHNFckc2QmJCWXpvQU5ZbUpQVlFFb2N0cTcxc1VYd0VzZkphMFRCc2VGVDJTeTNobEtxU1lsMVIxRThTcmdyVm90WE1WR2d3VjM3MWhGOTl1S0NzMnRsTWQ4MTVzdkJaM2RUOUdQaVBoVnMrVTRqamdjTy83dTQ2ZTR1QlNqWjl1NVl1M2JqNGE4UTVKeXFKeWpNU09rQTB4TWJxaXBNUnNZMjFsVkFWTGIzU1FlTUxCSTdGWSsrcWc1Tzg4ZGZiVFRhV1BjdGNIU1VFTU1wbVlMRWdHUU9EZFFwWGNhWTdnUFpwVlFYY3NNcW9zRWM0UXdrUks3bDc5OCtOUTRqZVFOd3BoZDJpV3ZXV01FVzFVS09BeUtBb2orRmZaU283NVBFbWdrendJVW5wQVNQdEFrQWVSOGFkc3lDNlFVT1JUbGdha0JkQkdtK2xHemttOWJBK3V2c0RBbjNBMWRNVGdyVDZzZ0o2L2pRZS9JN1BORjFNQW8ydTRpUWVGUTdLZi9wOXcvV3ZON2tTb3lndGpLa1paOVU3dXZXcCtiQ1lBQWNiam55RlJWZHdSK2NQY2FZVUJnQU14NjQwK05IVVI2cDhxMXIwZkN0YUJ0Z3NOaHlnTHVRMnNqTW80bU5EcnVyS2syZGpjTXR0UmN0Wm1FeWNvTTZualBWV1VDRE5VVE5VYTNLMVpxb25TNVVweFZBNTYxTDBCcHYxNlJJb0ZXcHZzNWtCQnVUbEcrQUQ3anZvRldVVHVudjhBK0tzT3k4TW1HeTRpOFZERHBKYmhTZFJvV0REZnJQWVlPc1JYdC9FV1E1K1MyV1p6dUpVNVUrNkdKanZKcWZCYk92QWwzU3pkWTcrZFRuQjRTZFBDb3BmdFhsQTE4a3NXZ21jb0psdTEyM24rNGlsMkV1WEM0a1FwQkVEY0ozZStLdkdIUXFJT0F3N0RxVStTM1FRUENpQmR3djhBbTdPdlcrMjNtYjhMRlIvTFFjeStUbG55amZyRUNkM2RSUTJhUnYwNzlQT3BjVXd0WWxYRTVWdUE2anBaTTJzZ3hybDRhVjFEQlc4TTNxMzBQZngvbHpDcU9aMnRsSHFvdTFzcXVtcnNyREU2OHpQWDBWUHQwTkVyeVN3NzZqTU8xYmhiM05JcVVjZzIxaHpieU1PSHdNMGZpVWRsNkloR0FNZ0FtRHJ2TlhUbDd5U0Z2QnRjUmkzTmxUQlVUREVLZFZnYVNEdTRVdDVDYk5mRTRRTXVRbTJ6VzJCWWh0SVpkTXNlcXk4ZUZLS1ltejdxaUZkZ05kTlFOZXdWdGFPSnQrcVY4Tkt2MlAyV3lIVllQM2s4ZzArNmxlSXc0QTFnbnExMThhQ2tZaTR5WEZ1RVF3T1lqaHYxSGNkYXMrRXhOdTROYlFCN0RGSk5zMmIxdzZXbEVkVDVqSGVZOHFLMmFYRnRRUVFScEhkdVBzaXFoNmxnZlJaMTk5UnZmdUF4bkI3Nld2aWoxbWhIdW1kOVJXdktIWmx5NDNPREtUQUJBTVpnTngxNC9rS3IxN0NYRjNvUi9mWFZpYkV0MTBMZHZNU0NlQkJqU0QyR3FoWGlyWVM0eTY5SG96MU1JOHlDUEdoMWJnZDJ2aFBHamJ0c2tzU1p6RWt6MW1vellGQnZzeThGdWgrQUJpZTdLTjNHS2N0dEtlTkpJTmVDYUJ6alFjcXNTZFJKSDNpY2c5aWx2RVVUWnZFNE9Ed2Q0OGRhVVBlektKTzREVHVWVi8yKytuRndINUlqSDZSWStBTUR5cUJWZ0QwajF4UjFBWVAxdkEwZFFlaXRDYTltdENhQi9zeTVmRnBjbGtNdXNFa0Nla1o0OWRaVU9BNTdtMXkzUXE4QmxtSko0eFh0QjFMYTNJUFpxUktLcFBVVzhnZmhWTzVZOGtzTGJ0bHJDUFBBN2w5K3Z1cm9YS0NKWFhqU3piMXJOWmJqcDhLaXVBc2ExbXA4VWtPdzZpZk9vYXFKTEkxcHRoTFlZaFR1Tks3TyttK0I5ZE84ZWRCZHNOc2U2cUFxRmNSdU1nK2RHWWE1Ykg2eFd0bnV6RDJpcmpzREJMelM4ZEJSdUoyYmJJOVVWS3F1WU8zWmYxYml0NGlqeHMwZG5oU2phT3lMV1k5QVQxN3ZLZ01pb1ltNG5jN1JRVkQwcTdNNXZFSzRHbHhBZjRsNko5MlgyMVpPUit5TUhpOEZadVBoN1pmTGtkZ01qRnJaeWtrcEJrd0Q0MHU1ZDJPY3c0Zm5DL050eDNnUDBUcjM1YXBtdzlzNDYycllmQ013RE1YSVZRV0JnS1RtSTZJMEZVZFR4UEl2Q3FzcmZ2NGNEaUwzUjhlZEI4NnFXMWNWWnNINXJhZ3VuNnZNYzRmRzRqQUNsK0g1SDR6RkhOaWNRRm42N204dy9obkw3NnR1eXZSdmdVMXVHNWVQMm15ci9La0gyazBGZXhYS05tc3RiRjh1WEJWZ2N5Q0RvUmxaajUwWHNISmFzbEV1WmM1bHdyNVpPN1dETlhXOXlVd0RMSHlXeU5JbFZ5SCtaWVB2cE5qUFIzaEQ2aHZXL3UzQXcvckJQdm9FZDVvQnl1NC9qWWorb2tWWDhSdDBham5aNzBuM2lLaTJuc0xtc2F1RnYzU3Rza1pibW5xdE9Ra0V3TlJsUGFEVHpHZjRaWkFWTEszR0habW52TGIvQUgwRlpYYTkxemx0b0dhQ1lnekFFekU5V3RhYkl3ajRpNmJiM210NkZ0UVNEQkVnQ1FCdnFiYnVNWnJ5WWhVNWtnQUNTQk9YU1lQWVkzYm9wM3M2eGtnczJaanFTUEx1cWhnZVR0cUZDM0xnZ0FiMU80UnJwVUY3azBRT2pkSGNVajNnL0NtbG1LekVYaUJVRlZ4bXpiaWZWYnVKK0lGSzdoWWIxUG41Vlk4Wmk2VFg3MDhLSVdQYzdLakxVWTdHdHNOaDFZNjFRQm1yeWo4UmhFRFFLMCtTRGdhZ0NxMWJTMHdlR0g3T2ZhU2FRSEJIaEZXRGJDWmNMaGdkNHRMUVYvQ2V2NEdqU2FEd3FuTlBDRFJab01CcldhOUZhVUIyR1MzbEdaaURySURSeDZvcktqc01tVVNoSjExanRyS0J0dEhsZmlyaG5vaUQyMU92TGU2VUt1dkRlRE5aV1ZZS2ZpMnpNemRabWhTYXlzb0pzUHZwdlpFRUh0RlpXVkIzWGt6Y215dmNLT3hXSmdWbFpXVlZuSFhDV29ERTI4MitzcktvQXgrQ0QyM3QvV1VqeGpRKzJ1ZGNtTVJ6V010OVRrMjI3bjBIOVdYMlZsWlZIVWZrUVBEM3hXTmhHVUVpNFFCNDFsWlVDTEY4c2x0TmxERjQrekE5K3RRdnl2dlh1amFoT3M5WG43aFdWbFVWYmxNcnN3THViajdwM1J1SUFuWGllcWdmbFRnZEdGN1FBRDdkOVpXVlVhQXRjSURtUk0wOXN2dXJLeWdkWUZwRkVYckpJcnlzcUtVNHJDVUJkdzlaV1VBajI2aXlWbFpSR1phM3lWbFpRYktLYjhvdjFGajkwdmxXVmxBbXdoK2JQZjhBbFhockt5ZzhGYTFsWlFISmZhQjBUdUc1eW9nRFRRR3NyS3lnLzlrPVwiLFxyXG4gICAgICAgICAgICB0aHVtYm5haWw6IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndDRUFBa0dCeE1URWhVVEV4TVZGUlVYRnhVWUZ4Y1lGeGNWRnhjWEZSWVdGeGdWRlJjWUhTZ2dHaDBsSFJjWElURWhKU2tyTGk0dUdCOHpPRE10TnlndExpc0JDZ29LRFEwTkZROFBGU3NaRlJrckt5c3RMUzByS3kwckxTc3JLeXNyS3kwckt6Y3RLemMzTFMwckt6YzNLeXN0TFMwdEt5c3JLeXNyTFMwckt5c3JLLy9BQUJFSUFMY0JFd01CSWdBQ0VRRURFUUgveEFBY0FBQUNBZ01CQVFBQUFBQUFBQUFBQUFBRUJRTUdBQUlIQVFqL3hBQkpFQUFDQVFJREF3Z0ZDQWdGQkFJREFBQUJBaEVBQXdRU0lRVXhRUVlUSWxGaGNZR3hCektSb2NFVUkwSlNZbkt5MFNRelkzT0NrcUx3RlVPend1RWxVOFBTUlBFMGc1UC94QUFYQVFFQkFRRUFBQUFBQUFBQUFBQUFBQUFBQVFJRC84UUFHUkVCQVFFQUF3QUFBQUFBQUFBQUFBQUFBQkVCSVRGQi85b0FEQU1CQUFJUkF4RUFQd0RtYm1vV05Oc1JzUzRENnkrOGZDaFRzbTU5bjJuOHE2SUN6VjVub283TXUvVkIvaUh4clQvRGJ2MUQ3Vi9PZ0J2SFd2RnFURzJHUWdNTXZmV2lVSG9yWVZnRmJSVUhnYXZjMWVSWGxCN05aTllLeUtEQ2E5VTE0UldDZ2xWcUt0WWlQNy81b0t0bGFnWU5pZVBaNW4zNjBIZHVFOGV6K3pYaGJ3OGZNMUc5QjR6MW9XcjBpdFlvUEMxYjI3a0dhMElyQUtDeWJLMm5rMUJqMmFuMlJHN3Q5cG9uYTIxbWNTZFowN0J4TW5XTzRWV1Z1eEJIeE5TdmRuKy9HZ2d4RDBSZ2pvS0R1VWJneDBSVkMwdHZyQTFlTnZQZlhnb0pVYXBWZW9FcVphQ1VYSzJWNmpGYmdVQnVHdlZZOW00aUNOZkdxdFpNZjNyUjFyRVIvd0RlN3QwcUM1LzRoMmorWS9BVmxWaE1ZWS9PVDhheWluMjByT3BwWXlVK3h5elN1NWJvQXdsVDJyTmJwYm91MGxBNDVMY2oyeG5PRmJ4dFpNZ2dUck9mWFE5bGE4cXVSVDRTMkhlOXpnTzRRZXNEV2Urcmg2TFAva0Q5ei81ZnlvbjBvcE9HSFlmOXlWTHlPTFhObmFrRFdDZm9xZmhVWjJZT3ovOEFtdjVWMVQwVjJsTjdFaGxCNk5zaVFEeGJyNzZ0NzNMUWZYRGlBU1BVVFhoU2o1MXU3S0gyZlpIbFNySDRmSXlpQnJQWHdqdDdhK25lVU96TFB5ZG1GcEZhVTFDcUNKZFpFanNKRmZObTJWbTZnN0Q3U2RmSVZjMERXc01DTzNUNHo4S2xYQkE5ZEd0aHlxejJqeVA1VnZZdEZqb0tJOHdXd09jQmdYR2lKS3dZbWQrblpXWWprOFY0WEIzcVB6RmRaOUNZZ1lyL0FQUi81cWs5S2R1WHRuN3cvb0ZTcTR4L2hmMy9BT1FmKzFSdnM2T0o4Vkk4cHJ1SEova0ZocitHdFhXTndNNkt4Z2lKTytOS2wyaDZOTU1xTXd1WGRBVEVydzhLVWNBdUlBWW4zTitWWXVIWnZWRTkzL05NdHQ0Y0RFRzJCNnVZZUFZZ2VWRmJLdzVrd09JSDRvcW9SL0pIK3FhbUd6TGtBNVJIM2s4cG1yU2NGY0dhVWdBeEpJTTlVQ2F2Mk41T1lkZGsycjYyZ0xwdzlwaTJzNWpia25mRytsVnhVN091ZlVZOXdKOHExT0JmNmpqK0VqNFYxSFlISUY4WmJhNmpXbEFkbGhnWjZNZFE3YTAyOTZON3VIdE5kZHJSVlFTY3VhZEFUeEE2cVZITCtZSTNqMmcxbVU4UDc3cUp0MjVaNDNCbUE3cE5OYkdEbUpYU0JxQXBPN3FKSG5WRmV1V2oyK05GNFZPaVA3NG1tRzM5bVhNT0xlZFZYbk14QTZKYUZ5NmtEZDZ3aWxXZGxBZ3dJbjNrZkNnQmEzcWExSzFmYlhvNjJoY1BSd1J5blVNMTYwb0lPNXZXblVhMGJzLzBVWXA4UUxGMTdWb2xPY0pWbXV3dWJMcUlVVFBiVW81dmFXcHd0ZGJ0ZWhqTXJOYnhlb1oxaDdjU1VZcnZWdEFTSjNHSjQwdXZlaURIcWRCaDNIV0x6QSt4clE4NlhCemxWcVcybFdURmNrSHMzZWJ1dmxZSHBBQU5HdTROTUh2aW84SnlkdmtuSkw1UUNTdGdYUGFKUHZGQWhDUlc0b3ZhMkJ2V2lCY0lXZHdObm15ZTdvVnRzYllXTHhSSXNJYmhXSmhsU00wNWRYS2pYS2ZaUVFoZjdtdmFiUHlVMmdoeXRadUFqaG5YanJ3YU9OWlRnV0RFTlFWdzBSZGFoV3FLOVFWTUxxcnZJSGVZcUZLMDJndWc3ejVWUjBuMFYzVkxZaktRZExPN3Z1MDE5STZ6aGozSDhTVlZmUTBDTVJpd2VOdkRuMkc2dndxNDh2bG5ETjNONVQ4S3o2SzE2TDlNUmVIWGF0bjhQNTEwcXVhZWpiVEYzUit3WDNjMStkZExwb0IyMnMyWC9oOXpMWHpEdHBJdjIvNHZ4Q3ZxSGFnK2Fidzh4WHpUeWlzeGZ0OTcvaUZYQVp0RG9XczBHQ3lnKy9Velh1QXc3M0ZaMEM1RUhTTFBiWGVyRVJMYW1FYmRPbzdhWVl2SFdyZUd1aHdYejI4Z3lGU3lQemx0bGVDZUJYZFZ4WEhXTVpzbjVhYk5rWFZWMXVFSWlOblFNTXVZQ1FDY3A4UlZEcjBhYkN2NFZzUUw2Qk00c2xZWlduS2JzK3FUMWlvUFNaYmsyKy96VnZ5cXdjbDhWaGJrdGhsVlExdTJXQ3JsNHRFamQ5YmRTZjBrSitwUDJ4NVBXZlE5NUZmL0FJT0grNThUVFBhQSthZjdyZVJwWHlKUDZEWSs2ZmM3VTJ4ZytiZjdyZVJxRDVuMjViLzZndyswL3dEcVBURkxXUWdnVDAxbmhBeXZyUW5LQWY4QVVXKy9jLzFHcTBZYkFJOXB5ZjFnYTN6V3BBekVYQzBqajBWTy92cllTWW5HM0N6SG1ueWhGYVRJR2xrUEIwMDZ1K3I1c2Zid3h1dzNJdDVEWkJzbGMyYWVidENHbUJ2QkdsT3ZrbHBzTnRCYlRCZzYzRW5PSEVERHJsT25lZkd1ZStpdTZUczdhVnZnQ0gvbXRPcC9BS2c2UDZMeCtpM1AzOXp5U21ITHhad1Y3N2ovQUlHb0gwWmo5R3UvdjMvQmJwbnl6V2NIZS9kditCcW5vK2M5aVdjeHVEN2JlWnAwaXVtb1VOR1dCbUFKMEdva2RmYlFQSmUzTDNmdnQrSTEwWGF1eTdTWVcxZkdIVzZSWVpuV1dVc0VWdXJ3OWxhSE9lWFcwVGVOZ2xXVXF0d0VNSTRvTkNORDZ2Q3EvZjhBVlQ3aC9HOU4rVnVMRnhjT1JadDJ0THArYloyREJqYklCVnljcFhYVUhXZHdpaytKYm9wKzcvM3ZWSGVmU055aXZZWEFXSHd0NEk4b3JRTGJrQTJpZFE0TWJodzQxSnlLNVMyMnc1eG1KdWczT1pzcTVqcEUycmVlNDJWQnBMT1RvSTNWUU52YkN2cGdjUmV1RUtvdW9GdDVGQmJQRGM2Ym04NkVDSk84blNhckNiVmEzaExLMjNJTDgvenVabk5zQURJcWkyRGx6RUlOVE85ZXFzd2QrNUU3YnRYMHZGU1lEODVtSUlCVzdKRENkWWxXSGdhYjdPMjdoNzhjMWVSODJhQk1FNVFyTU1wMTBEcVQzaXZtV3p5aXhKVmJDTWdYbTFTT2JTY3F0bkV2R2YxaWR6RGZWdDVGWWU5aU1YYXQyOFZpTFE1dk14dHVQbXlTeUVLclN1NjNiR29tSTdLUVd6YjJ5cjEvRjNibHEyem9IS2xoRUFxWVpaNndhdEhKWEFtMWNWV1FJM3lXM25HazVoY3VTVEc4Njc2bTVHNFo3Vmk5YnVPMXhseEdJQmRvelAweVF6UnBKQkIwcHBiWDlKSi9aRC9VYW9PY2VtWEFaNzJGSStxNDk0SStOSmVUZTJQOE53K014QlZHY0N3cUkzMDNacmdFR1FRQkpKaldCVnY5SmRxY1JoRDltOS9zcXFiZXdhbXlRK3Z6bHM1ZE5ZRnpXSTEzeHY4QXBWYzZGSHgzcEYyamNkbk9JQ3p3VzFheWlCRURNcE1kNU5aUU9NMkV3ZG9BanMzZG9IWldWb1crZWlPNFZHVFcxMDZVUHpsUVRod0FTZEFOVDRVRnREYUZ0Z3VWME9wM09rN3UxcU10TldtMUQwVjcvaFFYYjBRM0ZPSXZGUVFEYVVhNnprZnJCSStudW1mYUt1L0xSSnc1L2kvMDNxaCtpRzZUaXJnSkorWmJlWi96TGRkQzVWTE5nL3hmNmIxbmV4VmVRK0VGdkVpNFcvV29iUVhxS2hXbnVpMlIzeFhRcW9uSkZ3MTlGSTlWV1lkOFI4VFY3cG9IMmgrcmJ1OHErZnR2WVdjWlpYcnVNUDYxcjZCeDQrYmY3cmVWY1QyM2FqSFdUMVhMeC9sR2I0VXdjLzJxaHVZeDhva2wzNEUvV080QW1yOXlOd242RmlzSTdFTXlMaUlHWVpRQ0ZPWkNRZFJ6WjFHNmVvVHpwN3pDODdLeFVpZWtPQVpncFA4QVZYVGRoWUJMREpkUURObEtuVTlOWFhLUTUra1RPOHpyV2hZUFFwaVNVdW9ZaEZTTjBqTTkzTUNRSlBTQk9zeE9sUDhBMGdXOHdzajdhKytSVlo5RHQzOUp4YTZUbHRzMGZXWjdoSTkvdnEyOHRVa1cvdkw1bXA2RHVTTnNKaDF0Q1R6Y2dFL1NERXRQdEpIOE04YWE0cjFHKzYza2FWY2tubkRJeDlZNXA4SFlDbXVJMVJ2dXQ1R3NqZ1cxOWxvK091TzJKczJTdDI2QWo4NFdicGt5b1JUcHJIaFRIRlhlYUNoYnlIcEJwVmI0SnlwY1VoUzFvQWRHNHhrbmhTemxqWmphUTdYdWZpcWZiNUtvcEJqMTU3c2gzMXNKdlJZYmd4MTE3ZGszUnpGMVhnbE1pdERaaXcrNUVIZko0MTV5SzIyMkZ1NHJEaXkxMDRpTFFBWUxEQTNOVElPa1pqMlFhZmVoV3kzTjQ2NWJaRWNoRXpYSnlpRll4b2RDUy9iNnU2Z2VRRnRmOFZ4S3NBVHpHSWREdmh1akRML0E3anVOUWRPNUhYOFJidEZiZUVCek1YSk45UjBzdHNHT2llR1gzMFh5bHhlTGJEWFEyRlJWS1BKRjhNUU1qU1FNb25UaE5IY2pCOHk4OEgvOGR1anVVYXpoN28reGMvMDJxRDUrNU5vUmN1NUFXT2RwekFMQms2QWhqTld6Rzh2aFlGcXk5dEhOdENyS3B6R0drWlhEUUFZMWdFNkVkWXBGeVl0UmV2ajlvMzRqVmY1YllZTGlEY1VhRXc1KzNMUVA1QVBZSzBJZG8zOFBjQ1pudXJFN3JTR1pqOXJwdTk5RDNyZUdLck4yOTZwQStaVTZabS9hOTlMYngwSGpXWERvTzc0bXFqbyszT1ZIeXZDWExDcVJ6ZlNZeEVtMnVYNnhnZEU4S291QnNHOHFXb0lBTFFWaGlTVzNaU1Y0a2Nhc1BKNjVtK1dyQkg2TGVPOEdXVWs1aG9JMGdScnVtZFlBZklqQ2M0elN4VlVMNW9NRnN5b0ZRbmVCTW5UZnFLaXBiZHF6YkFWcnpqTEtqOUhVbmVmcEMvck05UXB0eWN4aVlPOXpsbTY1YzVWeTNNTkFQMHdOTVF1OGYzTko5czRGTFRncUlBT2FPSEhoNzZuNVZPWHVKbHlBaEV6RWtnbGdHamNPcHZLZ3VXMU9VR1BTTG9mSUxqWHdxclpYSmN1UGFERU5HS0psVkVxZElKTTV0dzZac0xGTmRGcTQwWm53OXRtamNDeEpJSGpYRUxtT3V1TEZpM2FSaWc1eHJuT0xmUUM2bVhTVkJScFJnMGRjZHRQZHU4dDc5cXlGc3ZidEVXMHRFckxYQUFTU3luMVY2dHhxUVc3MG1ZdExWekR0Y1lLb1c2U1QyWk4zRTl3cmxtMytXWE9BcFpTRitzMnJHQ0NDQU5CcUJ4TkljWHRibm5EWHJseTYyN05jZG5JazhNeE1Ec29tM2hjckszTnlBUVlPNGpxcXdBTnRPNlRKWSt3ZmxXVTlURTJvMXcrdjhQOEE2MWxCQmc5c3ZlelRidElCSHFLd0pKbmVXWTFzMXd6UU95MENxUklra3RvUWROQkdoODZKbldnWTRacTkycS9SWHY4QWhWVjJ0ajdxWFlWeW9nUUJ1M2FuMnpYbHJiVi8vdWUwS2ZoUWRVOUQ5MzlPSTY3RnozUGFOZFQ1UWtjMXFRQkoza0Q2RGRkY1k5RE9QZTV0TVoySitZdWpjRkc5RDZvNDZiNnRuS2owVkppTGpYV3hMZEs1Y2JwVzFjam5YWjh1Wmo2b21BS205aGp5YnhWbE1RcE4yMk9nd1BUWHQ3YXMySTVUNEpKelkzREwzM3JRODJybUd6L1E5aDJjSytJdXdabktscFRwTzZWYnFxdzJmUTNnVi96Y1VmNDdZL0RiRlRnV2NjcWNGZVc2bHJGMkhJUmljdHhTSWpmTXdmQ3VZY29zVlpOOHN0MjA1VVlrOUYxWTZwQTNIck5YaXg2Tk5uMnM3bEh1eXBBVzYvT0lDTmN3QitsMjF6dmx0eVpzV0d2T2xwVlhMTnVKQVVsMEJBNGNkT3cxY0hQTFFCVy85WWhBQnhNM0ZZKzVhYjdBMnplUjdhM0hibVZQR0RBQU1heG1qc29UWitGellURlhJbGhjdzZxUUpJMWN0SEVUSW1nc001dDNGWnd3eW1ZaUR1MDBQaFdrZEw5R1czc05oY1hpcmwyNnhXNkJsT1M0NUpGeGlBQXFrZ0JTTjlYSGxCeTJ3dHdES3VKZlVIVEQzUnVKK3NCU2IwVkVmNGpmSzdud3R0K3drdUZKL3A5OWRLMnNOUEFlZFkzdFZIMk55MFJMZHRWd08wcmhCT3FZUWxkV0o5WXNCeHB2YzVZM1dWZ3V5dG9iajZ5V2s4ZGJsTjhIZFZRbzE2Sk82TzNyUGJSRjdhSXlrUWRaM2tEZlFjVDVRTmliK09EREEzUXdXNi9ORjBERVNvelNOTkdkSkc4ejQwbTI3dHE4VmUxY3d4dEZjd0p6aGlEcXBCQUFxK2NvTVMveThOWmFHK1M0bVNPbEV2aDRQdEE5aHFxOHY3UUZwcms5Tm1LbnQxa2s5dTZ0QlB5STVUWWpCMjNXeHpZNTU1WXNxT1lRQlFPbGNRTHZiZVRQVU9PK3pMdHkxak0xdG1URXRiSUU4M2xaR3RpUW9DM0FUa0UrQnF0NExHODBxbk1NMHpsS2h4QjZ3Zjc3dDlPTmpiZURiU3dON0tFQ1BoN2JFa0tDUDFiUDFJSWJkSmlOOUVYZmtoNldMZUdXNG1MNXk2U3dLRzIyR2FBRmdnbWJmVU5JUEhYaFRuSGVtakFYRVpCWnhNa01QL2pjVkkvNy9iVHArVVdGRTVuc0hyK2R3NzZ4OWx5YVU3UzVUN1BqVTRieFM2MzRiQkh2ckt1ZWJMNVQyYmQyNitTNlE3bGhITlNBVE92em0ray9LREhHL2NZb0dDRjg4TmttY29YZ1R3SFhVWEswMlRmRFduUjBacEpSQ2lyTEhvNVR2Z1JyQTMwbVJWblZSSGRXMEYzN0xRTkRwUXozdUh4SDUxNDl0UVlnYitvVEJBMG12U0JHNFVEYlkyMmJxT3h0V2MrYTNjUndvdVBLM0psaUZHOEE5MmdyVFkrMVhzQzZVZ2dsUVFlTTVqb2VCNkk5OU5MV013OW5wMnJqSTNObFdEZy9yVGJpVklFeHZHNDZrSHRxdDJ0YzRHN29uMlNQalFQOXY0clBaUjkyYXlwN3VqQkh1TkM0TnJyMjFZc1NZZ3lNMGhRRlVtUWR3VWExb0Jud3lLRDZvdUlUMUUzSGNEMk1LZzJuZEp0NGNaZWt0dTJ1dkhwUEVIcTBqd2lvcTU3U3hiMnNIaDFBUE8zYlNGb2trQWpvb3Nra0RVbU8ya2xqWjkzbXIzT0pMdUZ5YWdrUVNUSjRjUFpWeHhRVTRwZ2Q5cTJpcjJhUWZMMzB2dTNlbXcwZ0dJNHhsbk5QVk9sQld0aTNMYWRCMVZYM0VsQVc5cC9LbXVGeC9SZ2xOTkJPOHhwOFBmU2ZsV0FHUmwwWXlQWkIvT29kdXIwTU0yLzV0WjdkOUJaUGxxL3MvZCtkWlZKeWRjVDJHdktvTlJvT2hwbmg3Wk5WN250YXNXemNXTXRFUzR2QUM0aFE5V2g0ZzhEVldhMWxUS2RHa2tqdEJ5Z1QvTjdhdUlDdnhJOFlwTnRYWW5GS0tzSG9YYkp0TzJXSUVwZEcvWDFDMm80ZXJYMEJqTVVDdWdKZ2c2Q2QzZFh5enNuYWx6RHNXdHNWWkpLc3JNcEdaWUlrUWVQblJkL2xsakgzM25QZmN1dDV2V2R3ZC84QWxiQS9xcjQ3ZWF1RDM1WXJMdTJRUFdrZmV1MjAvRzRyNXd2Yll2TnFXRTl3UDRwcVAvRXJ2MXo0QlI1Q2tIMEplMi9hUDA3UGpmc3QrQm1xbDh2OW9oOEsrVjdURE1naEdkb25NZGN5S09IQW11V05qcnAzM0gvbWI4NllXNzUrUlBKSkxYZ05UUHFXd2VQMzZRTitTZUpXM2dyMHN1YzNzd1V5SlZFVVJNUkoxcHRoY1Ridkt3ZGN2UkFLc0JBSVRLd3R6T2trYWU4OE9mYk9BTGF4RU5xZTQxMEhDOURDbThkVXQyeTZUcUpHbzd5TGdnZGlSdWJXZ0xrZnkwWEFzamkyYm56VDJtQnVGU2c1eVZPaUdkRkhBYjZmN1E5TG9jUU1Pdmk5MCtSU3VUWnBKZ2tnWlFKQUVka0RUU1Q1NlRXVFNJNkJjOUo5ejZObTJPL25XL0hmSTkxQTMvU1BpVDZxV1Y3ck5pZmExc24zMVRLd0NUQUJKTUFBYWtrN2dCeE5JTEsvTHZHa2tpNWxMYnlvVkNZM1R6WVdvTnE3WHZYOElHdlhHYzg4d0JabWJRSWgra1R4SnFERjdLdDJyVXU3dGRndVVSUmxWQVF1Wm1QMGN4eTVvMVBxaGhEbUxhR21Gc0NDSjV4b0lnNnNRRDNRQlFDSllLcm55cDBZSkpiVmcwQUFBOVhkeDQ2VnBlWW5LMEVMbUVIV1BvblFuODZrdjN3STV0VjZobUFlNVAzVzBIWVF2alVOMUxqaHJqRm15NVFTeEpqTUdJWFg3cDA3S284ZTR4M3NUM2ttb2lLMlkxb2FEYTRlaDQvbFd0dHQxYkJKVnV5RDdKbW83Vzd4b0NyL0FLM2dLM1RSV2VBY29FQTdpekdCUFh4TWNjc1ZwZkV3UndFSHMxNDlWVE9zV0JwcTl3K3kyb0E5OTF2WlFIY25ObVc3bDlGdWt0SkVpWUo2TEdDZC9BYm8zMUJoY0dHeEwyMUtvUG5OVE9VQkRQa3ZsUmVFNVFHeW9Gb1N3SUpNTEdhQU5XSWs5d3BaaEx4NThNdzFPZVJxb2hsYVIxOGRPMktDWEI1N2JrTU9peHl0OWxsSUV4djBMUWUrbTJ6U0RmdDIyVUhPTGRuZE1NTVNMZ1lRd2pRd1RyeDBNMExpUUlJTW5PRTZYVm9DSjdUR3ZkMXpKSEpPL254bUZCRWtNQ2REL2wyMmFlL28xQXg1VDdWYTNqSGRlc2dqZ1JPNzNVVFp4OXU0QVJmdEtTTlZZdktucWFFSTlrMGoyazR1WXB5ZFFTM3VOZWhRTjI2aXBkcFlRc1NTOXArcklYSUE0em1VZGxMM3c5d3dHdVNBSUFNNkFVY25IdXJVbWlBZmtUZldGWlIwMTVRVnJQUmRyRVJRNHR6UlZuQUUxUVpoY2FSeHAzaGNVR0VHa2d3Qm9teGJLMUJKdFRCZ0t4RytQQ05aK0h2cXZpcmtxNTBJUFVhcWVMczVISW9xS3NGZVRXVFJIczB5eFdtRHRmYWU2M3ZDZjdLV1RUSGF4aXhoMS9aay93QTd1Mys0VUF1eXhMcUl6U0RwSkU5RThSVjV2S1RzdTdxVkNtMk1nMWtDN2FWaUR2MENNSTR6TlVMQWs1eGxFbldBQkpKZzZBY2F1dHZhVGpaMTFTakl5aE16UnBQT1d3b1ljRHI1ZldvcW5ZaEFGMFZ4cnZZUVBEU2hacGxhUzdpR0ZwZFNUeE1LSUJKSkozQUNhYTNzUGhzTWhVSG5ycEVaNGdLVC93QnRlSGZSRmQ1aC9xTi9LZnlvN1pWMXNQZVc2d2hsekZRU29ZRXFRR0tIcGFUT280Q2dMcWF6clVVQURRVlFmdGpiVnk5ZnVNSEtLK1JRbzlVTGJYS2dBK3lOM1VTU0tONVc0b08xc2hWVmNnS3F1aXF2MFZBNmdBS1FXN2NtTmN4SWpTUVpQRXpwNzZ0R0kyQTJJam1yaU02cXFtMU1YQUZVYXFEby9nWjdLQ3FtU0ozZFVEalRiRnNCaGJZQWpuYnJQNFc3YUlCL00xeWdyK0FaR0N1Q3V2ckhSZERydzBQWVJQWlJHMklVMjdZM1c3U0R4ZWJwL3dCUWV5Z0NOYW1zcnlnbnduMGg5aytYL05iM01NMlZZQitjWmd1bStOSUhzUHRyYkFYa1ZXbTJXWWtRMHRDZ2FrWlYzejFrNlJwV3lZcTVOc0FraTFuWlJ3V1lMTlFBWG96RURRQ1FQRDQxTVNlYkVra0RkM3R3OXhvZlBEU1lPcFB0b3pINHBuVlZPVVpBcTZBRDFRUnIxbnROQm1Cdm9IK2NNTEU1aHFSeGpTaTlxT3B2UXVpaFFCd0o2T2t4dU9vb0hBbVdVQWRLUkhHRE84anFxWFBtZTRkOGs5dW1hUjVDZ2JZakdGN0ZwUVBva2J0Y3dNeVQxRU1SL0R3MXB0eUp3b241Uk90c1g0R25DeUFEMTczSThEU213ck5oeTBDRXVRMm11VjlZbmh4NzVqcW96a2dHTnk2Zm9peTJuVkxJZk5SVUFIK2VlNDBWUVZ0cHZudWFqQ2FEZE9QZFdocjFEdjdxMUpvTnF5c0ZaUUFiUHdIRTAwV0JYaTZDSzFacUNYUFhvcUROVXFVQkdIdXdhUWJiTXZOT1RRT093bWZjeTl1WmxRRHhjaWZDYUtSVFQ3QWJNWDVIZHhKQ3V3WUtxdG15cU5RWE9VaVRPZ21SNDdsZC9CaFFmbnJURWZSWG5XSjdtNXZKL1ZUekZiUVpObklqbGM5d3JrUUFBaXlpd3J2SEZqcU9KM21pSzJ4NGoyZFJwaHQxU09iVDZ0cTBQWmJXYVdXcnVYZUF3NGd6QjhScUQyaW0yMG9mRUxKSVZtUVNOU0ZNRFR3cWhkWWdOcVlHdXZTSHdxMmJKZkNwaCtaYTRsek1WSlJYeWpvdG5VT1NRU1FaMEhXWU5MTm80ZkRneGJ6ejkvTUIzbU5UMkNnRGhRZVB0QU5BWnRNWFJjTnhGZFZuUlFyQkFJaUFOeEhzcGJZZGlTV0duRW1hOGJCaWRJNzRpTzBtZEtpdDRUTVdoZ1NvbmNkZFFOSjc2QWk3ZVJqdkNpTityVDJ3S0hoUHJud1VreDF3MEQzMHd0N0pWRkRYMlpaOVcySTV4dThSMFIzMERlYTJwYm9FUUcwbVNEQnk1aTNiRWdjSjNHZzl0NGhFSUtobU1NTlNGM3FSSVVCdDB6djRWN2N4ckYrY0F5dHZCRTZkUkVtckdjR2x2REMycXE5NXdjMjhrM0FuT3R1M0paUmxYS3ZyM0cxbktBVUY4TVU2WHIyMlpHN0NDZjhBa2VGQkpleDkvRk1sdTdkZTVtWlZFbWQ1Q3pBRytPTy9TdGIySHVZaS9jTnBHZVhhSUdnRTlFVHVIUmpmVzJ4bmhpK2c1dEhieEM1Vi9xWUdnYmJRcEU2SGVOUDdOQlpzRDZPOW9YQm1GcEVIVzEyMy9zTEgyMUh0SGtGamJJbHhaajkvYlgzM0NvcEpaMmpjUUVXM1pKK3F4WHlxVFp1Mjc5bk9iZHhsWjR6UFBUTWJ1a2RmZlU1RXVIMlZqRkpGdEx3a2FtMFdaV0FCMEwyU1ZQSFNlUGJVTnpabHpuQ0NqVzRVbVNyTEVBekU3OU5JcDVoZVZXTkNITmZ6THBMc1V1c0NaZ1FaYVQxYnRLU2JVMmpjWTlLOHpzZldHVUpIVURsZ1QxZ1NCMTFRSmc4TVd1S3JDSk1tUkhSVUZtOXdOUnZCSkprU1Rydkg5NzZOMmNkTHJuWExhWWVOeGxUeVpxRHNvSm5QbFBqNTBCV3pWQ3RtM3dHYWZ1cVNQZUJVV0ZKQUpHK1J1ME83VFgyMU5oN1lBdXNHemRDTjBhc3lqODZnY0VJc0RmUGlkL2t3b0hHelhaclYxUnVKVE5KSkVGYnF5ZkVyNGdVNjVIaUxPTFkvVXREd0piVCttcXpzdlVPckVpVUpFSDZhbm85Mjl0ZTJyTHNCL3dCRHhMZGJvdmZDaytiVkJYOE1mbmozTlJ4Tkw4SCtzUGNhUG9ObE8vdXJRbXRsNDkxYUdna0JyS2pyS0NmUFVEdlhoYW9iaG9JbXhCSjBvekIzVFMrMWJNMDJzMmdCVkV6TlFlTk9sVE05QjR4OUtnVVB4bzNhV0s1OWtPNXNsdEkzQWxGQ0NPK0JRZVFuZ2FsdzFnNTExQTZTOFo0anFxaWZCWWRiZDFlZUFpQ1lPb08rSmplSkc3alJHMm1EZ1hGM0h1MGc5bE1jVHlkdlhiaXN3TnUyVURCbUhDVHVCSVBiTzdkSkVpb01aaExTMjJ0MjNMNVRKYmVOUU5BWTdQZlFDcXd5aHVzVFdqc2VvOXdFc2Z5SGFhRXRZa0tJTXlOeGlZN2hVVDRnbmZKN3lUUVQzMllqTEFVYjRrZS9XVFcyeTJ5WFZZTkdzYVR4MG5YcU1Id29Ocmg3dTZ2RG1QV2FBeTlkWU14WWt0T3BKMVB0MTlsTHcydXU0a0U5c0hqVERISm1ZSDZ3QjhTTlI3WnFGOEM0VTlDUVlPYmlzVE9uYlB1b0M3ZTF6YWNYRVVNd1Y4aFlrODI3dm1GMVFDQVdYZXM2QXdZTUNoTm10T1pUOUlUNGloeW1vTFNGbU0wYWRzR3RzRXJHNkJiQll6b0FOWW1KUFZRRW9jdHE3MXNVWHdFc2ZKYTBUQnNlRlQyU3kzaGxLcVNZbDFSMUU4U3JnclZvdFhNVkdnd1YzNzFoRjk5dUtDczJ0bE1kODE1c3ZCWjNkVDlHUGlQaFZzK1U0ampnY08vN3U0NmU0dUJTalo5dTVZdTNiajRhOFE1SnlxSnlqTVNPa0EweE1icWlwTVJzWTIxbFZBVkxiM1NRZU1MQkk3RlkrK3FnNU84OGRmYlRUYVdQY3RjSFNVRU1NcG1ZTEVnR1FPRGRRcFhjYVk3Z1BacFZRWGNzTXFvc0VjNFF3a1JLN2w3OTgrTlE0amVRTndwaGQyaVd2V1dNRVcxVUtPQXlLQW9qK0ZmWlNvNzVQRW1na3p3SVVucEFTUHRBa0FlUjhhZHN5QzZRVU9SVGxnYWtCZEJHbStsR3prbTliQSt1dnNEQW4zQTFkTVRnclQ2c2dKNi9qUWUvSTdQTkYxTUFvMnU0aVFlRlE3S2YvcDl3L1d2TjdrU295Z3RqS2taWjlVN3V2V3ArYkNZQUFjYmpueUZSVmR3UitjUGNhWVVCZ0FNeDY0MCtOSFVSNnA4cTFyMGZDdGFCdGdzTmh5Z0x1UTJzak1vNG1ORHJ1cktrMmRqY010dFJjdFptRXljb002bmpQVldVQ0ROVVROVWEzSzFacW9uUzVVcHhWQTU2MUwwQnB2MTZSSW9GV3B2czVrQkJ1VGxHK0FEN2p2b0ZXVVR1bnY4QStLc095OE1tR3k0aThWRERwSmJoU2RSb1dERGZyUFlZT3NSWHQvRVdRNStTMldaenVKVTVVKzZHSmp2SnFmQmJPdkFsM1N6ZFk3K2RUbkI0U2RQQ29wZnRYbEExOGtzV2dtY29KbHUxMjNuKzRpbDJFdVhDNGtRcEJFRGNKM2UrS3ZHSFFxSU9BdzdEcVUrUzNRUVBDaUJkd3Y4QW03T3ZXKzIzbWI4TEZSL0xRY3krVGxueWpmckVDZDNkUlEyYVJ2MDc5UE9wY1V3dFlsWEU1VnVBNmpwWk0yc2d4cmw0YVYxREJXOE0zcTMwUGZ4L2x6Q3FPWjJ0bEhxb3Uxc3F1bXJzckRFNjh6UFgwVlB0ME5FcnlTdzc2ak1PMWJoYjNOSXFVY2cyMWh6YnlNT0h3TTBmaVVkbDZJaEdBTWdBbURydk5YVGw3eVNGdkJ0Y1JpM05sVEJVVERFS2RWZ2FTRHU0VXQ1Q2JOZkU0UU11UW0yelcyQllodElaZE1zZXF5OGVGS0tZbXo3cWlGZGdOZE5RTmV3VnRhT0p0K3FWOE5LdjJQMld5SFZZUDNrOGcwKzZsZUl3NEExZ25xMTE4YUNrWWk0eVhGdUVRd09Zamh2MUhjZGFzK0V4TnU0TmJRQjdERkpOczJiMXc2V2xFZFQ1akhlWThxSzJhWEZ0UVFRUnBIZHVQc2lxaDZsZ2ZSWjE5OVJ2ZnVBeG5CNzZXdmlqMW1oSHVtZDlSV3ZLSFpseTQzT0RLVEFCQU1aZ054MTQva0tyMTdDWEYzb1IvZlhWaWJFdDEwTGR2TVNDZUJCalNEMkdxaFhpcllTNHk2OUhvejFNSTh5Q1BHaDFiZ2QydmhQR2pidHNrc1NaekVrejFtb3pZRkJ2c3k4RnVoK0FCaWU3S04zR0tjdHRLZU5KSU5lQ2FCempRY3FzU2RSSkgzaWNnOWlsdkVVVFp2RTRPRHdkNDhkYVVQZXpLSk80RFR1VlYvMisrbkZ3SDVJakg2UlkrQU1EeXFCVmdEMGoxeFIxQVlQMXZBMGRRZWl0Q2E5bXRDYUIvc3k1ZkZwY2xrTXVzRWtDZWtaNDlkWlVPQTU3bTF5M1FxOEJsbUpKNHhYdEIxTGEzSVBacVJLS3BQVVc4Z2ZoVk81WThrc0xidGxyQ1BQQTdsOSt2dXJvWEtDSlhYalN6YjFyTlpianA4S2l1QXNhMW1wOFVrT3c2aWZPb2FxSkxJMXB0aExZWWhUdU5LN08rbStCOWRPOGVkQmRzTnNlNnFBcUZjUnVNZytkR1lhNWJINnhXdG51ekQyaXJqc0RCTHpTOGRCUnVKMmJiSTlVVktxdVlPM1pmMWJpdDRpanhzMGRuaFNqYU95TFdZOUFUMTd2S2dNaW9ZbTRuYzdSUVZEMHE3TTV2RUs0R2x4QWY0bDZKOTJYMjFaT1IreU1IaThGWnVQaDdaZkxrZGdNakZyWnlra3BCa3dENDB1NWQyT2N3NGZuQy9OdHgzZ1AwVHIzNWFwbXc5czQ2MnJZZkNNd0RNWElWUVdCZ0tUbUk2STBGVWRUeFBJdkNxc3JmdjRjRGlMM1I4ZWRCODZxVzFjVlpzSDVyYWd1bjZ2TWM0Zkc0akFDbCtINUg0ekZITmljUUZuNjdtOHcvaG5MNzZ0dXl2UnZnVTF1RzVlUDJteXIvS2tIMmswRmV4WEtObXN0YkY4dVhCVmdjeUNEb1JsWmo1MFhzSEphc2xFdVpjNWx3cjVaTzdXRE5YVzl5VXdETEh5V3lOSWxWeUgrWllQdnBOalBSM2hENmh2Vy91M0F3L3JCUHZvRWQ1b0J5dTQvallqK29rVlg4UnQwYWpuWjcwbjNpS2kybnNMbXNhdUZ2M1N0c2taYm1ucXRPUWtFd05SbFBhRFR6R2Y0WlpBVkxLM0dIWm1udkxiL0FIMEZaWGE5MXpsdG9HYUNZZ3pBRXpFOVd0YWJJd2o0aTZiYjNtdDZGdFFTREJFZ0NRQnZxYmJ1TVpyeVloVTVrZ0FDU0JPWFNZUFlZM2JvcDNzNnhrZ3MyWmpxU1BMdXFoZ2VUdHFGQzNMZ2dBYjFPNFJycFVGN2swUU9qZEhjVWozZy9DbWxtS3pFWGlCVUZWeG16YmlmVmJ1SitJRks3aFliMVBuNVZZOFppNlRYNzA4S0lXUGM3S2pMVVk3R3RzTmgxWTYxUUJtcnlqOFJoRURRSzArU0RnYWdDcTFiUzB3ZUdIN09mYVNhUUhCSGhGV0RiQ1pjTGhnZDR0TFFWL0NldjRHalNhRHdxbk5QQ0RSWm9NQnJXYTlGYVVCMkdTM2xHWmlEcklEUng2b3JLanNNbVVTaEoxMWp0cktCdHRIbGZpcmhub2lEMjFPdkxlNlVLdXZEZUROWldWWUtmaTJ6TXpkWm1oU2F5c29Kc1B2cHZaRUVIdEZaV1ZCM1hremNteXZjS094V0pnVmxaV1ZWbkhYQ1dvREUyODIrc3JLb0F4K0NEMjN0L1dVanhqUSsydWRjbU1SeldNdDlUazIyN24wSDlXWDJWbFpWSFVma1FQRDN4V05oR1VFaTRRQjQxbFpVQ0xGOHNsdE5sREY0K3pBOSt0UXZ5dnZYdWphaE9zOVhuN2hXVmxVVmJsTXJzd0x1Ymo3cDNSdUlBblhpZXFnZmxUZ2RHRjdRQUQ3ZDlaV1ZVYUF0Y0lEbVJNMDlzdnVyS3lnZFlGcEZFWHJKSXJ5c3FLVTRyQ1VCZHc5WldVQWoyNml5VmxaUkdaYTN5VmxaUWJLS2I4b3YxRmo5MHZsV1ZsQW13aCtiUGY4QWxYaHJLeWc4RmExbFpRSEpmYUIwVHVHNXlvZ0RUUUdzckt5Zy85az1cIixcclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgIHRpdGxlOiBcIlNvY2FyIEJyYciZb3ZcIixcclxuICAgICAgICAgICAgc3VidGl0bGU6IFwiQmVuemluYXJpZVwiLFxyXG4gICAgICAgICAgICBsaW5rOiBcIi9cIixcclxuICAgICAgICAgICAgaW1hZ2U6IFwiaHR0cHM6Ly9zdG9yYWdlMC5kbXMubXBpbnRlcmFjdGl2LnJvL21lZGlhLzEvMTQ4MS8yMTMzMC8xNjk0NTgzOS8xL3BvemEtMi5qcGdcIixcclxuICAgICAgICAgICAgdGh1bWJuYWlsOiBcImh0dHBzOi8vc3RvcmFnZTAuZG1zLm1waW50ZXJhY3Rpdi5yby9tZWRpYS8xLzE0ODEvMjEzMzAvMTY5NDU4MzkvMS9wb3phLTIuanBnXCIsXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgICB0aXRsZTogXCJGaWxhcm1vbmljYSBCcmHImW92XCIsXHJcbiAgICAgICAgICAgIHN1YnRpdGxlOiBcIkZpbGFybW9uaWNhXCIsXHJcbiAgICAgICAgICAgIGxpbms6IFwiL1wiLFxyXG4gICAgICAgICAgICBpbWFnZTogXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8yd0NFQUFrR0J4TVNFaFVTRXhNVkZoVVhHQmNYR0JjWEdCY1dGeGdYRlJVWEZoY1ZGUmNhSGlnZ0dCb2xIaFVWSVRFaEpTa3JMaTR1Rng4ek9ETXROeWd0TGlzQkNnb0tEZzBPR2hBUUd5MG1IeVV0THkwdExTMHZMUzB0TGkwdExTMHRLeTB0TFMwdExTMHRMUzB0TFMwckxTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExmL0FBQkVJQUxjQkV3TUJJZ0FDRVFFREVRSC94QUFiQUFBQkJRRUJBQUFBQUFBQUFBQUFBQUFGQUFJREJBWUJCLy9FQUVFUUFBSUJBZ1FEQmdNRkJnUUdBd0VBQUFFQ0VRQURCQkloTVFWQlVRWVRJbUZ4a1RLQm9VSlNzY0hSRkJVall1SHdNM0tTb2xPQ3N0TGk4UlpEd2dmL3hBQWFBUUFEQVFFQkFRQUFBQUFBQUFBQUFBQUFBUUlEQkFVRy84UUFLQkVBQWdJQ0FnSUNBUVFEQVFBQUFBQUFBQUVDRVFNaEVqRVRVU0pCWVJReWdiR1JvZkFFLzlvQURBTUJBQUlSQXhFQVB3QVMxZEZOYzA1VFh6N1BwRVNMWE1ReGlCdWRKNkhrYTZ0TlY1YjAvRS8wbjNwb0dXcnVDZXlRbHhXVXdJRENESEkxQmRRTUlJQkI2MU5ldnMwWmlUQWdUcm9PVlJEZWh2ZWdTMXNyWURCSllMRkpHZlNDWmdEZVBlcmk2MEY3V2Q2ajJXdHF4Q2hnMENkVEJJTWVTMDNEY2NUSk9ZQW4rNXJTY0pOSjltY1p4aTJ1Z3pjYmxUSm9QKzlrKzhQY1Z6OTdwOTlmY1VLREJ6WHNMazAwdFFvOFl0L2ZYM0ZOUEdMZjMxOXhSd2ZvT2NmWVRacWFHb1dPTElUQVlFbnpGRXNNd090SnByc2FrbjBUb25XcEs0RFNxRFE3U0FycEFBazA2eStZU0FZODlQbjZWU2lTNUhHMEVnRW5wVEVzc1NDeDIyVWJUNTlhdVc3SlBwVnEzYUEvV3JTSVpYdFlZbmZUOGF0SWdHd3A0RlBDMDBpV3lxOGt3QlQ3V0c2MUsxd0NvOHhQcFZwRXRuTGpCVHA5S2tiRXJ5cTl4ZE1PRXQ5eVdMUjQ4MjA2YmZYNlVISzAyaVV4NzRnR21tb3lsY0JpZ0J4RmNwd05jSW9HY3BVb3JvRkFoc1YxYlpOUzIwbzd3UGlDV2MwVzB1TWRCSUxSNkFVMGhObWU3azEyano0RzZ4TGR5ZGRlUStuS2xRSXc0dVRVeU5VTnUzb0tkM1I1VnlVZGlMS21yR0ZTMTNSa1AzcE1neU11V05tRVRtMjFtaHdVa2hXT1VFZ0VtZEJPcHE3ZGhXS2gxZURHWlpnK1ltRFQ2UXUySW1wOElBUEVmbDY4cXIyMXpHS3RYRHJwc05xUzFzcnZReDB6QWc4OStSMTg2eU9MN0lPQ2NyZ0NUR2FUb1lpWTI1OWRoVy80VGdzNUxOOEkrcC9Tb09KcnJXbU9jb2JSbmxoR2VtZWZqc2xkL3dDSW5zMVBQWkYvK0tzZjVUK3RhdWFSYXIvVVQ5bVg2Ykg2TXAvOFJiWCtNSjVlRS9YV2t2Wkk4NzNzblA4QTFWcUdha3F6dlIrb243R3YvTmo5R2F0OWt6L3h1djJJMTVmYXFLMWpIdzl6dXJ2eWJrdzVFZjM1VnJxcThRd0tYbHl1T3NIbXBJaVJTV1p5MVBvYndLTzRhWnpDWGM0a1ZjdFJ5MTVmMHFsd3poeHQyeGJKT2gzR2tqOHFMWWZDQUNJZ2RCVThWOUZKdjdJQll6RWFUSHNLdVc4T0J2cWFtVlkwRlBDOWFwSVRZMENwQW5XbW01RzFSbGlhcEloc2xhNkJ0VVRPVFNDMDRMVkNJd0tjRnA5TkxVQWNJcHVXa1hwOXE1cm9KTkFpd2VGWE83RndvY2hNQm8wbXFWNjFHOWJMaEhDNzE5QUhjcmJHeWpYMm5RVU03UWNJc284QytvZ2FxSWU0V2t6SjF5amFxclZrY3QwWlI3c0hULzNVdHU2RDY5S0o0dnMvM1NMZUthUDhMTVpZL3BRekpxTktUUlNkaVo2cTNjYXE2RmhQVGMrd3E0OXNFRUhucDcxSGg3Q1cvZ1FBOWR6NzBoc2w0UGJONTRLT0ZpY3gwQk9tZ0hQblcxd043QzRZZU4xQjZEeE43Q1RXTGU4eDBreDAyRlJSVHNUVm8zajl0c09EQXQzQ09zTCtiVXF3Y1Vxcm15UEZFcjI3TkU4RGdwT3RWa3E5aDNyak80bTRodzRFYkNnMk40YUYybWpqWGlLZ3hWMEVHZWxLeDBDTUt1VlBNaysyMVBGUUV3ZktuREVBVXV4OUJpMWpjcWdEbFZERjNacW0rSzlhaWU2VFZXUlE5bXBoYW95VFhVTklaS3E5YWttb3dhbVMzMXBkajZPS0pydHRobXk3bm4wSHFlVlRJblNwN1dIQXExRWhzcDRQSHFicjJ2dExsK1laUWZ6cTVjeGx0ZmlkUjh4UTdqM0JPL0FhMlFsMGFCdFFDc3psWWozSDlhSFlYc2V5bVh2L0FDUmZPZDJQNVYwUmpCcTJ6bmxLYWRKQnEzeHl5eHlxNmsrdS9wMXF5TDA4NkVYZXkxa3FBR2NFZmFPVWsrb2dUUTl1RVl5eHJhZnZGNmYrTGZrYXFvL1RKNVNYYU5VaWF6UHk1VklCV1d3L2FOa09XOWJaVDZINnFkUjlhTllQaTl1NThMQStYTWVvcE9MUTFOTUpCYWF3TkV1QTR0bkpzMndEbklWdkRualhjL2RBOVJSRGpIQzdOclEzZ3ovZEVhZkliZk9pdFdISlhSbDN1UlRGSFNmbVpvaGl1ejRRbzF3RmxmeExKa1JQSWJEZXI5NUxWaThDbjhSQkIxRVQxRUhhaWgyQmJQREx0NWdsc3dUNVNmbE9sRXVFOEtXMWZ5M0NWWW5Lek9aalhuMEZQdmNSaThidHNaTlpVRGxWWEZZdHJqRm1NazZrMDlDMnk5eDNFdUhhMHQ0dGJHZ3luS3ArUTMrYzBHVVJUMjFwc1Vtd1NDZGdkNWJiUGRWY2c4S3RMRStTallVSWRha21uMnJKWXhRQlZOTkJvdGorR2kyWURxK2t5a241YlRRVEY0aEUzUDhBZnB2UlFXVEVWeUtnc1luYVJvZGordFRzNHBET1JTcXMzRWJZTUYxa2VZcFVDc3VxbFc3SzFkdmNNWlRCQkZNRmlLd2FPbE1ndWlxV0liUTFmdkxWQy9VVVVVWEZRc2xXeWxPV3dUeW9BSHNLN2xxOWZ3VFNBQnFlVlQvdWE3R1lvMFRsMk8vU21sWXJvRTVhNHkxYXZZWmxKQkVFYmcxR2JkRkRzZllTcmFXZXRMRERvS0lwZ21pWW1yakd5SlNvcXF2U25DcjFxMmduT3JiR0kwaHVST2hrVldLaXRPTkdmS3hrbXA3dDhGRlhJb0t6NGhPWnArOXJ5cUlpbWsweENDMWFUQVhDbWNLY3N4TWFURXhWUlNhTzhGeEZpM3JmWm02SXNtVDU4dmMwSVRkSUFZcTJwRU9vSTh3Q0I3N1VLZkMyTVA4QXh3SURGUVlNcnJNSFhsODYwM0dzVmF2UEsyUW9HMmJYZitVYWZqVld6aEJkUGR0a3luU0hnSnByck9nMi9DcVQraE5Yc2l3UGEvRFdReXU0WldVaktoSThSMkp5L25RN0NjZXMzREN0cjBiUSszT3V0MmV3K2NzeVpqNWtrZXcwSTlacm1ON1BZZTZQZ0NIa3llRSsyeCtZcXZpUjgrd3N1S0pqWGJhcHNiZlYybFVDQ0JvQ1NQWFhXc2kzQzhYWTFzM0JkWDdyYU44cE1mVWVsWGVGY1V1WEpWclRJeW1DR2tmTVNOUlNhOURVdDdEYVdpZGdUNlUxbElvbDJlNzBIdkxoN3ExcXJzRDRvUDJZVUdaNlRWamliWVJ5RnRCenl6Tk1ldXBuNlVxSHkzUUFhNE90TU4zb0tLVytBMmJkNEM2SGROdzRrazlHWE55bXU0ZkVXYlljTWl0SUlVazZxZXZuUlFXQkMxMGtoYlpJSDJwQUczdjlLTzhHNFlTaHZYUktxZkZsa2dkQnJGV3VBNHNPR3NybWRHak1FeWd5TlI0anRVdkV1RzRpemFJVmZDWThPZlErdXdwMEs5azEvdE5hQ0czYXcwZ2dnNWlCb1JHeS9yVlhoZUJ0WGJkeitEbGNDVkNCVlh6ekZ0YUNXN040dHFWVWVXcDI5T3RhN2dIRGJlOXp4SG9USXAyMnlhU1dqSFluRFJNa0NxaWxUc3cwMHIwYmkvQ01PNTB0QXUyZzU4b2dMdHk1VmllSjRSRVlyQ2dqY0RTQ09vcE5VVkdWZzA0VlB1TDdDbFRoQTBCcnRTTTladVl5MWN1QWxBUlZKK0NJNXVRWUoxUWNoNjFuTFBFSU5XVzR3UnNkYXllUnQ3UmZnY2YyT2dYeFd3RWdCZ3pTUTZnRVpTREcvT2Q5S0ZsWnFiSDM1YWVacUt4enFHN05vcWppMkt2WVd4VUttckZ1L0ZTV2p0eHdNUmI4c24vVlcxZmpDQVJwdUQ4eHpyemk3ZW03UG1QcFZoOFVhYWJYUm5QSEdmN2d0MjF4NlhIaEZXR3lsakF6WmxuVUhsTTYrZ3JNcXRUWFduZWtvcW0yK3dqRlJWSW13eWFpdEhoWXJQMkJxUFVmalJpMWNxNEV6TG1Lc3FScFFDOVoybzFjdWFWUXVyTWYzeU5hR1lNTnN6NVVpQUtJZDNVdjdNRHlvb0FkWlJTUkpnVHFRSmdkWTUwbnRpVEdvNVZadjRRY3FxT3JDZ0IzY25lRFRUcFJQaDNGTGRwU0xnTnptRkw1VkJpSklHNStWRDc5MUhhUUFKNURXZ1ZrUXVEMW83dy9BTGN0K1B1N1VHYzd0QlA4c1NCVlhFY0d1SXZlQlNVNU5HV2ZrZGFkZ01KYVpHTngwdHdmaUpMSFVhTGxIcFRTRTNyUU00amgyRGtXN2lGZXNFL29QclZIaTFpL2xEV1NNNno0VzJZSGxNaUQ2NlVTWmtWdEhMTDFWWW4vQUZVUnh2R2JUcmxGaGl4R3J2Y0piYU52NjBJR1k5YnZFaGJJNzIxQklKdGJBeDV4djg2SzRDM2RlQm15bm5wTmR0VzBBT2dCMGdsaVlITWE3OHZhckFzT0VOd0U1UWNwSTBFa1RFME4yQ2pScnNOdzZ5dG4rSzV1Tjk1enQ1S09sWjNGOE90dExxRktxd0U2UUNkUitGQ3I5MHNjekVzZXByaXZIS2l3VVRROE80bmJ3NFVqeFNKaFlrUVlnajdOVDhVN1VoamxWU1Ywa3pCNVNJajFGQU1MaUxldmV6R1V4bEtqeGNwbmxWRzVkSFg4YUwwSEZYWVgvZW9XN25DQW9ESVZ0eU9qRWZsVlRGY1RkbUpEbFFTZkNwSUFIVFNoeHVpbzJ4QUhUNW1sWTZMOWpGRld6aG1ERFlnbWZlcmRyQ202dHk1SytIVnN6QU1aNkE2azBEWEZBN1FmVFd1dGlUMWoyb3NLTEpQbFNxZ2NVUHZqM3BVaGg0SFdvNUpNMTNOVExna0FhN2pZa2JhOHVWWUhRUkRyVWxrNkdvM3J0czZVaGtwYXVCNlpYS0FJdnRWTE5RcnZVdE1RcWV0Y0ZPRkFFMW5jZXRFVk5Eckh4Q3I0cldIUmxQc216YVUwamIrK1ZObW5IbFdoQjBDcGtOUWlwQWFBSkhBTlZybG1RYW5tdTBnQkY3Q0RXcW5jbFRvU1BTamwycTF5MERURUNiNGM2bG1iL01TZnhxQmNUbDNnZktpVnhLRjQxS1FGMFk5Y2hVckxFZ2h0UVFCTWlOdGRQYXFwdmpwUWNzWk9wOTZxVzhjRGQ3c3FkWk1uK1dsZGo2TkNjVUIwOTY0ZUlhUm1IeTFvUmg3b0pZUjhKajEvU3A4MVRaWEV0TmpmTSt4cU00cnlQemlnR0w0M2xMaUl5c0ZHeG5lWjEwbVByVTNEdUlaMUI2YUdZblRtWXEzR1NWa0tVVzZDNXhCNkQzL3BUR3Z0NWZYOWFyUGlBQm1MQUFiNmJpb3I5OEFocDM4SUU2TVRCL0NJK2RKSnNwdEl0czdIbjlCUVhHOE11TzBxNFZmVS9wUlF3SkdjTWN4RUFiYURicVBPb3J1SUNrQWg5ZWlNZnFCSHVhRTVKNkZKUmEyVWNCd3RyYlpqY25RaU5mMW9sa0hTcmQ3Q0txWjF6RXNRUnRwSTJQMXFzbHBqOW44cVVtMjlqaWtsU09aYVZTL3M3ZFBxUDFwVkJab2dhUk5ObXVrMW1ha053NjExTnFpdXJKNSs4VTBXdk52OVIvV2dDeEZLS0hZbkdMYmRVSmFXRTduYVlxdmdiWnQ0aTROU3R6K0lyYTc4MW5iejlLcmlUWVN0Ym1weFZleHovdm5VNHFSamhUNmpyb3BnV01OOFEvdmxWNnFHRitLcnRhdzZNcDlrbFBxSnpBUHBXZnhIRWJ1WkVidTJETVJxazdJemRmNWFwdWlLTk5YYUU0UEhYR3VLalpZSU93SU9nOWFLelFuWU5VUFduQTB3R25Vd0dPZGFoY1UzRjRsVWtzd0hseitRb1BpZU9pU0VIb1czOWhURVg4UlFxNmN4aWhsL2lWMTJpV1U5VzBVZ2JCY3ZPcVZ0N2hsZ3p6bE01NG1aMUZ1QnZ0dlJURnlRZEdBVGZYM3FGZUVXZytlRG1FL2FQUGZTaHFYcmhEUTF3QVFSbmpPZkpNdW5MbjFwclhMaHpBTTZxTlJuK002ZkNwVXh5K3RUd2ZzcnlSOUJwY0hiRW5MdVpPcDFQWGVuL3N5ZmRGWjVicnZLS3pLUGlsODB6b0l6Qi9uRlNZU3pkdk9MTnBidmkrOW1Zam5PWU9JR2cvczB2Ry9ZZVZlZ28zQzdHdjhBQnQ2bVRLZ3lkZFQxT3A5NmRid2xwZEZ0b3ZvcWo4QlYvaDNBTFZnVGRZM2JoRUZjN0cyRDVrblgwR25tYWhmQ1d3NUlRRDBtTnVRcUpTK3JOSXh2ZEdkN1RJcEZ0ZEpMSFFEbGxNL2xWREZZUWQ1YlNQQ0ZYNlQrZ3JZL3N5ZmRIdFVkL0JXanExdERBNXFEb05hY2NpUXBZMnpCY0VGd1lyTXdjQTU5U0RHL1UrbGJIdlFlWXE5dzdDSmVDaTNiVXp5eWpTTkpQSUNpallMRDRlUWx1Mjk0L0UrUllYcUJwcWY3OHFlVEp6ZDBUanh1Q3F6enJoNWNYN21kbUlCT1hNeElnbWRKT25LdEV1SVg3dzk2SGNad0FONWlBb0JnL0F1NUd0TlhEa0FhcjdSN0FiVmN2bnNpTDRhQzM3UXZVVnloZ1FjMjE5UC9BQ3BWUGpSWGtacXdhUk5SWWErcnFHVXlDSkJxUmpXQjAyUUx6cHhOY3Q4NnA4WHd4dTJtdEtZWndBSTE1ZzdjOXFGWDJOS1QxRld3MWFzNGUvYkM1VmNnZkdHMUIzMWpsODZDY1FsSGx2Q3R0d0ZFeG1raGMwZElPMVppeng1TUozbHF6bnptUVhKakt5L1pnanlQek5EYnZFcmx6K0pjL2l4b0RjSmJVa0V3Wm4ycnE4T2psODI2UFFMVGdBa2tBRGNrd1BlcStMNHhiVElCTnpNU0IzZVZnSWdrc1pBRzRvWmY0Qmk4VllXNW10aTFxNFZpUXpMdURFYkFUSFdhT1d1RzJVdzlxVk1vUXhBSXp1eEFKR1dkaWZscHZXWEJMdGw4MjMxb3NVNFZReFBGYmRzTTEwaE1wV1FNeEF6YkRxVG9hcEh0WmhSLzloLzBQK2xTc2NuMGlua2l1MmFQQ2ZGOHFlMk9VWGhaZ3lWelRwSFBUZVowNlVFNG54UnJlR2E5YUJ6RlZ5eXBueHNvbkwxZ2t3YUE0THRJNmdYcmlscms1Vm53ako5b05BMms2R0pueXJXRVh4TTV5WEtqMEs4ZkMzb2Z3ck5ZMXd0eTBTUUZCY2trd0IvRFlhKzlXeDJsdzdXUy9lQUU2WllZc0Q4aHFQT2duRUxCeHlCYkJEQWc2ekFuU0o1eEkrbERqdFdKUzA2N0R2Q2NVbHk0clcyVmhEYWd6eUZIZ2F4M1pUczlld1Jkcm9CekRUSVpYUWFTU0JCMVAwb2x4RzdpYmhQZGpJcCt5R0dvTWFFenlvcFJ0SU9UYVRhRE4vR29reWRRQ1k1NlVGdmRwUStaRk9RaUFkQm1CSW53dFBRamxRYkgyTHFnbDBBMDFKWlBMWFhlaFNjSHhSYzN3akcyWUpsWlB3d1BBUnQ1MDByZlltOWFRYXZzV21UbUo1eko5NXFMTEEyWWVaQi9HcUQzU2dsMHkvNWtqOENLTTJ1emd4ZHBBU3R0R2hpUk9ZamNRcGtENW1xSnB2b2dXdzIvL2Q5TkthVWdpU0k1em0vU244UzdQWGNJb0lJZTFNSyt4MTFBY2NqeTAwMCtWVnYyaUNScUJyQjd3ekhLUWY3MW9ZRmhtVDc0L3dCMzZVMXd2L0VCK1ovU3U0ZHkwQWQ1dnVMZ0kxMG5RVEh2UmpoTEcyOGdra243WWtqZlVTTkRVeWx4S2pGeUc0SHMrZml2RW91NEFnM0c5QVI0UjVuMm93SFZGeVcxQ0x6QTNiemR0Mi9DbXV4T3BNbnFhelBIT0xsYjlwVlpncXQvRXkvYTIwT25MWG56ckw1VGRHdFJnckQ5eDZFWW5Gc0hJQUIyL0NwVTRrSHVNaXFZQ2hzK2tHWTBqY0hYNkdxMTgrS29hcnMwVEt1TDRrd1pJMGd5d25RcVozbXEvYUxIM2podTl0cVJiN3hGTnhTUnZNQStwQUI5Zk9yNHdpUHFTd01nZUdOZ0NkWkhtYWt4cFA3SzJIVFMyckc0UWRTN0I4OHR0cG9BQU5vSFBXdG9jVlRNTW5KMnJBWFlMaVY4WDc2cTdDMWxJeXlTRkpjWmNzN0dBMm82VnFjVmkxUVFZTFJvSkgxNlZtZUR2M1daNFVGbFZRQWtDWnpabUs2c2RUcVorS3U0Zkd1N09ibHN5dlR4RWlla2FSK2RQUHR1U0p3YWlreTgySmxpWEtrbU54TVJ5M3B0L0hBYUFMTWJnZjFvYnd1NjFyT3BSbURzempML0FEZFJCTTFKY1JYR1Z4Y1lHUENVRGU0bXFVZlpMbDZLdDNpc0V4RERySXBVOXVJcGJKUkxZQ2c2QmtCT3VwblR6cmxhVitET3phOEs0UzFxMGxza1NxZ0gxalg2MWNPQlBYNlVVVkJUd29ybGF0MmRhMHFSbThCWjcyMkhSaEI1RmRRZGlERFVIVmJqWXdXMVlmSGxKSU9paU01QW5vQ2FNOEN4RnV3K0t0dXdBVzZ6Q1R0bVB3Z2RBbmRlOVpiZ0hhSFBlYkxrUjJpRGRCSUpkOVFJWVFTWTY3OHFwNG0zcGFMdzU0d2kzSjdhcEk5UTRad0RCV21OMWJLbTYrcHVONG1KTzhUb3N4eWlzejI2N0kyN2gvYWJCRW9CbnNFUXR3QmlTVks3TWRRZXZsekpjTDRvemZ3cm9WWCt5VlBnWWhaS2lkUTBTMEhlRDBJcVRHWWxFUDhBRVlLakEvRVFKNUh6TzRyYTJqbjBaMWUwdUhuSmZ0NWROUXlEWWpRYVRLK1EzMm9IMnE3VzJqZGpEV25WaUZZczBOQlpROExaQkNqZm1kT2xDMDRVbCs2MW0xZUdkVzhCWWtnd1RHWnRUcU5JM242d1liaDEvRDNuTFdPOHVSQzVXTURPSFV0SzZtSTErdTlPR0RHdHN4bm1tK3Y4bG5pR0liRk1saTlmdDIyWHhGaXVYT3pBWlJrSkVFWmlOSkcrMVcrRzlpSkNPOTJSb1N1U0pFN0U1anZWZTNoTGY3UjMyTHVoMUJsTFFhWVl4bzZrNWxYUWN0ZEpPbXV2d2VNSnNvQUIzaHlKRXlvWjlKSjAwR3NqVFZTS2M1TktvaWhGU2R6Tk5nemJVQUtxZ3h1ZmlQditWUTR5elplU1VHZnJBTTlKbXN4ZHRYY3B1ZDg4QUVoWXQ1Y3UrdmgwTWMrWG5Hc1YzaVp0bGN3azVvSkFpUVVMSzBjdmhJanFEV1BFNnVacnNUY1ZMWlBoRUtZMkd3MG9Kd1Z4WnRMYmtiWnRCdVg4VXo4NkQ5bjhOYkYyNERhMHUrUHhoV2hpekVFSG93SStZMjFxN3grNWxZS2hnNUN4aVBDcVJvQnlKekFhOHZTbngzU0pVL3RoY2NST3NIOC9wUW5pR0d0NVd1QWtMSVpsVFF5VEJ5UkVBeURIclE1TUdSQjcyNW1KQVBqSkhpSVV3cDAwbWZsVi9COEN1bEFWdlJCSTJJMVVsU1FaMjBQeU5KclErVHVnZnczQVc3VndYU1djbktVTHdWeXVGSVlUcUdHcS9oV3BiaUdUeEVoZlBRVmtNZHhHM1p2SXQ2K2pBTTJZSWM1QktuL0V5aVFKTmNUaTJFWmk5MjliSThXVlQ0b0dZZ0FDSjJBTzMydklSZkJ2WkhraXRCbnRGWi9hQXVWYmJpWmVDdWRsOE8yeG1KRy9UV3J2Q0x1NWdoZDFrUjRlV2gyR2hyekRqUEYxZTVjTmxHQ3NRTTNpQjhNNVlFd3VrRDVWcHVGY1p0M0xLSUhBelpBNEpHWUVFWndaNUdEOGpWUEZKRVJ6UmJvMU9PNDVaMFIvR2paZ1JsSlZpQUNzRWpLZFlPaG9PbkZ1R09wWTJ5Z0J5a2taWVBUNHFxY1FOeTYySDdpNWJ6b0M1N3g0RzZITUR0bWtFZjJhdHZlNGhtWU5aVzViQUpVeGJmTWVoQXFaS2kxS3lhMjNEMklGdThVSkVnUm1rRVNDQXluNlZjNGZZc0E1bHhWdGhJNUtwMG5wRlo1K0toZjRsN2h3Vmdjc2l5VllhYmhsNWNxaHU0dmhvUGR2aHpiTnpLZkE3aWRkUFF5VFV1TjYzL1lLVmIxL1J2MHRJZjhBN0ZQb1IrdFlqam5aNjYxMjY3WDdZVExjdURMbUo4QUJDc3NBQW1BTkNaaVlwcjRQQTNZVk1UZnRsQkVBcVlIODJoSitkU1hlRWFscmVNbFNEL0MrQ2ROZ1pwUnFKVW01QVBCY2NzaDFjTXdnQVFSdEFnYWpsVzhQQTJjQjBkQ0dBSTNHaEVqa2V0ZWV0Mlh4akJBYll1UkNpR0hoVVRvV25iMHJUNFhHY1NzMjROcG1DZ0FLQWphQ0JwbGoreFcyWlJrbFJqaGxKTjJXMktXMzd0cnR2TU5ZRGF4QkhQblZERjhXdGhDc2pNWmthekRiUnlOUGJ0UmNBejM4TEVHUEZiWUh5STMwOHhVdHZ0ZllaQTdXeGxPazV2T05tQWlzZU5mUnJ6djdBMW5GQkVKa1NGVXhDc1R1TXZseU5QdytLS3N6RFhOSGlCQUVjaHlrZVZHdjNuZzdna1d4NjVFWWU0TkRFNGRoZ3hLNHFBVE9Scll5aldZQUFBRlUrRXRTRkdVNE80a2VJc29kVGVYckJWeDlRQ0tyTDRoQVlBVHV6SUJQTW1XbXRRTUZnbjBtM1BrNVg2WnE0M1puRE44SmNlalQrTTBKb1RUc3lXSzRwWnpIbWRKMDV3SnBVQTdRV2haeE4yM3FRckdENUhVVDU2MHE3RmhUUnhTelNUYVBkNjRibm5WYkE0b1hMYVhNcFhNb2FEdUpFd2FtTDE1OUhwcG1WNDdoclA3Uzk5MFFoYkxNL2dWaVNtV1RxQ0NjcktQenJKL3Y2eWwzdkxhZUFObUF5SXAzdEhMNzJ6L3I2VnJPMDFxNExlSmNKSWUyNEdza1oxdHBBRzUvdzUrZGVaV0dLdHBLdHVOd1oyMDh6TVYxWWttaml5eWFZVnQ5cjhVRG1Ecm1rTk9VYnFUSHFOVHYxb2Z4WGpWL0VzR3YzV2Nyb0pnQUFrSFFLQU53UGFvYmdLa2pLQWZNRG55Zyt0R2NCd1U1VVo4aUs2M3ZFTlNTcENsQkdtY1NkUEk3Nm10dml0bVB5bHF3WHduRzVIZ1FGTXlPc0F4UHpxOE9LTm5LTzJhMlRCSElkQ1BTbHg3RGtZeGdHVmpsQkpVWlJJdHdkQ2Q5SUk2OGhWRTJ1OGNLcEprYnhFQWJzZklhKzFKcUxkL2dFNUxYNUx1T3ZXTFRaVUJZalJzeG1DT2dBVWZVMWNlOWZ2NGN2YkhkakRNdHc4bTErRmwwR2dLQ0JIUHlvUGpjVERQbFZQRVF3YUphR0diUW5hUXdxWHMrWHUzSHRsekJzMzRCWTVaN3BvMHAxcXd2ZEZtMzJ0eFFUdTVSbElJMVRYWGVDSTZtbGhPTVhMdUp0M2JwQmhoNFZsZHAyVmZFWTNqbWRPZEd1eW1FdGpDdGV1VzdiS0Z6RTNDZElhNGRCQkcyVWUxVSt4bURscnVKWk5RcDdzZFMrZFdLanlpQjZtcGJpcjBXbEoxdnMyL0FMaU9DVjFHU3pvUkVFSkd4MUJrVjU3eCs5ZHcrT3ZzckRNekUrSVNDamdNQWZJYUQvbHJZOW43d3Rrbzg1amJzNlRNTWxzQng1SFVIemswSDdaWWdMaWNOZVVRVUl6SFROQmZ3d0R2SGo1YzZ5aHFiUnJrM0JQMENjVjJpdjNnbHEyaVczYUZsU1N6TWZBSW5SWm4rdGVyWU5WdFcwUmRGUlFvbm9vajhxOHJ4MW51OFVNeC93VVc2ZHBCYkVaMlZRc1pvNzAxdUwzRWkxb20yVllzdmhrRXFaSFB5cFpVcVZEd3QyNzdQTThOZzJ4VjE3azVWZTYyc1RCZlBjMWtnYUJUdVJ1SzdpK0NGRlo4NmxCbWpVQnpsZFUxU1RsTXNOSk5hanN0Z253OEs2cklaN2dZYS9ZVkFEMDNhcW5hUmpjQ0FJNXpQY3paSmdqdmcyb0drd05DUnlIUVZ0NVBsUzZNUEZVYmZab3YvQU9kMmJkdkJHNDRuTzd1ZjhxZUFEL1lUODZGOXIrQ0phc0l3Q0J5QjRnb1VscFFRUUYxSkxiaytkRWVES2k0VmJTWmdDREliVWpNWllmaUtzY1R3UDdUa1Z5Y29NbURHZ2tqWC9NRnJIbFU3TitGd1MvQkZ3L3N1aVNyWmd5cWdsZkdEb2RUejNuWUFWTis1b2IrSGZUTjBNbzM0ejlLTVdTUXhZbmNLUGFkL2VwN2hEQ0dBSTZFQWo2MWxMYnMyaXFWQVh1Y2JiMkxIMGJOOUdxcGY0aGRIK05ZUmgvTmIvTWFVYy9ZMEh3RjdmK1JpQi9wTXI5S2F3dmpaMHVEbzY1VC9BS2wwL3dCdElabTBmQnNXUDdQa0xBaGpiYmNIZVJwVmRlQ1lQS3kyNzkyMW1qNGdUbEk2R05QZWorSmREL2pZUWorWkl1RDEwZ2oycW9NSmc3bndYc2g2RXhyNk5UVW1TNG9vRHMvZjd0Ull4TnQzQitJblVqWFE3OVI3VXJ2NzBzb3BDbTQydVlCcFdKMGlhdlhPemo3cTZzUFA5UlVCczR1MFpCZU9pdG1Ic2FFMTZCcCsyTXY5cXNSWlJHdTJ5WkF6TGsxVXhydEdsTWJ0VGhiaUJydGkyVmJTU0I5UkI2R3B2My9lV0E0VTljNlFmcEZNeFBFc0xjMHZZWlNPcXdmMC9HaFVEYkdvT0czVUlXMlVSdENVMEgrMCtuS2xoK0E0UUt5MnI1QWJreG1OSTBtS1ljQncrNWJOdFhlMHA1YSt2T1FOcVpoT3lZV1RheFBlQWpRRWhvOHhCMHA5cDdKcW10RExYWkc2ckJseEl1S1Bza2VYM2dhb1kvaHVNc2t1VlFwTzZreUJQOWFsdDluc2RiY0hPSFFIV0RySHpINTAzaVBFc1pZWVpVdUZZMTBZd2ZyNVZXM0txVEowbzN0ZjkvSms4ZGR6M0dicWVaMTZhMHExbGp0UGRaUVNBRHpsUk9oalhTbFc2elNTcmljN3d3azc1ZjZQVkJhQXBGUlVwRk1LMXhub0VMb1AvZFp2ajJkN2x1M2F5S2ZHek1STUxDb2NvNWtoeVBuV3BhM05VYnZERUxaL3RSbG5YYVpqZnJUVG9tU3RIbWZHdUFsc1FZSmk0eGxqcUFUNG9BM0FoVDE1Vlp0OEl1QTIwa2xWWXlSSk1aVG9CeVV4N3RXK3VjSXRzeXNabFRJOWNwWFhyb3hxZExDcnNBUHBXbmtkVVorRlhaNTQzWXU1ZXVGMmNJdkxUTVFCOHdQL0FIUmRPeHR0VXlDN2M4L2hBUHJBbVBLYTE3VkUxSjVKTWF4Uld6QVgrd1RsdjhaUXVuMlNXZ0FDSW1PWFdyRDlrN1ZpMjVYT3pzcFROdkdmd2tnRGJldG95MDByUjVaQzhNZlJoVzRZeTRaOE9BV1V0bUdiUWdpSTIzMm1yWENEZEZ1M0FpTGFydEIwMko5NjFqMjZpN21rNXRsTEdsMEFPRjRPNmpzN3ZKZUorUWdhVkZ4cmdvdnNwSUo2NjdBQm9BNTdtdEliVk5ObWtwTmJHNEpxbVkyL3dWZ3hkVmw5TlNUc0NwLy9BQ0tsNExZeENNVlpJdG1ZZ2lGNWlOWmp5OUsxbmRWMFc2Zk4xVEY0MG5hS0Z1eWVkU0pnbEFpUDdPdFhNbExMVTJWUlh0NFlMb0FCNlZLbHVwSXBSUllVZFUwOFBUQlhab0dQelVzMU1tdUdnUkxucURFWWRMbnhvcmVvMTk5NjdOZG1nQWMzQjFVemFlNWFQOHJFajVnL3JUYzJNdDdNbDBkQ0liOHZ4TkVzMUltZ0FXM0hGMnYyV1R6SWtmV0tqTm5CWGZ1cVQveUdpMmJsVlBFOE1zdjhTQ2VvOFA0VUJRUHZkbGxPcVhENVRxS0dZbnMvaUUrR0Q1Z3dmclJLN3dSMU0yTHpLZWhtUGRmMHB2N2JqYlh4b0xnNmdULzB3ZmNVeVdCbHhXTXMvYXVqMThZK3NpcDdQYTI4TkhWSEhwbFAwMjlxS1crMDFzNlhFS25ueittOVRtNWhMM05ENitFL1duL0JOZW1DL3dENVduUERmN2gvMjBxdkhzeGh6cUFma3hqOGE1VCtJZkk5Qk5OTktsV1pzTk5NTktsUUExaFVUQ2xTcGlPUlhDdEtsU0dNS1V3clNwVUFNWVUyS1ZLZ1FpSzVGS2xRTTRCWEtWS2dCaHJrVXFWQWpzVXBybEtnQkdrS1ZLZ0RrMHBwVXFCQ3BVcVZNRHNWd2lsU29BWVRUU2FWS2dCcGFtNXE3U3BBUlg3Q1hOSFJXOVFEN0hsUXUvMmV0SDRDeUgvVVBZNi9XdTBxZGcwbURMblp5N09qV3lQK1lmU0tWS2xUNU1qZ2ovL1pcIixcclxuICAgICAgICAgICAgdGh1bWJuYWlsOiBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFELzJ3Q0VBQWtHQnhNU0VoVVNFeE1WRmhVWEdCY1hHQmNYR0JjV0Z4Z1hGUlVYRmhjVkZSY2FIaWdnR0JvbEhoVVZJVEVoSlNrckxpNHVGeDh6T0RNdE55Z3RMaXNCQ2dvS0RnME9HaEFRR3kwbUh5VXRMeTB0TFMwdkxTMHRMaTB0TFMwdEt5MHRMUzB0TFMwdExTMHRMUzByTFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TGYvQUFCRUlBTGNCRXdNQklnQUNFUUVERVFIL3hBQWJBQUFCQlFFQkFBQUFBQUFBQUFBQUFBQUZBQUlEQkFZQkIvL0VBRUVRQUFJQkFnUURCZ01GQmdRR0F3RUFBQUVDRVFBREJCSWhNUVZCVVFZVEltRnhrVEtCb1VKU3NjSFJGQlVqWXVId00zS1NvbE9Dc3RMaThSWkR3Z2YveEFBYUFRQURBUUVCQVFBQUFBQUFBQUFBQUFBQUFRSURCQVVHLzhRQUtCRUFBZ0lDQWdJQ0FRUURBUUFBQUFBQUFBRUNFUU1oRWpFVFVTSkJZUlF5Z2JHUm9mQUUvOW9BREFNQkFBSVJBeEVBUHdBUzFkRk5jMDVUWHo3UHBFU0xYTVF4aUJ1ZEo2SGthNnROVjViMC9FLzBuM3BvR1dydUNleVFseFdVd0lEQ0RISTFCZFFNSUlCQjYxTmV2czBaaVRBZ1Ryb09WUkRlaHZlZ1Mxc3JZREJKWUxGSkdmU0NaZ0RlUGVyaTYwRjdXZDZqMld0cXhDaGcwQ2RUQklNZVMwM0RjY1RKT1lBbis1clNjSk5KOW1jWnhpMnVnemNibFRKb1ArOWsrOFBjVno5N3A5OWZjVUtEQnpYc0xrMDB0UW84WXQvZlgzRk5QR0xmMzE5eFJ3Zm9PY2ZZVFpxYUdvV09MSVRBWUVuekZFc013T3RKcHJzYWtuMFRvbldwSzREU3FEUTdTQXJwQUFrMDZ5K1lTQVk4OVBuNlZTaVM1SEcwRWdFbnBURXNzU0N4MjJVYlQ1OWF1VzdKUHBWcTNhQS9XclNJWlh0WVluZlQ4YXRJZ0d3cDRGUEMwMGlXeXE4a3dCVDdXRzYxSzF3Q284eFBwVnBFdG5MakJUcDlLa2JFcnlxOXhkTU9FdDl5V0xSNDgyMDZiZlg2VUhLMDJpVXg3NGdHbW1veWxjQmlnQnhGY3B3TmNJb0djcFVvcm9GQWhzVjFiWk5TMjBvN3dQaUNXYzBXMHVNZEJJTFI2QVUwaE5tZTdrMTJqejRHNnhMZHlkZGVRK25LbFFJdzR1VFV5TlVOdTNvS2QzUjVWeVVkaUxLbXJHRlMxM1JrUDNwTWd5TXVXTm1FVG0yMW1od1VraFdPVUVnRW1kQk9wcTdkaFdLaDFlREdaWmcrWW1EVDZRdTJJbXA4SUFQRWZsNjhxcjIxekdLdFhEcnBzTnFTMXNydlF4MHpBZzg5K1IxODZ5T0w3SU9DY3JnQ1RHYVRvWWlZMjU5ZGhXLzRUZ3M1TE44SStwL1NvT0pycldtT2NvYlJubGhHZW1lZmpzbGQvd0NJbnMxUFBaRi8rS3NmNVQrdGF1YVJhci9VVDltWDZiSDZNcC84UmJYK01KNWVFL1hXa3ZaSTg3M3NuUDhBMVZxR2FrcXp2UitvbjdHdi9OajlHYXQ5a3oveHV2MkkxNWZhcUsxakh3OXp1cnZ5Ymt3NUVmMzVWcnFxOFF3S1hseXVPc0htcElpUlNXWnkxUG9id0tPNGFaekNYYzRrVmN0UnkxNWYwcWx3emh4dDJ4YkpPaDNHa2o4cUxZZkNBQ0lnZEJVOFY5Rkp2N0lCWXpFYVRIc0t1VzhPQnZxYW1WWTBGUEM5YXBJVFkwQ3BBbldtbTVHMVJsaWFwSWhzbGE2QnRVVE9UU0MwNExWQ0l3S2NGcDlOTFVBY0lwdVdrWHA5cTVyb0pOQWl3ZUZYTzdGd29jaE1CbzBtcVY2MUc5YkxoSEM3MTlBSGNyYkd5algyblFVTTdRY0lzbzhDK29nYXFJZTRXa3pKMXlqYXFyVmtjdDBaUjdzSFQvM1V0dTZENjlLSjR2cy8zU0xlS2FQOExNWlkvcFF6SnFOS1RSU2RpWjZxM2NhcTZGaFBUYyt3cTQ5c0VFSG5wNzFIaDdDVy9nUUE5ZHo3MGhzbDRQYk41NEtPRmljeDBCT21nSFBuVzF3TjdDNFllTjFCNkR4TjdDVFdMZTh4MGt4MDJGUlJUc1RWbzNqOXRzT0RBdDNDT3NMK2JVcXdjVXFybXlQRkVyMjdORThEZ3BPdFZrcTloM3JqTzRtNGh3NEViQ2cyTjRhRjJtampYaUtneFYwRUdlbEt4MENNS3VWUE1rKzIxUEZRRXdmS25ERUFVdXg5QmkxamNxZ0RsVkRGM1pxbStLOWFpZTZUVldSUTltcGhhb3lUWFVOSVpLcTlha21vd2FtUzMxcGRqNk9LSnJ0dGhteTdubjBIcWVWVEluU3A3V0hBcTFFaHNwNFBIcWJyMnZ0TGwrWVpRZnpxNWN4bHRmaWRSOHhRN2ozQk8vQWEyUWwwYUJ0UUNzemxZajNIOWFIWVhzZXltWHYvQUNSZk9kMlA1VjBSakJxMnpubEthZEpCcTN4eXl4eXE2ayt1L3AxcXlMMDg2RVhleTFrcUFHY0VmYU9VaytvZ1RROXVFWXl4cmFmdkY2ZitMZmthcW8vVEo1U1hhTlVpYXpQeTVWSUJXV3cvYU5rT1c5YlpUNkg2cWRSOWFOWVBpOXU1OExBK1hNZW9wT0xRMU5NSkJhYXdORXVBNHRuSnMyd0RuSVZ2RG5qWGMvZEE5UlJEakhDN05yUTNnei9kRWFmSWJmT2l0V0hKWFJsM3VSVEZIU2ZtWm9oaXV6NFFvMXdGbGZ4TEprUlBJYkRlcjk1TFZpOENuOFJCQjFFVDFFSGFpaDJCYlBETHQ1Z2xzd1Q1U2ZsT2xFdUU4S1cxZnkzQ1ZZbkt6T1pqWG4wRlB2Y1JpOGJ0c1pOWlVEbFZYRll0cmpGbU1rNmswOUMyeTl4M0V1SGEwdDR0YkdneW5LcCtRMytjMEdVUlQyMXBzVW13U0NkZ2Q1YmJQZFZjZzhLdExFK1NqWVVJZGFrbW4yckpZeFFCVk5OQm90aitHaTJZRHEra3lrbjViVFFURjRoRTNQOEFmcHZSUVdURVZ5S2dzWW5hUm9kait0VHM0cERPUlNxczNFYllNRjFrZVlwVUNzdXFsVzdLMWR2Y01aVEJCRk1GaUt3YU9sTWd1aXFXSWJRMWZ2TFZDL1VVVVVYRlFzbFd5bE9Xd1R5b0FIc0s3bHE5ZndUU0FCcWVWVC91YTdHWW8wVGwyTy9TbWxZcm9FNWE0eTFhdllabEpCRUViZzFHYmRGRHNmWVNyYVdldExERG9LSXBnbWlZbXJqR3lKU29xcXZTbkNyMXEyZ25PcmJHSTBodVJPaGtWV0tpdE9OR2ZLeGttcDd0OEZGWElvS3o0aE9acCs5cnlxSWltazB4Q0MxYVRBWENtY0tjc3hNYVRFeFZSU2FPOEZ4RmkzcmZabTZJc21UNTh2YzBJVGRJQVlxMnBFT29JOHdDQjc3VUtmQzJNUDhBeHdJREZRWU1yck1IWGw4NjAzR3NWYXZQSzJRb0cyYlhmK1VhZmpWV3poQmRQZHRreW5TSGdKcHJyT2cyL0NxVCtoTlhzaXdQYS9EV1F5dTRaV1VqS2hJOFIySnkvblE3Q2NlczNEQ3RyMGJRKzNPdXQyZXcrY3N5Wmo1a2tldzBJOVpybU43UFllNlBnQ0hreWVFKzJ4K1lxdmlSOCt3c3VLSmpYYmFwc2JmVjJsVUNDQm9DU1BYWFdzaTNDOFhZMXMzQmRYN3JhTjhwTWZVZWxYZUZjVXVYSlZyVEl5bUNHa2ZNU05SU2E5RFV0N0RhV2lkZ1Q2VTFsSW9sMmU3MEh2TGg3cTFxcnNENG9QMllVR1o2VFZqaWJZUnlGdEJ6eXpOTWV1cG42VXFIeTNRQWE0T3RNTjNvS0tXK0EyYmQ0QzZIZE53NGtrOUdYTnltdTRmRVdiWWNNaXRJSVVrNnFldm5SUVdCQzEwa2hiWklIMnBBRzN2OUtPOEc0WVNodlhSS3FmRmxrZ2RCckZXdUE0c09Hc3JtZEdqTUV5Z3lOUjRqdFV2RXVHNGl6YUlWZkNZOE9mUSt1d3AwSzlrMS90TmFDRzNhdzBnZ2c1aUJvUkd5L3JWWGhlQnRYYmR6K0RsY0NWQ0JWWHp6RnRhQ1c3TjR0cVZVZVdwMjlPdGE3Z0hEYmU5enhIb1RJcDIyeWFTV2pIWW5EUk1rQ3FpbFRzdzAwcjBiaS9DTU81MHRBdTJnNThvZ0x0eTVWaWVKNFJFWXJDZ2pjRFNDT29wTlVWR1ZnMDRWUHVMN0NsVGhBMEJydFNNOVp1WXkxY3VBbEFSVkorQ0k1dVFZSjFRY2g2MW5MUEVJTldXNHdSc2RheWVSdDdSZmdjZjJPZ1h4V3dFZ0JnelNRNmdFWlNERy9PZDlLRmxacWJIMzVhZVpxS3h6cUc3Tm9xamkyS3ZZV3hVS21yRnUvRlNXanR4d01SYjhzbi9WVzFmakNBUnB1RDh4enJ6aTdlbTdQbVBwVmg4VWFhYlhSblBIR2Y3Z3QyMXg2WEhoRldHeWxqQXpabG5VSGxNNitnck1xdFRYV25la29xbTIrd2pGUlZJbXd5YWl0SGhZclAyQnFQVWZqUmkxY3E0RXpMbUtzcVJwUUM5WjJvMWN1YVZRdXJNZjN5TmFHWU1Oc3o1VWlBS0lkM1V2N01EeW9vQWRaUlNSSmdUcVFKZ2RZNTBudGlUR281Vlp2NFFjcXFPckNnQjNjbmVEVFRwUlBoM0ZMZHBTTGdOem1GTDVWQmlKSUc1K1ZENzkxSGFRQUo1RFdnVmtRdUQxbzd3L0FMY3QrUHU3VUdjN3RCUDhzU0JWWEVjR3VJdmVCU1U1TkdXZmtkYWRnTUphWkdOeDB0d2ZpSkxIVWFMbEhwVFNFM3JRTTRqaDJEa1c3aUZlc0Uvb1ByVkhpMWkvbERXU002ejRXMllIbE1pRDY2VVNaa1Z0SExMMVZZbi9BRlVSeHZHYlRybEZoaXhHcnZjSmJhTnY2MElHWTlidkVoYkk3MjFCSUp0YkF4NXh2ODZLNEMzZGVCbXlubnBOZHRXMEFPZ0IwZ2xpWUhNYTc4dmFyQXNPRU53RTVRY3BJMEVrVEUwTjJDalJyc053Nnl0bitLNXVOOTV6dDVLT2xaM0Y4T3R0THFGS3F3RTZRQ2RSK0ZDcjkwc2N6RXNlcHJpdkhLaXdVVFE4TzRuYnc0VWp4U0poWWtRWWdqN05UOFU3VWhqbFZTVjBrekI1U0lqMUZBTUxpTGV2ZXpHVXhsS2p4Y3BubFZHNWRIWDhhTDBIRlhZWC9lb1c3bkNBb0RJVnR5T2pFZmxWVEZjVGRtSkRsUVNmQ3BJQUhUU2h4dWlvMnhBSFQ1bWxZNkw5akZGV3pobUREWWdtZmVyZHJDbTZ0eTVLK0hWc3pBTVo2QTZrMERYRkE3UWZUV3V0aVQxajJvc0tMSlBsU3FnY1VQdmozcFVoaDRIV281Sk0xM05UTGdrQWE3allrYmE4dVZZSFFSRHJVbGs2R28zcnRzNlVoa3BhdUI2WlhLQUl2dFZMTlFydlV0TVFxZXRjRk9GQUUxbmNldEVWTkRySHhDcjRyV0hSbFBzbXphVTBqYisrVk5tbkhsV2hCMENwa05RaXBBYUFKSEFOVnJsbVFhbm11MGdCRjdDRFdxbmNsVG9TUFNqbDJxMXkwRFRFQ2I0YzZsbWIvTVNmeHFCY1RsM2dmS2lWeEtGNDFLUUYwWTljaFVyTEVnaHRRUUJNaU50ZFBhcXB2anBRY3NaT3A5NnFXOGNEZDdzcWRaTW4rV2xkajZOQ2NVQjA5NjRlSWFSbUh5MW9SaDdvSllSOEpqMS9TcDgxVFpYRXROamZNK3hxTTRyeVB6aWdHTDQzbExpSXlzRkd4bmVaMTBtUHJVM0R1SVoxQjZhR1luVG1ZcTNHU1ZrS1VXNkM1eEI2RDMvcFRHdnQ1Zlg5YXJQaUFCbUxBQWI2Ymlvcjk4QWhwMzhJRTZNVEIvQ0krZEpKc3B0SXRzN0huOUJRWEc4TXVPMHE0VmZVL3BSUXdKR2NNY3hFQWJhRGJxUE9vcnVJQ2tBaDllaU1mcUJIdWFFNUo2RkpSYTJVY0J3dHJiWmpjblFpTmYxb2xrSFNyZDdDS3FaMXpFc1FSdHBJMlAxcXNscGo5bjhxVW0yOWppa2xTT1phVlMvczdkUHFQMXBWQlpvZ2FSTk5tdWsxbWFrTnc2MTFOcWl1cko1KzhVMFd2TnY5Ui9XZ0N4RktLSFluR0xiZFVKYVdFN25hWXF2Z2JadDRpNE5TdHorSXJhNzgxbmJ6OUtyaVRZU3RibXB4VmV4ei92blU0cVJqaFQ2anJvcGdXTU44US92bFY2cUdGK0tydGF3Nk1wOWtsUHFKekFQcFdmeEhFYnVaRWJ1MkRNUnFrN0l6ZGY1YXB1aUtOTlhhRTRQSFhHdUtqWllJT3dJT2c5YUt6UW5ZTlVQV25BMHdHblV3R09kYWhjVTNGNGxVa3N3SGx6K1FvUGllT2lTRUhvVzM5aFRFWDhSUXE2Y3hpaGwvaVYxMmlXVTlXMFVnYkJjdk9xVnQ3aGxnenpsTTU0bVoxRnVCdnR2UlRGeVFkR0FUZlgzcUZlRVdnK2VEbUUvYVBQZlNocVhyaERRMXdBUVJuak9mSk11bkxuMXByWExoekFNNnFOUm4rTTZmQ3BVeHkrdFR3ZnNyeVI5QnBjSGJFbkx1Wk9wMVBYZW4vc3lmZEZaNWJydktLektQaWw4MHpvSXpCL25GU1lTemR2T0xOcGJ2aSs5bVlqbk9ZT0lHZy9zMHZHL1llVmVnbzNDN0d2OEFCdDZtVEtneWRkVDFPcDk2ZGJ3bHBkRnRvdm9xajhCVi9oM0FMVmdUZFkzYmhFRmM3RzJENWtuWDBHbm1haGZDV3c1SVFEMG1OdVFxSlMrck5JeHZkR2Q3VElwRnRkSkxIUURsbE0vbFZERllRZDViU1BDRlg2VCtnclkvc3lmZEh0VWQvQldqcTF0REE1cURvTmFjY2lRcFkyekJjRUZ3WXJNd2NBNTlTREcvVStsYkh2UWVZcTl3N0NKZUNpM2JVenl5alNOSlBJQ2lqWUxENGVRbHUyOTQvRStSWVhxQnBxZjc4cWVUSnpkMFRqeHVDcXp6cmg1Y1g3bWRtSUJPWE14SWdtZEpPbkt0RXVJWDd3OTZIY1p3QU41aUFvQmcvQXU1R3ROWERrQWFyN1I3QWJWY3Zuc2lMNGFDMzdRdlVWeWhnUWMyMTlQL0FDcFZQalJYa1pxd2FSTlJZYStycUdVeUNKQnFSaldCMDJRTHpweE5jdDg2cDhYd3h1Mm10S1lad0FJMTVnN2M5cUZYMk5LVDFGV3cxYXM0ZS9iQzVWY2dmR0cxQjMxamw4NkNjUWxIbHZDdHR3RkV4bWtoYzBkSU8xWml6eDVNSjNscXpuem1RWEpqS3kvWmdqeVB6TkRidkVybHorSmMvaXhvRGNKYlVrRXdabjJycThPamw4MjZQUUxUZ0Fra0FEY2t3UGVxK0w0eGJUSUJOek1TQjNlVmdJZ2tzWkFHNG9aZjRCaThWWVc1bXRpMXE0VmlRekx1REViQVRIV2FPV3VHMlV3OXFWTW9ReEFJenV4QUpHV2RpZmxwdldYQkx0bDgyMzFvc1U0VlF4UEZiZHNNMTBoTXBXUU14QXpiRHFUb2FwSHRaaFIvOWgvMFArbFNzY24waW5raXUyYVBDZkY4cWUyT1VYaFpneVZ6VHBIUFRlWjA2VUU0bnhScmVHYTlhQnpGVnl5cG54c29uTDFna3dhQTRMdEk2Z1hyaWxyazVWbndqSjlvTkEyazZHSm55cldFWHhNNXlYS2owSzhmQzNvZndyTlkxd3R5MFNRRkJja2t3Qi9EWWErOVd4Mmx3N1dTL2VBRTZaWVlzRDhocVBPZ25FTEJ4eUJiQkRBZzZ6QW5TSjV4SStsRGp0V0pTMDY3RHZDY1VseTRyVzJWaERhZ3p5RkhnYXgzWlRzOWV3UmRyb0J6RFRJWlhRYVNTQkIxUDBvbHhHN2liaFBkaklwK3lHR29NYUV6eW9wUnRJT1RhVGFETi9Hb2t5ZFFDWTU2VUZ2ZHBRK1pGT1FpQWRCbUJJbnd0UFFqbFFiSDJMcWdsMEEwMUpaUExYWGVoU2NIeFJjM3dqRzJZSmxaUHd3UEFSdDUwMHJmWW05YVFhdnNXbVRtSjV6Sjk1cUxMQTJZZVpCL0dxRDNTZ2wweS81a2o4Q0tNMnV6Z3hkcEFTdHRHaGlST1lqY1Fwa0Q1bXFKcHZvZ1d3Mi8vZDlOS2FVZ2lTSTV6bS9TbjhTN1BYY0lvSUllMU1LK3gxMUFjY2p5MDAwK1ZWdjJpQ1JxQnJCN3d6SEtRZjcxb1lGaG1UNzQvd0IzNlUxd3YvRUIrWi9TdTRkeTBBZDV2dUxnSTEwblFUSHZSamhMRzI4Z2trbjdZa2pmVVNORFV5bHhLakZ5RzRIcytmaXZFb3U0QWczRzlBUjRSNW4yb3dIVkZ5VzFDTHpBM2J6ZHQyL0NtdXhPcE1ucWF6UEhPTGxiOXBWWmdxdC9FeS9hMjBPbkxYbnpyTDVUZEd0UmdyRDl4NkVZbkZzSElBQjIvQ3BVNGtIdU1pcVlDaHMra0dZMGpjSFg2R3ExOCtLb2FyczBUS3VMNGt3WkkwZ3l3blFxWjNtcS9hTEgzamh1OXRxUmI3eEZOeFNSdk1BK3BBQjlmT3I0d2lQcVN3TWdlR05nQ2RaSG1ha3hwUDdLMkhUUzJyRzRRZFM3Qjg4dHRwb0FBTm9IUFd0b2NWVE1NbkoyckFYWUxpVjhYNzZxN0MxbEl5eVNGSmNaY3M3R0EybzZWcWNWaTFRUVlMUm9KSDE2Vm1lRHYzV1o0VUZsVlFBa0NaelptSzZzZFRxWitLdTRmR3U3T2Jsc3l2VHhFaWVrYVIrZFBQdHVTSndhaWt5ODJKbGlYS2ttTnhNUnkzcHQvSEFhQUxNYmdmMW9id3U2MXJPcFJtRHN6akwvQURkUkJNMUpjUlhHVnhjWUdQQ1VEZTRtcVVmWkxsNkt0M2lzRXhERHJJcFU5dUlwYkpSTFlDZzZCa0JPdXBuVHpybGFWK0RPemE4SzRTMXEwbHNrU3FnSDFqWDYxY09CUFg2VVVWQlR3b3JsYXQyZGEwcVJtOEJaNzIySFJoQjVGZFFkaUREVUhWYmpZd1cxWWZIbEpJT2lpTTVBbm9DYU04Q3hGdXcrS3R1d0FXNnpDVHRtUHdnZEFuZGU5WmJnSGFIUGViTGtSMmlEZEJJSmQ5UUlZUVNZNjc4cXA0bTNwYUx3NTR3aTNKN2FwSTlRNFp3REJXbU4xYkttNitwdU40bUpPOFRvc3h5aXN6MjY3STI3aC9hYkJFb0Juc0VRdHdCaVNWSzdNZFFldmx6SmNMNG96Zndyb1ZYK3lWUGdZaFpLaWRRMFMwSGVEMElxVEdZbEVQOEFFWUtqQS9FUUo1SHpPNHJhMmpuMFoxZTB1SG5KZnQ1ZE5ReURZalFhVEsrUTMyb0gycTdXMmpkakRXblZpRllzME5CWlE4TFpCQ2pmbWRPbEMwNFVsKzYxbTFlR2RXOEJZa2d3VEdadFRxTkkzbjZ3WWJoMS9EM25MV084dVJDNVdNRE9IVXRLNm1JMSt1OU9HREd0c3hubW0rdjhsbmlHSWJGTWxpOWZ0MjJYeEZpdVhPekFaUmtKRUVaaU5KRysxVytHOWlKQ085MlJvU3VTSkU3RTVqdlZlM2hMZjdSMzJMdWgxQmxMUWFZWXhvNms1bFhRY3RkSk9tdXZ3ZU1Kc29BQjNoeUpFeW9aOUpKMDBHc2pUVlNLYzVOS29paEZTZHpOTmd6YlVBS3FneHVmaVB2K1ZRNHl6WmVTVUdmckFNOUptc3hkdFhjcHVkODhBRWhZdDVjdSt2aDBNYytYbkdzVjNpWnRsY3drNW9KQWlRVUxLMGN2aElqcURXUEU2dVpyc1RjVkxaUGhFS1kyR3cwb0p3VnhadExia2JadEJ1WDhVejg2RDluOE5iRjI0RGEwdStQeGhXaGl6RUVIb3dJK1kyMXE3eCs1bFlLaGc1Q3hpUENxUm9CeUp6QWE4dlNueDNTSlUvdGhjY1JPc0g4L3BRbmlHR3Q1V3VBa0xJWmxUUXlUQnlSRUF5REhyUTVNR1JCNzI1bUpBUGpKSGlJVXdwMDBtZmxWL0I4Q3VsQVZ2UkJJMkkxVWxTUVoyMFB5TkpyUStUdWdmdzNBVzdWd1hTV2NuS1VMd1Z5dUZJWVRxR0dxL2hXcGJpR1R4RWhmUFFWa01keEczWnZJdDYrakFNMllJYzVCS24vRXlpUUpOY1RpMkVaaTkyOWJJOFdWVDRvR1lnQUNKMkFPMzJ2SVJmQnZaSGtpdEJudEZaL2FBdVZiYmlaZUN1ZGw4TzJ4bUpHL1RXcnZDTHU1Z2hkMWtSNGVXaDJHaHJ6RGpQRjFlNWNObEdDc1FNM2lCOE01WUV3dWtENVZwdUZjWnQzTEtJSEF6WkE0SkdZRUVad1o1R0Q4alZQRkpFUnpSYm8xT080NVowUi9HalpnUmxKVmlBQ3NFaktkWU9ob09uRnVHT3BZMnlnQnlra1pZUFQ0cXFjUU55NjJIN2k1YnpvQzU3eDRHNkhNRHRta0VmMmF0dmU0aG1ZTlpXNWJBSlV4YmZNZWhBcVpLaTFLeWEyM0QySUZ1OFVKRWdSbWtFU0NBeW42VmM0ZllzQTVseFZ0aEk1S3AwbnBGWjUrS2hmNGw3aHdWZ2NzaXlWWWFiaGw1Y3FodTR2aG9QZHZoemJOektmQTdpZGRQUXlUVXVONjMvWUtWYjEvUnYwdElmOEE3RlBvUit0WWpqblo2NjEyNjdYN1lUTGN1RExtSjhBQkNzc0FBbUFOQ1ppWXByNFBBM1lWTVRmdGxCRUFxWUg4MmhKK2RTWGVFYWxyZU1sU0QvQytDZE5nWnBScUpVbTVBUEJjY3NoMWNNd2dBUVJ0QWdhamxXOFBBMmNCMGRDR0FJM0doRWprZXRlZXQyWHhqQkFiWXVSQ2lHSGhVVG9XbmIwclQ0WEdjU3MyNE5wbUNnQUtBamFDQnBsait4VzJaUmtsUmpobEpOMlcyS1czN3RydHZNTllEYXhCSFBuVkRGOFd0aENzak1aa2F6RGJSeU5QYnRSY0F6MzhMRUdQRmJZSHlJMzA4eFV0dnRmWVpBN1d4bE9rNXZPTm1BaXNlTmZScnp2N0ExbkZCRUprU0ZVeENzVHVNdmx5TlB3K0tLc3pEWE5IaUJBRWNoeWtlVkd2M25nN2drV3g2NUVZZTROREU0ZGhneEs0cUFUT1JyWXlqV1lBQUFGVStFdFNGR1U0TzRrZUlzb2RUZVhyQlZ4OVFDS3JMNGhBWUFUdXpJQlBNbVdtdFFNRmduMG0zUGs1WDZacTQzWm5ETjhKY2VqVCtNMEpvVFRzeVdLNHBaekhtZEowNXdKcFVBN1FXaFp4TjIzcVFyR0Q1SFVUNTYwcTdGaFRSeFN6U1RhUGQ2NGJublZiQTRvWExhWE1wWE1vYUR1SkV3YW1MMTU5SHBwbVY0N2hyUDdTOTkwUWhiTE0vZ1ZpU21XVHFDQ2NyS1B6ckovdjZ5bDN2TGFlQU5tQXlJcDN0SEw3MnovcjZWck8wMXE0TGVKY0pJZTI0R3NrWjF0cEFHNS93NStkZVpXR0t0cEt0dU53WjIwOHpNVjFZa21qaXl5YVlWdDlyOFVEbURybWtOT1VicVRIcU5UdjFvZnhYalYvRXNHdjNXY3JvSmdBQWtIUUtBTndQYW9iZ0traktBZk1EbnlnK3RHY0J3VTVVWjhpSzYzdkVOU1NwQ2xCR21jU2RQSTc2bXR2aXRtUHlscXdYd25HNUhnUUZNeU9zQXhQenE4T0tObktPMmEyVEJISWRDUFNseDdEa1l4Z0dWamxCSlVaUkl0d2RDZDlJSTY4aFZFMnU4Y0twSmtieEVBYnNmSWErMUpxTGQvZ0U1TFg1THVPdldMVFpVQllqUnN4bUNPZ0FVZlUxY2U5ZnY0Y3ZiSGRqRE10dzhtMStGbDBHZ0tDQkhQeW9QamNURFBsVlBFUXdhSmFHR2JRbmFRd3FYcytYdTNIdGx6QnMzNEJZNVo3cG8wcDFxd3ZkRm0zMnR4UVR1NVJsSUkxVFhYZUNJNm1saE9NWEx1SnQzYnBCaGg0VmxkcDJWZkVZM2ptZE9kR3V5bUV0akN0ZXVXN2JLRnpFM0NkSWE0ZEJCRzJVZTFVK3htRGxydUpaTlFwN3NkUytkV0tqeWlCNm1wYmlyMFdsSjF2czIvQUxpT0NWMUdTem9SRUVKR3gxQmtWNTd4KzlkdytPdnNyRE16RStJU0NqZ01BZklhRC9sclk5bjd3dGtvODVqYnM2VE1NbHNCeDVIVUh6azBIN1pZZ0xpY05lVVFVSXpIVE5CZnd3RHZIajVjNnlocWJScmszQlAwQ2NWMml2M2dscTJpVzNhRmxTU3pNZkFJblJabit0ZXJZTlZ0VzBSZEZSUW9ub29qOHE4cngxbnU4VU14L3dVVzZkcEJiRVoyVlFzWm83MDF1TDNFaTFvbTJWWXN2aGtFcVpIUHlwWlVxVkR3dDI3N1BNOE5nMnhWMTdrNVZlNjJzVEJmUGMxa2dhQlR1UnVLN2krQ0ZGWjg2bEJtalVCemxkVTFTVGxNc05KTmFqc3Rnbnc4SzZySVo3Z1lhL1lWQUQwM2FxbmFSamNDQUk1elBjelpKZ2p2ZzJvR2t3TkNSeUhRVnQ1UGxTNk1QRlViZlpvdi9BT2QyYmR2Qkc0NG5PN3VmOHFlQUQvWVQ4NkY5citDSmFzSXdDQnlCNGdvVWxwUVFRRjFKTGJrK2RFZURLaTRWYlNaZ0NESWJVak1aWWZpS3NjVHdQN1RrVnljb01tREdna2pYL01GckhsVTdOK0Z3Uy9CRncvc3VpU3JaZ3lxZ2xmR0RvZFR6M25ZQVZOKzVvYitIZlROME1vMzR6OUtNV1NReFluY0tQYWQvZXA3aERDR0FJNkVBajYxbExiczJpcVZBWHVjYmIyTEgwYk45R3FwZjRoZEgrTllSaC9OYi9NYVVjL1kwSHdGN2YrUmlCL3BNcjlLYXd2alowdURvNjVUL0FLbDAvd0J0SVptMGZCc1dQN1BrTEFoamJiY0hlUnBWZGVDWVBLeTI3OTIxbWo0Z1RsSTZHTlBlaitKZEQvallRaitaSXVEMTBnajJxb01KZzdud1hzaDZFeHI2TlRVbVM0b29Ecy9mN3RSWXhOdDNCK0luVWpYUTc5UjdVcnY3MHNvcENtNDJ1WUJwV0owaWF2WE96ajdxNnNQUDlSVUJzNHUwWkJlT2l0bUhzYUUxNkJwKzJNdjlxc1JaUkd1MnlaQXpMazFVeHJ0R2xNYnRUaGJpQnJ0aTJWYlNTQjlSQjZHcHYzL2VXQTRVOWM2UWZwRk14UEVzTGMwdllaU09xd2YwL0doVURiR29PRzNVSVcyVVJ0Q1UwSCswK25LbGgrQTRRS3kycjVBYmt4bU5JMG1LWWNCdys1Yk50WGUwcDVhK3ZPUU5xWmhPeVlXVGF4UGVBalFFaG84eEIwcDlwN0pxbXRETFhaRzZyQmx4SXVLUHNrZVgzZ2FvWS9odU1za3VWUXBPNmt5QlA5YWx0OW5zZGJjSE9IUUhXRHJIekg1MDNpUEVzWllZWlV1RlkxMFl3ZnI1VlczS3FUSjBvM3RmOS9KazhkZHozR2JxZVoxNmEwcTFsanRQZFpRU0FEemxST2hqWFNsVzZ6U1NyaWM3d3drNzVmNlBWQmFBcEZSVXBGTUsxeG5vRUxvUC9kWnZqMmQ3bHUzYXlLZkd6TVJNTENvY281a2h5UG5XcGEzTlVidkRFTFovdFJsblhhWmpmclRUb21TdEhtZkd1QWxzUVlKaTR4bGpxQVQ0b0EzQWhUMTVWWnQ4SXVBMjBrbFZZeVJKTVpUb0J5VXg3dFcrdWNJdHN5c1psVEk5Y3BYWHJveHFkTENyc0FQcFdua2RVWitGWFo1NDNZdTVldUYyY0l2TFRNUUI4d1AvQUhSZE94dHRVeUM3YzgvaEFQckFtUEthMTdWRTFKNUpNYXhSV3pBWCt3VGx2OFpRdW4yU1dnQUNJbU9YV3JEOWs3VmkyNVhPenNwVE52R2Z3a2dEYmV0b3kwMHJSNVpDOE1mUmhXNFl5NFo4T0FXVXRtR2JRZ2lJMjMybXJYQ0RkRnUzQWlMYXJ0QjAySjk2MWoyNmk3bWs1dGxMR2wwQU9GNE82anM3dkplSitRZ2FWRnhyZ292c3BJSjY2N0FCb0E1N210SWJWTk5ta3BOYkc0SnFtWTIvd1ZneGRWbDlOU1RzQ3AvL0FDS2w0TFl4Q01WWkl0bVlnaUY1aU5aank5SzFuZFYwVzZmTjFURjQwbmFLRnV5ZWRTSmdsQWlQN090WE1sTExVMlZSWHQ0WUxvQUI2VktsdXBJcFJSWVVkVTA4UFRCWFpvR1B6VXMxTW11R2dSTG5xREVZZExueG9yZW8xOTk2N05kbWdBYzNCMVV6YWU1YVA4ckVqNWcvclRjMk10N01sMGRDSWI4dnhORXMxSW1nQVczSEYydjJXVHpJa2ZXS2pObkJYZnVxVC95R2kyYmxWUEU4TXN2OFNDZW84UDRVQlFQdmRsbE9xWEQ1VHFLR1lucy9pRStHRDVnd2ZyUks3d1IxTTJMektlaG1QZGYwcHY3YmpiWHhvTGc2Z1QvMHdmY1V5V0JseFdNcy9hdWoxOFkrc2lwN1BhMjhOSFZISHBsUDAyOXFLVyswMXM2WEVLbm56K205VG01aEwzTkQ2K0UvV24vQk5lbUMvd0Q1V25QRGY3aC8yMHF2SHN4aHpxQWZreGo4YTVUK0lmSTlCTk5OS2xXWnNOTk1OS2xRQTFoVVRDbFNwaU9SWEN0S2xTR01LVXdyU3BVQU1ZVTJLVktnUWlLNUZLbFFNNEJYS1ZLZ0JocmtVcVZBanNVcHJsS2dCR2tLVktnRGswcHBVcUJDcFVxVk1Ec1Z3aWxTb0FZVFRTYVZLZ0JwYW01cTdTcEFSWDdDWE5IUlc5UUQ3SGxRdS8yZXRINEN5SC9VUFk2L1d1MHFkZzBtRExuWnk3T2pXeVArWWZTS1ZLbFQ1TWpnai8vWlwiLFxyXG4gICAgICAgIH0se1xyXG4gICAgICAgICAgICB0aXRsZTogXCJIb3RlbCBBbGluYWxleFwiLFxyXG4gICAgICAgICAgICBsaW5rOiBcIi9ob3RlbDNcIixcclxuICAgICAgICAgICAgc3VidGl0bGU6IFwiQnJhyJlvdlwiLFxyXG4gICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9ob3RlbDMuanBnXCIsXHJcbiAgICAgICAgICAgIHRodW1ibmFpbDogXCIvaW1hZ2VzL3BhcnRlbmVyaS9ob3RlbDMuanBnXCIsXHJcbiAgICAgICAgfSwgIFxyXG4gICAgICAgIF0sXHJcblxyXG5cclxuXHJcblxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lIDogXCJIb3RlbHVyaVwiLFxyXG4gICAgICAgIGNsYXNzOiBcImhvdGVsdXJpXCIsXHJcbiAgICAgICAgaXRlbXM6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiUGlhdHJhIE1hcmVcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL2hvdGVsMVwiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiUG9pYW5hIEJyYciZb3ZcIixcclxuICAgICAgICAgICAgICAgIGltYWdlOiBcIi9pbWFnZXMvcGFydGVuZXJpL2hvdGVsMS5qcGdcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCIvaW1hZ2VzL3BhcnRlbmVyaS9ob3RlbDEuanBnXCIsXHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJIb3RlbCBTdG9wXCIsXHJcbiAgICAgICAgICAgICAgICBsaW5rOiBcIi9ob3RlbDJcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIkJyYciZb3ZcIixcclxuICAgICAgICAgICAgICAgIGltYWdlOiBcIi9pbWFnZXMvcGFydGVuZXJpL2hvdGVsMi5qcGdcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCIvaW1hZ2VzL3BhcnRlbmVyaS9ob3RlbDIuanBnXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkhvdGVsIEFsaW5hbGV4XCIsXHJcbiAgICAgICAgICAgICAgICBsaW5rOiBcIi9ob3RlbDNcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIkJyYciZb3ZcIixcclxuICAgICAgICAgICAgICAgIGltYWdlOiBcIi9pbWFnZXMvcGFydGVuZXJpL2hvdGVsMy5qcGdcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCIvaW1hZ2VzL3BhcnRlbmVyaS9ob3RlbDMuanBnXCIsXHJcbiAgICAgICAgICAgIH0sICAgIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkhvdGVsIEVzcHJpdFwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvaG90ZWw0XCIsXHJcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZTogXCJCcmHImW92XCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9ob3RlbDQuanBnXCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvaG90ZWw0LmpwZ1wiLFxyXG4gICAgICAgICAgICB9LHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkhvdGVsIEtvbHBpbmdcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL2hvdGVsNVwiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiQnJhyJlvdlwiLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvaG90ZWw1LmpwZ1wiLFxyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsOiBcIi9pbWFnZXMvcGFydGVuZXJpL2hvdGVsNS5qcGdcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuXHJcblxyXG5cclxuICAgIHtcclxuICAgICAgICBuYW1lOiBcIlJlc3RhdXJhbnRlXCIsXHJcbiAgICAgICAgY2xhc3M6IFwicmVzdGF1cmFudGVcIixcclxuICAgICAgICBcclxuICAgICAgICBpdGVtczogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJDZWFzdWwgUsSDdVwiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiUmVzdGF1cmFudCBUcmFkaXRpb25hbFwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvcmVzdGF1cmFudDFcIixcclxuICAgICAgICAgICAgICAgIGltYWdlOiBcIi9pbWFnZXMvcGFydGVuZXJpL3Jlc3RhdXJhbnQxLmpwZ1wiLFxyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsOiBcIi9pbWFnZXMvcGFydGVuZXJpL3Jlc3RhdXJhbnQxLmpwZ1wiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJQaWx2YXhcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIlJlc3RhdXJhbnQgTWFnaGlhclwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvcmVzdGF1cmFudDFcIixcclxuICAgICAgICAgICAgICAgIGltYWdlOiBcIi9pbWFnZXMvcGFydGVuZXJpL3Jlc3RhdXJhbnQyLmpwZ1wiLFxyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsOiBcIi9pbWFnZXMvcGFydGVuZXJpL3Jlc3RhdXJhbnQyLmpwZ1wiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJHYXVyYSBEdWxjZVwiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiUmVzdGF1cmFudCBcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL3Jlc3RhdXJhbnQxXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9yZXN0YXVyYW50My5qcGdcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCIvaW1hZ2VzL3BhcnRlbmVyaS9yZXN0YXVyYW50My5qcGdcIixcclxuICAgICAgICAgICAgfSwgIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkRlaSBGcmF0dGlcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIlJlc3RhdXJhbnQgSXRhbGlhblwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvcmVzdGF1cmFudDFcIixcclxuICAgICAgICAgICAgICAgIGltYWdlOiBcIi9pbWFnZXMvcGFydGVuZXJpL3Jlc3RhdXJhbnQ0LmpwZ1wiLFxyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsOiBcIi9pbWFnZXMvcGFydGVuZXJpL3Jlc3RhdXJhbnQ0LmpwZ1wiLFxyXG4gICAgICAgICAgICB9LCAge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiTGUgUG9tcG9uIFJvdWdlXCIsXHJcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZTogXCJSZXN0YXVyYW50IEZyYW7Im3V6ZXNjXCIsXHJcbiAgICAgICAgICAgICAgICBsaW5rOiBcIi9yZXN0YXVyYW50MVwiLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvcmVzdGF1cmFudDUuanBnXCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvcmVzdGF1cmFudDUuanBnXCIsXHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIlByaW1hIMiYY29hbMSDIFJvbcOibmVhc2PEg1wiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiTXV6ZXVcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL1wiLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndDRUFBa0dCeE1URWhVVEV4TVZGaFVXRnhZWEdCY1lGeGdaR0JnWUZ4Z1lHQjBZRnhjWUhTZ2dHQm9sSFJZYUlURWhKU2tyTGk0dUZ4OHpPRE10TnlndExpc0JDZ29LRGcwT0d4QVFHeThsSHlVdExTMHRMUzh2TFMwdExTOHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMZi9BQUJFSUFNSUJBd01CSWdBQ0VRRURFUUgveEFBY0FBQUJCUUVCQVFBQUFBQUFBQUFBQUFBRkFBSURCQVlCQndqL3hBQkFFQUFCQWdRREJRVUdCUU1DQmdNQUFBQUJBaEVBQXhJaEJERkJCU0pSWVhFR0V6S0JrVUtoc2NIUjhBY1VJMUxoWXBMeEZYSWtNelJqZ3NORG9yTC94QUFhQVFBREFRRUJBUUFBQUFBQUFBQUFBQUFCQWdNQUJBVUcvOFFBTGhFQUFnSUNBZ0VDQlFRQkJRRUFBQUFBQUFFQ0VRTWhFakVFSWtFVE1tRnhnUVVqVWZDUlFxSEI0ZkVVLzlvQURBTUJBQUlSQXhFQVB3RHphYnRCSVNTazd6a2RPYjZ2RlhaN3BLVkVicWxNSDhKME9SRE0vd0FlRVZjSXRBWHZnaFBSeTR1TGRRM1F4Y3draGE1Z0NrS29mSk5pQVhiVG1mVXh6MG82Q2VoN093dEtBSDBjOFhPYm1KaWkrVUN0aVl4RXROS2lxb25JK0s1c0ZGODc1TU1vTVNTVHZHM0xueGowY0hreG5TWC9BSVRsQ2hwazhvaktZdENiSENCSFlteWRGWWlIQ0pGdEViUXhqa2NJaDdRbWdnR1V4Mm1IdENhTVlZRXdxWWUwSm93UmxNS21IdENhTUFaVEhhWWUwSm94aU9tRlRFalJ4b3dSbE1LbUpHaE5BTVIwd2dtSkdpbmo1cldjQWF2azJlY1E4ak44T05qUmpaWUtrNmtCdGZQV0VsUXNPcEhPQmtuRW9jQUY2dDRXR2RsWlBkOC9UTEtIb21xUzVGdzdIeXpMMkd2dWp5bytlMDFmUlY0d2lVUnltSG9JSXR3QmpyUjdFSnFVVTBSYW9qcGpsTVN0SEdockJSSFRIS1lsYU9OQnN4SFRDaVJvVUVGR0xuRkNaaElTZ3FwREZnVW03MnZjNmNvNmlmVVdRVWhLVHZLU2FTWGZ3bFYzT1dSZ1JzN0ZOTkRrTVFROW1lMXlZc1l1UUVWSVFsUys4WlNkQUdPZFBCOHVJQTV4ODA0VTZaMVdYY05qVjk4SmFYVXAyZnhCS1AzWDF1Ynh0azRoS2FVamVMRC9BREdHMlRzeGNzOTRvVkZsTWx4ZHJhNWpsempRN0x4RmFrdUZWT0hCR1JBZHM3Znowam93Wll3a293VzMyeFpMV3crZVFpTXhJTTRldVZIdHJSRXJtT0FSSlRDcGhoUmpRbWg5TWRwZ21HTkNhSktZVk1ZeEhUSFdoN1Ixb3hpT21GVEVsTUpveGlPbU8wdzlvN1RHTVJOQ2FKS1k3VEFNUnRIR2lXbUZUQUNSV2dYalpSTlNGQ3BKNWdXT2c0bjBpOWkxczQvZFo3MnR1c0c0ZzY2Y29DeXBxM1ZVbGdsVmlXVUFubWZPOGVGNXZrckl1TmJUT2pIR3RsT1RoMXl6U0ZiZ3pEMGtHd3Z3eWErb2k5M3dBS2xPMVRXM2Q1Z1FEZTdqaHdnTHRDYk5SNFU3clBVb2dVZ05ZM2R3ZE5ZVW1ma29sMHJBZk1sTmd6OVdQbUk0bkJ5VmozUnBjTGllSTBaUDB0NVJvTmg3UE01WVNBNEFkVEhUcnhPVVl2QllxcFhFWHpjTnJhMnZEN1BwUDRaWXFUV3BDbEVMS1JaV3FyMlRhekM3ZE9jVXg1OG1QMHAvOUc0eDdZRXhtSG9XcFA3VkVmYlJCVEdtN1o0SUptaVlrYnN3WnRtcExCL1J2U004MGU5Z3ljOGFrUW1xZEVUUnhvbGFPVXhZUWphRkQyaFFRSG1td3NDeEtweVNFcHlTUXpuay9UaEJ1Wk5yUVZpV0V1NURpOW5VR3FMZ1pNV01WTnF6NkFVRlNSVjRhV0pacnVkQzU0OG1nVmdKazVaYW1wSURVbFJUWWdzUnpERnVFZk50T2ZyWjBsdkhZMEs4TmJGTytSd1VMQjJzSEkreVl2ZGtKeDc1S1NvanZMcEpZZ3NEWWh6cGJPMEQ4SHNpWWFndVlFaVdReVM0SmNXQUpENUtObWEvT0pxU1o3SU5Vd0dwWU4wZ0JpUE5qcHd6dTBXeFRqQ1NyMk0wZWp6SkxSeEN0SVpoSmlpZ08vQzREKzZKa29lUGNpN1ZuT3hpcFo0UnltSldJNHdxakRKaWtWTUpva2FFRXd3QmpRbWlTbUdxVUFRRG1jdktOWmhyUjFvZlRIYVl4aU5vVk1TVXdxWXhpT21PdEVsTUttTVlpYU90RWxNY0pBaEp6akZYSjBOR0xmUXhvVk1jbVRRUDV5K3NWUHpEdU5Ea1VrTVMyUU9aTE1lRjQ4L04rcDQ0YWpzdkh4cGUrZ1Iybjd5V3BLMEVrR3lnUzlQUVpnSDR0eVlZbkZsUzFvWHVwV0FBb1hLZ29nTUwzdURxOGFHWXBNeVd0S21HaEJ0a0JmcGZQSjR4L3dDWmVlSmFxZHdxQ1ZNQUFDbHJod2N3T1BrN3g1YzhueDI1MVRMT0NpdE11S3FTcFNWbFV5a0NrMHNHTG55WmhiUW5qRklTUVpkcVZCU2lwVEVBcERra0M0L3B6alJUY002QWtrRlJTTFhkMjFaVjJMYVFBdytGcENsVFNudTFySnBBdVNhYnVjblkyNXhMSE5QL0FHRmFKc0ZTN01BbFJCR1J1TFZXMElWd3plTlpzWEVqRHkxS0NYbXJJU3lFaHlBN2dFdWZKaGs3MmpQWVdVbEpBQUFTQ3dDZ1dOaDRpMTh6WnN5QnBCbloyRkU2WWxLeXBLVlRMS1NPSjhZQWUzaTlCb0lXY3ZVTWpmWVRDcW03UFVwWVhXQ1ZwcUtpd1M0cEZWd0FISGwwak1LVU9JajB6RGZsd2tTRXFFMmpjVVNRcWtpeGVvN3NZSGFHRU1xWXVXZlpKSGxwN21qMlAwK2RKdy9KSEl2Y0gxY0FUNU44V2psK0E4ejlJc1V4eW1QVElsZWxYRWYybjZ3b25waFJqSGprcWE1Y3BLMUd6Tlp5Q0RscTk3UWYyZnMrWktKVXBTQVFEWXFUbTJSQk9kOGpFTWllZ1RtV1FsVEVrc0VuZzFudjV2eGlwdGFmTFFSTGtxcjNuVVdKTHNMcEpBYXdJYnA1ZlBTYm0rS09oQktianl0Umx6RmdKZHd0R1Q1NXNEZG1ab3M0QllLaWlYU2hTaXlsRm5PbDFDL0V0eEhXQk1qWkN5RWtNRUtDWFM3S1hlMlRrRnpweGJqSGRyNHNTOXlVRkpWY0ZKdVF3MEpHUjljN3hvUWc1SkxvenVqMHJDczFOMlRaenEzQjgrc1dLQm9ZemZaakhudTVhQ0hKRHFJY2hQQnhrQ2Ira2FVSmozc2N1VVV6bWVtSUtNY2FITkVjMmNsTE9jNGFVMUZXd1UyUENZN1REaEhRSWF3RFFtSVpzdmZSbUxLMEZ4YmsvcEJUWnVCTTJZbEFzK1o0SkdaKzlXalZiVTJWS21nU2dFQmFFZ29DVkR2VURJRlNUNGsrKzlzNDQvSjh1T0ZwZGxjZVBsc3c5TUttSlY0U2RMSkU1RkJBRm5CR3QzR25WbzRTT0lqb2hueHpqeVRGbGprblZER2hVd2pNR2w0YVZIaTNTT2ZKNStLSFcvc1ZoNDA1ZlFjUkVhcG8wdjhBRDFpTlNzamU3Wjg3Nnh3S2poeS9xV1I2aXFPaUhpUlhleHhKT2ZwOVk3aUVYQkwrRk9wMEFIeWhwTVNUU0NsQnpkUE0rMnYrSTgrVTVTZHlkblNvcGRGVlNCY0hweDV4bk1YaUJKVXBLbEFLVVFSWVpFNUJoeHZiSjlZMHlRY3pjKzdXS0cwY0FoZjZoUW1zYXFzOWhFblhiRnlSdFdEMWxZUTluSVoyZkxRNWV2QWNvR1RNSUtsVERkTEFNbDZncFRVcVpqb0NQTURoRVIya1pTajM0VWxPU1FMa2wrdVRNUDhBRVMxR2NsU1pkU2xJU1NxN0pCQmRpK1l6QXZmcERLTW8vYitUbnV5K1ZwbU1wSm9LQ2tLcVVvVmVISm1aMnlITzBDWnpLSVBmVk1wWVMyNlF0eWZFNEpBYWtkWWdSaTVoVUFwQkJTQ29rM0pCVUVraHJPK3JabUNNekN5eExyVUFiSktzM04wOEdZM0pmMTVzbDhOaTlqSjh4MFZMS2dIcUo0bHlEWVprT1BTQ1d5c1NwdTh3Nm1LQWsxS0lMUGJXd2I0OUlHeVo0bUh1eXRWWlNHUVVzbEtkUVZFOEJxSTdoWlUwQk10WUNVa01GRktsSjZrYXVYOUg1a2NiKzVyUFJmdzRrVGpPS3d4bHBjVWxUS0wrMEx0bW9xSUg3aUhONE85dDhJMHhNd0RQZFBVWEh1ZjBnYitIT0FuQlFNeVltbEtsRUlGQ2xYY0EyZGszeTVaV2phZHBNSUpzcFNRMVEzZ05YRi9oYnpqcjhhZkNTbDlUU1ZxanpZcGpqUktSSENJOTZ6bElxWVVTVXdveGp5ekFIdWtybWdwWjJTa2h3ZWJabmg2bUlFN1JrVmhabHBjaHlFdUM5c3RHekhHMmNVNXUwRFNrQUpZRjZYZEp1ZERsL2lLaUpJV29zYWIyREV1VHh2YmhaNDhOWTd0eUxocVZqRE5Vb3BTa2xLWENhcVFLVGFrYW01dDA0d094RXRheVZNYmxtT1lMdFRZWjI0REtMeWRpazNTZTdERUZ6ZHRRM3RETFgxZ2xnMWlVUWsrSkpHUllMelpSenVPZkRqQzg0eCtVTkJQc2xoVm9VM2VuSUNoc3ZhVUFlQUpQcThiUUNNWnN6Rnlrdk5uTFRTbHlBWEt5VFN6c0h6WVg0Q05Ec0hhWXhGYXdTQllCSmF3NGx0U1hqMGZEbkxqNisyUm4zb0tOR2EyempOODdwSUJBdGZJOHVZalFZNmJRZ3FiS01oT0xxdVhKeUdZdG5jNlorY1EvVXNtb3cvSStCZHNKeU5vTEN4b2tBTzRObklCZnA5ZWJhT1VYQUl5TVl1V2lXU3lpMlNpNVV6V0xKVHFTUU0rQmpZN01uQmFBcElOTndIc1MycmFSWHdNbjdhVFlNeTJhUHNoS1VaNElCcEFOWEJpTFA1Z2VrYlV5UU1raHc1SFVqTitNUWJMd0NaU0VKQVlnQithbURreGNNY1hrNUZsbHlyNkR4VktqemJ0aEttSXhSbUtObG9Td3lhbCtHWjQ4bWdPaWVGRmdwOUwvQUZ6amI5dnNIVkpDL3dCaDU1S3RwekNZOHlrbFZRQkRYenV4dnhCamtPM0c3aWd3UXd5UGxmOEFsb1pNVXhabkxQa3c0WndwMDhJRHM1T1FHcGJKemIxaXRLcnYrNVZ6d1R3QWJoL01JVUhZWkxEVFBRdmtXaVVrUTFFa0FEV0VWaU0yYWlPZk1ZUDhMeEhLVVRaN0IyRGNTU2ZVa3hIUHhzcFBpbUpIbmxiUVJRbjlwNUtiSkpKL3p4amJNMEhBZzUvZmxFV1BsSlVta2h0QWJBaCtCT1I1aUFtRTdRS21xb1FnQUgybExZQ3h1ZU9Rc0RwMWhrMzh5VXFxbkpUTWMwc0FXR2RLdFJtUUxXdDVJM1RwZ2NrdXdmTXdpcEN1OElVVWlxck5kblNrT3dPNkFvOUhmV0tKQlZpRkpSWkZCV3NwT2JPQVE1REtZZ2NiSHJGMUM1MHNncldWR3dZcVlIOXdEbHFodXRrTHRBUGJ3V2toZ0VrcEtWZ1dGc2h5Wno2K2NkR1AxU09TYlhzYW1RWmRsUFZRbmprbXAyWTYyNjJnRmk5bS93RE1DbGtBTWJQZXh2U1MxeU12ZnJBWEI3Uzdza2dPU21raHlNZ3p2YzVmdzBYWisxMkV1Y0NrcVZVbGFNMlNGRXB2MExla05IRE9EMC83Mkp5c0tGVytrZDJrOTJTQ2J1dElZdXM2a2k3ODJqZDlrTVJMbVRXbXBjcFNaaXlwaU1udWh3NlVGUjNRNzhSSG0rQng0TktsS0FJSUNqY0VpbXhHWWQxRUZ4b0lLenNTRUJSY2t0dkpOaTJUcGJJVS9EV0p5VGkwZ3BtLzJmdGRLVlRDbWJMWEtTVkJJdEt1a0xaa2daRWxyTVhQTnpQaDl2TFhPVk9sbGpRQVVzVjdvQXFWeEEwejExanphV1hDY3YzSkRwZW5pQ1BQS04zK0gyQlJQbnBTRktaTHJKQlp5TFU1K2VYSHFGYmZKSU5oTEZ5aUM3Rmxid3MyZktLNUViZnRYZ0twWVdMbFB3MStzWTJtUGU4Ykx6aFQ3V2pubkdub2hwanNQYUZIVFlsSHo2cVkvbnd0N2hCVEE3Sm1oYVNYVHUxZzVOd2Q4aThTZmxaU0ZpK1hFUGxyekwvNGl2UHg2Z3NsSkljK2YzOUk4aHljdFJMaHp2SnFYclNpa0NvRmdONXdOQVdMRThmS0tPSW1pZ3FBTG01Y2daaXdBMUd1UU5vNU8ycTZHRnlFdWZWdmxGRUxlNUlKNE5rT2VrU2pCOXRHQ09CMmRNbTBQU21XUlU1NUdrODZ1WEJ1c2VwN0x3a3VVZ1MwRElCN1hOc3lSYVBKRVkrWlVoQ1ZLczFON0M5Z0FiQVBIcTJ3OEwzTWxOU3Q1UWMxSzFOMmVQUXdOV1RtVnRxN1VTeTVWd28yQllzcTl3NDhKQTBqTDRtZXJlQ1VoUkxsbmEyaDB5dGVMbU9tMVQxaHJ0Y25RNWhtUDN5eWk1czdZQzVpYWxyTXVTQmRmN3Izb1NNeVRySG5lVms1WmRsc1VkQS9aMnpWNGhkRXNWSy8rb2VvMzRDNDEwajBmc2pzOENkTGxWQ2FwSkpXUUFKVXNJelNoSThhbnNWSEorTmdHR0tUTFIzVWhJbHl1VFZyMGRTdlBJZXVrU2JBQzF6Q2c0Z3lSWUlUSVNTdGRpNHEweTVDSXh5UytXOUYvaHBLejFqRjQrVktEekppRUQrcFFIeGdCaU8zR0hjcGtKbTRoWC9iUWFmN3phS09DN0t5d1gvTEtXcjkrSW1BbnJTS3ZsQjFHejFwVHZUVVMwalNXaEtRUC9LWlVSNU5EY2lkSXhmYTdiT1BtU1MrSFRLbHFhMVZTemZKUkFJQTF0cTBZM0RZbWNsM2xtNXpCQjkyY2VuZG9kbnkzUmRTMUc5U2xxWHBvNVllVUNwR0RsQllDeUFEeEkrZG9WdU5GWTJ1akM0bkdxU3J2Q0NCa0F4Y0MxcVN6QTV2OFd0RlA3UVczVUMzOVYvUVI2TjJvN0wweSs5a2dxcEc4RXNDMzdnQUdMZEk4OHhYZHF6QVArNUlQdkVTYlJXTXJCVS9iazAyQ21QQUovay9DS3kxejEreXBYVXFBOUN3alNTMHBBc3c2TUlxNGhTZXZxWXlraHJabkRzOWY3a29mK3AvY0lYK204VktQUlB6TFFWbTRrRElmTDRSVzc0cUlEWi9lWmgrWk4yTnc2VVMwa3BTRXFHcmh5Q1hjdGR4OE5Jc2pIdkxxVWduMnE2V0pBSkJmaVg1eFF4NlZwTnpabmZSdXZXenhST0tJZXNsYUZYNDBrRndSeWZTTndVOWtacXRoL1pXSUJGVHVvS0RBSUZnMVFMbHhyYmsyUnRENXJLUzVTTjYxOTVLVGU3Rm05MlVVY0JPU2tvbXBTb0dZRGNvL1RUU2tpcWw4MkE5QmxFMHphdGFsV1NCY3FMSnBUTXl2MUQyYlVSSndmSjBKWUM3UVlFTUtXcWR3bENiTVNiYnZ0WEdiTzNHQmVHMmZVaW9rQXZrU3lyMkc2cHFuSXpCNHh1dG50U1ZMN3NGQ255eUFGMGpuQ3grRHJKWFFoU0R1M1Q3SUlaZ3JYSSs3cmVQbE9QcGYrUU9KZ1pjd29TRk94MERaTzk3MjB0OXZwTU9KaG83eWdxOFFXNEFXQ0dBRm5KWjdRVG5ZSlFGVWxNdGsrenU3NUxrbFNHM1g0SmE5dFdnUmlOanJLalVsS1VFTVRVN0tJOWdBbTlYSHBhSGVXT1Q2QXFpeE5uRksxUzFJQVRrbFl6dUFBeDFBY3hxK3hXMVB5eTByS1FzT2RiaTl5T2JNTkRBSGFnUWhJU1M0Q1FBQmV6TVNBTkxQNUhnSWRzM0ZLU1RrUXdMcGE5SWU3RnhrSEVjMG01UnRCOXozRkhhbkR6a05VQVRZcFVDRDBiWHlqTll5VFF0U1JjQTI2RzQ5MFpERFlvWWliTFQzZEtRVWdoQ1FDcW91UzZpOVEwR1YrY2FmRWJJN3NWU3NYWVg3cWNoU1ZFRE1JcVlueWVPenhmSWNKYjl6VGdwTFJ4UVBLRkV3aFI3Tm5LZk9zNUpCTjN1WHp6MWg2SlpWMWg2Wm8xUzVleHZEakxlOVc5YlNQUGJMQ2tTNlhKdFkyYk9Ka1RpcTVaallzMVhsd2l0MzVMQVo4ZUx4MmRMQ2NqVStvNDZpQTFmWVNmQkovVVRuYlIyOThheElTVXY4K3VVWkNYUFlFM2ZUbHorK01YZG1MSlZXYnNmTThnZmxBYmFRQTdnc1doTlM1cTFFQ3dRa1ZLYkxOalNQckV1SjdiaElDRVMxTWtNa0tzQU9UdWZXS2V5eUF0YWc5SlM3RTVNZFBYM2VxbTQ5RkpJSThYTFM3TzkvUGxISzZjdHF5c1oxMFJUZTBtSlhrUWtjbUh4Zy84QWh1Wmk5cDRVclVWYjVOeVRraGZHTWZoU1NWQk9ReTBQbUJHOC9DVkovd0JSbHBJUzVUTVlrT1VFSUpxU0h6WUZOOUZHS1Rpa3RJZFNiV3owN3R4dDZmaEZTNXFTNkt3Z1N3UEdia3ZiZ0NQU0MzYkNXbFdHVW9rc2xKV2tCM0tnSEZobi9NWjM4VWxxbC9sVkpPK1p3WmVTazBsUGh1MTM5SGpVOW9wUVJoWnhSVUNFRWcxRndlSWM1eHh1TDR1d3BxMVJnZXorMFFVSVN0ZHdWVWpNMDVzZUYzdEFYdEZpSm41bzVsTzdRRTd4cEFEdUJjWHFnbDJObGdKVnptTHp6eUVDOXIvOVlzNWI2UGdrUXMxVUVpMGZtWjZvbkdtWGdWTGxBcVVoRzZHSkw1QjA1c0h5NENQS0Z6Qk5CQ3FTUzVjTUM1NlJ2TVhpRXlzRFBVOUZLZkVIQkRrQTNIV0R1eXV6dUhRbEg2U0NVcEc4VWdsUmE2aTQ5Qi9EVGxGeWFRcWtvVy81UElKT0ROSUhLSXNkZ1ZwRG1XdGk5NmQwQVprazVEbkh2a3JEcFQ0VXBIUUFmQ0FmYVFPdVdMTXlxZ1dZZ2doaS9XTFF4YjJLODk5SThGNzlKVUVnb0tpUUFBcW9ra3N6QWNlZXNiRWRoSnlRRE1WSlFTbXBsTHpET1dzWC9pTXhoSkNVVEpiSi93RGtrbTFPVHExQlAyMGUyN2FrQ2ZoMUpscUNabENVaFZTUjdPVlFkczdobnVScThVblNqbzBtMHp4WGFwUkxKUk9zcEtpazUxZEdVTEFXdHdnVkoyYmRTNmU4VXBWU1ErVjMxeU1TZG9zU3VZczFvL1VTZDhGd29teVhWdkc1S2FtSEU2US9aZ3BwV0VxSnlLVWdxWWFYQnNiR0p1TGhIVEpTN0xOMC9wci9BT1dmWVlrbHhZaElOOVc2amxETVZocEl3NU1zS1FFZ2tYZDBtOXp4WjlSbEY0NHVzS1R1MGtKVWYzUHZEalp1V3Vla1Voc3VXbEc2bFp1QnZFa0JyNjVhM2lVWlYzb0RBbUV4NmxxbEJDQVdBcUtra2dsTmd3Y3ViaHJPN0NEZUwyd3N5VkdncEl6OW5nU2FTTnpQVHJHZXhXTFRJbUJJcFVFN3lXZmRVUm1XQWRRY3RkbU9zRUZiYm1USllXZ09wRnp1ajJraDI2RUdPcWVQazArT2hVd3JMbkttUzBMVWFxd3B5QjRTQWFUWUFrTlNOWUg0UGJJWEtLVjJVRU9rR3pzbG1EM1ZxTFpHT2JQbktEcElLR0ZZY0QycmtsclUyOFBsRmdUMHByV2tnandra094V0d0VlloeWJEakV1S1RhcjdCc0dGS3hNL1VKM3lkQi9VV0FJeXNjbUxuVjRuUkxtVmxKQVlBWERpcDNEN3RtSWZUaEJEWitFbEVnelZJQlVCTUxyQkFKUzVKWU9HSXlEc3dpVFlzOUU0cUsxRmtxWU1sd29IVW01QkZpM1hqRkp0cFhRS05kMlIyUE5seTB6TGxCSUNxUW1zTjRnb3NvQmtxT2VqNU5GM0g0bFltbVRZMUlxRjNMT1E0WlJENkVzOW9nN0g0K1gzckdjcVVsU2N3a1pnM0NuY2NUVVFXRm5ad1QzYVJjZ1lpVExYTlE0U0FaaFNBd0tuOFpzN0xmUFhuQzQ1cExtUFY2c0FCT0orMUkrYUlVQlp1M3ByMldtMXROTFBuSFk5RDQ4UDVaSGd6eWlrdFpoOTg0WUZFWGl5cWVvQnl4NVhZanBFYXBvS2JjWHBiVEp3ZEl5c3hUcUlNY0Jpd3RBVXplalEwU2pGTFJoOGtaRWkyclFjdytMbFVkMGdGT3BKSWM4UkFTUkxKTGN0SXNZZFAzbEVwN01hVEJTV1NWcURGUVlDenM3dDkyZ0J0V1FBcFNra0FPeEF0ZnF3R3NHNStKRXhrc2wyTEFPN01iaFdSRHNPRUQ4WGdCUUppZkFYQUk5a2dzUWZNUkhBdlZ0MDMwUDlqWmZnN3NDUlBsWXViUEJJUVpJU3hhNTd3blIvMjVSNkYyWDJMaGtiUlV1UWdnSUFDVHZtNVFvS2Nra2FqM2VlTC9DL0gwNEtlZ3R2VGtEUDJRaDhzeGVQU093dUZGTXljbERMSktGR29rS3BZZ2hKREpzYnQ1d2tyYzJVL3dCSS93REVSU3pMa3kwU3lydkpxQVNBQ1FBdEJZYTNJR1dnTUYrMVIvNFNkL3MrWWp1TW5zVWxaU0NMcGRMdG80M294SGFMYWMyYXRTVVRWVWl6QWtCK2hjUXJTZDB3SmRGYnN4SXBRNTFLaU9oTUNOcjRZL215R3VwYUNPaHBnM3N2RHJSbXNrWHM0c2QzK21Da3VXQ1FTSFBFc1Q2dENaSUxwc3RDVDdvb2RyWC9BTlB4SUdxTk9BV2trK2dKajBtU04wWGV3dng1eGpNWVU5ek1yU0ZKb1VWSklCQ2dBWEJEM0JqWVlTWlVnSGtJRWF1aGN0MFRSazlzQjhaYWlxbFFBVWtPZjAzOFdiQXQvZEd0Z1h0RFljdWN1cGFFSHFnRTVObWMvU0x1TkVVenc2WklQZXNBYm1Sa0NTUEVYWWFDN3R4MWkvMnA3YnJVUUpjcEVvME1vc0FzbFBCWHNwQkZ0ZGVFZXA3VzdNeVRKV2xLRU9VbElkRXNBRWdwQ25DSGNPOGVKZHJ1emMyVXBNeFFkSUNhMUlJVnZtcHhNc0dOUUlJYlEzNFRjVTNUS09WN1JuTWZpeXJ2RmswclhjWEpOM0xQbTJYcEZqWThqRUpTVnkxVkxzVkJUcERDOUtTYzFkUHBGanM5aGtLSlVWQjFhVWp3Z3NjeGJsRmtiSW55VnFSTFgrbVhVRWtleW9sbVViRldWOWVUd3M4aTNEWDVFYXZaVmxTWnRTbE1rRlNBR0ZnbFNtM2p5c1R3dWJ3Yk5rQk00VkZtVmNieERPbDFEbXh0WjNpWkV0THFJQ2xLRnl4U0E0M2lMMzBlMldjWmpiY3hVcWVGRWhrRWxndFNrM0lPNFRkMlNMRWtEanhqSDk2VkdmcDJEdTFFdGxtaEpwUUFra2czenBOUnpzTTRtMkJ0TVN5bVdVbE5qVTd1Ykt5QnNIcTRaRG5CN0d5NVU5TlpLZ0ZKS2FTb01vbGlGWnUrdm1ZRjRxU0VnaWVrQk9RbUJyZ25oWVpKSFVSMHd5S1VPRWwvZitSWC9JN0VCUkJJU2xyRjFVaGRKenVDQ1ExMlBBY0doYlBrb1VEVy93QzI1SVo3c1FlZDI1eE11U2tyTXlXSHBLUXRLa2tLSUNSdkJySG8yUk40ajdRU2lKVlNBeGNLVVJ3Q1RwcGJOczRWU3VvOVdBSzRyQXlGa0FoS2xVamR6dGs0UEFrdmxiM25zcVVKYUNFSnBUbUtlbDNHWnl6UEdNM2dOc29aUUtFcHNBRk8xaHhPaGZYbTBYMDdXUXVTeEpCcFliNXFKTE9BK2JBTUR5aEpZWnJUdWh1U05EaDV5RUFHWHUyTjI4Vmc0WnJPZEdFUnpKNmxqOVFsVFpCbnNhVForWHlnYmdaOWFnaEpDUmE1QkNXRkxPem5PeDV2RmphQktEU1ZFdlkwa0VlRVhDaFpuNThlY1RVR25RVTdKVjQxUkpLVkxTSE82RFNCZklEUVFvSC9BSjllbFpHbHpsNUJvNUZxbUhaaisrSTBjYzNhR0JRSkRKSTQ2dkhWTUErWjYvS0dpWVdMT1BsSG9VUkoxS0hoQUQ4NHJxSnl1M1hPRWhWNzNQRjRtVFNldWx2bEc2Q1JwbkhRZmZQakZpVUtpTFc1R09HV2tBNVBZOHMrbyt6SE1NdHNnSVY5YUFHVTdMQ2tKVXZSd0tlb1luaGQvV0lwTzFPN3d4bGpNcVVBT0NUY24zeEtuRXRJcXFkdDFyWmxTczM1RE1SbjFxY3hLRU9lcGV6SFVuSG8zLzRma0hEekE2ZzgxM1MxbVFqVTlUN285czdENDlDcEhkaGdwRGtocmtFMkowSno4Z0k4Uy9Eei9wMW4vdXEvL0NJOWU3Q0ZJbHU0M2lvOVdaT3ZTSjVwOGJLeGp5UmQ3VnJJSWF1eVQ0VXVOY3pTV2pBWUdhU2trMU9WRTd3WStoQStFYlA4UWUwd3drc0lDVktXc09XeVNPS2pvOTdjakdQd2VPUlBsQ2FqaXlod1BNYUgrSVNLMFpCWEJZcEs3cFVTYnU0SS9iayttY1BuYlNWS0kzYWtubmNkSUdiR1ZuOThJczQ5WGg4L2xFNXl0MldqR3RCekI0NlhPU1FDN2dncE9iRzF4R2wySmlTUlNUbGxhUE1RU0NGSkxFYXhwOWdiWktqY01vZWl1TFFzVzF1SVp4dFV6ZXVlUHdoWDRuM2ZTSTVFMEtTRkRJeEpIVXNrbjFaeDBLL0UrNzZSNUgrS1dDYWMzZWxJSXFLS2lBdXFvRXNsTFB1bmVMK0ljbzljYVBLL3hpVEozVktzcEJTVkhqWXNCd0xjMnp0Q1pITFhZMER5S1ZnVnBXb0FtZ2hnQVdVY25BWXRvM1M4YW51Wm9UVXF3c0ZPbXB5ckpsYUd3ekRubHJudHFUVWtHWWhmN1NnMlkrSkt2T3JUaUlrMlB0eWdFVFhTRmtrYXBBM1EycEJKZThUeXhuT0tra0MwbUxFWXFtYnZLYWE3T2xOcUdjQ3JNS0p6UE04SU95TzdVQ2ljQ3AwV2RMaFJ1ZlRkTitMUlV4T0dFNEZLR1d0bkRGd3pFZ20yb1B2NndOd2VKVjM1VFBKQ3dBQWtLWUIydUd6K0ZvUng1eDEydjgvZ1BRUm5ZS1ZLWXByY0FuTXVIZE83Y0FGdUdtdWNEdG9CT0lrN3MxMktYTCsxbHZjTGUrRG41VVpwSkJLUnZQVTROMklmM3dIbWJNUlVaY3hTZ3FhUW9BSTNTUUxid0ZqbWVYS0JpbXJ0dDJoV2dac2hjMlNsWkllV3BRQzFYSnp1cm16QWs5WUw3S3g2WnlUS3NVckJRcXdzS2M2dlBOaGxBekI3Uy9MdEpLU2FIQ25UVUxHekFObnIwMWN3elpPRzd5YUp3Q1Vpb2xnOTdrOGJhL1NPbkpGU1RsSmZaZ1RJdG00R2RLV1VnZ0c0QXM3bTNNQjJCNWlDUCtpRllaUlNGdG0zaEpZa2hMWHNUa2JkWWsvS3FSTkNBaXBDZzZsa2lwSUJzb0tMRnc0RjN5aWRVd3l3RktBOW1vamR1V3VsL0VPamF3czhrbTdUVm1vaHdzdGNsWnFXQ0tpYkRQZXVhYnM1NXhPbVlxLzZacUJleDB2Wng3TDM4aGV6UmJTc0ttQUFFRUpWWndYSUJheERPU1JseHlMUlpHREN6WXNEWWdobkxzZWQ3V2YydFlqOFRlME9rQ3U3a202MUxxTFB2R0ZCdzlsSnVnUTJqaFI5N3dvcCtTbE04bUt6SFVySXloMGpEcVdvSVFIVW9zQkd0N01kZ1p1S21yUXBWQ1UrMVpUbHlHdGJUcmQyajBwU2pGYk9kSnN5TlZtYUpKRXRSTERQcVBuQjNhM1pDWkptbVYzaUZxU0FTMVFZRitJWjdlK0c5cit6UndTMElycktwU0ZxZE5MRlY2UjBoZWNYcFBzTkE2Wmd5a09WRjJ5NW1IYkVub1RPbENZa0tRVnBDbklHNlNBUTZpRWdjenBFV0ZuS1dVb2NacFNMQjdxQStjTW00VjFsSXZkUXR3RC9BQ0VaTDJrWkkyUDRoOWwveWpLbElVSktqYzJvRDNTd2VvWmtFbXprTm0wWWlZNEpCREhobEh1dUkyek5VTUVKMHBJWE9sVXpFekdCY0NsWGVTMUYyTFZDeFlLTHRuSG1QYWZCMTdSbmdDeWlaajVPQ3hKSHFZamh5ZXpIbERlaDJCeGE1V3pLNWFpbFJuRU9HMUxhOUk5UjdQN1dBS1phbFV5NWFTVmh6ZFMxYm9ERGpTWXd1enBNdEdGTXNwY2I2Z0ZBS0RseVB0b3Q3RXhYNnlTczJxU1Y4Q0FzWmpWbUhtMFJ5eVVsYUxSaTR1bWVqZHNGQ2FoUlltb01TMXJCWVVIOGlJd0haa2lWTW55dzFDaUdGUWNFQTVQZmg2UWY3UTdVcVN3ZGwxcUw1N3htblRLeCtNWmJCdDN4dGwvRUpGdGJNbGVqVDdFVlkvZkNMV09YbDV4UTJNYkdMR09WY1JLWFJSZGtaVkZyQnJJQUl6ZDRvS1ZGbkNxM2ZXTmo3RGs2TjEyWjJzRHVuSSs1WDBNSHRzcGZEenJrSHUxa0ZLaWtnaEpJSVVDNlR6anpQQzRvb1VGRHpIS054STJ4TG1ZZVltc1ZHV3NCaUg4SjA0eDBZM3hsVDZPZWNiMmp5M1pHMWNYK2FrSi9OemxvNytRbHUvVVFwSldnS2NFM3M3anJCNzhZdXppMW9NOUsxRnJCTEZWeTlTam9rTllkT2NBamhTbkdZWUVLUzAvQ2tKVm95cFQyZXd1R0dqUjZsMnhsSVZLcFc3RXRaVkl2YmU1ZStGbEwwMzlUUDVqNWl4aEJsaFNqU0U3b1FCcXdkVGpSd2ZUaEFmdkFwYmtsam5xVzVhUEhwSGJmWU1rWWNxVFl5bkNhYkpMcURraHJ2ZjFqelZTR2pzeGZLUmtxWnRPem93NjFBWWRTMExTQVNvbFJxT1RGSVlITzN1ZTRpYkYwb3JVaGYvRUFoU3FnTWhaZ1FIQWU5dUl2QS9zanNzcG16S2h2SlNBVXVHSVVIdHg2dUdqdTNNUE5CTTZZb0JnRTJMN3RnUVFCZHlvUDVSeHp4L3UxZXY3b1BzSFphd0ZDcXpnZUhOYkV2bHE1SllSMlpOclFVME94Q2sxRVYrYkU3ekFOWVBBRForMFUzUXFhRGNCQnV4M00zSnRjM2lnTm9yQ3d0SGVMUVVrSjNXSXp0d0xIVVovQ2Yvek5zM0kwODlVcEI3M3V3c3FTQ1ZKY2tFTzRVTXJBNWpwQWZaMjI1ZmVGQ2dKYWN3K2I2Z2tsbXpiSjNncnNuYUFuaFNsc2x6d3NwV1YrYk5mb09FQ2R0OW1WdVpxQnVxSktnekJJOG5KT1pObzJQaW00Wk5NMit3M00ybWhBU21vWEl1TlhKZjVhNkNHN1JBVktVeVhDR3FOVlZTVkpOVzYyNkE0L3RNWktlVlRGRTFKcVRZTUdld0xoUE12OFkwR3dNVGlFeXlvaXBLU3BKZk1aV0kxVHZFNjVRMC9INExsSHNObGlUWXBxQ0R1bWhWN2hSZG5GaVhPZjlSaTB0S2xUZ1FrZ1U2QzZqbU91ZWwrc1Z0a29VcXBLVUVJY2toM1pMQnlrOGljeGRqQjdadUlmZFdpcWtxRklMWktBRndiN29ZUkdXbmJDaVdYMmZzSG16WFlQdXRkcmhpWEY0VWVrWU5qTFFYSmRJdWM4dGVjS0xwdWg5bnk3c2xZRTFKTHNDY3M4anJHcndtM2NRZ05KbWlVbnZPODBKSzJTTGtpNDNCdWx3Ymd1Q1l5c3VSVGNFRW5oRTZTWTc1eFVpS2JRYlFnZDUzaXB4bUxVWFc0SVNRNzBsU2lMV0dReXNJVzAwaWVvcW1MV1hiZXNBQUFBQUhjbkxoQWxFU3YxOVlSNC9leGliRDRYRHlsb21BelNVcVNwdDFuU1FROXIrc0greW1Kd3FKeFd0REpBVWFscENpbFoxQk9UM3NJem9uQUh3anpjL09GTXhKVm1iY01nT2dGb1Z3ay9jQzBhanRWMnQ3NVV2dXBzeDBBdXE3UFpneHNkYmw0eSt6c1ZNTThLV2FpeWszSUZpbG12YUkyRUk5STBZcUtEYllUVnRCcFNBenVuUEx6Z3JzU2N5MG5tazU2VjMrK2taQ1lTVGNXNVo1ZWthckI3VWxpamV1S0xaMlNvV2hKWTFXaWtjbXd6aVpsUWZNYjMvc2lyaFJ2cUowMTQ1UkRNMmpMcHp1eGZQSTE4T3NXdG5LU3RKVmU2aUIwRFJPVWIwaG82N0N1elp5VXBMbUlzWnRORDNWa0Q5WXF6YkpOSUx0YXppNytzWlA4QVVVU0FEbTF3YmVXY1QrRzMyTTVwYlJyVjdUUmJlRi9uL2lMdUZ4NkFBS2c3L0huSG5zOVMwNktHaGZRK1JPa1dObTQxcVFRcXh6Yjc1UWZndGJRUGljdE05SUU5SnlVUFVSUjc0cFdTTkRiWDR4UmtBS0FJT2NTOXlvYSsrRWJrMFBGUk5qSjJQTG1wUmpDdFlVNkZxNEF5eU4zS3daQUVRZHBPMTNma0pvS1VwTDV1NTQ1Q0JXd2R1R1U4dGQ1WmNVdTJiMzlURkxHQ1VDdmVCRm1iUjc4WHRsRW56WDJHU2kvdVZlMEdKVE9rTGxwREZRMXkwdjdvd0dJN1B6bU5rbTJpaHc1dEd3WE1FUUxYSFRETkpDU3hSWVV3WlFsS1dLYW1CTnc3bTVIckZQYjBpdVFzQU9XY2RmTDdPVUQxVEloVk1qY20zYkI4TlZRUDJwc3I5QUZRQW1wY3FDUis3aUc1ZXNETm03UW15VXFZcUFJTEROSVV6NUZ3OGEzWjZ4V2dxRnlmTmhkMzRXRm00UUI3Uk5Vb0pMQUxjQUFpeERrbnpNVWhrNStpU09lVWFERXVUTFNrVDVZQVVRQVE0VUVzajJDSEJkUUh4aTNzNmNzVGFGTVNKU1NVM3pKc0dkblk4TlJ6alA3QXhjc1llWWhadVZPd1o3QUM0YXdzQU9aUEdEdjRlaENzVE5LMGxRWFNsSXMxZ1FYZTlpQmw4NG5MSHFWK3hsc0lvMllqeEp3NzdoSGVaZUhWN2h3dzgvUUU5bVlOU2twM1NVcU43ZzNEZ0tMVzQrUkdiVzEyNnpNVzROOG9nbHJsb3NIU0IvU3BoMUxXam5hdmJaVGlaanNMc2RhZ0p0UkNTcWNnZ043S2xJeUwzdDd4R3Z3L1p4S1p4bXZaUzFMWUJtS2k0OHVVWm5zNXRRWWVVdEIzbEdiTldpV254Szd5WVZCeWJDMStoamI3SHh4bXlndFNDZzNCU2JzMXVBdEZQUzJCVVhBMGNoZWtLS0JQbEVBeElpYW9hbUhVUk5Jd2FsQXF5UU0xSExoYmpIZlpGRWdtajcrRVBFeUlab0ZnbDJHVDZ2bVcwaElqR1pNa3c4UTBLNUQwK3NPUUlXekR3TlhFT0FqZ1RFcVVRckNjU2tSSUVmZjNsSFVKam9FQUlpaDlZbWtURkk4S2lBL2svU0lrbldPbFhEUDcxaEdFZjNzeHlvTFZ2WjVOWjhvWWl0Nmd0UVBJdC9FTk13Z09UNkNHcVZxOEF3eWZoeXBWUldxcmk3UjFXSGNNcGFqMVAwaHN5ZFRmUGkwV3BDa2w5MGx1YitrSFlEdUhXVU5TbzJ5dmxGdE8xNW9jMU9HMUdYVG45SWg3NlRZaXVyazNMSWs4eEZLY3NLQ21keFppMXoxZUY0aldYdjhBVUZGeG54Ni9md2lMOHkra0RjSVZKYk9OWnN0WVdpNlJma09QMGllU2Z3MTBCVGJBSDU1aTE0Yk4ybVdzNWpVNG5aU0ZBQW9EbkpneGdYTjdPcGNsS3p5SEw1d2k4aUQ3TTNJejV4S2dYQk4rTWQvUGs2Um9aMnhFczJkZ0JiN3ZlQk9ON1BxSGd2Zk1pd0hsemlrTTJPV2dYSUxZSXBuaVVoSzZaaVV2eHA5bHkvQTZkSXFZdkRtYWdKVXBJTmFuWUFxM1NvV2U3WDlESE95RXZ1OFlVekRrbFE0ZzNTUTNVWGpaN1dsWWRRL1RRQVNVclNRbTRkM05YbS9tWWxPc2IxOXc4YmpaNW1jSUFxWUVncW9ZbFF0U0FxbmU2dUkwUFovYkNwS1VsTXRHU3JzNTNpZjQ1UVNWaE41YmpOQlFTQzVJcUJTUzRaeHZldXNSVGNGTFh1bEJKUWxJVDdMZ2F1R0QzOTBHV2RTanNEMEc1SGFpYXNPUlNmOEFhVytrVk1SalpxcXYxV2V4M2lSY0d4Qk83RklTV1ZTQlRieTY1Tnp6OVluU2l4SUdUV3N5ckMxenA3bzVtMzdDOG1NbUJZVHVCTDJBUE8zRGxhQyt3OXJ6SlJVa2hWSnNEVVZHMWc0SmF6ZWZIU0JjMDVjcm40Mzk4V0JZTUhQSEk4Zzc5T2VzSTI2TW13b2Uxa3orciswd29FRlhGUHVQeWhScmYxTnlaNXdrWEVFZHBocVFMQ3hZV0QwSkx0Q2hSN1FFVWhEeWZoQ2hRd1IvMWl6SkZ2OEF5RUtGQU15ZkZwQVdXNC9LSHlranV5ZGFoZnlNS0ZDTUkyWHA1eDFHc0tGQVFUaWN2UDZRelF4MkZBTVJUTG0vRXcyYWtBV3RuQ2hRb0NvczdwOG9JWVh3VGY4QWFQbkNoUXo2R2gwTEhCbEpiaDh4RmpDRGQ4dm5DaFFwaWxOOFhtZmhCbll5akhJVVF6ZklUOXpVeXpZZGZvWWpsNndvVWVaL0pSOUhVSkJkOUNsdVdXWHJIRWVIMStKaFFvcXVoME9reXgrWWwyR1owNlJZeFEzaHptSUI2WHRIWVVhUHlvZVB5Zy9haVJVcXcwOTRoTFNLVTIwUHVlRkNndjJJejdIcEdmbjhSREppUlFDM0Q0R0ZDaFYyTDdFU0xvdmQ1WmZudWpQakVjNE1TMXQwZkNGQ2dyc0RMY3RSYk13b1VLRWZaTm4vMlE9PVwiLFxyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsOiBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFELzJ3Q0VBQWtHQnhNVEVoVVRFeE1WRmhVV0Z4WVhHQmNZRnhnWkdCZ1lGeGdZR0IwWUZ4Y1lIU2dnR0JvbEhSWWFJVEVoSlNrckxpNHVGeDh6T0RNdE55Z3RMaXNCQ2dvS0RnME9HeEFRR3k4bEh5VXRMUzB0TFM4dkxTMHRMUzh0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TGYvQUFCRUlBTUlCQXdNQklnQUNFUUVERVFIL3hBQWNBQUFCQlFFQkFRQUFBQUFBQUFBQUFBQUZBQUlEQkFZQkJ3ai94QUJBRUFBQkFnUURCUVVHQlFNQ0JnTUFBQUFCQWhFQUF4SWhCREZCQlNKUllYRUdFektCa1VLaHNjSFI4QWNVSTFMaFlwTHhGWElrTXpSamdzTkRvckwveEFBYUFRQURBUUVCQVFBQUFBQUFBQUFBQUFBQkFnTUFCQVVHLzhRQUxoRUFBZ0lDQWdFQ0JRUUJCUUVBQUFBQUFBRUNFUU1oRWpFRUlrRVRNbUZ4Z1FValVmQ1JRcUhCNGZFVS85b0FEQU1CQUFJUkF4RUFQd0R6YWJ0QklTU2s3emtkT2I2dkZYWjdwS1ZFYnFsTUg4SjBPUkRNL3dBZUVWY0l0QVh2Z2hQUnk0dUxkUTNReGN3a2hhNWdDa0tvZkpOaUFYYlRtZlV4ejBvNkNlaDdPd3RLQUgwYzhYT2JtSmlpK1VDdGlZeEV0TktpcW9uSStLNXNGRjg3NU1Nb01TU1R2RzNMbnhqMGNIa3huU1gvQUlUbENocGs4b2pLWXRDYkhDQkhZbXlkRllpSENKRnRFYlF4amtjSWg3UW1nZ0dVeDJtSHRDYU1ZWUV3cVllMEpvd1JsTUttSHRDYU1BWlRIYVllMEpveGlPbUZURWpSeG93UmxNS21KR2hOQU1SMHdnbUpHaW5qNXJXY0FhdmsyZWNROGpOOE9OalJqWllLazZrQnRmUFdFbFFzT3BIT0JrbkVvY0FGNnQ0V0dkbFpQZDgvVExLSG9tcVM1Rnc3SHl6TDJHdnVqeW8rZTAxZlJWNHdpVVJ5bUhvSUl0d0JqclI3RUpxVVUwUmFvanBqbE1TdEhHaHJCUkhUSEtZbGFPTkJzeEhUQ2lSb1VFRkdMbkZDWmhJU2dxcERGZ1VtNzJ2YzZjbzZpZlVXUVVoS1R2S1NhU1hmd2xWM09XUmdSczdGTk5Ea01RUTltZTF5WXNZdVFFVklRbFMrOFpTZEFHT2RQQjh1SUE1eDgwNFU2WjFXWGNOalY5OEphWFVwMmZ4QktQM1gxdWJ4dGs0aEthVWplTEQvQURHRzJUc3hjczk0b1ZGbE1seGRyYTVqbHpqUTdMeEZha3VGVk9IQkdSQWRzN2Z6MGpvd1pZd2tvd1czMnhaTFd3K2VRaU14SU00ZXVWSHRyUkVybU9BUkpUQ3BoaFJqUW1oOU1kcGdtR05DYUpLWVZNWXhIVEhXaDdSMW94aU9tRlRFbE1Kb3hpT21PMHc5bzdUR01STkNhSktZN1RBTVJ0SEdpV21GVEFDUldnWGpaUk5TRkNwSjVnV09nNG4waTlpMXM0L2RaNzJ0dXNHNGc2NmNvQ3lwcTNWVWxnbFZpV1VBbm1mTzhlRjV2a3JJdU5iVE9qSEd0bE9UaDF5elNGYmd6RDBrR3d2d3lhK29pOTN3QUtsTzFUVzNkNWdRRGU3amh3Z0x0Q2JOUjRVN3JQVW9nVWdOWTNkd2ROWVVtZmtvbDByQWZNbE5nejlXUG1JNG5CeVZqM1JwY0xpZUkwWlAwdDVSb05oN1BNNVlTQTRBZFRIVHJ4T1VZdkJZcXBYRVh6Y05yYTJ2RDdQcFA0WllxVFdwQ2xFTEtSWldxcjJUYXpDN2RPY1V4NThtUDBwLzlHNHg3WUV4bUhvV3BQN1ZFZmJSQlRHbTdaNElKbWlZa2Jzd1p0bXBMQi9SdlNNODBlOWd5Yzhha1FtcWRFVFJ4b2xhT1V4WVFqYUZEMmhRUUhtbXdzQ3hLcHlTRXB5U1F6bmsvVGhCdVpOclFWaVdFdTVEaTluVUdxTGdaTVdNVk5xejZBVUZTUlY0YVdKWnJ1ZEM1NDhtZ1ZnSms1WmFtcElEVWxSVFlnc1J6REZ1RWZOdE9mclowbHZIWTBLOE5iRk8rUndVTEIyc0hJK3lZdmRrSng3NUtTb2p2THBKWWdzRFloenBiTzBEOEhzaVlhZ3VZRWlXUXlTNEpjV0FKRDVLTm1hL09KcVNaN0lOVXdHcFlOMGdCaVBOanB3enUwV3hUakNTcjJNMGVqekpMUnhDdElaaEppaWdPL0M0RCs2SmtvZVBjaTdWbk94aXBaNFJ5bUpXSTR3cWpESmlrVk1Kb2thRUV3d0JqUW1pU21HcVVBUURtY3ZLTlpoclIxb2ZUSGFZeGlOb1ZNU1V3cVl4aU9tT3RFbE1LbU1ZaWFPdEVsTWNKQWhKempGWEowTkdMZlF4b1ZNY21UUVA1eStzVlB6RHVORGtVa01TMlFPWkxNZUY0OC9OK3A0NGFqc3ZIeHBlK2dSMm43eVdwSzBFa0d5Z1M5UFFaZ0g0dHlZWW5GbFMxb1h1cFdBQW9YS2dvZ01MM3VEcThhR1lwTXlXdEttR2hCdGtCZnBmUEo0eC93Q1plZUphcWR3cUNWTUFBQ2xyaHdjd09Qazd4NWM4bngyNTFUTE9DaXRNdUtxU3BTVmxVeWtDazBzR0xueVpoYlFuakZJU1FaZHFWQlNpcFRFQXBEa2tDNC9wempSVGNNNkFra0ZSU0xYZDIxWlYyTGFRQXcrRnBDbFRTbnUxckpwQXVTYWJ1Y25ZMjV4TEhOUC9BR0ZhSnNGUzdNQWxSQkdSdUxWVzBJVnd6ZU5ac1hFakR5MUtDWG1ySVN5RWh5QTdnRXVmSmhrNzJqUFlXVWxKQUFBU0N3Q2dXTmg0aTE4elpzeUJwQm5aMkZFNllsS3lwS1ZUTEtTT0o4WUFlM2k5Qm9JV2N2VU1qZllUQ3FtN1BVcFlYV0NWcHFLaXdTNHBGVndBSEhsMGpNS1VPSWowekRmbHdrU0VxRTJqY1VTUXFraXhlbzdzWUhhR0VNcVl1V2ZaSkhscDdtajJQMCtkSncvSkhJdmNIMWNBVDVOOFdqbCtBOHo5SXNVeHltUFRJbGVsWEVmMm42d29ucGhSakhqa3FhNWNwSzFHek5aeUNEbHE5N1FmMmZzK1pLSlVwU0FRRFlxVG0yUkJPZDhqRU1pZWdUbVdRbFRFa3NFbmcxbnY1dnhpcHRhZkxRUkxrcXIzblVXSkxzTHBKQWF3SWJwNWZQU2JtK0tPaEJLYmp5dFJsekZnSmR3dEdUNTVzRGRtWm9zNEJZS2lpWFNoU2l5bEZuT2wxQy9FdHhIV0JNalpDeUVrTUVLQ1hTN0tYZTJUa0Z6cHhiakhkcjRzUzl5VUZKVmNGSnVRdzBKR1I5Yzd4b1FnNUpMb3p1ajByQ3MxTjJUWnpxM0I4K3NXS0JvWXpmWmpIbnU1YUNISkRxSWNoUEJ4a0NiK2thVUpqM3NjdVVVem1lbUlLTWNhSE5FYzJjbExPYzRhVTFGV3dVMlBDWTdURGhIUUlhd0RRbUlac3ZmUm1MSzBGeGJrL3BCVFp1Qk0yWWxBcytaNEpHWis5V2pWYlUyVkttZ1NnRUJhRWdvQ1ZEdlVESUZTVDRrKys5czQ0L0o4dU9GcGRsY2VQbHN3OU1LbUpWNFNkTEpFNUZCQUZuQkd0M0duVm80U09Jam9obnh6anlURmxqa25WREdoVXdqTUdsNGFWSGkzU09mSjUrS0hXL3NWaDQwNWZRY1JFYXBvMHY4QUQxaU5Tc2plN1o4NzZ4d0tqaHkvcVdSNmlxT2lIaVJYZXh4Sk9mcDlZN2lFWEJMK0ZPcDBBSHlocE1TVFNDbEJ6ZFBNKzJ2K0k4K1U1U2R5ZG5Tb3BkRlZTQmNIcHg1eG5NWGlCSlVwS2xBS1VRUllaRTVCaHh2Yko5WTB5UWN6Yys3V0tHMGNBaGY2aFFtc2FxczloRW5YYkZ5UnRXRDFsWVE5bklaMmZMUTVldkFjb0dUTUlLbFREZExBTWw2Z3BUVXFaam9DUE1EaEVSMmtaU2ozNFVsT1NRTGtsK3VUTVA4QUVTMUdjbFNaZFNsSVNTcTdKQkJkaStZekF2ZnBES01vL2IrVG51eStWcG1NcEpvS0NrS3FVb1ZlSEptWjJ5SE8wQ1p6S0lQZlZNcFlTMjZRdHlmRTRKQWFrZFlnUmk1aFVBcEJCU0NvazNKQlVFa2hyTytyWm1DTXpDeXhMclVBYkpLczNOMDhHWTNKZjE1c2w4Tmk5ako4eDBWTEtnSHFKNGx5RFlaa09QU0NXeXNTcHU4dzZtS0FrMUtJTFBiV3diNDlJR3laNG1IdXl0VlpTR1FVc2xLZFFWRThCcUk3aFpVMEJNdFlDVWtNRkZLbEo2a2F1WDlINWtjYis1clBSZnc0a1RqT0t3eGxwY1VsVEtMKzBMdG1vcUlIN2lITjRPOXQ4STB4TXdEUGRQVVhIdWYwZ2IrSE9BbkJRTXlZbWxLbEVJRkNsWGNBMmRrM3k1WldqYWRwTUlKc3BTUTFRM2dOWEYvaGJ6anI4YWZDU2w5VFNWcWp6WXBqalJLUkhDSTk2emxJcVlVU1V3b3hqeXpBSHVrcm1ncFoyU2tod2ViWm5oNm1JRTdSa1ZoWmxwY2h5RXVDOXN0R3pIRzJjVTV1MERTa0FKWUY2WGRKdWREbC9pS2lKSVdvc2FiMkRFdVR4dmJoWjQ4Tlk3dHlMaHFWakROVW9wU2tsS1hDYXFRS1Rha2FtNXQwNHdPeEV0YXlWTWJsbU9ZTHRUWVoyNERLTHlkaWszU2U3REVGemR0UTN0RExYMWdsZzFpVVFrK0pKR1JZTHpaUnp1T2ZEakM4NHgrVU5CUHNsaFZvVTNlbklDaHN2YVVBZUFKUHE4YlFDTVpzekZ5a3ZObkxUU2x5QVhLeVRTenNIellYNENORHNIYVl4RmF3U0JZQkphdzRsdFNYajBmRG5MajYrMlJuM29LTkdhMnpqTjg3cElCQXRmSTh1WWpRWTZiUWdxYktNaE9McXVYSnlHWXRuYzZaK2NRL1VzbW93L0krQmRzSnlOb0xDeG9rQU80Tm5JQmZwOWViYU9VWEFJeU1ZdVdpV1N5aTJTaTVVeldMSlRxU1FNK0JqWTdNbkJhQXBJTk53SHNTMnJhUlh3TW43YVRZTXkyYVBzaEtVWjRJQnBBTlhCaUxQNWdla2JVeVFNa2h3NUhVak4rTVFiTHdDWlNFSkFZZ0IrYW1Ea3hjTWNYazVGbGx5cjZEeFZLanpidGhLbUl4Um1LTmxvU3d5YWwrR1o0OG1nT2llRkZncDlML0FGempiOXZzSFZKQy93Qmg1NUt0cHpDWTh5a2xWUUJEWHp1eHZ4QmprTzNHN2lnd1F3eVBsZjhBbG9aTVV4Wm5MUGt3NFp3cDA4SURzNU9RR3BiSnpiMWl0S3J2KzVWendUd0FiaC9NSVVIWVpMRFRQUXZrV2lVa1ExRWtBRFdFVmlNMmFpT2ZNWVA4THhIS1VUWjdCMkRjU1NmVWt4SFB4c3BQaW1KSG5sYlFSUW45cDVLYkpKSi96eGpiTTBIQWc1L2ZsRVdQbEpVbWtodEFiQWgrQk9SNWlBbUU3UUttcW9RZ0FIMmxMWUN4dWVPUXNEcDFoazM4eVVxcW5KVE1jMHNBV0dkS3RSbVFMV3Q1STNUcGdja3V3Zk13aXBDdThJVVVpcXJOZG5Ta093TzZBbzlIZldLSkJWaUZKUlpGQldzcE9iT0FRNURLWWdjYkhyRjFDNTBzZ3JXVkd3WXFZSDl3RGxxaHV0a0x0QVBid1draGdFa3BLVmdXRnNoeVp6NitjZEdQMVNPU2JYc2FtUVpkbFBWUW5qa21wMlk2MjYyZ0ZpOW0vd0RNQ2xrQU1iUGV4dlNTMXlNdmZyQVhCN1M3c2tnT1Nta2h5TWd6dmM1ZncwWForMTJFdWNDa3FWVWxhTTJTRkVwdjBMZWtOSERPRDAvNzJKeXNLRlcra2QyazkyU0NidXRJWXVzNmtpNzgyamQ5a01STG1UV21wY3BTWml5cGlNbnVodzZVRlIzUTc4UkhtK0J4NE5LbEtBSUlDamNFaW14R1lkMUVGeG9JS3pzU0VCUmNrdHZKTmkyVHBiSVUvRFdKeVRpMGdwbS8yZnRkS1ZUQ21iTFhLU1ZCSXRLdWtMWmtnWkVsck1YUE56UGg5dkxYT1ZPbGxqUUFVc1Y3b0FxVnhBMHoxMWp6YVdYQ2N2M0pEcGVuaUNQUEtOMytIMkJSUG5wU0ZLWkxySkJaeUxVNStlWEhxRmJmSklOaExGeWlDN0ZsYndzMmZLSzVFYmZ0WGdLcFlXTGxQdzErc1kybVBlOGJMemhUN1dqbm5Hbm9ocGpzUGFGSFRZbEh6NnFZL253dDdoQlRBN0ptaGFTWFR1MWc1TndkOGk4U2ZsWlNGaStYRVBscnpMLzRpdlB4NmdzbEpJYytmMzlJOGh5Y3RSTGh6dkpxWHJTaWtDb0ZnTjV3TkFXTEU4ZktLT0ltaWdxQUxtNWNnWml3QTFHdVFObzVPMnE2R0Z5RXVmVnZsRkVMZTVJSjROa09la1NqQjl0R0NPQjJkTW0wUFNtV1JVNTVHazg2dVhCdXNlcDdMd2t1VWdTMERJQjdYTnN5UmFQSkVZK1pVaENWS3MxTjdDOWdBYkFQSHEydzhMM01sTlN0NVFjMUsxTjJlUFF3TldUbVZ0cTdVU3k1VndvMkJZc3E5dzQ4SkEwakw0bWVyZUNVaFJMbG5hMmgweXRlTG1PbTFUMWhydGNuUTVobVAzeXlpNXM3WUM1aWFsck11U0JkZjdyM29TTXlUckhuZVZrNVpkbHNVZEEvWjJ6VjRoZEVzVksvK29lbzM0QzQxMGowZnNqczhDZExsVkNhcEpKV1FBSlVzSXpTaEk4YW5zVkhKK05nR0dLVExSM1VoSWx5dVRWcjBkU3ZQSWV1a1NiQUMxekNnNGd5UllJVElTU3RkaTRxMHk1Q0l4eVMrVzlGL2hwS3oxakY0K1ZLRHpKaUVEK3BRSHhnQmlPM0dIY3BrSm00aFgvYlFhZjd6YUtPQzdLeXdYL0xLV3I5K0ltQW5yU0t2bEIxR3oxcFR2VFVTMGpTV2hLUVAvS1pVUjVORGNpZEl4ZmE3Yk9QbVNTK0hUS2xxYTFWU3pmSlJBSUExdHEwWTNEWW1jbDNsbTV6QkI5MmNlbmRvZG55M1JkUzFHOVNscVhwbzVZZVVDcEdEbEJZQ3lBRHhJK2RvVnVORlkydWpDNG5HcVNydkNDQmtBeGNDMXFTekE1djhXdEZQN1FXM1VDMzlWL1FSNk4ybzdMMHkrOWtncXBHOEVzQzM3Z0FHTGRJODh4WGRxekFQKzVJUHZFU2JSV01yQlUvYmswMkNtUEFKL2svQ0t5MXoxK3lwWFVxQTlDd2pTUzBwQXN3Nk1JcTRoU2V2cVl5a2hyWm5EczlmN2tvZitwL2NJWCttOFZLUFJQekxRVm00a0RJZkw0Ulc3NHFJRFovZVpoK1pOMk53NlVTMGtwU0VxR3JoeUNYY3RkeDhOSXNqSHZMcVVnbjJxNldKQUpCZmlYNXhReDZWcE56Wm5mUnV2V3p4Uk9LSWVzbGFGWDQwa0Z3UnlmU053VTlrWnF0aC9aV0lCRlR1b0tEQUlGZzFRTGx4cmJrMlJ0RDVyS1M1U042MTk1S1RlN0ZtOTJVVWNCT1Nrb21wU29HWURjby9UVFNraXFsODJBOUJsRTB6YXRhbFdTQmNxTEpwVE15djFEMmJVUkp3ZkowSllDN1FZRU1LV3Fkd2xDYk1TYmJ2dFhHYk8zR0JlRzJmVWlva0F2a1N5cjJHNnBxbkl6QjR4dXRudFNWTDdzRkNueXlBRjBqbkN4K0RySlhRaFNEdTNUN0lJWmdyWEkrN3JlUGxPUHBmK1FPSmdaY3dvU0ZPeDBEWk85NzIwdDl2cE1PSmhvN3lncThRVzRBV0NHQUZuSlo3UVRuWUpRRlVsTXRrK3p1NzVMa2xTRzNYNEphOXRXZ1JpTmpyS2pVbEtVRU1UVTdLSTlnQW05WEhwYUhlV09UNkFxaXhObkZLMVMxSUFUa2xZenVBQXgxQWN4cSt4VzFQeXkwcktRc09kYmk5eU9iTU5EQUhhZ1FoSVNTNENRQUJlek1TQU5MUDVIZ0lkczNGS1NUa1F3THBhOUllN0Z4a0hFYzBtNVJ0Qjl6M0ZIYW5EemtOVUFUWXBVQ0QwYlh5ak5ZeVRRdFNSY0EyNkc0OTBaRERZb1lpYkxUM2RLUVVnaENRQ3FvdVM2aTlRMEdWK2NhZkViSTdzVlNzWFlYN3FjaFNWRURNSXFZbnllT3p4ZkljSmI5elRncExSeFFQS0ZFd2hSN05uS2ZPczVKQk4zdVh6ejFoNkpaVjFoNlpvMVM1ZXh2RGpMZTlXOWJTUFBiTENrUzZYSnRZMmJPSmtUaXE1WmpZczFYbHdpdDM1TEFaOGVMeDJkTENjalUrbzQ2aUExZllTZkJKL1VUbmJSMjk4YXhJU1V2OCt1VVpDWFBZRTNmVGx6KytNWGRtTEpWV2JzZk04Z2ZsQWJhUUE3Z3NXaE5TNXExRUN3UWtWS2JMTmpTUHJFdUo3YmhJQ0VTMU1rTWtLc0FPVHVmV0tleXlBdGFnOUpTN0U1TWRQWDNlcW00OUZKSUk4WExTN085L1BsSEs2Y3RxeXNaMTBSVGUwbUpYa1FrY21IeGcvOEFodVppOXA0VXJVVmI1TnlUa2hmR01maFNTVkJPUXkwUG1CRzgvQ1ZKL3dCUmxwSVM1VE1Za09VRUlKcVNIellGTjlGR0tUaWt0SWRTYld6MDd0eHQ2ZmhGUzVxUzZLd2dTd1BHYmt2YmdDUFNDM2JDV2xXR1Vva3NsSldrQjNLZ0hGaG4vTVozOFVscWwvbFZKTytad1plU2swbFBodTEzOUhqVTlvcFFSaFp4UlVDRUVnMUZ3ZUljNXh4dUw0dXdwcTFSZ2V6KzBRVUlTdGR3VlVqTTA1c2VGM3RBWHRGaUpuNW81bE83UUU3eHBBRHVCY1hxZ2wyTmxnSlZ6bUx6enlFQzlyLzlZczViNlBna1FzMVVFaTBmbVo2b25HbVhnVkxsQXFVaEc2R0pMNUIwNXNIeTRDUEtGekJOQkNxU1M1Y01DNTZSdk1YaUV5c0RQVTlGS2ZFSEJEa0EzSFdEdXl1enVIUWxINlNDVXBHOFVnbFJhNmk0OUIvRFRsRnlhUXFrb1cvNVBJSk9ETklIS0lzZGdWcERtV3RpOTZkMEFaa2s1RG5IdmtyRHBUNFVwSFFBZkNBZmFRT3VXTE15cWdXWWdnaGkvV0xReGIySzg5OUk4Rjc5SlVFZ29LaVFBQXFva2tzekFjZWVzYkVkaEp5UURNVkpRU21wbEx6RE9Xc1gvaU14aEpDVVRKYkovd0Rra20xT1RxMUJQMjBlMjdha0NmaDFKbHFDWmxDVWhWU1I3T1ZRZHM3aG51UnE4VW5Tam8wbTB6eFhhcFJMSlJPc3BLaWs1MWRHVUxBV3R3Z1ZKMmJkUzZlOFVwVlNRK1YzMXlNU2Rvc1N1WXMxby9VU2Q4RndvbXlYVnZHNUthbUhFNlEvWmdwcFdFcUp5S1VncVlhWEJzYkdKdUxoSFRKUzdMTjAvcHIvQU9XZllZa2x4WWhJTjlXNmpsRE1WaHBJdzVNc0tRRWdrWGQwbTl6eFo5UmxGNDR1c0tUdTBrSlVmM1B2RGpadVd1ZWtVaHN1V2xHNmxadUJ2RWtCcjY1YTNpVVpWM29EQW1FeDZscWxCQ0FXQXFLa2tnbE5nd2N1YmhyTzdDRGVMMndzeVZHZ3BJejluZ1NhU056UFRyR2V4V0xUSW1CSXBVRTd5V2ZkVVJtV0FkUWN0ZG1Pc0VGYmJtVEpZV2dPcEZ6dWoya2gyNkVHT3FlUGswK09oVXdyTG5LbVMwTFVhcXdweUI0U0FhVFlBa05TTllINFBiSVhLS1YyVUVPa0d6c2xtRDNWcUxaR09iUG5LRHBJS0dGWWNEMnJrbHJVMjhQbEZnVDBwcldrZ2p3a2tPeFdHdFZZaHliRGpFdUtUYXI3QnNHRkt4TS9VSjN5ZEIvVVdBSXlzY21MblY0blJMbVZsSkFZQVhEaXAzRDd0bUlmVGhCRForRWxFZ3pWSUJVQk1MckJBSlM1SllPR0l5RHN3aVRZczlFNHFLMUZrcVlNbHdvSFVtNUJGaTNYakZKdHBYUUtOZDJSMlBObHkwekxsQklDcVFtc040Z29zb0JrcU9lajVORjNINGxZbW1UWTFJcUYzTE9RNFpSRDZFczlvZzdINCtYM3JHY3FVbFNjd2taZzNDbmNjVFVRV0ZuWndUM2FSY2dZaVRMWE5RNFNBWmhTQXdLbjhaczdMZlBYbkM0NXBMbVBWNnNBQk9KKzFJK2FJVUJadTNwcjJXbTF0TkxQbkhZOUQ0OFA1Wkhnenlpa3RaaDk4NFlGRVhpeXFlb0J5eDVYWWpwRWFwb0tiY1hwYlRKd2RJeXN4VHFJTWNCaXd0QVV6ZWpRMFNqRkxSaDhrWkVpMnJRY3crTGxVZDBnRk9wSkljOFJBU1JMSkxjdElzWWRQM2xFcDdNYVRCU1dTVnFERlFZQ3pzN3Q5MmdCdFdRQXBTa2tBT3hBdGZxd0dzRzUrSkV4a3NsMkxBTzdNYmhXUkRzT0VEOFhnQlFKaWZBWEFJOWtnc1FmTVJIQXZWdDAzMFA5alpmZzdzQ1JQbFl1YlBCSVFaSVN4YTU3d25SLzI1UjZGMlgyTGhrYlJVdVFnZ0lBQ1R2bTVRb0tja2thajNlZUwvQy9IMDRLZWd0dlRrRFAyUWg4c3hlUFNPd3VGRk15Y2xETEpLRkdva0twWWdoSkRKc2J0NXdrcmMyVS93Qkkvd0RFUlN6TGt5MFN5cnZKcUFTQUNRQXRCWWEzSUdXZ01GKzFSLzRTZC9zK1lqdU1uc1VsWlNDTHBkTHRvNDNveEhhTGFjMmF0U1VUVlVpekFrQitoY1FyU2Qwd0pkRmJzeElwUTUxS2lPaE1DTnI0WS9teUd1cGFDT2hwZzNzdkRyUm1za1hzNHNkMyttQ2t1V0NRU0hQRXNUNnRDWklMcHN0Q1Q3b29kclgvQU5QeElHcU5PQVdraytnSmowbVNOMFhld3Z4NXhqTVlVOXpNclNGSm9VVkpJQkNnQVhCRDNCallZU1pVZ0hrSUVhdWhjdDBUUms5c0I4WmFpcWxRQVVrT2YwMzhXYkF0L2RHdGdYdERZY3VjdXBhRUhxZ0U1Tm1jL1NMdU5FVXp3NlpJUGVzQWJtUmtDU1BFWFlhQzd0eDFpLzJwN2JyVVFKY3BFbzBNb3NBc2xQQlhzcEJGdGRlRWVwN1c3TXlUSldsS0VPVWxJZEVzQUVncENuQ0hjTzhlSmRydXpjMlVwTXhRZElDYTFJSVZ2bXB4TXNHTlFJSWJRMzRUY1UzVEtPVjdSbk1maXlydkZrMHJYY1hKTjNMUG0yWHBGalk4akVKU1Z5MVZMc1ZCVHBEQzlLU2MxZFBwRmpzOWhrS0pVVkIxYVVqd2dzY3hibEZrYklueVZxUkxYK21YVUVrZXlvbG1VYkZXVjllVHdzOGkzRFg1RWF2WlZsU1p0U2xNa0ZTQUdGZ2xTbTNqeXNUd3Vid2JOa0JNNFZGbVZjYnhET2wxRG14dFozaVpFdExxSUNsS0Z5eFNBNDNpTDMwZTJXY1pqYmN4VXFlRkVoa0VsZ3RTazNJTzRUZDJTTEVrRGp4akg5NlZHZnAyRHUxRXRsbWhKcFFBa2tnM3pwTlJ6c000bTJCdE1TeW1XVWxOalU3dWJLeUJzSHE0WkRuQjdHeTVVOU5aS2dGSkthU29Nb2xpRlp1K3ZtWUY0cVNFZ2lla0JPUW1CcmduaFlaSkhVUjB3eUtVT0VsL2YrUlgvSTdFQlJCSVNsckYxVWhkSnp1Q0NRMTJQQWNHaGJQa29VRFcvd0MyNUlaN3NRZWQyNXhNdVNrck15V0hwS1F0S2trS0lDUnZCckhvMlJONGo3UVNpSlZTQXhjS1VSd0NUcHBiTnM0VlN1bzlXQUs0ckF5RmtBaEtsVWpkenRrNFBBa3ZsYjNuc3FVSmFDRUpwVG1LZWwzR1p5elBHTTNnTnNvWlFLRXBzQUZPMWh4T2hmWG0wWDA3V1F1U3hKQnBZYjVxSkxPQStiQU1EeWhKWVpyVHVodVNORGg1eUVBR1h1Mk4yOFZnNFpyT2RHRVJ6SjZsajlRbFRaQm5zYVRaK1h5Z2JnWjlhZ2hKQ1JhNUJDV0ZMT3puT3g1dkZqYUJLRFNWRXZZMGtFZUVYQ2habjU4ZWNUVUduUVU3SlY0MVJKS1ZMU0hPNkRTQmZJRFFRb0gvQUo5ZWxaR2x6bDVCbzVGcW1IWmorK0kwY2MzYUdCUUpESkk0NnZIVk1BK1o2L0tHaVlXTE9QbEhvVVJKMUtIaEFEODRycUp5dTNYT0VoVjczUEY0bVRTZXVsdmxHNkNScG5IUWZmUGpGaVVLaUxXNUdPR1drQTVQWThzK28rekhNTXRzZ0lWOWFBR1U3TENrSlV2UndLZW9ZbmhkL1dJcE8xTzd3eGxqTXFVQU9DVGNuM3hLbkV0SXFxZHQxclpsU3MzNURNUm4xcWN4S0VPZXBlekhVbkhvMy80ZmtIRHpBNmc4MTNTMW1RalU5VDdvOXM3RDQ5Q3BIZGhncERraHJrRTJKMEp6OGdJOFMvRHovcDFuL3VxLy9DSTllN0NGSWx1NDNpbzlXWk92U0o1cDhiS3hqeVJkN1ZySUlhdXlUNFV1TmN6U1dqQVlHYVNrazFPVkU3d1kraEErRWJQOFFlMHd3a3NJQ1ZLV3NPV3lTT0tqbzk3Y2pHUHdlT1JQbENhaml5aHdQTWFIK0lTSzBaQlhCWXBLN3BVU2J1NEkvYmsrbWNQbmJTVktJM2Frbm5jZElHYkdWbjk4SXM0OVhoOC9sRTV5dDJXakd0QnpCNDZYT1NRQzdnZ3BPYkcxeEdsMkppU1JTVGxsYVBNUVNDRkpMRWF4cDlnYlpLamNNb2VpdUxRc1cxdUlaeHRVemV1ZVB3aFg0bjNmU0k1RTBLU0ZESXhKSFVza24xWngwSy9FKzc2UjVIK0tXQ2FjM2VsSUlxS0tpQXVxb0VzbExQdW5lTCtJY285Y2FQSy94aVRKM1ZLc3BCU1ZIallzQndMYzJ6dENaSExYWTBEeUtWZ1ZwV29BbWdoZ0FXVWNuQVl0bzNTOGFudVpvVFVxd3NGT21weXJKbGFHd3pEbmxybnRxVFVrR1loZjdTZzJZK0pLdk9yVGlJazJQdHlnRVRYU0Zra2FwQTNRMnBCSmU4VHl4bk9La2tDMG1MRVlxbWJ2S2FhN09sTnFHY0NyTUtKelBNOElPeU83VUNpY0NwMFdkTGhSdWZUZE4rTFJVeE9HRTRGS0dXdG5ERnd6RWdtMm9QdjZ3TndlSlYzNVRQSkN3QUFrS1lCMnVHeitGb1J4NXgxMnY4L2dQUVJuWUtWS1lwcmNBbk11SGRPN2NBRnVHbXVjRHRvQk9JazdzMTJLWEwrMWx2Y0xlK0RuNVVacEpCS1J2UFU0TjJJZjN3SG1iTVJVWmN4U2dxYVFvQUkzU1FMYndGam1lWEtCaW1ydHQyaFdnWnNoYzJTbFpJZVdwUUMxWEp6dXJtekFrOVlMN0t4Nlp5VEtzVXJCUXF3c0tjNnZQTmhsQXpCN1MvTHRKS1NhSENuVFVMR3pBTm5yMDFjd3paT0c3eWFKd0NVaW9sZzk3azhiYS9TT25KRlNUbEpmWmdUSXRtNEdkS1dVZ2dHNEFzN20zTUIyQjVpQ1AraUZZWlJTRnRtM2hKWWtoTFhzVGtiZFlrL0txUk5DQWlwQ2c2bGtpcElCc29LTEZ3NEYzeWlkVXd5d0ZLQTltb2pkdVd1bC9FT2phd3M4a203VFZtb2h3c3RjbFpxV0NLaWJEUGV1YWJzNTV4T21ZcS82WnFCZXgwdlp4N0wzOGhlelJiU3NLbUFBRUVKVlp3WElCYXhET1NSbHh5TFJaR0RDellzRFlnaG5Mc2VkN1dmMnRZajhUZTBPa0N1N2ttNjFMcUxQdkdGQnc5bEp1Z1EyamhSOTd3b3ArU2xNOG1LekhVckl5aDBqRHFXb0lRSFVvc0JHdDdNZGdadUttclFwVkNVKzFaVGx5R3RiVHJkMmowcFNqRmJPZEpzeU5WbWFKSkV0UkxEUHFQbkIzYTNaQ1pKbW1WM2lGcVNBUzFRWUYrSVo3ZStHOXIrelJ3UzBJcnJLcFNGcWROTEZWNlIwaGVjWHBQc05BNlpneWtPVkYyeTVtSGJFbm9UT2xDWWtLUVZwQ25JRzZTQVE2aUVnY3pwRVdGbktXVW9jWnBTTEI3cUErY01tNFYxbEl2ZFF0d0QvQUNFWkwya1pJMlA0aDlsL3lqS2xJVUpLamMyb0QzU3dlb1prRW16a05tMFlpWTRKQkRIaGxIdXVJMnpOVU1FSjBwSVhPbFV6RXpHQmNDbFhlUzFGMkxWQ3hZS0x0bkhtUGFmQjE3Um5nQ3lpWmo1T0N4SkhxWWpoeWV6SGxEZWgyQnhhNVd6SzVhaWxSbkVPRzFMYTlJOVI3UDdXQUtaYWxVeTVhU1ZoemRTMWJvRERqU1l3dXpwTXRHRk1zcGNiNmdGQUtEbHlQdG90N0V4WDZ5U3MycVNWOENBc1pqVm1IbTBSeXlVbGFMUmk0dW1lamRzRkNhaFJZbW9NUzFyQllVSDhpSXdIWmtpVk1ueXcxQ2lHRlFjRUE1UGZoNlFmN1E3VXFTd2RsMXFMNTd4bW5US3grTVpiQnQzeHRsL0VKRnRiTWxlalQ3RVZZL2ZDTFdPWGw1eFEyTWJHTEdPVmNSS1hSUmRrWlZGckJySUFJemQ0b0tWRm5DcTNmV05qN0RrNk4xMloyc0R1bkkrNVgwTUh0c3BmRHpya0h1MWtGS2lrZ2hKSUlVQzZUemp6UEM0b29VRkR6SEtOeEkyeExtWWVZbXNWR1dzQmlIOEowNHgwWTN4bFQ2T2VjYjJqeTNaRzFjWCtha0ovTnpsbzcrUWx1L1VRcEpXZ0tjRTNzN2pyQjc4WXV6aTFvTTlLMUZyQkxGVnk5U2pva05ZZE9jQWpoU25HWVlFS1MwL0NrSlZveXBUMmV3dUdHalI2bDJ4bElWS3BXN0V0WlZJdmJlNWUrRmxMMDM5VFA1ajVpeGhCbGhTalNFN29RQnF3ZFRqUndmVGhBZnZBcGJrbGpucVc1YVBIcEhiZllNa1ljcVRZeW5DYWJKTHFEa2hydmYxanpWU0dqc3hmS1JrcVp0T3pvdzYxQVlkUzBMU0FTb2xScU9URklZSE8zdWU0aWJGMG9yVWhmL0VBaFNxZ01oWmdRSEFlOXVJdkEvc2pzc3BtektodkpTQVV1R0lVSHR4NnVHanUzTVBOQk02WW9CZ0UyTDd0Z1FRQmR5b1A1Unh6eC91MWV2N29Qc0haYXdGQ3F6Z2VITmJFdmxxNUpZUjJaTnJRVTBPeENrMUVWK2JFN3pBTllQQURaKzBVM1FxYURjQkJ1eDNNM0p0YzNpZ05vckN3dEhlTFFVa0ozV0l6dHdMSFVaL0NmL3pOczNJMDg5VXBCNzN1d3NxU0NWSmNrRU80VU1yQTVqcEFmWjIyNWZlRkNnSmFjdytiNmdrbG16YkozZ3JzbmFBbmhTbHNsendzcFdWK2JOZm9PRUNkdDltVnVacUJ1cUpLZ3pCSThuSk9aTm8yUGltNFpOTTIrdzNNMm1oQVNtb1hJdU5YSmY1YTZDRzdSQVZLVXlYQ0dxTlZWU1ZKTlc2MjZBNC90TVpLZVZURkUxSnFUWU1HZXdMaFBNdjhZMEd3TVRpRXl5b2lwS1NwSmZNWldJMVR2RTY1UTAvSDRMbEhzTmxpVFlwcUNEdW1oVjdoUmRuRmlYT2Y5UmkwdEtsVGdRa2dVNkM2am1PdWVsK3NWdGtvVXFwS1VFSWNraDNaTEJ5azhpY3hkakI3WnVJZmRXaXFrcUZJTFpLQUZ3YjdvWVJHV25iQ2lXWDJmc0htelhZUHV0ZHJoaVhGNFVla1lOakxRWEpkSXVjOHRlY0tMcHVoOW55N3NsWUUxSkxzQ2NzOGpyR3J3bTNjUWdOSm1pVW52TzgwSksyU0xraTQzQnVsd2JndUNZeXN1UlRjRUVuaEU2U1k3NXhVaUtiUWJRZ2Q1M2lweG1MVVhXNElTUTcwbFNpTFdHUXlzSVcwMGllb3FtTFdYYmVzQUFBQUFIY25MaEFsRVN2MTlZUjQvZXhpYkQ0WER5bG9tQXpTVXFTcHQxblNRUTlyK3NIK3ltSndxSnhXdERKQVVhbHBDaWxaMUJPVDNzSXpvbkFId2p6Yy9PRk14SlZtYmNNZ09nRm9Wd2svY0MwYWp0VjJ0NzVVdnVwc3gwQXVxN1BaZ3hzZGJsNHkrenNWTU04S1dhaXlrM0lGaWxtdmFJMkVJOUkwWXFLRGJZVFZ0QnBTQXp1blBMemdyc1NjeTBubWs1NlYzKytrWkNZU1RjVzVaNWVrYXJCN1VsaWpldUtMWjJTb1doSlkxV2lrY213emlabFFmTWIzL3NpcmhSdnFKMDE0NVJETTJqTHB6dXhmUEkxOE9zV3RuS1N0SlZlNmlCMERST1ViMGhvNjdDdXpaeVVwTG1Jc1p0TkQzVmtEOVlxemJKTklMdGF6aTcrc1pQOEFVVVNBRG0xd2JlV2NUK0czMk01cGJSclY3VFJiZUYvbi9pTHVGeDZBQUtnNy9IbkhuczlTMDZLR2hmUStST2tXTm00MXFRUXF4emI3NVFmZ3RiUVBpY3RNOUlFOUp5VVBVUlI3NHBXU05EYlg0eFJrQUtBSU9jUzl5b2ErK0ViazBQRlJOakoyUExtcFJqQ3RZVTZGcTRBeXlOM0t3WkFFUWRwTzEzZmtKb0tVcEw1dTU0NUNCV3dkdUdVOHRkNVpjVXUyYjM5VEZMR0NVQ3ZlQkZtYlI3OFh0bEVuelgyR1NpL3VWZTBHSlRPa0xscERGUTF5MHY3b3dHSTdQem1Oa20yaWh3NXRHd1hNRVFMWEhURE5KQ1N4UllVd1pRbEtXS2FtQk53N201SHJGUGIwaXVRc0FPV2NkZkw3T1VEMVRJaFZNamNtM2JCOE5WUVAycHNyOUFGUUFtcGNxQ1IrN2lHNWVzRE5tN1FteVVxWXFBSUxETklVejVGdzhhM1o2eFdncUZ5Zk5oZDM0V0ZtNFFCN1JOVW9KTEFMY0FBaXhEa256TVVoazUraVNPZVVhREV1VExTa1Q1WUFVUUFRNFVFc2oyQ0hCZFFIeGkzczZjc1RhRk1TSlNTVTN6SnNHZG5ZOE5SempQN0F4Y3NZZVloWnVWT3daN0FDNGF3c0FPWlBHRHY0ZWhDc1ROSzBsUVhTbElzMWdRWGU5aUJsODRuTEhxVit4bHNJbzJZanhKdzc3aEhlWmVIVjdod3c4L1FFOW1ZTlNrcDNTVXFON2czRGdLTFc0K1JHYlcxMjZ6TVc0TjhvZ2xybG9zSFNCL1NwaDFMV2puYXZiWlRpWmpzTHNkYWdKdFJDU3FjZ2dON0tsSXlMM3Q3eEd2dy9aeEtaeG12WlMxTFlCbUtpNDh1VVpuczV0UVllVXRCM2xHYk5XaVdueEs3eVlWQnliQzEraGpiN0h4eG15Z3RTQ2czQlNiczF1QXRGUFMyQlVYQTBjaGVrS0tCUGxFQXhJaWFvYW1IVVJOSXdhbEFxeVFNMUhMaGJqSGZaRkVnbWo3K0VQRXlJWm9GZ2wyR1Q2dm1XMGhJakdaTWt3OFEwSzVEMCtzT1FJV3pEd05YRU9BamdURXFVUXJDY1NrUklFZmYzbEhVSmpvRUFJaWg5WW1rVEZJOEtpQS9rL1NJa25XT2xYRFA3MWhHRWYzc3h5b0xWdlo1Tlo4b1lpdDZndFFQSXQvRU5Nd2dPVDZDR3FWcThBd3lmaHlwVlJXcXJpN1IxV0hjTXBhajFQMGhzeWRUZlBpMFdwQ2tsOTBsdWIra0hZRHVIV1VOU28yeXZsRnRPMTVvYzFPRzFHWFRuOUloNzZUWWl1cmszTElrOHhGS2NzS0NtZHhaaTF6MWVGNGpXWHY4QVVGRnhueDYvZndpTDh5K2tEY0lWSmJPTlpzdFlXaTZSZmtPUDBpZVNmdzEwQlRiQUg1NWkxNGJOMm1XczVqVTRuWlNGQUFvRG5KZ3hnWE43T3BjbEt6eUhMNXdpOGlEN00zSXo1eEtnWEJOK01kL1BrNlJvWjJ4RXMyZGdCYjd2ZUJPTjdQcUhndmZNaXdIbHppa00yT1dnWElMWUlwbmlVaEs2WmlVdnhwOWx5L0E2ZElxWXZEbWFnSlVwSU5hbllBcTNTb1dlN1g5REhPeUV2dThZVXpEa2xRNGczU1EzVVhqWjdXbFlkUS9UUUFTVXJTUW00ZDNOWG0vbVlsT3NiMTl3OGJqWjVtY0lBcVlFZ3FvWWxRdFNBcW5lNnVJMFBaL2JDcEtVbE10R1NyczUzaWY0NVFTVmhONWJqTkJRU0M1SXFCU1M0Wnh2ZXVzUlRjRkxYdWxCSlFsSVQ3TGdhdUdEMzkwR1dkU2pzRDBHNUhhaWFzT1JTZjhBYVcra1ZNUmpacXF2MVdleDNpUmNHeEJPN0ZJU1dWU0JUYnk2NU56ejlZblNpeElHVFdzeXJDMXpwN281bTM3QzhtTW1CWVR1QkwyQVBPM0RsYUMrdzlyekpSVWtoVkpzRFVWRzFnNEphemVmSFNCYzA1Y3JuNDM5OFdCWU1IUEhJOGc3OU9lc0kyNk1td29lMWt6K3IrMHdvRUZYRlB1UHloUnJmMU55WjV3a1hFRWRwaHFRTEN4WVdEMEpMdENoUjdRRVVoRHlmaENoUXdSLzFpekpGdjhBeUVLRkFNeWZGcEFXVzQvS0h5a2p1eWRhaGZ5TUtGQ01JMlhwNXgxR3NLRkFRVGljdlA2UXpReDJGQU1SVExtL0V3MmFrQVd0bkNoUW9Db3M3cDhvSVlYd1RmOEFhUG5DaFF6NkdoMExIQmxKYmg4eEZqQ0RkOHZuQ2hRcGlsTjhYbWZoQm5ZeWpISVVRemZJVDl6VXl6WWRmb1lqbDZ3b1VlWi9KUjlIVUpCZDlDbHVXV1hySEVlSDErSmhRb3F1aDBPa3l4K1lsMkdaMDZSWXhRM2h6bUlCNlh0SFlVYVB5b2VQeWcvYWlSVXF3MDk0aExTS1UyMFB1ZUZDZ3YySXo3SHBHZm44UkRKaVJRQzNENEdGQ2hWMkw3RVNMb3ZkNVpmbnVqUGpFYzRNUzF0MGZDRkNncnNETGN0UmJNd29VS0VmWk5uLzJRPT1cIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiBcIkJhcnVyaVwiLFxyXG4gICAgICAgIGNsYXNzOiBcImJhcnVyaVwiLFxyXG4gICAgICAgIGl0ZW1zOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkVuZ2xpc2ggQ2x1YlwiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiQmFyIGVuZ2xlemVzY1wiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9iYXIxLmpwZ1wiLFxyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsOiBcIi9pbWFnZXMvcGFydGVuZXJpL2JhcjEuanBnXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIlNjdWzEg3JpZVwiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiQmFyXCIsXHJcbiAgICAgICAgICAgICAgICBsaW5rOiBcIi9cIixcclxuICAgICAgICAgICAgICAgIGltYWdlOiBcIi9pbWFnZXMvcGFydGVuZXJpL2JhcjIuanBnXCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvYmFyMi5qcGdcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiRGVhbmUnc1wiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiSXJpc2ggQmFyXCIsXHJcbiAgICAgICAgICAgICAgICBsaW5rOiBcIi9cIixcclxuICAgICAgICAgICAgICAgIGltYWdlOiBcIi9pbWFnZXMvcGFydGVuZXJpL2JhcjMuanBnXCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvYmFyMy5qcGdcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiSmFtYWljYVwiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiUmFzdGEgQmFyXCIsXHJcbiAgICAgICAgICAgICAgICBsaW5rOiBcIi9cIixcclxuICAgICAgICAgICAgICAgIGltYWdlOiBcIi9pbWFnZXMvcGFydGVuZXJpL2JhcjQuanBnXCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvYmFyNC5qcGdcIixcclxuICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiQ2FmZTEzXCIsXHJcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZTogXCJDYWZlbmVhXCIsXHJcbiAgICAgICAgICAgICAgICBsaW5rOiBcIi9cIixcclxuICAgICAgICAgICAgICAgIGltYWdlOiBcIi9pbWFnZXMvcGFydGVuZXJpL2JhcjUuanBnXCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiL2ltYWdlcy9wYXJ0ZW5lcmkvYmFyNS5qcGdcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuICAgIFxyXG5cclxuXHJcblxyXG5cclxuICAgIHtcclxuICAgICAgICBuYW1lOiBcIkNsdWJ1cmlcIixcclxuICAgICAgICBjbGFzczogXCJjbHVidXJpXCIsXHJcbiAgICAgICAgaXRlbXM6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiRm91ciBSb29tc1wiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiQ2x1YlwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9jbHViMS5qcGdcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCIvaW1hZ2VzL3BhcnRlbmVyaS9jbHViMS5qcGdcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiTU9WZVwiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiQ2x1YlwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9jbHViMi5qcGdcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCIvaW1hZ2VzL3BhcnRlbmVyaS9jbHViMi5qcGdcIixcclxuICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiQXJ0YVwiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiU3BvcnQgQ2x1YlwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9jbHViMy5qcGdcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCIvaW1hZ2VzL3BhcnRlbmVyaS9jbHViMy5qcGdcIixcclxuICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiWmFvIFBsYW5ldFwiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiQ2hpbGRyZW4gQ2x1YlwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9jbHViNC5qcGdcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCIvaW1hZ2VzL3BhcnRlbmVyaS9jbHViNC5qcGdcIixcclxuICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiTWFsaWJ1IEJyYciZb3ZcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIkdlbnRsZW1lbiBDbHViXCIsXHJcbiAgICAgICAgICAgICAgICBsaW5rOiBcIi9cIixcclxuICAgICAgICAgICAgICAgIGltYWdlOiBcIi9pbWFnZXMvcGFydGVuZXJpL2NsdWI1LmpwZ1wiLFxyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsOiBcIi9pbWFnZXMvcGFydGVuZXJpL2NsdWI1LmpwZ1wiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICB9LFxyXG5cclxuXHJcblxyXG5cclxuICAgIHtcclxuICAgICAgICBuYW1lOiBcIkZpdG5lc3NcIixcclxuICAgICAgICBjbGFzczogXCJmaXRuZXNzXCIsXHJcbiAgICAgICAgaXRlbXM6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiMThnaW1cIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIkZpdG5lc3MgQ2x1YlwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCIvaW1hZ2VzL3BhcnRlbmVyaS9maXRuZXNzMS5qcGdcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCIvaW1hZ2VzL3BhcnRlbmVyaS9maXRuZXNzMS5qcGdcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiR3ltIHB1bHMgQnJhc292XCIsXHJcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZTogXCJGaXRuZXNzXCIsXHJcbiAgICAgICAgICAgICAgICBsaW5rOiBcIi9cIixcclxuICAgICAgICAgICAgICAgIGltYWdlOiBcImh0dHBzOi8vdXBmaXQud29ybGQvZGF0YV9maWxlcy9jbHVicy1nYWxsZXJ5Lzc1Mi9neW0tcHVscy1icmFzb3ZfNzUyLmpwZz9jYWNoZT0xNTMyMzM4NTE5XCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiaHR0cHM6Ly91cGZpdC53b3JsZC9kYXRhX2ZpbGVzL2NsdWJzLWdhbGxlcnkvNzUyL2d5bS1wdWxzLWJyYXNvdl83NTIuanBnP2NhY2hlPTE1MzIzMzg1MTlcIixcclxuICAgICAgICAgICAgfSx7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJVUlNVXCIsXHJcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZTogXCJHZW50bGVtZW4gZml0bmVzc1wiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCJodHRwczovL3VwZml0LndvcmxkL2RhdGFfZmlsZXMvY2x1YnMtZ2FsbGVyeS82NzIvc2FsYS1maXRuZXNzLWJyYXNvdl82NzIuanBnP2NhY2hlPTE1MzE3NDgxNjJcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCJodHRwczovL3VwZml0LndvcmxkL2RhdGFfZmlsZXMvY2x1YnMtZ2FsbGVyeS82NzIvc2FsYS1maXRuZXNzLWJyYXNvdl82NzIuanBnP2NhY2hlPTE1MzE3NDgxNjJcIixcclxuICAgICAgICAgICAgfSx7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJJcm9uIFdpbGxcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcImZpdG5lc3NcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL1wiLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndDRUFBa0dCeE1URWhVVEV4TVZGUlVYRnhVWUZ4Y1lGeGNWRnhjWEZSWVdGeGdWRlJjWUhTZ2dHaDBsSFJjWElURWhKU2tyTGk0dUdCOHpPRE10TnlndExpc0JDZ29LRFEwTkZROFBGU3NaRlJrckt5c3RMUzByS3kwckxTc3JLeXNyS3kwckt6Y3RLemMzTFMwckt6YzNLeXN0TFMwdEt5c3JLeXNyTFMwckt5c3JLLy9BQUJFSUFMY0JFd01CSWdBQ0VRRURFUUgveEFBY0FBQUNBZ01CQVFBQUFBQUFBQUFBQUFBRUJRTUdBQUlIQVFqL3hBQkpFQUFDQVFJREF3Z0ZDQWdGQkFJREFBQUJBaEVBQXdRU0lRVXhRUVlUSWxGaGNZR3hCektSb2NFVUkwSlNZbkt5MFNRelkzT0NrcUx3RlVPend1RWxVOFBTUlBFMGc1UC94QUFYQVFFQkFRRUFBQUFBQUFBQUFBQUFBQUFBQVFJRC84UUFHUkVCQVFFQUF3QUFBQUFBQUFBQUFBQUFBQkVCSVRGQi85b0FEQU1CQUFJUkF4RUFQd0RtYm1vV05Oc1JzUzRENnkrOGZDaFRzbTU5bjJuOHE2SUN6VjVub283TXUvVkIvaUh4clQvRGJ2MUQ3Vi9PZ0J2SFd2RnFURzJHUWdNTXZmV2lVSG9yWVZnRmJSVUhnYXZjMWVSWGxCN05aTllLeUtEQ2E5VTE0UldDZ2xWcUt0WWlQNy81b0t0bGFnWU5pZVBaNW4zNjBIZHVFOGV6K3pYaGJ3OGZNMUc5QjR6MW9XcjBpdFlvUEMxYjI3a0dhMElyQUtDeWJLMm5rMUJqMmFuMlJHN3Q5cG9uYTIxbWNTZFowN0J4TW5XTzRWV1Z1eEJIeE5TdmRuKy9HZ2d4RDBSZ2pvS0R1VWJneDBSVkMwdHZyQTFlTnZQZlhnb0pVYXBWZW9FcVphQ1VYSzJWNmpGYmdVQnVHdlZZOW00aUNOZkdxdFpNZjNyUjFyRVIvd0RlN3QwcUM1LzRoMmorWS9BVmxWaE1ZWS9PVDhheWluMjByT3BwWXlVK3h5elN1NWJvQXdsVDJyTmJwYm91MGxBNDVMY2oyeG5PRmJ4dFpNZ2dUck9mWFE5bGE4cXVSVDRTMkhlOXpnTzRRZXNEV2Urcmg2TFAva0Q5ei81ZnlvbjBvcE9HSFlmOXlWTHlPTFhObmFrRFdDZm9xZmhVWjJZT3ovOEFtdjVWMVQwVjJsTjdFaGxCNk5zaVFEeGJyNzZ0NzNMUWZYRGlBU1BVVFhoU2o1MXU3S0gyZlpIbFNySDRmSXlpQnJQWHdqdDdhK25lVU96TFB5ZG1GcEZhVTFDcUNKZFpFanNKRmZObTJWbTZnN0Q3U2RmSVZjMERXc01DTzNUNHo4S2xYQkE5ZEd0aHlxejJqeVA1VnZZdEZqb0tJOHdXd09jQmdYR2lKS3dZbWQrblpXWWprOFY0WEIzcVB6RmRaOUNZZ1lyL0FQUi81cWs5S2R1WHRuN3cvb0ZTcTR4L2hmMy9BT1FmKzFSdnM2T0o4Vkk4cHJ1SEova0ZocitHdFhXTndNNkt4Z2lKTytOS2wyaDZOTU1xTXd1WGRBVEVydzhLVWNBdUlBWW4zTitWWXVIWnZWRTkzL05NdHQ0Y0RFRzJCNnVZZUFZZ2VWRmJLdzVrd09JSDRvcW9SL0pIK3FhbUd6TGtBNVJIM2s4cG1yU2NGY0dhVWdBeEpJTTlVQ2F2Mk41T1lkZGsycjYyZ0xwdzlwaTJzNWpia25mRytsVnhVN091ZlVZOXdKOHExT0JmNmpqK0VqNFYxSFlISUY4WmJhNmpXbEFkbGhnWjZNZFE3YTAyOTZON3VIdE5kZHJSVlFTY3VhZEFUeEE2cVZITCtZSTNqMmcxbVU4UDc3cUp0MjVaNDNCbUE3cE5OYkdEbUpYU0JxQXBPN3FKSG5WRmV1V2oyK05GNFZPaVA3NG1tRzM5bVhNT0xlZFZYbk14QTZKYUZ5NmtEZDZ3aWxXZGxBZ3dJbjNrZkNnQmEzcWExSzFmYlhvNjJoY1BSd1J5blVNMTYwb0lPNXZXblVhMGJzLzBVWXA4UUxGMTdWb2xPY0pWbXV3dWJMcUlVVFBiVW81dmFXcHd0ZGJ0ZWhqTXJOYnhlb1oxaDdjU1VZcnZWdEFTSjNHSjQwdXZlaURIcWRCaDNIV0x6QSt4clE4NlhCemxWcVcybFdURmNrSHMzZWJ1dmxZSHBBQU5HdTROTUh2aW84SnlkdmtuSkw1UUNTdGdYUGFKUHZGQWhDUlc0b3ZhMkJ2V2lCY0lXZHdObm15ZTdvVnRzYllXTHhSSXNJYmhXSmhsU00wNWRYS2pYS2ZaUVFoZjdtdmFiUHlVMmdoeXRadUFqaG5YanJ3YU9OWlRnV0RFTlFWdzBSZGFoV3FLOVFWTUxxcnZJSGVZcUZLMDJndWc3ejVWUjBuMFYzVkxZaktRZExPN3Z1MDE5STZ6aGozSDhTVlZmUTBDTVJpd2VOdkRuMkc2dndxNDh2bG5ETjNONVQ4S3o2SzE2TDlNUmVIWGF0bjhQNTEwcXVhZWpiVEYzUit3WDNjMStkZExwb0IyMnMyWC9oOXpMWHpEdHBJdjIvNHZ4Q3ZxSGFnK2Fidzh4WHpUeWlzeGZ0OTcvaUZYQVp0RG9XczBHQ3lnKy9Velh1QXc3M0ZaMEM1RUhTTFBiWGVyRVJMYW1FYmRPbzdhWVl2SFdyZUd1aHdYejI4Z3lGU3lQemx0bGVDZUJYZFZ4WEhXTVpzbjVhYk5rWFZWMXVFSWlOblFNTXVZQ1FDY3A4UlZEcjBhYkN2NFZzUUw2Qk00c2xZWlduS2JzK3FUMWlvUFNaYmsyKy96VnZ5cXdjbDhWaGJrdGhsVlExdTJXQ3JsNHRFamQ5YmRTZjBrSitwUDJ4NVBXZlE5NUZmL0FJT0grNThUVFBhQSthZjdyZVJwWHlKUDZEWSs2ZmM3VTJ4ZytiZjdyZVJxRDVuMjViLzZndyswL3dEcVBURkxXUWdnVDAxbmhBeXZyUW5LQWY4QVVXKy9jLzFHcTBZYkFJOXB5ZjFnYTN6V3BBekVYQzBqajBWTy92cllTWW5HM0N6SG1ueWhGYVRJR2xrUEIwMDZ1K3I1c2Zid3h1dzNJdDVEWkJzbGMyYWVidENHbUJ2QkdsT3ZrbHBzTnRCYlRCZzYzRW5PSEVERHJsT25lZkd1ZStpdTZUczdhVnZnQ0gvbXRPcC9BS2c2UDZMeCtpM1AzOXp5U21ITHhad1Y3N2ovQUlHb0gwWmo5R3UvdjMvQmJwbnl6V2NIZS9kditCcW5vK2M5aVdjeHVEN2JlWnAwaXVtb1VOR1dCbUFKMEdva2RmYlFQSmUzTDNmdnQrSTEwWGF1eTdTWVcxZkdIVzZSWVpuV1dVc0VWdXJ3OWxhSE9lWFcwVGVOZ2xXVXF0d0VNSTRvTkNORDZ2Q3EvZjhBVlQ3aC9HOU4rVnVMRnhjT1JadDJ0THArYloyREJqYklCVnljcFhYVUhXZHdpaytKYm9wKzcvM3ZWSGVmU055aXZZWEFXSHd0NEk4b3JRTGJrQTJpZFE0TWJodzQxSnlLNVMyMnc1eG1KdWczT1pzcTVqcEUycmVlNDJWQnBMT1RvSTNWUU52YkN2cGdjUmV1RUtvdW9GdDVGQmJQRGM2Ym04NkVDSk84blNhckNiVmEzaExLMjNJTDgvenVabk5zQURJcWkyRGx6RUlOVE85ZXFzd2QrNUU3YnRYMHZGU1lEODVtSUlCVzdKRENkWWxXSGdhYjdPMjdoNzhjMWVSODJhQk1FNVFyTU1wMTBEcVQzaXZtV3p5aXhKVmJDTWdYbTFTT2JTY3F0bkV2R2YxaWR6RGZWdDVGWWU5aU1YYXQyOFZpTFE1dk14dHVQbXlTeUVLclN1NjNiR29tSTdLUVd6YjJ5cjEvRjNibHEyem9IS2xoRUFxWVpaNndhdEhKWEFtMWNWV1FJM3lXM25HazVoY3VTVEc4Njc2bTVHNFo3Vmk5YnVPMXhseEdJQmRvelAweVF6UnBKQkIwcHBiWDlKSi9aRC9VYW9PY2VtWEFaNzJGSStxNDk0SStOSmVUZTJQOE53K014QlZHY0N3cUkzMDNacmdFR1FRQkpKaldCVnY5SmRxY1JoRDltOS9zcXFiZXdhbXlRK3Z6bHM1ZE5ZRnpXSTEzeHY4QXBWYzZGSHgzcEYyamNkbk9JQ3p3VzFheWlCRURNcE1kNU5aUU9NMkV3ZG9BanMzZG9IWldWb1crZWlPNFZHVFcxMDZVUHpsUVRod0FTZEFOVDRVRnREYUZ0Z3VWME9wM09rN3UxcU10TldtMUQwVjcvaFFYYjBRM0ZPSXZGUVFEYVVhNnprZnJCSStudW1mYUt1L0xSSnc1L2kvMDNxaCtpRzZUaXJnSkorWmJlWi96TGRkQzVWTE5nL3hmNmIxbmV4VmVRK0VGdkVpNFcvV29iUVhxS2hXbnVpMlIzeFhRcW9uSkZ3MTlGSTlWV1lkOFI4VFY3cG9IMmgrcmJ1OHErZnR2WVdjWlpYcnVNUDYxcjZCeDQrYmY3cmVWY1QyM2FqSFdUMVhMeC9sR2I0VXdjLzJxaHVZeDhva2wzNEUvV080QW1yOXlOd242RmlzSTdFTXlMaUlHWVpRQ0ZPWkNRZFJ6WjFHNmVvVHpwN3pDODdLeFVpZWtPQVpncFA4QVZYVGRoWUJMREpkUURObEtuVTlOWFhLUTUra1RPOHpyV2hZUFFwaVNVdW9ZaEZTTjBqTTkzTUNRSlBTQk9zeE9sUDhBMGdXOHdzajdhKytSVlo5RHQzOUp4YTZUbHRzMGZXWjdoSTkvdnEyOHRVa1cvdkw1bXA2RHVTTnNKaDF0Q1R6Y2dFL1NERXRQdEpIOE04YWE0cjFHKzYza2FWY2tubkRJeDlZNXA4SFlDbXVJMVJ2dXQ1R3NqZ1cxOWxvK091TzJKczJTdDI2QWo4NFdicGt5b1JUcHJIaFRIRlhlYUNoYnlIcEJwVmI0SnlwY1VoUzFvQWRHNHhrbmhTemxqWmphUTdYdWZpcWZiNUtvcEJqMTU3c2gzMXNKdlJZYmd4MTE3ZGszUnpGMVhnbE1pdERaaXcrNUVIZko0MTV5SzIyMkZ1NHJEaXkxMDRpTFFBWUxEQTNOVElPa1pqMlFhZmVoV3kzTjQ2NWJaRWNoRXpYSnlpRll4b2RDUy9iNnU2Z2VRRnRmOFZ4S3NBVHpHSWREdmh1akRML0E3anVOUWRPNUhYOFJidEZiZUVCek1YSk45UjBzdHNHT2llR1gzMFh5bHhlTGJEWFEyRlJWS1BKRjhNUU1qU1FNb25UaE5IY2pCOHk4OEgvOGR1anVVYXpoN28reGMvMDJxRDUrNU5vUmN1NUFXT2RwekFMQms2QWhqTld6Rzh2aFlGcXk5dEhOdENyS3B6R0drWlhEUUFZMWdFNkVkWXBGeVl0UmV2ajlvMzRqVmY1YllZTGlEY1VhRXc1KzNMUVA1QVBZSzBJZG8zOFBjQ1pudXJFN3JTR1pqOXJwdTk5RDNyZUdLck4yOTZwQStaVTZabS9hOTlMYngwSGpXWERvTzc0bXFqbyszT1ZIeXZDWExDcVJ6ZlNZeEVtMnVYNnhnZEU4S291QnNHOHFXb0lBTFFWaGlTVzNaU1Y0a2Nhc1BKNjVtK1dyQkg2TGVPOEdXVWs1aG9JMGdScnVtZFlBZklqQ2M0elN4VlVMNW9NRnN5b0ZRbmVCTW5UZnFLaXBiZHF6YkFWcnpqTEtqOUhVbmVmcEMvck05UXB0eWN4aVlPOXpsbTY1YzVWeTNNTkFQMHdOTVF1OGYzTko5czRGTFRncUlBT2FPSEhoNzZuNVZPWHVKbHlBaEV6RWtnbGdHamNPcHZLZ3VXMU9VR1BTTG9mSUxqWHdxclpYSmN1UGFERU5HS0psVkVxZElKTTV0dzZac0xGTmRGcTQwWm53OXRtamNDeEpJSGpYRUxtT3V1TEZpM2FSaWc1eHJuT0xmUUM2bVhTVkJScFJnMGRjZHRQZHU4dDc5cXlGc3ZidEVXMHRFckxYQUFTU3luMVY2dHhxUVc3MG1ZdExWekR0Y1lLb1c2U1QyWk4zRTl3cmxtMytXWE9BcFpTRitzMnJHQ0NDQU5CcUJ4TkljWHRibm5EWHJseTYyN05jZG5JazhNeE1Ec29tM2hjckszTnlBUVlPNGpxcXdBTnRPNlRKWSt3ZmxXVTlURTJvMXcrdjhQOEE2MWxCQmc5c3ZlelRidElCSHFLd0pKbmVXWTFzMXd6UU95MENxUklra3RvUWROQkdoODZKbldnWTRacTkycS9SWHY4QWhWVjJ0ajdxWFlWeW9nUUJ1M2FuMnpYbHJiVi8vdWUwS2ZoUWRVOUQ5MzlPSTY3RnozUGFOZFQ1UWtjMXFRQkoza0Q2RGRkY1k5RE9QZTV0TVoySitZdWpjRkc5RDZvNDZiNnRuS2owVkppTGpYV3hMZEs1Y2JwVzFjam5YWjh1Wmo2b21BS205aGp5YnhWbE1RcE4yMk9nd1BUWHQ3YXMySTVUNEpKelkzREwzM3JRODJybUd6L1E5aDJjSytJdXdabktscFRwTzZWYnFxdzJmUTNnVi96Y1VmNDdZL0RiRlRnV2NjcWNGZVc2bHJGMkhJUmljdHhTSWpmTXdmQ3VZY29zVlpOOHN0MjA1VVlrOUYxWTZwQTNIck5YaXg2Tk5uMnM3bEh1eXBBVzYvT0lDTmN3QitsMjF6dmx0eVpzV0d2T2xwVlhMTnVKQVVsMEJBNGNkT3cxY0hQTFFCVy85WWhBQnhNM0ZZKzVhYjdBMnplUjdhM0hibVZQR0RBQU1heG1qc29UWitGellURlhJbGhjdzZxUUpJMWN0SEVUSW1nc001dDNGWnd3eW1ZaUR1MDBQaFdrZEw5R1czc05oY1hpcmwyNnhXNkJsT1M0NUpGeGlBQXFrZ0JTTjlYSGxCeTJ3dHdES3VKZlVIVEQzUnVKK3NCU2IwVkVmNGpmSzdud3R0K3drdUZKL3A5OWRLMnNOUEFlZFkzdFZIMk55MFJMZHRWd08wcmhCT3FZUWxkV0o5WXNCeHB2YzVZM1dWZ3V5dG9iajZ5V2s4ZGJsTjhIZFZRbzE2Sk82TzNyUGJSRjdhSXlrUWRaM2tEZlFjVDVRTmliK09EREEzUXdXNi9ORjBERVNvelNOTkdkSkc4ejQwbTI3dHE4VmUxY3d4dEZjd0p6aGlEcXBCQUFxK2NvTVMveThOWmFHK1M0bVNPbEV2aDRQdEE5aHFxOHY3UUZwcms5Tm1LbnQxa2s5dTZ0QlB5STVUWWpCMjNXeHpZNTU1WXNxT1lRQlFPbGNRTHZiZVRQVU9PK3pMdHkxak0xdG1URXRiSUU4M2xaR3RpUW9DM0FUa0UrQnF0NExHODBxbk1NMHpsS2h4QjZ3Zjc3dDlPTmpiZURiU3dON0tFQ1BoN2JFa0tDUDFiUDFJSWJkSmlOOUVYZmtoNldMZUdXNG1MNXk2U3dLRzIyR2FBRmdnbWJmVU5JUEhYaFRuSGVtakFYRVpCWnhNa01QL2pjVkkvNy9iVHArVVdGRTVuc0hyK2R3NzZ4OWx5YVU3UzVUN1BqVTRieFM2MzRiQkh2ckt1ZWJMNVQyYmQyNitTNlE3bGhITlNBVE92em0ray9LREhHL2NZb0dDRjg4TmttY29YZ1R3SFhVWEswMlRmRFduUjBacEpSQ2lyTEhvNVR2Z1JyQTMwbVJWblZSSGRXMEYzN0xRTkRwUXozdUh4SDUxNDl0UVlnYitvVEJBMG12U0JHNFVEYlkyMmJxT3h0V2MrYTNjUndvdVBLM0psaUZHOEE5MmdyVFkrMVhzQzZVZ2dsUVFlTTVqb2VCNkk5OU5MV013OW5wMnJqSTNObFdEZy9yVGJpVklFeHZHNDZrSHRxdDJ0YzRHN29uMlNQalFQOXY0clBaUjkyYXlwN3VqQkh1TkM0TnJyMjFZc1NZZ3lNMGhRRlVtUWR3VWExb0Jud3lLRDZvdUlUMUUzSGNEMk1LZzJuZEp0NGNaZWt0dTJ1dkhwUEVIcTBqd2lvcTU3U3hiMnNIaDFBUE8zYlNGb2trQWpvb3Nra0RVbU8ya2xqWjkzbXIzT0pMdUZ5YWdrUVNUSjRjUFpWeHhRVTRwZ2Q5cTJpcjJhUWZMMzB2dTNlbXcwZ0dJNHhsbk5QVk9sQld0aTNMYWRCMVZYM0VsQVc5cC9LbXVGeC9SZ2xOTkJPOHhwOFBmU2ZsV0FHUmwwWXlQWkIvT29kdXIwTU0yLzV0WjdkOUJaUGxxL3MvZCtkWlZKeWRjVDJHdktvTlJvT2hwbmg3Wk5WN250YXNXemNXTXRFUzR2QUM0aFE5V2g0ZzhEVldhMWxUS2RHa2tqdEJ5Z1QvTjdhdUlDdnhJOFlwTnRYWW5GS0tzSG9YYkp0TzJXSUVwZEcvWDFDMm80ZXJYMEJqTVVDdWdKZ2c2Q2QzZFh5enNuYWx6RHNXdHNWWkpLc3JNcEdaWUlrUWVQblJkL2xsakgzM25QZmN1dDV2V2R3ZC84QWxiQS9xcjQ3ZWF1RDM1WXJMdTJRUFdrZmV1MjAvRzRyNXd2Yll2TnFXRTl3UDRwcVAvRXJ2MXo0QlI1Q2tIMEplMi9hUDA3UGpmc3QrQm1xbDh2OW9oOEsrVjdURE1naEdkb25NZGN5S09IQW11V05qcnAzM0gvbWI4NllXNzUrUlBKSkxYZ05UUHFXd2VQMzZRTitTZUpXM2dyMHN1YzNzd1V5SlZFVVJNUkoxcHRoY1Ridkt3ZGN2UkFLc0JBSVRLd3R6T2trYWU4OE9mYk9BTGF4RU5xZTQxMEhDOURDbThkVXQyeTZUcUpHbzd5TGdnZGlSdWJXZ0xrZnkwWEFzamkyYm56VDJtQnVGU2c1eVZPaUdkRkhBYjZmN1E5TG9jUU1Pdmk5MCtSU3VUWnBKZ2tnWlFKQUVka0RUU1Q1NlRXVFNJNkJjOUo5ejZObTJPL25XL0hmSTkxQTMvU1BpVDZxV1Y3ck5pZmExc24zMVRLd0NUQUJKTUFBYWtrN2dCeE5JTEsvTHZHa2tpNWxMYnlvVkNZM1R6WVdvTnE3WHZYOElHdlhHYzg4d0JabWJRSWgra1R4SnFERjdLdDJyVXU3dGRndVVSUmxWQVF1Wm1QMGN4eTVvMVBxaGhEbUxhR21Gc0NDSjV4b0lnNnNRRDNRQlFDSllLcm55cDBZSkpiVmcwQUFBOVhkeDQ2VnBlWW5LMEVMbUVIV1BvblFuODZrdjN3STV0VjZobUFlNVAzVzBIWVF2alVOMUxqaHJqRm15NVFTeEpqTUdJWFg3cDA3S284ZTR4M3NUM2ttb2lLMlkxb2FEYTRlaDQvbFd0dHQxYkJKVnV5RDdKbW83Vzd4b0NyL0FLM2dLM1RSV2VBY29FQTdpekdCUFh4TWNjc1ZwZkV3UndFSHMxNDlWVE9zV0JwcTl3K3kyb0E5OTF2WlFIY25ObVc3bDlGdWt0SkVpWUo2TEdDZC9BYm8zMUJoY0dHeEwyMUtvUG5OVE9VQkRQa3ZsUmVFNVFHeW9Gb1N3SUpNTEdhQU5XSWs5d3BaaEx4NThNdzFPZVJxb2hsYVIxOGRPMktDWEI1N2JrTU9peHl0OWxsSUV4djBMUWUrbTJ6U0RmdDIyVUhPTGRuZE1NTVNMZ1lRd2pRd1RyeDBNMExpUUlJTW5PRTZYVm9DSjdUR3ZkMXpKSEpPL254bUZCRWtNQ2REL2wyMmFlL28xQXg1VDdWYTNqSGRlc2dqZ1JPNzNVVFp4OXU0QVJmdEtTTlZZdktucWFFSTlrMGoyazR1WXB5ZFFTM3VOZWhRTjI2aXBkcFlRc1NTOXArcklYSUE0em1VZGxMM3c5d3dHdVNBSUFNNkFVY25IdXJVbWlBZmtUZldGWlIwMTVRVnJQUmRyRVJRNHR6UlZuQUUxUVpoY2FSeHAzaGNVR0VHa2d3Qm9teGJLMUJKdFRCZ0t4RytQQ05aK0h2cXZpcmtxNTBJUFVhcWVMczVISW9xS3NGZVRXVFJIczB5eFdtRHRmYWU2M3ZDZjdLV1RUSGF4aXhoMS9aay93QTd1Mys0VUF1eXhMcUl6U0RwSkU5RThSVjV2S1RzdTdxVkNtMk1nMWtDN2FWaUR2MENNSTR6TlVMQWs1eGxFbldBQkpKZzZBY2F1dHZhVGpaMTFTakl5aE16UnBQT1d3b1ljRHI1ZldvcW5ZaEFGMFZ4cnZZUVBEU2hacGxhUzdpR0ZwZFNUeE1LSUJKSkozQUNhYTNzUGhzTWhVSG5ycEVaNGdLVC93QnRlSGZSRmQ1aC9xTi9LZnlvN1pWMXNQZVc2d2hsekZRU29ZRXFRR0tIcGFUT280Q2dMcWF6clVVQURRVlFmdGpiVnk5ZnVNSEtLK1JRbzlVTGJYS2dBK3lOM1VTU0tONVc0b08xc2hWVmNnS3F1aXF2MFZBNmdBS1FXN2NtTmN4SWpTUVpQRXpwNzZ0R0kyQTJJam1yaU02cXFtMU1YQUZVYXFEby9nWjdLQ3FtU0ozZFVEalRiRnNCaGJZQWpuYnJQNFc3YUlCL00xeWdyK0FaR0N1Q3V2ckhSZERydzBQWVJQWlJHMklVMjdZM1c3U0R4ZWJwL3dCUWV5Z0NOYW1zcnlnbnduMGg5aytYL05iM01NMlZZQitjWmd1bStOSUhzUHRyYkFYa1ZXbTJXWWtRMHRDZ2FrWlYzejFrNlJwV3lZcTVOc0FraTFuWlJ3V1lMTlFBWG96RURRQ1FQRDQxTVNlYkVra0RkM3R3OXhvZlBEU1lPcFB0b3pINHBuVlZPVVpBcTZBRDFRUnIxbnROQm1Cdm9IK2NNTEU1aHFSeGpTaTlxT3B2UXVpaFFCd0o2T2t4dU9vb0hBbVdVQWRLUkhHRE84anFxWFBtZTRkOGs5dW1hUjVDZ2JZakdGN0ZwUVBva2J0Y3dNeVQxRU1SL0R3MXB0eUp3b241Uk90c1g0R25DeUFEMTczSThEU213ck5oeTBDRXVRMm11VjlZbmh4NzVqcW96a2dHTnk2Zm9peTJuVkxJZk5SVUFIK2VlNDBWUVZ0cHZudWFqQ2FEZE9QZFdocjFEdjdxMUpvTnF5c0ZaUUFiUHdIRTAwV0JYaTZDSzFacUNYUFhvcUROVXFVQkdIdXdhUWJiTXZOT1RRT093bWZjeTl1WmxRRHhjaWZDYUtSVFQ3QWJNWDVIZHhKQ3V3WUtxdG15cU5RWE9VaVRPZ21SNDdsZC9CaFFmbnJURWZSWG5XSjdtNXZKL1ZUekZiUVpObklqbGM5d3JrUUFBaXlpd3J2SEZqcU9KM21pSzJ4NGoyZFJwaHQxU09iVDZ0cTBQWmJXYVdXcnVYZUF3NGd6QjhScUQyaW0yMG9mRUxKSVZtUVNOU0ZNRFR3cWhkWWdOcVlHdXZTSHdxMmJKZkNwaCtaYTRsek1WSlJYeWpvdG5VT1NRU1FaMEhXWU5MTm80ZkRneGJ6ejkvTUIzbU5UMkNnRGhRZVB0QU5BWnRNWFJjTnhGZFZuUlFyQkFJaUFOeEhzcGJZZGlTV0duRW1hOGJCaWRJNzRpTzBtZEtpdDRUTVdoZ1NvbmNkZFFOSjc2QWk3ZVJqdkNpTityVDJ3S0hoUHJud1VreDF3MEQzMHd0N0pWRkRYMlpaOVcySTV4dThSMFIzMERlYTJwYm9FUUcwbVNEQnk1aTNiRWdjSjNHZzl0NGhFSUtobU1NTlNGM3FSSVVCdDB6djRWN2N4ckYrY0F5dHZCRTZkUkVtckdjR2x2REMycXE5NXdjMjhrM0FuT3R1M0paUmxYS3ZyM0cxbktBVUY4TVU2WHIyMlpHN0NDZjhBa2VGQkpleDkvRk1sdTdkZTVtWlZFbWQ1Q3pBRytPTy9TdGIySHVZaS9jTnBHZVhhSUdnRTlFVHVIUmpmVzJ4bmhpK2c1dEhieEM1Vi9xWUdnYmJRcEU2SGVOUDdOQlpzRDZPOW9YQm1GcEVIVzEyMy9zTEgyMUh0SGtGamJJbHhaajkvYlgzM0NvcEpaMmpjUUVXM1pKK3F4WHlxVFp1Mjc5bk9iZHhsWjR6UFBUTWJ1a2RmZlU1RXVIMlZqRkpGdEx3a2FtMFdaV0FCMEwyU1ZQSFNlUGJVTnpabHpuQ0NqVzRVbVNyTEVBekU3OU5JcDVoZVZXTkNITmZ6THBMc1V1c0NaZ1FaYVQxYnRLU2JVMmpjWTlLOHpzZldHVUpIVURsZ1QxZ1NCMTFRSmc4TVd1S3JDSk1tUkhSVUZtOXdOUnZCSkprU1Rydkg5NzZOMmNkTHJuWExhWWVOeGxUeVpxRHNvSm5QbFBqNTBCV3pWQ3RtM3dHYWZ1cVNQZUJVV0ZKQUpHK1J1ME83VFgyMU5oN1lBdXNHemRDTjBhc3lqODZnY0VJc0RmUGlkL2t3b0hHelhaclYxUnVKVE5KSkVGYnF5ZkVyNGdVNjVIaUxPTFkvVXREd0piVCttcXpzdlVPckVpVUpFSDZhbm85Mjl0ZTJyTHNCL3dCRHhMZGJvdmZDaytiVkJYOE1mbmozTlJ4Tkw4SCtzUGNhUG9ObE8vdXJRbXRsNDkxYUdna0JyS2pyS0NmUFVEdlhoYW9iaG9JbXhCSjBvekIzVFMrMWJNMDJzMmdCVkV6TlFlTk9sVE05QjR4OUtnVVB4bzNhV0s1OWtPNXNsdEkzQWxGQ0NPK0JRZVFuZ2FsdzFnNTExQTZTOFo0anFxaWZCWWRiZDFlZUFpQ1lPb08rSmplSkc3alJHMm1EZ1hGM0h1MGc5bE1jVHlkdlhiaXN3TnUyVURCbUhDVHVCSVBiTzdkSkVpb01aaExTMjJ0MjNMNVRKYmVOUU5BWTdQZlFDcXd5aHVzVFdqc2VvOXdFc2Z5SGFhRXRZa0tJTXlOeGlZN2hVVDRnbmZKN3lUUVQzMllqTEFVYjRrZS9XVFcyeTJ5WFZZTkdzYVR4MG5YcU1Id29Ocmg3dTZ2RG1QV2FBeTlkWU14WWt0T3BKMVB0MTlsTHcydXU0a0U5c0hqVERISm1ZSDZ3QjhTTlI3WnFGOEM0VTlDUVlPYmlzVE9uYlB1b0M3ZTF6YWNYRVVNd1Y4aFlrODI3dm1GMVFDQVdYZXM2QXdZTUNoTm10T1pUOUlUNGloeW1vTFNGbU0wYWRzR3RzRXJHNkJiQll6b0FOWW1KUFZRRW9jdHE3MXNVWHdFc2ZKYTBUQnNlRlQyU3kzaGxLcVNZbDFSMUU4U3JnclZvdFhNVkdnd1YzNzFoRjk5dUtDczJ0bE1kODE1c3ZCWjNkVDlHUGlQaFZzK1U0ampnY08vN3U0NmU0dUJTalo5dTVZdTNiajRhOFE1SnlxSnlqTVNPa0EweE1icWlwTVJzWTIxbFZBVkxiM1NRZU1MQkk3RlkrK3FnNU84OGRmYlRUYVdQY3RjSFNVRU1NcG1ZTEVnR1FPRGRRcFhjYVk3Z1BacFZRWGNzTXFvc0VjNFF3a1JLN2w3OTgrTlE0amVRTndwaGQyaVd2V1dNRVcxVUtPQXlLQW9qK0ZmWlNvNzVQRW1na3p3SVVucEFTUHRBa0FlUjhhZHN5QzZRVU9SVGxnYWtCZEJHbStsR3prbTliQSt1dnNEQW4zQTFkTVRnclQ2c2dKNi9qUWUvSTdQTkYxTUFvMnU0aVFlRlE3S2YvcDl3L1d2TjdrU295Z3RqS2taWjlVN3V2V3ArYkNZQUFjYmpueUZSVmR3UitjUGNhWVVCZ0FNeDY0MCtOSFVSNnA4cTFyMGZDdGFCdGdzTmh5Z0x1UTJzak1vNG1ORHJ1cktrMmRqY010dFJjdFptRXljb002bmpQVldVQ0ROVVROVWEzSzFacW9uUzVVcHhWQTU2MUwwQnB2MTZSSW9GV3B2czVrQkJ1VGxHK0FEN2p2b0ZXVVR1bnY4QStLc095OE1tR3k0aThWRERwSmJoU2RSb1dERGZyUFlZT3NSWHQvRVdRNStTMldaenVKVTVVKzZHSmp2SnFmQmJPdkFsM1N6ZFk3K2RUbkI0U2RQQ29wZnRYbEExOGtzV2dtY29KbHUxMjNuKzRpbDJFdVhDNGtRcEJFRGNKM2UrS3ZHSFFxSU9BdzdEcVUrUzNRUVBDaUJkd3Y4QW03T3ZXKzIzbWI4TEZSL0xRY3krVGxueWpmckVDZDNkUlEyYVJ2MDc5UE9wY1V3dFlsWEU1VnVBNmpwWk0yc2d4cmw0YVYxREJXOE0zcTMwUGZ4L2x6Q3FPWjJ0bEhxb3Uxc3F1bXJzckRFNjh6UFgwVlB0ME5FcnlTdzc2ak1PMWJoYjNOSXFVY2cyMWh6YnlNT0h3TTBmaVVkbDZJaEdBTWdBbURydk5YVGw3eVNGdkJ0Y1JpM05sVEJVVERFS2RWZ2FTRHU0VXQ1Q2JOZkU0UU11UW0yelcyQllodElaZE1zZXF5OGVGS0tZbXo3cWlGZGdOZE5RTmV3VnRhT0p0K3FWOE5LdjJQMld5SFZZUDNrOGcwKzZsZUl3NEExZ25xMTE4YUNrWWk0eVhGdUVRd09Zamh2MUhjZGFzK0V4TnU0TmJRQjdERkpOczJiMXc2V2xFZFQ1akhlWThxSzJhWEZ0UVFRUnBIZHVQc2lxaDZsZ2ZSWjE5OVJ2ZnVBeG5CNzZXdmlqMW1oSHVtZDlSV3ZLSFpseTQzT0RLVEFCQU1aZ054MTQva0tyMTdDWEYzb1IvZlhWaWJFdDEwTGR2TVNDZUJCalNEMkdxaFhpcllTNHk2OUhvejFNSTh5Q1BHaDFiZ2QydmhQR2pidHNrc1NaekVrejFtb3pZRkJ2c3k4RnVoK0FCaWU3S04zR0tjdHRLZU5KSU5lQ2FCempRY3FzU2RSSkgzaWNnOWlsdkVVVFp2RTRPRHdkNDhkYVVQZXpLSk80RFR1VlYvMisrbkZ3SDVJakg2UlkrQU1EeXFCVmdEMGoxeFIxQVlQMXZBMGRRZWl0Q2E5bXRDYUIvc3k1ZkZwY2xrTXVzRWtDZWtaNDlkWlVPQTU3bTF5M1FxOEJsbUpKNHhYdEIxTGEzSVBacVJLS3BQVVc4Z2ZoVk81WThrc0xidGxyQ1BQQTdsOSt2dXJvWEtDSlhYalN6YjFyTlpianA4S2l1QXNhMW1wOFVrT3c2aWZPb2FxSkxJMXB0aExZWWhUdU5LN08rbStCOWRPOGVkQmRzTnNlNnFBcUZjUnVNZytkR1lhNWJINnhXdG51ekQyaXJqc0RCTHpTOGRCUnVKMmJiSTlVVktxdVlPM1pmMWJpdDRpanhzMGRuaFNqYU95TFdZOUFUMTd2S2dNaW9ZbTRuYzdSUVZEMHE3TTV2RUs0R2x4QWY0bDZKOTJYMjFaT1IreU1IaThGWnVQaDdaZkxrZGdNakZyWnlra3BCa3dENDB1NWQyT2N3NGZuQy9OdHgzZ1AwVHIzNWFwbXc5czQ2MnJZZkNNd0RNWElWUVdCZ0tUbUk2STBGVWRUeFBJdkNxc3JmdjRjRGlMM1I4ZWRCODZxVzFjVlpzSDVyYWd1bjZ2TWM0Zkc0akFDbCtINUg0ekZITmljUUZuNjdtOHcvaG5MNzZ0dXl2UnZnVTF1RzVlUDJteXIvS2tIMmswRmV4WEtObXN0YkY4dVhCVmdjeUNEb1JsWmo1MFhzSEphc2xFdVpjNWx3cjVaTzdXRE5YVzl5VXdETEh5V3lOSWxWeUgrWllQdnBOalBSM2hENmh2Vy91M0F3L3JCUHZvRWQ1b0J5dTQvallqK29rVlg4UnQwYWpuWjcwbjNpS2kybnNMbXNhdUZ2M1N0c2taYm1ucXRPUWtFd05SbFBhRFR6R2Y0WlpBVkxLM0dIWm1udkxiL0FIMEZaWGE5MXpsdG9HYUNZZ3pBRXpFOVd0YWJJd2o0aTZiYjNtdDZGdFFTREJFZ0NRQnZxYmJ1TVpyeVloVTVrZ0FDU0JPWFNZUFlZM2JvcDNzNnhrZ3MyWmpxU1BMdXFoZ2VUdHFGQzNMZ2dBYjFPNFJycFVGN2swUU9qZEhjVWozZy9DbWxtS3pFWGlCVUZWeG16YmlmVmJ1SitJRks3aFliMVBuNVZZOFppNlRYNzA4S0lXUGM3S2pMVVk3R3RzTmgxWTYxUUJtcnlqOFJoRURRSzArU0RnYWdDcTFiUzB3ZUdIN09mYVNhUUhCSGhGV0RiQ1pjTGhnZDR0TFFWL0NldjRHalNhRHdxbk5QQ0RSWm9NQnJXYTlGYVVCMkdTM2xHWmlEcklEUng2b3JLanNNbVVTaEoxMWp0cktCdHRIbGZpcmhub2lEMjFPdkxlNlVLdXZEZUROWldWWUtmaTJ6TXpkWm1oU2F5c29Kc1B2cHZaRUVIdEZaV1ZCM1hremNteXZjS094V0pnVmxaV1ZWbkhYQ1dvREUyODIrc3JLb0F4K0NEMjN0L1dVanhqUSsydWRjbU1SeldNdDlUazIyN24wSDlXWDJWbFpWSFVma1FQRDN4V05oR1VFaTRRQjQxbFpVQ0xGOHNsdE5sREY0K3pBOSt0UXZ5dnZYdWphaE9zOVhuN2hXVmxVVmJsTXJzd0x1Ymo3cDNSdUlBblhpZXFnZmxUZ2RHRjdRQUQ3ZDlaV1ZVYUF0Y0lEbVJNMDlzdnVyS3lnZFlGcEZFWHJKSXJ5c3FLVTRyQ1VCZHc5WldVQWoyNml5VmxaUkdaYTN5VmxaUWJLS2I4b3YxRmo5MHZsV1ZsQW13aCtiUGY4QWxYaHJLeWc4RmExbFpRSEpmYUIwVHVHNXlvZ0RUUUdzckt5Zy85az1cIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8yd0NFQUFrR0J4TVRFaFVURXhNVkZSVVhGeFVZRnhjWUZ4Y1ZGeGNYRlJZV0Z4Z1ZGUmNZSFNnZ0doMGxIUmNYSVRFaEpTa3JMaTR1R0I4ek9ETXROeWd0TGlzQkNnb0tEUTBORlE4UEZTc1pGUmtyS3lzdExTMHJLeTByTFNzckt5c3JLeTByS3pjdEt6YzNMUzByS3pjM0t5c3RMUzB0S3lzckt5c3JMUzByS3lzcksvL0FBQkVJQUxjQkV3TUJJZ0FDRVFFREVRSC94QUFjQUFBQ0FnTUJBUUFBQUFBQUFBQUFBQUFFQlFNR0FBSUhBUWoveEFCSkVBQUNBUUlEQXdnRkNBZ0ZCQUlEQUFBQkFoRUFBd1FTSVFVeFFRWVRJbEZoY1lHeEJ6S1JvY0VVSTBKU1luS3kwU1F6WTNPQ2txTHdGVU96d3VFbFU4UFNSUEUwZzVQL3hBQVhBUUVCQVFFQUFBQUFBQUFBQUFBQUFBQUFBUUlELzhRQUdSRUJBUUVBQXdBQUFBQUFBQUFBQUFBQUFCRUJJVEZCLzlvQURBTUJBQUlSQXhFQVB3RG1ibW9XTk5zUnNTNEQ2eSs4ZkNoVHNtNTluMm44cTZJQ3pWNW5vbzdNdS9WQi9pSHhyVC9EYnYxRDdWL09nQnZIV3ZGcVRHMkdRZ01NdmZXaVVIb3JZVmdGYlJVSGdhdmMxZVJYbEI3TlpOWUt5S0RDYTlVMTRSV0NnbFZxS3RZaVA3LzVvS3RsYWdZTmllUFo1bjM2MEhkdUU4ZXorelhoYnc4Zk0xRzlCNHoxb1dyMGl0WW9QQzFiMjdrR2EwSXJBS0N5YksybmsxQmoyYW4yUkc3dDlwb25hMjFtY1NkWjA3QnhNbldPNFZXVnV4Qkh4TlN2ZG4rL0dnZ3hEMFJnam9LRHVVYmd4MFJWQzB0dnJBMWVOdlBmWGdvSlVhcFZlb0VxWmFDVVhLMlY2akZiZ1VCdUd2Vlk5bTRpQ05mR3F0Wk1mM3JSMXJFUi93RGU3dDBxQzUvNGgyaitZL0FWbFZoTVlZL09UOGF5aW4yMHJPcHBZeVUreHl6U3U1Ym9Bd2xUMnJOYnBib3UwbEE0NUxjajJ4bk9GYnh0Wk1nZ1RyT2ZYUTlsYThxdVJUNFMySGU5emdPNFFlc0RXZStyaDZMUC9rRDl6LzVmeW9uMG9wT0dIWWY5eVZMeU9MWE5uYWtEV0Nmb3FmaFVaMllPei84QW12NVYxVDBWMmxON0VobEI2TnNpUUR4YnI3NnQ3M0xRZlhEaUFTUFVUWGhTajUxdTdLSDJmWkhsU3JINGZJeWlCclBYd2p0N2ErbmVVT3pMUHlkbUZwRmFVMUNxQ0pkWkVqc0pGZk5tMlZtNmc3RDdTZGZJVmMwRFdzTUNPM1Q0ejhLbFhCQTlkR3RoeXF6Mmp5UDVWdll0RmpvS0k4d1d3T2NCZ1hHaUpLd1ltZCtuWldZams4VjRYQjNxUHpGZFo5Q1lnWXIvQVBSLzVxazlLZHVYdG43dy9vRlNxNHgvaGYzL0FPUWYrMVJ2czZPSjhWSThwcnVISi9rRmhyK0d0WFdOd002S3hnaUpPK05LbDJoNk5NTXFNd3VYZEFURXJ3OEtVY0F1SUFZbjNOK1ZZdUhadlZFOTMvTk10dDRjREVHMkI2dVllQVlnZVZGYkt3NWt3T0lING9xb1IvSkgrcWFtR3pMa0E1UkgzazhwbXJTY0ZjR2FVZ0F4SklNOVVDYXYyTjVPWWRkazJyNjJnTHB3OXBpMnM1amJrbmZHK2xWeFU3T3VmVVk5d0o4cTFPQmY2amorRWo0VjFIWUhJRjhaYmE2aldsQWRsaGdaNk1kUTdhMDI5Nk43dUh0TmRkclJWUVNjdWFkQVR4QTZxVkhMK1lJM2oyZzFtVThQNzdxSnQyNVo0M0JtQTdwTk5iR0RtSlhTQnFBcE83cUpIblZGZXVXajIrTkY0Vk9pUDc0bW1HMzltWE1PTGVkVlhuTXhBNkphRnk2a0RkNndpbFdkbEFnd0luM2tmQ2dCYTNxYTFLMWZiWG82MmhjUFJ3UnluVU0xNjBvSU81dlduVWEwYnMvMFVZcDhRTEYxN1ZvbE9jSlZtdXd1YkxxSVVUUGJVbzV2YVdwd3RkYnRlaGpNck5ieGVvWjFoN2NTVVlydlZ0QVNKM0dKNDB1dmVpREhxZEJoM0hXTHpBK3hyUTg2WEJ6bFZxVzJsV1RGY2tIczNlYnV2bFlIcEFBTkd1NE5NSHZpbzhKeWR2a25KTDVRQ1N0Z1hQYUpQdkZBaENSVzRvdmEyQnZXaUJjSVdkd05ubXllN29WdHNiWVdMeFJJc0liaFdKaGxTTTA1ZFhLalhLZlpRUWhmN212YWJQeVUyZ2h5dFp1QWpoblhqcndhT05aVGdXREVOUVZ3MFJkYWhXcUs5UVZNTHFydklIZVlxRkswMmd1Zzd6NVZSMG4wVjNWTFlqS1FkTE83dnUwMTlJNnpoajNIOFNWVmZRMENNUml3ZU52RG4yRzZ2d3E0OHZsbkROM041VDhLejZLMTZMOU1SZUhYYXRuOFA1MTBxdWFlamJURjNSK3dYM2MxK2RkTHBvQjIyczJYL2g5ekxYekR0cEl2Mi80dnhDdnFIYWcrYWJ3OHhYelR5aXN4ZnQ5Ny9pRlhBWnREb1dzMEdDeWcrL1V6WHVBdzczRlowQzVFSFNMUGJYZXJFUkxhbUViZE9vN2FZWXZIV3JlR3Vod1h6MjhneUZTeVB6bHRsZUNlQlhkVnhYSFdNWnNuNWFiTmtYVlYxdUVJaU5uUU1NdVlDUUNjcDhSVkRyMGFiQ3Y0VnNRTDZCTTRzbFlaV25LYnMrcVQxaW9QU1piazIrL3pWdnlxd2NsOFZoYmt0aGxWUTF1MldDcmw0dEVqZDliZFNmMGtKK3BQMng1UFdmUTk1RmYvQUlPSCs1OFRUUGFBK2FmN3JlUnBYeUpQNkRZKzZmYzdVMnhnK2JmN3JlUnFENW4yNWIvNmd3KzAvd0RxUFRGTFdRZ2dUMDFuaEF5dnJRbktBZjhBVVcrL2MvMUdxMFliQUk5cHlmMWdhM3pXcEF6RVhDMGpqMFZPL3ZyWVNZbkczQ3pIbW55aEZhVElHbGtQQjAwNnUrcjVzZmJ3eHV3M0l0NURaQnNsYzJhZWJ0Q0dtQnZCR2xPdmtscHNOdEJiVEJnNjNFbk9IRUREcmxPbmVmR3VlK2l1NlRzN2FWdmdDSC9tdE9wL0FLZzZQNkx4K2kzUDM5enlTbUhMeFp3Vjc3ai9BSUdvSDBaajlHdS92My9CYnBueXpXY0hlL2R2K0Jxbm8rYzlpV2N4dUQ3YmVacDBpdW1vVU5HV0JtQUowR29rZGZiUVBKZTNMM2Z2dCtJMTBYYXV5N1NZVzFmR0hXNlJZWm5XV1VzRVZ1cnc5bGFIT2VYVzBUZU5nbFdVcXR3RU1JNG9OQ05ENnZDcS9mOEFWVDdoL0c5TitWdUxGeGNPUlp0MnRMcCtiWjJEQmpiSUJWeWNwWFhVSFdkd2lrK0pib3ArNy8zdlZIZWZTTnlpdllYQVdId3Q0SThvclFMYmtBMmlkUTRNYmh3NDFKeUs1UzIydzV4bUp1ZzNPWnNxNWpwRTJyZWU0MlZCcExPVG9JM1ZRTnZiQ3ZwZ2NSZXVFS291b0Z0NUZCYlBEYzZibTg2RUNKTzhuU2FyQ2JWYTNoTEsyM0lMOC96dVpuTnNBRElxaTJEbHpFSU5UTzllcXN3ZCs1RTdidFgwdkZTWUQ4NW1JSUJXN0pEQ2RZbFdIZ2FiN08yN2g3OGMxZVI4MmFCTUU1UXJNTXAxMERxVDNpdm1XenlpeEpWYkNNZ1htMVNPYlNjcXRuRXZHZjFpZHpEZlZ0NUZZZTlpTVhhdDI4VmlMUTV2TXh0dVBteVN5RUtyU3U2M2JHb21JN0tRV3piMnlyMS9GM2JscTJ6b0hLbGhFQXFZWlo2d2F0SEpYQW0xY1ZXUUkzeVczbkdrNWhjdVNURzg2NzZtNUc0WjdWaTlidU8xeGx4R0lCZG96UDB5UXpScEpCQjBwcGJYOUpKL1pEL1Vhb09jZW1YQVo3MkZJK3E0OTRJK05KZVRlMlA4TncrTXhCVkdjQ3dxSTMwM1pyZ0VHUVFCSkpqV0JWdjlKZHFjUmhEOW05L3NxcWJld2FteVErdnpsczVkTllGeldJMTN4djhBcFZjNkZIeDNwRjJqY2RuT0lDendXMWF5aUJFRE1wTWQ1TlpRT00yRXdkb0FqczNkb0haV1ZvVytlaU80VkdUVzEwNlVQemxRVGh3QVNkQU5UNFVGdERhRnRndVYwT3AzT2s3dTFxTXROV20xRDBWNy9oUVhiMFEzRk9JdkZRUURhVWE2emtmckJJK251bWZhS3UvTFJKdzUvaS8wM3FoK2lHNlRpcmdKSitaYmVaL3pMZGRDNVZMTmcveGY2YjFuZXhWZVErRUZ2RWk0Vy9Xb2JRWHFLaFdudWkyUjN4WFFxb25KRncxOUZJOVZXWWQ4UjhUVjdwb0gyaCtyYnU4cStmdHZZV2NaWlhydU1QNjFyNkJ4NCtiZjdyZVZjVDIzYWpIV1QxWEx4L2xHYjRVd2MvMnFodVl4OG9rbDM0RS9XTzRBbXI5eU53bjZGaXNJN0VNeUxpSUdZWlFDRk9aQ1FkUnpaMUc2ZW9UenA3ekM4N0t4VWlla09BWmdwUDhBVlhUZGhZQkxESmRRRE5sS25VOU5YWEtRNStrVE84enJXaFlQUXBpU1V1b1loRlNOMGpNOTNNQ1FKUFNCT3N4T2xQOEEwZ1c4d3NqN2ErK1JWWjlEdDM5SnhhNlRsdHMwZldaN2hJOS92cTI4dFVrVy92TDVtcDZEdVNOc0poMXRDVHpjZ0UvU0RFdFB0Skg4TThhYTRyMUcrNjNrYVZja25uREl4OVk1cDhIWUNtdUkxUnZ1dDVHc2pnVzE5bG8rT3VPMkpzMlN0MjZBajg0V2Jwa3lvUlRwckhoVEhGWGVhQ2hieUhwQnBWYjRKeXBjVWhTMW9BZEc0eGtuaFN6bGpaamFRN1h1ZmlxZmI1S29wQmoxNTdzaDMxc0p2UlliZ3gxMTdkazNSekYxWGdsTWl0RFppdys1RUhmSjQxNXlLMjIyRnU0ckRpeTEwNGlMUUFZTERBM05USU9rWmoyUWFmZWhXeTNONDY1YlpFY2hFelhKeWlGWXhvZENTL2I2dTZnZVFGdGY4VnhLc0FUekdJZER2aHVqREwvQTdqdU5RZE81SFg4UmJ0RmJlRUJ6TVhKTjlSMHN0c0dPaWVHWDMwWHlseGVMYkRYUTJGUlZLUEpGOE1RTWpTUU1vblRoTkhjakI4eTg4SC84ZHVqdVVhemg3byt4Yy8wMnFENSs1Tm9SY3U1QVdPZHB6QUxCazZBaGpOV3pHOHZoWUZxeTl0SE50Q3JLcHpHR2taWERRQVkxZ0U2RWRZcEZ5WXRSZXZqOW8zNGpWZjViWVlMaURjVWFFdzUrM0xRUDVBUFlLMElkbzM4UGNDWm51ckU3clNHWmo5cnB1OTlEM3JlR0tyTjI5NnBBK1pVNlptL2E5OUxieDBIaldYRG9PNzRtcWpvKzNPVkh5dkNYTENxUnpmU1l4RW0ydVg2eGdkRThLb3VCc0c4cVdvSUFMUVZoaVNXM1pTVjRrY2FzUEo2NW0rV3JCSDZMZU84R1dVazVob0kwZ1JydW1kWUFmSWpDYzR6U3hWVUw1b01Gc3lvRlFuZUJNblRmcUtpcGJkcXpiQVZyempMS2o5SFVuZWZwQy9yTTlRcHR5Y3hpWU85emxtNjVjNVZ5M01OQVAwd05NUXU4ZjNOSjlzNEZMVGdxSUFPYU9ISGg3Nm41Vk9YdUpseUFoRXpFa2dsZ0dqY09wdktndVcxT1VHUFNMb2ZJTGpYd3FyWlhKY3VQYURFTkdLSmxWRXFkSUpNNXR3NlpzTEZOZEZxNDBabnc5dG1qY0N4SklIalhFTG1PdXVMRmkzYVJpZzV4cm5PTGZRQzZtWFNWQlJwUmcwZGNkdFBkdTh0NzlxeUZzdmJ0RVcwdEVyTFhBQVNTeW4xVjZ0eHFRVzcwbVl0TFZ6RHRjWUtvVzZTVDJaTjNFOXdybG0zK1dYT0FwWlNGK3MyckdDQ0NBTkJxQnhOSWNYdGJubkRYcmx5NjI3TmNkbklrOE14TURzb20zaGNySzNOeUFRWU80anFxd0FOdE82VEpZK3dmbFdVOVRFMm8xdyt2OFA4QTYxbEJCZzlzdmV6VGJ0SUJIcUt3SkpuZVdZMXMxd3pRT3kwQ3FSSWtrdG9RZE5CR2g4NkpuV2dZNFpxOTJxL1JYdjhBaFZWMnRqN3FYWVZ5b2dRQnUzYW4yelhscmJWLy91ZTBLZmhRZFU5RDkzOU9JNjdGejNQYU5kVDVRa2MxcVFCSjNrRDZEZGRjWTlET1BlNXRNWjJKK1l1amNGRzlENm80NmI2dG5LajBWSmlMalhXeExkSzVjYnBXMWNqblhaOHVaajZvbUFLbTloanlieFZsTVFwTjIyT2d3UFRYdDdhczJJNVQ0Skp6WTNETDMzclE4MnJtR3ovUTloMmNLK0l1d1puS2xwVHBPNlZicXF3MmZRM2dWL3pjVWY0N1kvRGJGVGdXY2NxY0ZlVzZsckYySElSaWN0eFNJamZNd2ZDdVljb3NWWk44c3QyMDVVWWs5RjFZNnBBM0hyTlhpeDZOTm4yczdsSHV5cEFXNi9PSUNOY3dCK2wyMXp2bHR5WnNXR3ZPbHBWWExOdUpBVWwwQkE0Y2RPdzFjSFBMUUJXLzlZaEFCeE0zRlkrNWFiN0EyemVSN2EzSGJtVlBHREFBTWF4bWpzb1RaK0Z6WVRGWElsaGN3NnFRSkkxY3RIRVRJbWdzTTV0M0Zad3d5bVlpRHUwMFBoV2tkTDlHVzNzTmhjWGlybDI2eFc2QmxPUzQ1SkZ4aUFBcWtnQlNOOVhIbEJ5Mnd0d0RLdUpmVUhURDNSdUorc0JTYjBWRWY0amZLN253dHQrd2t1RkovcDk5ZEsyc05QQWVkWTN0VkgyTnkwUkxkdFZ3TzByaEJPcVlRbGRXSjlZc0J4cHZjNVkzV1ZndXl0b2JqNnlXazhkYmxOOEhkVlFvMTZKTzZPM3JQYlJGN2FJeWtRZFoza0RmUWNUNVFOaWIrT0REQTNRd1c2L05GMERFU296U05OR2RKRzh6NDBtMjd0cThWZTFjd3h0RmN3SnpoaURxcEJBQXErY29NUy95OE5aYUcrUzRtU09sRXZoNFB0QTlocXE4djdRRnByazlObUtudDFrazl1NnRCUHlJNVRZakIyM1d4elk1NTVZc3FPWVFCUU9sY1FMdmJlVFBVT08rekx0eTFqTTF0bVRFdGJJRTgzbFpHdGlRb0MzQVRrRStCcXQ0TEc4MHFuTU0wemxLaHhCNndmNzd0OU9OamJlRGJTd043S0VDUGg3YkVrS0NQMWJQMUlJYmRKaU45RVhma2g2V0xlR1c0bUw1eTZTd0tHMjJHYUFGZ2dtYmZVTklQSFhoVG5IZW1qQVhFWkJaeE1rTVAvamNWSS83L2JUcCtVV0ZFNW5zSHIrZHc3Nng5bHlhVTdTNVQ3UGpVNGJ4UzYzNGJCSHZyS3VlYkw1VDJiZDI2K1M2UTdsaEhOU0FUT3Z6bStrL0tESEcvY1lvR0NGODhOa21jb1hnVHdIWFVYSzAyVGZEV25SMFpwSlJDaXJMSG81VHZnUnJBMzBtUlZuVlJIZFcwRjM3TFFORHBRejN1SHhINTE0OXRRWWdiK29UQkEwbXZTQkc0VURiWTIyYnFPeHRXYythM2NSd291UEszSmxpRkc4QTkyZ3JUWSsxWHNDNlVnZ2xRUWVNNWpvZUI2STk5TkxXTXc5bnAycmpJM05sV0RnL3JUYmlWSUV4dkc0NmtIdHF0MnRjNEc3b24yU1BqUVA5djRyUFpSOTJheXA3dWpCSHVOQzROcnIyMVlzU1lneU0waFFGVW1RZHdVYTFvQm53eUtENm91SVQxRTNIY0QyTUtnMm5kSnQ0Y1pla3R1MnV2SHBQRUhxMGp3aW9xNTdTeGIyc0hoMUFQTzNiU0Zva2tBam9vc2trRFVtTzJrbGpaOTNtcjNPSkx1RnlhZ2tRU1RKNGNQWlZ4eFFVNHBnZDlxMmlyMmFRZkwzMHZ1M2VtdzBnR0k0eGxuTlBWT2xCV3RpM0xhZEIxVlgzRWxBVzlwL0ttdUZ4L1JnbE5OQk84eHA4UGZTZmxXQUdSbDBZeVBaQi9Pb2R1cjBNTTIvNXRaN2Q5QlpQbHEvcy9kK2RaVkp5ZGNUMkd2S29OUm9PaHBuaDdaTlY3bnRhc1d6Y1dNdEVTNHZBQzRoUTlXaDRnOERWV2ExbFRLZEdra2p0QnlnVC9ON2F1SUN2eEk4WXBOdFhZbkZLS3NIb1hiSnRPMldJRXBkRy9YMUMybzRlclgwQmpNVUN1Z0pnZzZDZDNkWHl6c25hbHpEc1d0c1ZaSktzck1wR1pZSWtRZVBuUmQvbGxqSDMzblBmY3V0NXZXZHdkLzhBbGJBL3FyNDdlYXVEMzVZckx1MlFQV2tmZXUyMC9HNHI1d3ZiWXZOcVdFOXdQNHBxUC9FcnYxejRCUjVDa0gwSmUyL2FQMDdQamZzdCtCbXFsOHY5b2g4SytWN1RETWdoR2Rvbk1kY3lLT0hBbXVXTmpycDMzSC9tYjg2WVc3NStSUEpKTFhnTlRQcVd3ZVAzNlFOK1NlSlczZ3Iwc3VjM3N3VXlKVkVVUk1SSjFwdGhjVGJ2S3dkY3ZSQUtzQkFJVEt3dHpPa2thZTg4T2ZiT0FMYXhFTnFlNDEwSEM5RENtOGRVdDJ5NlRxSkdvN3lMZ2dkaVJ1YldnTGtmeTBYQXNqaTJibnpUMm1CdUZTZzV5Vk9pR2RGSEFiNmY3UTlMb2NRTU92aTkwK1JTdVRacEpna2daUUpBRWRrRFRTVDU2VFdUU0k2QmM5Sjl6Nk5tMk8vblcvSGZJOTFBMy9TUGlUNnFXVjdyTmlmYTFzbjMxVEt3Q1RBQkpNQUFha2s3Z0J4TklMSy9Mdkdra2k1bExieW9WQ1kzVHpZV29OcTdYdlg4SUd2WEdjODh3QlptYlFJaCtrVHhKcURGN0t0MnJVdTd0ZGd1VVJSbFZBUXVabVAwY3h5NW8xUHFoaERtTGFHbUZzQ0NKNXhvSWc2c1FEM1FCUUNKWUtybnlwMFlKSmJWZzBBQUE5WGR4NDZWcGVZbkswRUxtRUhXUG9uUW44Nmt2M3dJNXRWNmhtQWU1UDNXMEhZUXZqVU4xTGpocmpGbXk1UVN4SmpNR0lYWDdwMDdLbzhlNHgzc1Qza21vaUsyWTFvYURhNGVoNC9sV3R0dDFiQkpWdXlEN0ptbzdXN3hvQ3IvQUszZ0szVFJXZUFjb0VBN2l6R0JQWHhNY2NzVnBmRXdSd0VIczE0OVZUT3NXQnBxOXcreTJvQTk5MXZaUUhjbk5tVzdsOUZ1a3RKRWlZSjZMR0NkL0FibzMxQmhjR0d4TDIxS29Qbk5UT1VCRFBrdmxSZUU1UUd5b0ZvU3dJSk1MR2FBTldJazl3cFpoTHg1OE13MU9lUnFvaGxhUjE4ZE8yS0NYQjU3YmtNT2l4eXQ5bGxJRXh2MExRZSttMnpTRGZ0MjJVSE9MZG5kTU1NU0xnWVF3alF3VHJ4ME0wTGlRSUlNbk9FNlhWb0NKN1RHdmQxekpISk8vbnhtRkJFa01DZEQvbDIyYWUvbzFBeDVUN1ZhM2pIZGVzZ2pnUk83M1VUWng5dTRBUmZ0S1NOVll2S25xYUVJOWswajJrNHVZcHlkUVMzdU5laFFOMjZpcGRwWVFzU1M5cCtySVhJQTR6bVVkbEwzdzl3d0d1U0FJQU02QVVjbkh1clVtaUFma1RmV0ZaUjAxNVFWclBSZHJFUlE0dHpSVm5BRTFRWmhjYVJ4cDNoY1VHRUdrZ3dCb214YksxQkp0VEJnS3hHK1BDTlorSHZxdmlya3E1MElQVWFxZUxzNUhJb3FLc0ZlVFdUUkhzMHl4V21EdGZhZTYzdkNmN0tXVFRIYXhpeGgxL1prL3dBN3UzKzRVQXV5eExxSXpTRHBKRTlFOFJWNXZLVHN1N3FWQ20yTWcxa0M3YVZpRHYwQ01JNHpOVUxBazV4bEVuV0FCSkpnNkFjYXV0dmFUaloxMVNqSXloTXpScFBPV3dvWWNEcjVmV29xblloQUYwVnhydllRUERTaFpwbGFTN2lHRnBkU1R4TUtJQkpKSjNBQ2FhM3NQaHNNaFVIbnJwRVo0Z0tUL3dCdGVIZlJGZDVoL3FOL0tmeW83WlYxc1BlVzZ3aGx6RlFTb1lFcVFHS0hwYVRPbzRDZ0xxYXpyVVVBRFFWUWZ0amJWeTlmdU1IS0srUlFvOVVMYlhLZ0EreU4zVVNTS041VzRvTzFzaFZWY2dLcXVpcXYwVkE2Z0FLUVc3Y21OY3hJalNRWlBFenA3NnRHSTJBMklqbXJpTTZxcW0xTVhBRlVhcURvL2daN0tDcW1TSjNkVURqVGJGc0JoYllBam5iclA0VzdhSUIvTTF5Z3IrQVpHQ3VDdXZySFJkRHJ3MFBZUlBaUkcySVUyN1kzVzdTRHhlYnAvd0JRZXlnQ05hbXNyeWdud24waDlrK1gvTmIzTU0yVllCK2NaZ3VtK05JSHNQdHJiQVhrVldtMldZa1EwdENnYWtaVjN6MWs2UnBXeVlxNU5zQWtpMW5aUndXWUxOUUFYb3pFRFFDUVBENDFNU2ViRWtrRGQzdHc5eG9mUERTWU9wUHRvekg0cG5WVk9VWkFxNkFEMVFScjFudE5CbUJ2b0grY01MRTVocVJ4alNpOXFPcHZRdWloUUJ3SjZPa3h1T29vSEFtV1VBZEtSSEdETzhqcXFYUG1lNGQ4azl1bWFSNUNnYllqR0Y3RnBRUG9rYnRjd015VDFFTVIvRHcxcHR5SndvbjVST3RzWDRHbkN5QUQxNzNJOERTbXdyTmh5MENFdVEybXVWOVluaHg3NWpxb3prZ0dOeTZmb2l5Mm5WTElmTlJVQUgrZWU0MFZRVnRwdm51YWpDYURkT1BkV2hyMUR2N3ExSm9OcXlzRlpRQWJQd0hFMDBXQlhpNkNLMVpxQ1hQWG9xRE5VcVVCR0h1d2FRYmJNdk5PVFFPT3dtZmN5OXVabFFEeGNpZkNhS1JUVDdBYk1YNUhkeEpDdXdZS3F0bXlxTlFYT1VpVE9nbVI0N2xkL0JoUWZuclRFZlJYbldKN201dkovVlR6RmJRWk5uSWpsYzl3cmtRQUFpeWl3cnZIRmpxT0ozbWlLMng0ajJkUnBodDFTT2JUNnRxMFBaYldhV1dydVhlQXc0Z3pCOFJxRDJpbTIwb2ZFTEpJVm1RU05TRk1EVHdxaGRZZ05xWUd1dlNId3EyYkpmQ3BoK1phNGx6TVZKUlh5am90blVPU1FTUVowSFdZTkxObzRmRGd4Ynp6OS9NQjNtTlQyQ2dEaFFlUHRBTkFadE1YUmNOeEZkVm5SUXJCQUlpQU54SHNwYllkaVNXR25FbWE4YkJpZEk3NGlPMG1kS2l0NFRNV2hnU29uY2RkUU5KNzZBaTdlUmp2Q2lOK3JUMndLSGhQcm53VWt4MXcwRDMwd3Q3SlZGRFgyWlo5VzJJNXh1OFIwUjMwRGVhMnBib0VRRzBtU0RCeTVpM2JFZ2NKM0dnOXQ0aEVJS2htTU1OU0YzcVJJVUJ0MHp2NFY3Y3hyRitjQXl0dkJFNmRSRW1yR2NHbHZEQzJxcTk1d2MyOGszQW5PdHUzSlpSbFhLdnIzRzFuS0FVRjhNVTZYcjIyWkc3Q0NmOEFrZUZCSmV4OS9GTWx1N2RlNW1aVkVtZDVDekFHK09PL1N0YjJIdVlpL2NOcEdlWGFJR2dFOUVUdUhSamZXMnhuaGkrZzV0SGJ4QzVWL3FZR2diYlFwRTZIZU5QN05CWnNENk85b1hCbUZwRUhXMTIzL3NMSDIxSHRIa0ZqYklseFpqOS9iWDMzQ29wSloyamNRRVczWkorcXhYeXFUWnUyNzluT2JkeGxaNHpQUFRNYnVrZGZmVTVFdUgyVmpGSkZ0THdrYW0wV1pXQUIwTDJTVlBIU2VQYlVOelpsem5DQ2pXNFVtU3JMRUF6RTc5TklwNWhlVldOQ0hOZnpMcExzVXVzQ1pnUVphVDFidEtTYlUyamNZOUs4enNmV0dVSkhVRGxnVDFnU0IxMVFKZzhNV3VLckNKTW1SSFJVRm05d05SdkJKSmtTVHJ2SDk3Nk4yY2RMcm5YTGFZZU54bFR5WnFEc29KblBsUGo1MEJXelZDdG0zd0dhZnVxU1BlQlVXRkpBSkcrUnUwTzdUWDIxTmg3WUF1c0d6ZENOMGFzeWo4NmdjRUlzRGZQaWQva3dvSEd6WFpyVjFSdUpUTkpKRUZicXlmRXI0Z1U2NUhpTE9MWS9VdER3SmJUK21xenN2VU9yRWlVSkVINmFubzkyOXRlMnJMc0Ivd0JEeExkYm92ZkNrK2JWQlg4TWZuajNOUnhOTDhIK3NQY2FQb05sTy91clFtdGw0OTFhR2drQnJLanJLQ2ZQVUR2WGhhb2Job0lteEJKMG96QjNUUysxYk0wMnMyZ0JWRXpOUWVOT2xUTTlCNHg5S2dVUHhvM2FXSzU5a081c2x0STNBbEZDQ08rQlFlUW5nYWx3MWc1MTFBNlM4WjRqcXFpZkJZZGJkMWVlQWlDWU9vTytKamVKRzdqUkcybURnWEYzSHUwZzlsTWNUeWR2WGJpc3dOdTJVREJtSENUdUJJUGJPN2RKRWlvTVpoTFMyMnQyM0w1VEpiZU5RTkFZN1BmUUNxd3lodXNUV2pzZW85d0VzZnlIYWFFdFlrS0lNeU54aVk3aFVUNGduZko3eVRRVDMyWWpMQVViNGtlL1dUVzJ5MnlYVllOR3NhVHgwblhxTUh3b05yaDd1NnZEbVBXYUF5OWRZTXhZa3RPcEoxUHQxOWxMdzJ1dTRrRTlzSGpUREhKbVlINndCOFNOUjdacUY4QzRVOUNRWU9iaXNUT25iUHVvQzdlMXphY1hFVU13VjhoWWs4Mjd2bUYxUUNBV1hlczZBd1lNQ2hObXRPWlQ5SVQ0aWh5bW9MU0ZtTTBhZHNHdHNFckc2QmJCWXpvQU5ZbUpQVlFFb2N0cTcxc1VYd0VzZkphMFRCc2VGVDJTeTNobEtxU1lsMVIxRThTcmdyVm90WE1WR2d3VjM3MWhGOTl1S0NzMnRsTWQ4MTVzdkJaM2RUOUdQaVBoVnMrVTRqamdjTy83dTQ2ZTR1QlNqWjl1NVl1M2JqNGE4UTVKeXFKeWpNU09rQTB4TWJxaXBNUnNZMjFsVkFWTGIzU1FlTUxCSTdGWSsrcWc1Tzg4ZGZiVFRhV1BjdGNIU1VFTU1wbVlMRWdHUU9EZFFwWGNhWTdnUFpwVlFYY3NNcW9zRWM0UXdrUks3bDc5OCtOUTRqZVFOd3BoZDJpV3ZXV01FVzFVS09BeUtBb2orRmZaU283NVBFbWdrendJVW5wQVNQdEFrQWVSOGFkc3lDNlFVT1JUbGdha0JkQkdtK2xHemttOWJBK3V2c0RBbjNBMWRNVGdyVDZzZ0o2L2pRZS9JN1BORjFNQW8ydTRpUWVGUTdLZi9wOXcvV3ZON2tTb3lndGpLa1paOVU3dXZXcCtiQ1lBQWNiam55RlJWZHdSK2NQY2FZVUJnQU14NjQwK05IVVI2cDhxMXIwZkN0YUJ0Z3NOaHlnTHVRMnNqTW80bU5EcnVyS2syZGpjTXR0UmN0Wm1FeWNvTTZualBWV1VDRE5VVE5VYTNLMVpxb25TNVVweFZBNTYxTDBCcHYxNlJJb0ZXcHZzNWtCQnVUbEcrQUQ3anZvRldVVHVudjhBK0tzT3k4TW1HeTRpOFZERHBKYmhTZFJvV0REZnJQWVlPc1JYdC9FV1E1K1MyV1p6dUpVNVUrNkdKanZKcWZCYk92QWwzU3pkWTcrZFRuQjRTZFBDb3BmdFhsQTE4a3NXZ21jb0psdTEyM24rNGlsMkV1WEM0a1FwQkVEY0ozZStLdkdIUXFJT0F3N0RxVStTM1FRUENpQmR3djhBbTdPdlcrMjNtYjhMRlIvTFFjeStUbG55amZyRUNkM2RSUTJhUnYwNzlQT3BjVXd0WWxYRTVWdUE2anBaTTJzZ3hybDRhVjFEQlc4TTNxMzBQZngvbHpDcU9aMnRsSHFvdTFzcXVtcnNyREU2OHpQWDBWUHQwTkVyeVN3NzZqTU8xYmhiM05JcVVjZzIxaHpieU1PSHdNMGZpVWRsNkloR0FNZ0FtRHJ2TlhUbDd5U0Z2QnRjUmkzTmxUQlVUREVLZFZnYVNEdTRVdDVDYk5mRTRRTXVRbTJ6VzJCWWh0SVpkTXNlcXk4ZUZLS1ltejdxaUZkZ05kTlFOZXdWdGFPSnQrcVY4Tkt2MlAyV3lIVllQM2s4ZzArNmxlSXc0QTFnbnExMThhQ2tZaTR5WEZ1RVF3T1lqaHYxSGNkYXMrRXhOdTROYlFCN0RGSk5zMmIxdzZXbEVkVDVqSGVZOHFLMmFYRnRRUVFScEhkdVBzaXFoNmxnZlJaMTk5UnZmdUF4bkI3Nld2aWoxbWhIdW1kOVJXdktIWmx5NDNPREtUQUJBTVpnTngxNC9rS3IxN0NYRjNvUi9mWFZpYkV0MTBMZHZNU0NlQkJqU0QyR3FoWGlyWVM0eTY5SG96MU1JOHlDUEdoMWJnZDJ2aFBHamJ0c2tzU1p6RWt6MW1vellGQnZzeThGdWgrQUJpZTdLTjNHS2N0dEtlTkpJTmVDYUJ6alFjcXNTZFJKSDNpY2c5aWx2RVVUWnZFNE9Ed2Q0OGRhVVBlektKTzREVHVWVi8yKytuRndINUlqSDZSWStBTUR5cUJWZ0QwajF4UjFBWVAxdkEwZFFlaXRDYTltdENhQi9zeTVmRnBjbGtNdXNFa0Nla1o0OWRaVU9BNTdtMXkzUXE4QmxtSko0eFh0QjFMYTNJUFpxUktLcFBVVzhnZmhWTzVZOGtzTGJ0bHJDUFBBN2w5K3Z1cm9YS0NKWFhqU3piMXJOWmJqcDhLaXVBc2ExbXA4VWtPdzZpZk9vYXFKTEkxcHRoTFlZaFR1Tks3TyttK0I5ZE84ZWRCZHNOc2U2cUFxRmNSdU1nK2RHWWE1Ykg2eFd0bnV6RDJpcmpzREJMelM4ZEJSdUoyYmJJOVVWS3F1WU8zWmYxYml0NGlqeHMwZG5oU2phT3lMV1k5QVQxN3ZLZ01pb1ltNG5jN1JRVkQwcTdNNXZFSzRHbHhBZjRsNko5MlgyMVpPUit5TUhpOEZadVBoN1pmTGtkZ01qRnJaeWtrcEJrd0Q0MHU1ZDJPY3c0Zm5DL050eDNnUDBUcjM1YXBtdzlzNDYycllmQ013RE1YSVZRV0JnS1RtSTZJMEZVZFR4UEl2Q3FzcmZ2NGNEaUwzUjhlZEI4NnFXMWNWWnNINXJhZ3VuNnZNYzRmRzRqQUNsK0g1SDR6RkhOaWNRRm42N204dy9obkw3NnR1eXZSdmdVMXVHNWVQMm15ci9La0gyazBGZXhYS05tc3RiRjh1WEJWZ2N5Q0RvUmxaajUwWHNISmFzbEV1WmM1bHdyNVpPN1dETlhXOXlVd0RMSHlXeU5JbFZ5SCtaWVB2cE5qUFIzaEQ2aHZXL3UzQXcvckJQdm9FZDVvQnl1NC9qWWorb2tWWDhSdDBham5aNzBuM2lLaTJuc0xtc2F1RnYzU3Rza1pibW5xdE9Ra0V3TlJsUGFEVHpHZjRaWkFWTEszR0habW52TGIvQUgwRlpYYTkxemx0b0dhQ1lnekFFekU5V3RhYkl3ajRpNmJiM210NkZ0UVNEQkVnQ1FCdnFiYnVNWnJ5WWhVNWtnQUNTQk9YU1lQWVkzYm9wM3M2eGtnczJaanFTUEx1cWhnZVR0cUZDM0xnZ0FiMU80UnJwVUY3azBRT2pkSGNVajNnL0NtbG1LekVYaUJVRlZ4bXpiaWZWYnVKK0lGSzdoWWIxUG41Vlk4Wmk2VFg3MDhLSVdQYzdLakxVWTdHdHNOaDFZNjFRQm1yeWo4UmhFRFFLMCtTRGdhZ0NxMWJTMHdlR0g3T2ZhU2FRSEJIaEZXRGJDWmNMaGdkNHRMUVYvQ2V2NEdqU2FEd3FuTlBDRFJab01CcldhOUZhVUIyR1MzbEdaaURySURSeDZvcktqc01tVVNoSjExanRyS0J0dEhsZmlyaG5vaUQyMU92TGU2VUt1dkRlRE5aV1ZZS2ZpMnpNemRabWhTYXlzb0pzUHZwdlpFRUh0RlpXVkIzWGt6Y215dmNLT3hXSmdWbFpXVlZuSFhDV29ERTI4MitzcktvQXgrQ0QyM3QvV1VqeGpRKzJ1ZGNtTVJ6V010OVRrMjI3bjBIOVdYMlZsWlZIVWZrUVBEM3hXTmhHVUVpNFFCNDFsWlVDTEY4c2x0TmxERjQrekE5K3RRdnl2dlh1amFoT3M5WG43aFdWbFVWYmxNcnN3THViajdwM1J1SUFuWGllcWdmbFRnZEdGN1FBRDdkOVpXVlVhQXRjSURtUk0wOXN2dXJLeWdkWUZwRkVYckpJcnlzcUtVNHJDVUJkdzlaV1VBajI2aXlWbFpSR1phM3lWbFpRYktLYjhvdjFGajkwdmxXVmxBbXdoK2JQZjhBbFhockt5ZzhGYTFsWlFISmZhQjBUdUc1eW9nRFRRR3NyS3lnLzlrPVwiLFxyXG4gICAgICAgICAgICB9LHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkJlbGFxdmFcIixcclxuICAgICAgICAgICAgICAgIHN1YnRpdGxlOiBcIkdlbnRsZW1lbiBmaXRuZXNzXCIsXHJcbiAgICAgICAgICAgICAgICBsaW5rOiBcIi9cIixcclxuICAgICAgICAgICAgICAgIGltYWdlOiBcImh0dHBzOi8vd3d3LmJlbGFxdmEuY29tL2RhdGFfZmlsZXMvZ2FsbGVyeS9ncm91cC1maXRuZXNzLzkvZ3JvdXAtZml0bmVzcy1pbWFnZS1jbGFzZS1yZWFscnlkZXItYmVsYXF2YS5qcGc/Y2FjaGU9MTU2NDY0ODI5MFwiLFxyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsOiBcImh0dHBzOi8vd3d3LmJlbGFxdmEuY29tL2RhdGFfZmlsZXMvZ2FsbGVyeS9ncm91cC1maXRuZXNzLzkvZ3JvdXAtZml0bmVzcy1pbWFnZS1jbGFzZS1yZWFscnlkZXItYmVsYXF2YS5qcGc/Y2FjaGU9MTU2NDY0ODI5MFwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICB9LCxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiBcIkNpcmN1aXRlIHR1cmlzdGljZVwiLFxyXG4gICAgICAgIGNsYXNzOiBcImNpcmN1aXRlXCIsXHJcbiAgICAgICAgaXRlbXM6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiVHVyIFByaXZhdCBCcmHImW92XCIsXHJcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZTogXCJUcmFuc2ZlciBCdWN1cmXImXRpIEJyYciZb3ZcIixcclxuICAgICAgICAgICAgICAgIGxpbms6IFwiL1wiLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IFwiaHR0cHM6Ly93d3cucmVudGNhcndpdGhkcml2ZXIucm8vd3AtY29udGVudC9nYWxsZXJ5L2JyYXNvdnZ2di9DaXJjdWl0LVR1cmlzdGljLUJyYXNvdi5qcGdcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCJodHRwczovL3d3dy5yZW50Y2Fyd2l0aGRyaXZlci5yby93cC1jb250ZW50L2dhbGxlcnkvYnJhc292dnZ2L0NpcmN1aXQtVHVyaXN0aWMtQnJhc292LmpwZ1wiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICBcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6IFwiQmVuemluYXJpXCIsXHJcbiAgICAgICAgY2xhc3M6IFwiYmVuemluYXJpXCIsXHJcbiAgICAgICAgaXRlbXM6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiU29jYXIgQnJhyJlvdlwiLFxyXG4gICAgICAgICAgICAgICAgc3VidGl0bGU6IFwiQmVuemluYXJpZVwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCJodHRwczovL3N0b3JhZ2UwLmRtcy5tcGludGVyYWN0aXYucm8vbWVkaWEvMS8xNDgxLzIxMzMwLzE2OTQ1ODM5LzEvcG96YS0yLmpwZ1wiLFxyXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsOiBcImh0dHBzOi8vc3RvcmFnZTAuZG1zLm1waW50ZXJhY3Rpdi5yby9tZWRpYS8xLzE0ODEvMjEzMzAvMTY5NDU4MzkvMS9wb3phLTIuanBnXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgIFxyXG4gICAgICAgIF0sXHJcbiAgICB9LFxyXG5cclxuXHJcblxyXG4gICAgXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogXCJDdWx0dXLEgyDImWkgZGl2ZXJ0aXNtZW50XCIsXHJcbiAgICAgICAgY2xhc3M6IFwiY3VsdHVyYVwiLFxyXG4gICAgICAgIGl0ZW1zOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIk11emV1bCBDaXZpbGl6YXRpZWkgVXJiYW5lXCIsXHJcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZTogXCJNdXpldVwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8yd0NFQUFrR0J4TVNFaFVTRXhNV0ZoVVdGeG9ZR0JjVkZ4Y2JHeGdZR0JvWUdCa2RGeGdZSFNnZ0dCb2xHeDBYSWpFaEpTa3RMaTR1R0I4ek9ETXROeWd0TGlzQkNnb0tEZzBPR2hBUUdpMGxJQ1V0TFMwdExTOHRMUzB0TFMwdExTMHRMUzByS3kwdExTMHRMUzB0TFMwdExTMHJMUzB0TFMwdExTMHRMUzB0TFMwdExmL0FBQkVJQUtJQk9BTUJJZ0FDRVFFREVRSC94QUFjQUFBQkJRRUJBUUFBQUFBQUFBQUFBQUFBQVFJREJBVUdCd2oveEFCRkVBQUJBZ01GQlFVR0F3WUVCUVVBQUFBQkFoRUFBeUVFQlJJeFFTSlJZWEdCQmhPUm9jRXlRckhSNGZBalVuSUhGR0tDb3ZFemtyTENGUlpUMHVJa05FTkVrLy9FQUJrQkFRRUJBUUVCQUFBQUFBQUFBQUFBQUFBQkFnTUVCZi9FQUNZUkFRRUFBZ0lDQWdJQ0FnTUFBQUFBQUFBQkFoRVNJUU14UVZFVFlTTEJjWUVFRkRMLzJnQU1Bd0VBQWhFREVRQS9BTytRbUprcGhFSmlkQ1k5RGtSS1lsU21GU21KRXBpQkFtSEJNUENZY0V4QTBDSGdRb0VPQWdFQWg0RUtCRGdJaWtBaHdFS0JDdEFJMExDd1JGRUxCQ3hBa0xCQkFFRUVFUlJCQkJBRUVFRUFRUVFRQkJCQkFFRUVFQVFRUVFCQkJCQUVFRUVBUVFRUUJCQkJBY1hZZTBGbm1lek1IVUdOZVROU29PRkFqZ1JIZ0taNmtsd3BRTzk5emZTTFVtOHB3eVdvQm16NE5EOHNhL0c5N1FRN09IaVZLWThXdXEvMUpVTzhHSk5YWWw2NnUrYnQ0UjBVcnROTFUzNHMxSDZpU0JVTTJGNmUxNVJlY1RoWHBZRUtCSG1zL3RaTkRwbHJDNkJsRXFCcUFUcXhZMHEwZEhkWGFGYVVBenNKRE80elpuVWRjVE8zR0pmTGpQYXp4WlYxSUVQQWlLeDJsRTFJV2hUcFAzVWFHTEFFYmM5RUFod0VLQkN4QWtMQkJCUkJDd1JBUVFRUkZFRUVFQVFRUVFCQkJCQUVFRUVBUVFRUUJCQkJBRUVFRUFRUVFRQkJESmEzS3NxRnFhVUJyeHJENEFnZ2dnQ0NDQ0FJSVpObkpRSFVvSkRnT29nQnlXQXJxVFNFZ1BtUXUybTk0SlFpS3prb2VXb1ZRY1BGc3dmRDRSYlVvYU5YS2tjUFQwZTBzcEQxaTNMbGVQM3FJcjJiblhQcEZwQ3NLc3VPcEhRYjR6YldwRnVWS0xmZE5Pa2FkaVZRQTZVKy9HTTVFeXRDR2ZOL3VzYWRtV3pPUHJITEt1dU1idHpYMnFRNENYcTU2dHV6b0I0eDNWMDNyTG5wQlNhNmcvZFk4dlFOQnhlSjdCYkZJSXdraFFOSTM0L0pjV1BKNDVrOVpnam03cTdTWXRtWi9tSHFJNktYTUNnNlNDT0VlbkhPWmVubHl3dVBzNkNDQ05NQ0NDQXdVaVZQbDl0Q3hqV0h0RlpGTFdoTnFRcFdNMFVwSUdRb2cwQ2s4YXhzSklJY1ZHOFFMTFBaWUlJalRPQldwRlhTRWswTE1yRXpISSt5Y3NxYjRDU0NDQ0FJSUlJQWdnZ2dDR3l5NGZpZklrUlV2cThVMmFSTW5xeVFrbHQ1eVNPcFlkWThLc2w4V2lXdFV4RSthaFpVVkt3cW9TcXBkSjJUVW5NUkxkTlk0N2ZRVUVlUldEOXBWc2xVblM1YzlPOGZocThRNlQvbEVkVGRuN1RMRk1ZVEN1UW8vd0RVUzZmODZYQTZ0Q1dKY2JIWXpWczFIY2dlTVBqamUydmFRQ1JMRmxuSktwaW5DNWFrcXdwUXhmVVo0UXg0eHk5Zy9haGFKS3NGcWtwbWdlL0wyRk52WTdLdWpRNVRlbDRYVzNyVUVjNWNuYmV4V2xnbWIzYXo3azdZUElFN0o2RXhzWHRlS0xQSlhQbUZrSVNWYzl3SE1zT3NWblRtdXhkODk5YXJ3bDFwUHhwZmN3a2x1WGRwL3dBMGRoSGhQWlh0WWl5V29UbGwwTEJUTlp5UWxaeEZRQXpZaCtoRWU1eVpvV2xLMGwwcUFVRHZCRGcrRVNYYldja3ZSOEVFRVZrUVFSVnZXM0NSSm1UbEFrUzBsUkFaeUJVczlJRGkvd0JxbHVDckNoRGY0MHpMK0ZPSS93RGI0d1J3dmJidFpMbnk3RUFSc1NXVWtLQ21WaXdLY2pnaCtzRWNzdTY3WTYwNWVkTUxvbk5teUNScitVbmNkRHppZGFodTg4dmxHMWJMc1N1VTRBR05JU1NNc1FabEFhRUZod2NSaVdNbFEyc3hza0YyeENtbmp5am51V2Jia3M2UFFxdTZMc2kwQUZqbHZpRk5seEJ3ZW1ZK2NUZDB6T0hvRFRQY2FjOThTMlZ1U3JzbVluTUZzOHN6emk5S0RhdU14dURSbEJXMENjc21JWXhwMlJRYlpMR3VldStPZVVieFdCTTQ5V29ZRlRkN2ZmR0ZNMEdoVHhmVGRUaEUwbENNelN1dFJremNuZU15Nld5MU5acldRWTE3SGVxMEYwcUlCcVFEbDBqQW5USzRnek13YktvZkxtNWl4WjdRQ3o2Q2plc2IvY1ovVmRwSTdVbjNrUHlwSFFXQzJKbW94cDVOdU1lYkttNnU5UHJETFoydW1XUjB5MC9pS0FJRXoyQ0RrdWhyNVZlT21IbHkzMjVaZUtYMDlCdjYvcEZqbDk1UFhoSHVwRlZMTzVDY3lmSWF0SGtQYUx0bmFMd1YzWUJsV2M1eWtuYVVOODFROXAveURaclhGUXhoV3VmTXRFM3ZaOHd6SnF5d2ZnOUVwRkFrVm9LZkdKTUdHbWU4eHZQUDZhOFhpazdxNUxrZ2tEQzVKQUFBcTVvQUFBL0lScWhOb3NpOEtWekpTbUJZS0l6RktaSDZHTkQ5bUpsZDVNQ2grT0Vrb1VTVHNhaElQc2tVUEVIaEd2Mm9rLzhBcFZxbUh2RkltZ1MxbHNRU3NKVVFTR2Naam9EbUk1Y0xyZTNYODA1OGRLbGc3YldwREJlQ2FQNGd5dkZMZkF4V3ZLL3BreFJteUpreXpUODNTUXVXc2FDYWhRWWpRRmlScHVqQjc0QWZaK3NkRGNsd0ttSU0yZWU0UVRoUUZqYktqUkpVTWtKSkl6cVhha01jOC9oZko0L0ZPNzBiZC83VXA4a2hGdHN3VlIrOGtLQWNjRUtKQlA4QU1PVWRuYy9iZXcybGdpZWxDajdrMzhOVDd0cWl1aE1lWTM3ZCtGZmRUeGhZc1NOSHlVTjR5UEVjY3NDOWJ0VlpsaVhPQXFIU1FYQ2s1T0k2NCtTNmViUHhTWHA5SGpmQkhodlpKYzhLQWxXaGNrVklEcXdMWU93Qk9CU2l4cG5uSFlYRDJ0bnlwMHlSYVVHYnRrS1hLU01RVU5rdUVnQllaUE9tdVVkSm01Zmp2dzlDaHExaElKSllBT1NjZ0JtVEVRdGFWU3pOUW9LVGhKQkJwUjZIZFdoM1JoM3BmOHFYSW5LVXRpc2hNcEpMbFNwa3FXVTRVNXM2cTdxbU5NU09UL2FyZm1LWW14cFV5VU11WXh6VVh3cDZDdlVibzg3blRTQ2VCOWErVG53aGJiYTVpNWt4YXFyVXBSV1N6bFQxb0JsU0dYb2hRbkxHajduelRYWGMvZ1l4ZTY3VHFhWFZDaEJ6RytLVXlTTng5ZkF3NjhKeTVjMWFVdG0rdW9IcVltblRHbXFTUlVTOFZOUmdDdWxJeWJaYzFMVlRSUXFHNGNvMDVheFBRQ2ZhRVZpcENrbFEwSUhpN1JDRjkwcEtoa29lcEhwQ3haVnBJRE1vVjQrOE12RVJLdWF0VXZ1RkxVWlRoUVFWRXBCRGdNSHBRbktHV2c1RU1GRFI5M0RVUTJVc0hKaHZENVFobzZ6MkpBVW1udkQ0L1U1eDdMMkR0UTdpY3FaT0tzRXphVk1tRldGQVFobktqc2lpdkE2dkhqcTdVbEcwb3N4Nm5rTll5N3d2WmMwcXFVcFVBQ2tFc1FEaUdQOEFOV3NXWHRuS1I2bGYzN1hrUzVoUlpwSW1wRk84V29wQlA4S1FIS2VOSGpuTFgrMTYzSzloRWhIOHFsSCtwVWVmS01SS1ZHdHM2anFiYiswVzhwbWRxVW45Q1VwOHdIam03ZGUwK2NYbXpwa3o5YTFIeUppcW94RXFBam1LaFlZcUNBOWJsS0JsbVVrZzRLSElBcUtNUXFLSkJ4TSs4UHBITkt4SW5Cd3htZTF1S21EVTRoekRiRGFKcHh5a3JUaTF3cEtndEtVWVNTUTI5TldiYWVoRVRYdlpMUXRJWGpscllobUdGbVlpb0JHZnJIbHdtcHExNmNydTdrV1o2aTUyV2IxMUVXQXNNUzV4YjNaaG44STUzdjV5azRqaEpPNHMzQTVWZjczV0xET211QmdPUk9JS1RScVpPNXI4SXQ4ZlN6eWR0YVNuYXdqYWNPN2tVcm5FNWtrQVVhbXZoRlZTVWxRVWxSU2FCUUlhdXVYckdwM2lRa09BV2F1NGNOMFl5cmNoQk1ETVhGT0ZQdWtYTytZNWExUHpHUkVVWkU3RmlvNDNCUHU4eEYyeVdSYzBFU2s0aVNDR1lOWFU1RFhXSngyY3RST1VnMEFGYVBUVFJ2Q3VjUVRXbGtWREg0eFp3SmxGTXZ2Uk1tcVdFMEFVZ0tvR1VWSk9Obkd5R2pNdGxyUmhuSXRVckN2RWdvUWhReFkyVzdtckpBSXozak9rZEpoWXhjNVdxdXhxbVNsakVFREJMbVM1dFFHSVVWQlp5TkFBMzhUNlJVdDk3ZDVKbFdhVWhNeVozYUF0ZUVIQ3lVZ2hBSXB6bzJsY3FLVXpweUVTNXE4RWxLVWdJMVZoeWNNNUwxNmpjOGRGZHQzRktXUW5BbmZtcy9JK1lqZHN4Yys2ejdvN09oR0x2cGhCbUFCUVNYZXV5OUM3RjJvMVRHb3ZzaktOVVRHL1ZwNWlOaXcyUkthdFhlUzU2bU5vb0I0Tm00K2NjK1Z0WHVlcTRiL2xTY2c0NVV4bERKU1N4SElnRDR3MjhKVjRLbG1WTktsb0pCcUFTNHlPSUFuemp1RTJVR29BNS9WTU9NZ2pVOVNENUdOYkpsWGt0b3NhL1pVazViblBsSFlYQjJoUis3R3pXbFlDaHNwVVFxcVcyY1RCM0ZLdHUxZU9vWElKRzBBZjFKK1ZJcFRybmxMb1pRL2xMZVZJUzY5R1dmTHF4eFBhNmVtWmFwcWtxeEpWaHdrT3pZRWluVjR3cjd0cFZKbGhaSlNnaVZNQURreWlka2did01TY3Z5NzQ5QnRIWmFTY3NTZVljZjB4a1cvc2xza1lnUTFRNHkvU1crTVdlMnNzNVpKOUMrYnVreXJFdVdrQlNFTW9MQzl2RUZJVHRIQ1FDeDQwRE1OS04xWFozZG5uTHhsTTBCUVF2RGlRVWdFcVRNSXhCUVVsd1F6TU1qRlc3dXprMllCWjBURXB3cFhobUZKQ3NLRm9TRXFLRGtYMExFQTBvWTNKUFptM29rcWxkOUtXRGljT29CV0lNQVhRNldjalpVS05IWGpmcHczUFcxRHMvYkxhMW9uSVZSU1ZyV2tnRkUwcnJzQUViWkRrTUFjZ2MyaXZkZG5Gc1ZMbXFLU3VVaElKVnNnQkJZRXBTSGZDTTNENFRReHNXS1RiNUVrUzFXWUtDVGhHRmJuRGhxUW9LVVZhakNValNzWjF5V3Y5MWs0WnlGb0NpeWhNbHFBVXlBQmpEbFNLZ1ZOTm8xT2tzcSsweUxtbEJpVnBkVHNBRVZaeFFyQkttR28zNlBFZHBzc3NvbWxDbHFTeFk0aW5KTzVKQXplQ2VudkNKNkVneTlrQlNXS1VuRUtDcnB6R1lFWDcxbkpVSnBTWDJEb2Z5QWF4eXUxak5YSWxtWTJJMXlCVXpzQTRDVHBybENUcm1RcGFzQ2dmd3k3cGFtQWc4Y216Nk5ETDlVRjJ4Q2hvSmZrRHZyNHhzV3lkS1ZNRGpZd012RU5tZ0J5cUd5cDExZU5JNHFkMmRVSlUwSUJiWlU0WXMyTFFzM0xoR1hlZDB6RXk1WWFvQ25lbWFuSExYd2pycm9SaXM4eDFFbEpWaHJuN1ZLbXRQSVJMZUtqM1VxWW9zamFjRUFOaUwxNE42NXZHNWFqaDdkS1VKeW1CTEdoRmZYUGw1UTFWcENVN1FPTTZEVDlRYWo3aDVSSmUxNW9XY010SVllK1JVNSt5RFVDTWxJZjcrM2loMHlZcFoxSkRaRGZ5aGt4S2txd3FCQloySVkxZlNIUzV6SW1JQVA0bUVFZ3NRRUhFR05jNGt0Q2xUQ0ZGSm9sS0tBbHdrTUhPcGdkYVZIZ3M4bkhqZFdFSVRpSklKWUNob000dFM3dW5LeWxxUFNKcGR6V2taSVVsNk9TQlRqRFpHZGFKUUNaYTBxeEpYaVlzUjdKQUxnOFlyTFJYZEczTXVLMEtiRVUwL05NZG9lT3pTdmVtSVQwSjlJY3A5cnh0OVJ6eFMwRWRJT3p5Um5OUDhvK2NFT2NYaGw5T2l1eXpJUk8yVkpvVXlpQVV1VllIWVZhcEFjYWtBVmFObTBweElKN3BLbHUyMHp2UTRUczBVQVFHQjMwam5iMDdKbElLNVNpVXUrQTBJRkRSVDFJSXpaMkcrSFdYdE9VQnBvWGlEcVRNRFBrelRFcVlLSkttZk9zY2NkV2JsYXozTDNHNVlMdWxNRE1reTBrNXVIemMxQUZTejYxK09UMmp0WVRNRXFXRWp1d3A4SXcrM2hJRFVJTER3VUlqdDNhY3BTKzBGNTRsNEhDc0tVN0NBNlFSU3VvQkRSa3JtTG1KN3d5eWtCdG91Vk9ha2s2ZzV1WFBMS09rbjJ4djZOVGVCRGc1Y1FEeGkwaTFPMlRjUGxwR1l1bkVHTDloc0NwcWtJbEpLMW5SR2JhdVNHRGI4b3ZDRXlycWtyRXVRbGFUdEsyeVZVU21XRUZSSjJxNkVrNlJVVjJtbXpwQ1VwSWx5Ni80YU83eERLb3F3UHJXTDEvS0V1VUpjd3BTbzA3dHdTN1Y0TW1nQjRCdU5PdzNTWmdjbDBpbkNsSE84K0FHZ2lTU0x1NWUwMDIxZ0ZjdXlld1ptUHZsZ01sVlA4SU53RmN5d2lTN0xtQ1RpQUpWbVZycXB6bXdPUkoxVldzYU5rc3lVcEJ6T0Vud2JMZG5wU0xLeVhXTk1NejRKYW11c1p2YlJMUFlrQlkxVUNISnFXSVZyOG8xTEJNZE9RREVoaHdNWnRtTzEvTEwrQ292WGNncFN4RGJSK01acy9vMm11UlpNc09TVGlWbVhQdEdOKzBqOE5mNkZmNlRHSGRzZ29RRWt1WEoxMVBHTjZZeEJTU0E0SXFScUdpWC93Qkh3d2JuUTAxR3l4T0xwN1FiSWZaaTlmVTVhVkl3S1VtbFd5T2J1R05XaVd4M2NsQ2txU1RzdlNsWGZkemlhMzJNcklJTE1HcjErY2RiWnljOVhpSkZwVis3aVk3cXc1a05xUlVCb1pkTnRNMXdvSm9BZGtuWG1TMFN5N09vU1JMeklHbVh0RS9DR1hYWmxJS3NRQWRLUlRoMWpQV3F2ZTRtdDg5TXRJVW9FdVdvSGFoTDVpbEl5cjlTSmxtV3BMK3lUV2gyUzUrRWFOOVNzU0VoaWRzR2o1TXJkRktja2l5cUdnUXR3b0VuVTV2R2RUanRkL3kwdyt5WlQzNUNWRnNDaGhMYjBrRklUUmlOSGlLK3UwY3p2eWlXY0tVWWc0STJtS2EvR0dkazVpamFaYnFkT0dhekhLc3VoREJ2bmloTERjWW5XY0t3cEV4YXl2RWFIRGpBTEhVRkRsc25ibkhxeHY4QUZ6MTIyckIybFFjV09qQndkL0E3bGVVYUYxM21tZUtVTE9VOEQ2UnoweTdVcG5TeElUaHdZZ3B5YTdMZ2t0VlZUNDhvcHlremJQYWtsVHNUVTV1S3ZscHo1eGRyd2RmYUxwa0xCU3FVaGptd3d2VUdwU3h6QVBRUlFuZG5KUkJDVkxEZ2pQRm8zdlZQakc0VERDcUZ4bDlzYnNjSmYxd0tsa1QrOFNRa3BCQkdFMTJRd0JJekkxME1RMnVhQjNlOEtMdTJSd2gyYktuSEtOWHQzYW1sQklQdko4bGZVUnk5NVRHd3JBeU83TmxBNStrY2M4WkwwM0t0WFNBVnpRYWdUcHJNeEI5cG1jY21pRzhiRWljcVNGakdKcVVwU2tLVWdPRXJXNXlCR2JPYVA0UldYQTB5V2tncFZNd0Ewb0Noem1Hby9ES3NZMXpwbnpMV2lhcXN1VzRHMEdZU3lnRUIyclEwM21JMVBicDA5ajVZT0g5M1ErYktXQ1czdGlpWlBaaEtDRWlWSlFWWkJzMjVDT2x0U2diU01pOHMvRlVSWGlmeDVQNmxmN2ZuSFBYWHQzNjNKcWVtTEt1TGFVZ0dVQ2xnUUVtajFIdWg0anRWM0NXV1ZOSWNPeVVraHFqVlEzR04yeS8rNG5EaWovVEdYZjhBVmFjTmRqTVY5NVc2SEdhMnVOM254K05FbWRuMGdPWmlqbmtBTWcrc1VMSFlKTXhSVCtKUVBWU2Q0RzdqSFRXbWNBQUtuRTRvQ1dwcnVFWU56eTFKV1NVcUF3SE1IZW1MY1l6aGxsY2NyVU42WGJLbEpjSXhWQXFUcUNkT1VNdmV5eTVPSERMVFVsOFRuSnVNWHI4U1Z5MlNrdmlCeTB3cStjVjcrUmpDY05XSmVvRzdmRXNtK2x3eXRrM1Q1bGpscGRrSW9kdzQrY0pFazYyb3J0RFBlT1BHRmpwMDgvOEFObUp2RktwVXBSMlRPREpHYm5DVk40QXhUdGNtV3RDQk1DUzRTbHptTVJBRmN4V01HWk9PQ3hEOGkxSCt0UG9UQ1dXMW9CQW5ZaWp2Rms0VCtVcFduekpqellZZlQxNVpmYlNGenlVRUVLU09PRUdoMGZFNGl4WVZKa3lzUGV5MVNub0NrQSsyUlU0ejVnRGpFTjZXK3lwVCtHVmZsTDRpa1pON1FkNDUrVmJVbEpRdDBvS3FLVmxtK2JtajhkUjA3eWIzTk9HVjlWdVNPejNma21TVXFRRlZKTkJxeko1a2FaRGZHekt2SDkwUjNkamtxY2dZNTAxTzB0aDdvV3pwRldhbTRWY3ozUmJaY3BBU21sRWs0YWg5ckNlb09VWkZzdDZaNHh5eWxhVU1DSEtEam9LbGFSU280Vk9zYXUyV25mQTd5UkxXeVRNS1RqSkF4REVuRVhZYjNwbzhXTHBrRk1vcGQyZkxlY0pQckhJMm04cGttV2dMbG5ET0NzQUMwdXdES0piRUtFNWJtcUdNVnBkOVQwS3NvUk1XbEV4ZTJtaENnSnJFVkRwTFU2Q05mREQwT1RLT0FPV2RKNFpnYitVUEFRNUx1UytRSnpaK0drWnliY2tiSVM1QXJTcFpuenp6M3crMFhpMk1BVlNsWnJrNkFnNkYyT01lQmpqemRlSzBtOFVLbWQwZ3VwS2hpVCtXaEljYVVhSGRuTFF0VWhKZXJxcWFrN2FzM2pueGFab014ZU11a0tLSEpJR3dDSFNUaE5YMGliczlhVmhObEFVeVZMbmhZWU1wZ3NqUnd4R2theTNNYi9yK3pHeXUza3FPcGVOc3l3Y3dEemptTEhNSld0eVdETkhUZ3h3M3R2V2lDVWc2Sjhva1RaMDZEd0pqeTN0QlprZnZOb0pTbHpNTlNuK0VheDFkK3pBTEhacWtPWllHSE1udWxNQlVmWWplT083SXpiMDZhYkxZR3Fzajd4M2M0NXZzUTZoTTJsTUFqZC9Id2lPMHFVbTdiUmhXdkVIWlJkS2g3SEVrYnM0cS9zOG5FekppY1JJRXNVZWo5NHZUZTN4ajBUSGo0OC84eG41anRTaFg1dkVEMGFNNitTb1NsZzRTTUN0Q05EclZqSE85dkw5bUlWM1VzcVNFZ0Zha0ZsRXFxQTdnZ014b2F2RkxzcGY2NW9YSW1LV29GQ2lncnFvRkx1a2tra2huTmNtOFBIUEpPV25XK082Mlc1YlFVSmxsUTJ0b0tLWDNLSnc4TmM5Tlk2YVJha3NqQzJGU1JoYkxlQU9rZWRydkg4ZE1zRXVsUnJYVkJVNDZOR3phYldzaEJER1hqYVlLdWtadW5tZGRDZU1mU3d4M2gwOGZLUzl1bkFjZDRvTmdXUTdtb1B0WlpoMjhJeXIxbEVxbDRTVllBUytaT1E4bnorTHhOWnJld0VvNkZZVVZGOFRFRjJPaEFQakdMZnQ4aEttQklxS2pWdDI0RGR4NXhlRHBobjJkTG5qQ0NKaUFhWnVOTjR6THc1RnFtdlNlQ04zZUg0R012R3dHMGtDbnY4TjJud2l1cTBFS3pIa1k4ZHZUN2Y0OXJYYUtZdFVwU2xLS2xKV25MaVErUXJrUHZLcGJaajJkWWNBaFNlZFZaeFF2VGFVRTBxbXVMTE01dnlpcGJaYUUyZFRoSlU2U2NqVEVrWmpxL3dCWTNPNUh5djhBa2FtZGthWVVwS2dseVN3SXplcE9YQnFhYVJQWUZoRTJZMUVncVlNQ3hBTGJKejVSemhtU2dFSENFbmdNeGlKalZzdHRBSlJpQlFjWUtXRk1pcXBhdGNubzQzeGRXK25HV2I3ZGl1M0x6TXlvRFAzU1BpVlJBdTNxL3dDb3FuOEtCNnhGWjVpWmhERnd3MEFCNGtnblFqd2d2R3lHVXNvV1V2UWdvcUdWaVlIS293bkxmSENiK1k5LzhOeUZOdVZYYm1kQ0I2UWh0cC9OTi84QTAvOEFHS2dyUkpkUlVsSXhBTU1XdXIvV0U5bkVtWVFWSVZnSlFBeFpLRk8ybnROMGlwdkhseFBuV3dETlV6cXY1SmlHeld0TTBrSnF3ZmFVUlJuM0N2RDZSUE5sS0NlOENrNFFyQ1VNSEtXRGtuT3IrY1Y1aUViUVluQ0ZIU3VFRXRscXpkWTFMTmZ0SlpiL0FJVXJSZUVzUFFhL25PWEl3ejk5UWNrandtZXBpdGRWdVZOWE1Rc0kyVWs3QVVraGlBMjBTNHJ6cEZ4UlR1UCtZZjhBYkdzdVBxUk1iTDJpTThFVVNud1BxWVdMeHNpVGovRUNTZ3NFdm1DU0Jzc3h5MTNWZ2pMbmZManYwNUswMmlrb0FFc1Q0RWd2NC9DSUo5VWlsWFVjK203Z0lsdkl0TlFQNFFmNmxmS0VzZGtYTUNjQTBZbmRreFo2NnhaaEhHNTJxc3lhcno0dTdidGRZZUx2SUMxS0N4UUtabEQyUWFCOHp5anBMRGRLSk8wUmlVYzFIanUzQ0k1aWl0UnozZEs2OUQ1UjFra1p0dGN6WmI2dEFEb1Vwa3BTb2hnZG5Fb1UzaGlsZ2Z5NkROTEhhNWtwU1VxbXpGbVlrRU1Td0JPZThxWVBsMWpwWlZ6SUNDZ2U5TEV1cDkwWW15MXFZV1RjUlFVTGxuYWxwbUJJVVNRNnhRUG1sSVBQV05JNXEzejVzMFNrcEtpWlF3QmlNa3NrSEFtcVN4TGtzNzhJbXR0MjJxWElsVEZTcGd3S1Z0a0w5b3FCU1NWSkZYR1lKSEdyUTNzNVlWeTdlRTRWNFhXbDFnakVHSUJjaXJxQU1keFo3M21XaGM2eXFsZ0pra2JUazQ4VlJpQnB1UFNGaEs1aTVyL25HMGhLMlVoVHB5WnRuRWs4d3dIV04yK0xkM2Rva3BBeEptQ2NxWndRSmFhRGM1U0s4T01XSmx5cE9TUU9JK1VWTGYyZksyTFlsSkJ3dVMvSjN5ZU1manhYbFVQWnU4MDJvYlFZa2tFUG1NSXlMRFF0SFdXYXl5d1VZUTJBa3BBb0hVQ0NhWnU1amtMdDdQMmlVUVVvcWw2YUZ4OTZ4dnlmM25XUi9VM3ppWmVPWmZKamx4bnB1MkpMVFppbk8xaDEzUGx1anJUTUFxU3czbU9GczRtdUNaSmY5U2ZVaU5HOUZ6SjB0Y3Z1bERFR2ZFaWxRZnpSeW5oL2JkOGpWbTNEWlp5bFRDbkVWRWtsTXhiRWpaUHNxYlJ1a1g1MTNTMXkweWxBNEVOaERtbUVZUlhNMGprdXhsbHRGa3NxWkswaGFncGFpcFN5NXhyS3FzRlZyV3Nib3RjOGtVbEFhakVvdnlPRU41eHFlUDhBYWMvMHYvOEFDcFhjcWtNZTdYbUhQRFhQUVJIZEZ4U0xNVktsSklLZ3hkUk5IZldJRE9uSDNwWS9sVWZVUlJzTjJ6SmE4WXRNd3VTNlZGU2sxNEtXV2JUZEY0WFd0cHovQUU1bnQ1Tkg3MU1CQi84QWpOTUwreWxtY0hXTTNzcE9IZkpiOHM3L0FFTGowSzBXTlN3UXFZYTVsS0VBdHpJSmlzTHFTRTRPOG1sTmZlUzljNjRYamovMSsvZnp0MS9QMXJYeHA1M2FyVWtLUk5BRGt1K0hNWVRSUjMxQTZ4czNQYXpNT09XZ2xBY0Z5a09BNFpuNTFqZUhZK3kva1dlY3hma3hEUmJzM1p5UkxUaFFoU1VuUVRKalZmOEFpNG54ajI0K1RMR2FqeTNHVnlGNjM2a0xKU2lZMHVpcUpMRUFJMmlDek9OZUVZMTIyNUU2MG9MQWdFTWxkUVM3Vkd2SDZ4NlRMN1BXWVltbEkyd1F0NjR3YUhHL3RQeGVGbDNCWjAreklsRGxMUjhvZmt5V1J6Rmd2MEMwelpKbG9CQndFbFFTQ1FBb0hDRUZpeGpNL3dDWUJhVVRGWVVvVWdVUUZZc1JkbWZDUGhIb1lzQ0FLSVNCd1NCNlF2Y0Q3YU03cmZLdkhyTWlaUG1sRXlYTmxnZ3NVcFZvWEcwVXRWaDR4bzJ5NVprbVROd0lDc3NKWFZScU1qaUFGVHU5M25IcHhzd2lOZGtUcVBJUTdTdktwblpKREFLN3paQnFrcWM3Z1FDekRnQkVndVh1bU12R3IvRWZHbFJPMmxBZEpiWk95Szg0OU5WWTBuUWVVUXF1OUowSTVFd2wxVXZibGJ0c1lYSlVrcXdGU0NqOU95QTlhMDV3K3gzV0pTRjQ1NW1PeW5PSWtCSUxnWWxLTmMyZk40NkJkM043eDZ4WG5XQndSaWR3elA2eExKV3BubE5kc0F5a1dpU3J1WitGeWxsdGtReW5TSEcrSDNkZEJsb0tWVGpNSldWWWlLbDBvU3hkUmYyWTBwTjBKbHBaQ01LWGZaQUFmTEpOSVZjZ2FwSFRDRDhJY0l2NU10NzJ4THd1eGxLbkdjUWtNb3BPTWhrcEFPeUZNOU4zakRWWHBaaVZFVHFrTG9VTDk1Skc3akd0YmJBaWJMVkxVRk1jMnd1SzZGb3psZG1MUHZYMWh3aFBKbEhOOW41cUpjMVJtTFNrS1FvT3lxRTFxNGpUVmFaSC9XSGdZbG5kajVLbE9GcURaakVHT2ZYKzBNVjJSbEQzajUvTVJPRVdlU3owa0ZzbHJKd0ZKTGs4V0o1Y1lJYlliakVsWlVoUkxobXJvWHpCZmQ0UVJxWXh6dElMaFNvaFMxT1FHb0cxSjM4WTBwTjFwRkFWVXlydWl4SUVYcGZyL2Y1Um5TN1VQK0dnNnE4WUJkQ0FYcjFKSERUcEdrRjA2RS9LSEZBZW9HZTRhL1dMbzJyMmV3cEhMcVltblNNQmJDNDBPaCsvdlI1MER4OWZyRm16S0hzcURqUTd2cjk3d1J0ay91eVZyQ2x5Z2NJMlNwamhMZ2hodnpyRnV6MlZDRkxXbENRcVkyTTFxVWhnNGRzcVJvcmxCR2c0Rmg5L2VvaDZWUnEzZnRKMHJKSjBIZ0lYQXM2SHdIeWkzQkdSVEZuWHg4Ujg0ZWl6SzN0MStVV29rU1lwdENpVXJlbno5QkU2SmUveWh6eElFSGNZZ2FKY0txbWJDSEZKSDJJZmhJcWZuOElCcWVrT2hSTTQrWHpoU1J1OVBLQVNGeGNUQUczZmZRdzhJT1lIbDgvbkFNeFFxUWQwUFNTTlc1TjZRaWlEbVFlUVAwZ0VZL1pBK01JdEc4RHdmNFFLdzdqNC93QjRRcUEwOGZvWW9ZeVJ1OFByQTRQMGNla0xpSm80aEZoV1JmclNBUmFUcVBFaUdFY3ZCL01RMHlRTS9JcWhpaW5SL0w2d0F0WTNud1B6aUphaHo1ay9LSG1adTlmbjZSR3VlcjgxZUgwRUFpa244b0hHbnJFYWs4UU9YL2pBUW82UHlhRUVnNmpxUzNrQVRBUnJiVnowOVNURVdNRFR4ZjVDRm1GSXpKSjBZWWFkYy9DRS9lQm9NUDhBVWZPQWF3VmtrSGxUNE5FY3l6RFV0MUh3WW1Icm1QN3g2NWVFUXFQRWVYeWdLaytRTkZFajlJaXRNa0VaVjhCOFNJdktCSm9BVHdQeU1OL2RpYXEyUnpyMEVVWmk4YWZ6ZENQbkNSYW56MFN3VHRGdFNTdzZEU0NHMFFTVmZJYy92MWk2bGJQd0huOXRHZkttSjRsdVVhQUNRa2tnNUlWVTZyVXdGTnpSQlB2SEQ1eEpucm1QdjR4V2xXaDFGZ01ob2Q2dDhTeWJTV1FYYkoyQUdZNGNXZ3EzTFMrV284Q1B2eWlWRXNuTU42SEp3K254NnhVN3hSSlM3bWhGZkR6QmlkQ1NXT0VzUlduZy9tUENDTDBsZE1LdklpbTdrTTJPbGVNSXFYaHpQa1g0L3dCdVhDS3dRWGJaY2IxQ280Z1Yrb2k1TFdrakNWQlc3TWRIVlFFWkIrVUZNU29jUzRvd0ZlVG55TUpQbWhJb2hTMzNLSG05ZWtLdEFUcVMvQmdkN1BVRUdoQll2ME1JbVlNeHlkUlBtS1JCRWkyTFAvMStaSzR2eTV3MUE4SytlZk9JVXJQNVFDMlZIL2xLdldIQ2FyU2c0VThXcW5uQVdpbFdhU1NQRDdFTktUcXc1cUQrWmlBck84dnord2ZqRTh1ZTRaVzBPci9NZmRZQmNJMUk4L3ZyRGtxU0RRbm9HODNyRGpaZ3pwY0RjVW55K25qQ0d6c0tsSUhVdjBIMWdoM2VEVURtL3dBZ0hoNlZqUU56RC9IS0dEQ1BlSjVEMUpwNVFvV244cjdnVC9ZSG84QS9hMEwvQUtTM2xTRUNDZEQ0UTBXZzVBQWNBSytMZktIb3RDaHFUNEdBWHVDTTZjeUI1WndCSWVxL0FFL0ZoQUZKT2FlbytXc0lVQTVLcnVWUm9vRnFUb0QxcDVDRU13YUFEby94aEZ5bEQzWDVHRkZtVVJrM09qUURDdFI5N283UkdVbmQ1ZktKVlNVaWlsLzVRL25wRERhRUpPeWwvd0JTdmlCcEJVQWZUeWlRV2RXWllEK05oQ0t0aGQzSFFmWmlOY3dITlBtUWZXQWNwQ0JtcC8wZy9GUmJ5aUF6RWpRZGF3eFdGNkU4aUg4V01OVWg4bEE5VytQemdDWk9KOTg4bVllVVZseXR4QjYvT0JVdFFGUjFhSXk1MXo0ZkNrQTVTRmpKMjRFdDRpSVROUDhBY0Era1dKVmlvVktVdzN1TS9nazhDUVliTnRLRUJrNGxjeVNQT3ZnQWVNQXlYS1VyM0J6TGp3WXdUWmN0UHRLYzdrbW5VL1ppQmR1V1h4R2gwUDNYcVRFQzU0L0szSlg5eEFUcnRZWms3QTRBRW5xNytVVUpwcjdUay9tZDRjVkpybVBQMWlDWUJsaUhJdUlvaXRDU1VxR0lNeEJaV25wQ1EyZElMRm1QNldQa0t3UVJVUmtldndqYXRTaXl2MXAvMEF3UVJCREk5czhrL3dDNk5pNzVTU2dPa0htQm9hUXNFQXRvV1FvQUVnTWNqeEVWeXNsQ25KUHQrUkxRa0VCWm1lNzErRU9zM3ZjLzlvZ2dnTldhTmhmNlpLdXBKQlBNaWp4VlB0ZFBXQ0NJRVY3S3VEdHdiSnQwUG1GbEpiakJCQVhMdlFDU0NBUTRvZWtYYlpzcDJhWlpVMTRRUVJSUktpVjFyVFdOR3hWQWVya2d2cUFLUEJCRUdkYWFIcjZ3NGUwQnZlRmdnQ1dLckc3TGhuQ3lqK0crdS9YWFdDQ0FuVHA5NzRKU1FWZ2Fib0lJRFJtSkFDbUFIS0lyVU5ua21DQ0tNbTAwd2dhNXhHc2JhUm8yWGhCQkFNQTJvWWMxY29JSUtyempseWhRTnB1UHlnZ2dJSlNqaU5kVDZ4ZldkbEIxSlk4UlNoM3dRUUZHOHY4QUVVTnpBY0F3b04wWm1uV0NDQ0loN0lnWDdMOElJSUtycjlrY25pRDVRUVJSUnRLamdKMWIxRUVFRUIvLzJRPT1cIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8yd0NFQUFrR0J4TVNFaFVTRXhNV0ZoVVdGeG9ZR0JjVkZ4Y2JHeGdZR0JvWUdCa2RGeGdZSFNnZ0dCb2xHeDBYSWpFaEpTa3RMaTR1R0I4ek9ETXROeWd0TGlzQkNnb0tEZzBPR2hBUUdpMGxJQ1V0TFMwdExTOHRMUzB0TFMwdExTMHRMUzByS3kwdExTMHRMUzB0TFMwdExTMHJMUzB0TFMwdExTMHRMUzB0TFMwdExmL0FBQkVJQUtJQk9BTUJJZ0FDRVFFREVRSC94QUFjQUFBQkJRRUJBUUFBQUFBQUFBQUFBQUFBQVFJREJBVUdCd2oveEFCRkVBQUJBZ01GQlFVR0F3WUVCUVVBQUFBQkFoRUFBeUVFQlJJeFFTSlJZWEdCQmhPUm9jRXlRckhSNGZBalVuSUhGR0tDb3ZFemtyTENGUlpUMHVJa05FTkVrLy9FQUJrQkFRRUJBUUVCQUFBQUFBQUFBQUFBQUFBQkFnTUVCZi9FQUNZUkFRRUFBZ0lDQWdJQ0FnTUFBQUFBQUFBQkFoRVNJUU14UVZFVFlTTEJjWUVFRkRMLzJnQU1Bd0VBQWhFREVRQS9BTytRbUprcGhFSmlkQ1k5RGtSS1lsU21GU21KRXBpQkFtSEJNUENZY0V4QTBDSGdRb0VPQWdFQWg0RUtCRGdJaWtBaHdFS0JDdEFJMExDd1JGRUxCQ3hBa0xCQkFFRUVFUlJCQkJBRUVFRUFRUVFRQkJCQkFFRUVFQVFRUVFCQkJCQUVFRUVBUVFRUUJCQkJBY1hZZTBGbm1lek1IVUdOZVROU29PRkFqZ1JIZ0taNmtsd3BRTzk5emZTTFVtOHB3eVdvQm16NE5EOHNhL0c5N1FRN09IaVZLWThXdXEvMUpVTzhHSk5YWWw2NnUrYnQ0UjBVcnROTFUzNHMxSDZpU0JVTTJGNmUxNVJlY1RoWHBZRUtCSG1zL3RaTkRwbHJDNkJsRXFCcUFUcXhZMHEwZEhkWGFGYVVBenNKRE80elpuVWRjVE8zR0pmTGpQYXp4WlYxSUVQQWlLeDJsRTFJV2hUcFAzVWFHTEFFYmM5RUFod0VLQkN4QWtMQkJCUkJDd1JBUVFRUkZFRUVFQVFRUVFCQkJCQUVFRUVBUVFRUUJCQkJBRUVFRUFRUVFRQkJESmEzS3NxRnFhVUJyeHJENEFnZ2dnQ0NDQ0FJSVpObkpRSFVvSkRnT29nQnlXQXJxVFNFZ1BtUXUybTk0SlFpS3prb2VXb1ZRY1BGc3dmRDRSYlVvYU5YS2tjUFQwZTBzcEQxaTNMbGVQM3FJcjJiblhQcEZwQ3NLc3VPcEhRYjR6YldwRnVWS0xmZE5Pa2FkaVZRQTZVKy9HTTVFeXRDR2ZOL3VzYWRtV3pPUHJITEt1dU1idHpYMnFRNENYcTU2dHV6b0I0eDNWMDNyTG5wQlNhNmcvZFk4dlFOQnhlSjdCYkZJSXdraFFOSTM0L0pjV1BKNDVrOVpnam03cTdTWXRtWi9tSHFJNktYTUNnNlNDT0VlbkhPWmVubHl3dVBzNkNDQ05NQ0NDQXdVaVZQbDl0Q3hqV0h0RlpGTFdoTnFRcFdNMFVwSUdRb2cwQ2s4YXhzSklJY1ZHOFFMTFBaWUlJalRPQldwRlhTRWswTE1yRXpISSt5Y3NxYjRDU0NDQ0FJSUlJQWdnZ2dDR3l5NGZpZklrUlV2cThVMmFSTW5xeVFrbHQ1eVNPcFlkWThLc2w4V2lXdFV4RSthaFpVVkt3cW9TcXBkSjJUVW5NUkxkTlk0N2ZRVUVlUldEOXBWc2xVblM1YzlPOGZocThRNlQvbEVkVGRuN1RMRk1ZVEN1UW8vd0RVUzZmODZYQTZ0Q1dKY2JIWXpWczFIY2dlTVBqamUydmFRQ1JMRmxuSktwaW5DNWFrcXdwUXhmVVo0UXg0eHk5Zy9haGFKS3NGcWtwbWdlL0wyRk52WTdLdWpRNVRlbDRYVzNyVUVjNWNuYmV4V2xnbWIzYXo3azdZUElFN0o2RXhzWHRlS0xQSlhQbUZrSVNWYzl3SE1zT3NWblRtdXhkODk5YXJ3bDFwUHhwZmN3a2x1WGRwL3dBMGRoSGhQWlh0WWl5V29UbGwwTEJUTlp5UWxaeEZRQXpZaCtoRWU1eVpvV2xLMGwwcUFVRHZCRGcrRVNYYldja3ZSOEVFRVZrUVFSVnZXM0NSSm1UbEFrUzBsUkFaeUJVczlJRGkvd0JxbHVDckNoRGY0MHpMK0ZPSS93RGI0d1J3dmJidFpMbnk3RUFSc1NXVWtLQ21WaXdLY2pnaCtzRWNzdTY3WTYwNWVkTUxvbk5teUNScitVbmNkRHppZGFodTg4dmxHMWJMc1N1VTRBR05JU1NNc1FabEFhRUZod2NSaVdNbFEyc3hza0YyeENtbmp5am51V2Jia3M2UFFxdTZMc2kwQUZqbHZpRk5seEJ3ZW1ZK2NUZDB6T0hvRFRQY2FjOThTMlZ1U3JzbVluTUZzOHN6emk5S0RhdU14dURSbEJXMENjc21JWXhwMlJRYlpMR3VldStPZVVieFdCTTQ5V29ZRlRkN2ZmR0ZNMEdoVHhmVGRUaEUwbENNelN1dFJremNuZU15Nld5MU5acldRWTE3SGVxMEYwcUlCcVFEbDBqQW5USzRnek13YktvZkxtNWl4WjdRQ3o2Q2plc2IvY1ovVmRwSTdVbjNrUHlwSFFXQzJKbW94cDVOdU1lYkttNnU5UHJETFoydW1XUjB5MC9pS0FJRXoyQ0RrdWhyNVZlT21IbHkzMjVaZUtYMDlCdjYvcEZqbDk1UFhoSHVwRlZMTzVDY3lmSWF0SGtQYUx0bmFMd1YzWUJsV2M1eWtuYVVOODFROXAveURaclhGUXhoV3VmTXRFM3ZaOHd6SnF5d2ZnOUVwRkFrVm9LZkdKTUdHbWU4eHZQUDZhOFhpazdxNUxrZ2tEQzVKQUFBcTVvQUFBL0lScWhOb3NpOEtWekpTbUJZS0l6RktaSDZHTkQ5bUpsZDVNQ2grT0Vrb1VTVHNhaElQc2tVUEVIaEd2Mm9rLzhBcFZxbUh2RkltZ1MxbHNRU3NKVVFTR2Naam9EbUk1Y0xyZTNYODA1OGRLbGc3YldwREJlQ2FQNGd5dkZMZkF4V3ZLL3BreFJteUpreXpUODNTUXVXc2FDYWhRWWpRRmlScHVqQjc0QWZaK3NkRGNsd0ttSU0yZWU0UVRoUUZqYktqUkpVTWtKSkl6cVhha01jOC9oZko0L0ZPNzBiZC83VXA4a2hGdHN3VlIrOGtLQWNjRUtKQlA4QU1PVWRuYy9iZXcybGdpZWxDajdrMzhOVDd0cWl1aE1lWTM3ZCtGZmRUeGhZc1NOSHlVTjR5UEVjY3NDOWJ0VlpsaVhPQXFIU1FYQ2s1T0k2NCtTNmViUHhTWHA5SGpmQkhodlpKYzhLQWxXaGNrVklEcXdMWU93Qk9CU2l4cG5uSFlYRDJ0bnlwMHlSYVVHYnRrS1hLU01RVU5rdUVnQllaUE9tdVVkSm01Zmp2dzlDaHExaElKSllBT1NjZ0JtVEVRdGFWU3pOUW9LVGhKQkJwUjZIZFdoM1JoM3BmOHFYSW5LVXRpc2hNcEpMbFNwa3FXVTRVNXM2cTdxbU5NU09UL2FyZm1LWW14cFV5VU11WXh6VVh3cDZDdlVibzg3blRTQ2VCOWErVG53aGJiYTVpNWt4YXFyVXBSV1N6bFQxb0JsU0dYb2hRbkxHajduelRYWGMvZ1l4ZTY3VHFhWFZDaEJ6RytLVXlTTng5ZkF3NjhKeTVjMWFVdG0rdW9IcVltblRHbXFTUlVTOFZOUmdDdWxJeWJaYzFMVlRSUXFHNGNvMDVheFBRQ2ZhRVZpcENrbFEwSUhpN1JDRjkwcEtoa29lcEhwQ3haVnBJRE1vVjQrOE12RVJLdWF0VXZ1RkxVWlRoUVFWRXBCRGdNSHBRbktHV2c1RU1GRFI5M0RVUTJVc0hKaHZENVFobzZ6MkpBVW1udkQ0L1U1eDdMMkR0UTdpY3FaT0tzRXphVk1tRldGQVFobktqc2lpdkE2dkhqcTdVbEcwb3N4Nm5rTll5N3d2WmMwcXFVcFVBQ2tFc1FEaUdQOEFOV3NXWHRuS1I2bGYzN1hrUzVoUlpwSW1wRk84V29wQlA4S1FIS2VOSGpuTFgrMTYzSzloRWhIOHFsSCtwVWVmS01SS1ZHdHM2anFiYiswVzhwbWRxVW45Q1VwOHdIam03ZGUwK2NYbXpwa3o5YTFIeUppcW94RXFBam1LaFlZcUNBOWJsS0JsbVVrZzRLSElBcUtNUXFLSkJ4TSs4UHBITkt4SW5Cd3htZTF1S21EVTRoekRiRGFKcHh5a3JUaTF3cEtndEtVWVNTUTI5TldiYWVoRVRYdlpMUXRJWGpscllobUdGbVlpb0JHZnJIbHdtcHExNmNydTdrV1o2aTUyV2IxMUVXQXNNUzV4YjNaaG44STUzdjV5azRqaEpPNHMzQTVWZjczV0xET211QmdPUk9JS1RScVpPNXI4SXQ4ZlN6eWR0YVNuYXdqYWNPN2tVcm5FNWtrQVVhbXZoRlZTVWxRVWxSU2FCUUlhdXVYckdwM2lRa09BV2F1NGNOMFl5cmNoQk1ETVhGT0ZQdWtYTytZNWExUHpHUkVVWkU3RmlvNDNCUHU4eEYyeVdSYzBFU2s0aVNDR1lOWFU1RFhXSngyY3RST1VnMEFGYVBUVFJ2Q3VjUVRXbGtWREg0eFp3SmxGTXZ2Uk1tcVdFMEFVZ0tvR1VWSk9Obkd5R2pNdGxyUmhuSXRVckN2RWdvUWhReFkyVzdtckpBSXozak9rZEpoWXhjNVdxdXhxbVNsakVFREJMbVM1dFFHSVVWQlp5TkFBMzhUNlJVdDk3ZDVKbFdhVWhNeVozYUF0ZUVIQ3lVZ2hBSXB6bzJsY3FLVXpweUVTNXE4RWxLVWdJMVZoeWNNNUwxNmpjOGRGZHQzRktXUW5BbmZtcy9JK1lqZHN4Yys2ejdvN09oR0x2cGhCbUFCUVNYZXV5OUM3RjJvMVRHb3ZzaktOVVRHL1ZwNWlOaXcyUkthdFhlUzU2bU5vb0I0Tm00K2NjK1Z0WHVlcTRiL2xTY2c0NVV4bERKU1N4SElnRDR3MjhKVjRLbG1WTktsb0pCcUFTNHlPSUFuemp1RTJVR29BNS9WTU9NZ2pVOVNENUdOYkpsWGt0b3NhL1pVazViblBsSFlYQjJoUis3R3pXbFlDaHNwVVFxcVcyY1RCM0ZLdHUxZU9vWElKRzBBZjFKK1ZJcFRybmxMb1pRL2xMZVZJUzY5R1dmTHF4eFBhNmVtWmFwcWtxeEpWaHdrT3pZRWluVjR3cjd0cFZKbGhaSlNnaVZNQURreWlka2did01TY3Z5NzQ5QnRIWmFTY3NTZVljZjB4a1cvc2xza1lnUTFRNHkvU1crTVdlMnNzNVpKOUMrYnVreXJFdVdrQlNFTW9MQzl2RUZJVHRIQ1FDeDQwRE1OS04xWFozZG5uTHhsTTBCUVF2RGlRVWdFcVRNSXhCUVVsd1F6TU1qRlc3dXprMllCWjBURXB3cFhobUZKQ3NLRm9TRXFLRGtYMExFQTBvWTNKUFptM29rcWxkOUtXRGljT29CV0lNQVhRNldjalpVS05IWGpmcHczUFcxRHMvYkxhMW9uSVZSU1ZyV2tnRkUwcnJzQUViWkRrTUFjZ2MyaXZkZG5Gc1ZMbXFLU3VVaElKVnNnQkJZRXBTSGZDTTNENFRReHNXS1RiNUVrUzFXWUtDVGhHRmJuRGhxUW9LVVZhakNValNzWjF5V3Y5MWs0WnlGb0NpeWhNbHFBVXlBQmpEbFNLZ1ZOTm8xT2tzcSsweUxtbEJpVnBkVHNBRVZaeFFyQkttR28zNlBFZHBzc3NvbWxDbHFTeFk0aW5KTzVKQXplQ2VudkNKNkVneTlrQlNXS1VuRUtDcnB6R1lFWDcxbkpVSnBTWDJEb2Z5QWF4eXUxak5YSWxtWTJJMXlCVXpzQTRDVHBybENUcm1RcGFzQ2dmd3k3cGFtQWc4Y216Nk5ETDlVRjJ4Q2hvSmZrRHZyNHhzV3lkS1ZNRGpZd012RU5tZ0J5cUd5cDExZU5JNHFkMmRVSlUwSUJiWlU0WXMyTFFzM0xoR1hlZDB6RXk1WWFvQ25lbWFuSExYd2pycm9SaXM4eDFFbEpWaHJuN1ZLbXRQSVJMZUtqM1VxWW9zamFjRUFOaUwxNE42NXZHNWFqaDdkS1VKeW1CTEdoRmZYUGw1UTFWcENVN1FPTTZEVDlRYWo3aDVSSmUxNW9XY010SVllK1JVNSt5RFVDTWxJZjcrM2loMHlZcFoxSkRaRGZ5aGt4S2txd3FCQloySVkxZlNIUzV6SW1JQVA0bUVFZ3NRRUhFR05jNGt0Q2xUQ0ZGSm9sS0tBbHdrTUhPcGdkYVZIZ3M4bkhqZFdFSVRpSklKWUNob000dFM3dW5LeWxxUFNKcGR6V2taSVVsNk9TQlRqRFpHZGFKUUNaYTBxeEpYaVlzUjdKQUxnOFlyTFJYZEczTXVLMEtiRVUwL05NZG9lT3pTdmVtSVQwSjlJY3A5cnh0OVJ6eFMwRWRJT3p5Um5OUDhvK2NFT2NYaGw5T2l1eXpJUk8yVkpvVXlpQVV1VllIWVZhcEFjYWtBVmFObTBweElKN3BLbHUyMHp2UTRUczBVQVFHQjMwam5iMDdKbElLNVNpVXUrQTBJRkRSVDFJSXpaMkcrSFdYdE9VQnBvWGlEcVRNRFBrelRFcVlLSkttZk9zY2NkV2JsYXozTDNHNVlMdWxNRE1reTBrNXVIemMxQUZTejYxK09UMmp0WVRNRXFXRWp1d3A4SXcrM2hJRFVJTER3VUlqdDNhY3BTKzBGNTRsNEhDc0tVN0NBNlFSU3VvQkRSa3JtTG1KN3d5eWtCdG91Vk9ha2s2ZzV1WFBMS09rbjJ4djZOVGVCRGc1Y1FEeGkwaTFPMlRjUGxwR1l1bkVHTDloc0NwcWtJbEpLMW5SR2JhdVNHRGI4b3ZDRXlycWtyRXVRbGFUdEsyeVZVU21XRUZSSjJxNkVrNlJVVjJtbXpwQ1VwSWx5Ni80YU83eERLb3F3UHJXTDEvS0V1VUpjd3BTbzA3dHdTN1Y0TW1nQjRCdU5PdzNTWmdjbDBpbkNsSE84K0FHZ2lTU0x1NWUwMDIxZ0ZjdXlld1ptUHZsZ01sVlA4SU53RmN5d2lTN0xtQ1RpQUpWbVZycXB6bXdPUkoxVldzYU5rc3lVcEJ6T0Vud2JMZG5wU0xLeVhXTk1NejRKYW11c1p2YlJMUFlrQlkxVUNISnFXSVZyOG8xTEJNZE9RREVoaHdNWnRtTzEvTEwrQ292WGNncFN4RGJSK01acy9vMm11UlpNc09TVGlWbVhQdEdOKzBqOE5mNkZmNlRHSGRzZ29RRWt1WEoxMVBHTjZZeEJTU0E0SXFScUdpWC93Qkh3d2JuUTAxR3l4T0xwN1FiSWZaaTlmVTVhVkl3S1VtbFd5T2J1R05XaVd4M2NsQ2txU1RzdlNsWGZkemlhMzJNcklJTE1HcjErY2RiWnljOVhpSkZwVis3aVk3cXc1a05xUlVCb1pkTnRNMXdvSm9BZGtuWG1TMFN5N09vU1JMeklHbVh0RS9DR1hYWmxJS3NRQWRLUlRoMWpQV3F2ZTRtdDg5TXRJVW9FdVdvSGFoTDVpbEl5cjlTSmxtV3BMK3lUV2gyUzUrRWFOOVNzU0VoaWRzR2o1TXJkRktja2l5cUdnUXR3b0VuVTV2R2RUanRkL3kwdyt5WlQzNUNWRnNDaGhMYjBrRklUUmlOSGlLK3UwY3p2eWlXY0tVWWc0STJtS2EvR0dkazVpamFaYnFkT0dhekhLc3VoREJ2bmloTERjWW5XY0t3cEV4YXl2RWFIRGpBTEhVRkRsc25ibkhxeHY4QUZ6MTIyckIybFFjV09qQndkL0E3bGVVYUYxM21tZUtVTE9VOEQ2UnoweTdVcG5TeElUaHdZZ3B5YTdMZ2t0VlZUNDhvcHlremJQYWtsVHNUVTV1S3ZscHo1eGRyd2RmYUxwa0xCU3FVaGptd3d2VUdwU3h6QVBRUlFuZG5KUkJDVkxEZ2pQRm8zdlZQakc0VERDcUZ4bDlzYnNjSmYxd0tsa1QrOFNRa3BCQkdFMTJRd0JJekkxME1RMnVhQjNlOEtMdTJSd2gyYktuSEtOWHQzYW1sQklQdko4bGZVUnk5NVRHd3JBeU83TmxBNStrY2M4WkwwM0t0WFNBVnpRYWdUcHJNeEI5cG1jY21pRzhiRWljcVNGakdKcVVwU2tLVWdPRXJXNXlCR2JPYVA0UldYQTB5V2tncFZNd0Ewb0Noem1Hby9ES3NZMXpwbnpMV2lhcXN1VzRHMEdZU3lnRUIyclEwM21JMVBicDA5ajVZT0g5M1ErYktXQ1czdGlpWlBaaEtDRWlWSlFWWkJzMjVDT2x0U2diU01pOHMvRlVSWGlmeDVQNmxmN2ZuSFBYWHQzNjNKcWVtTEt1TGFVZ0dVQ2xnUUVtajFIdWg0anRWM0NXV1ZOSWNPeVVraHFqVlEzR04yeS8rNG5EaWovVEdYZjhBVmFjTmRqTVY5NVc2SEdhMnVOM254K05FbWRuMGdPWmlqbmtBTWcrc1VMSFlKTXhSVCtKUVBWU2Q0RzdqSFRXbWNBQUtuRTRvQ1dwcnVFWU56eTFKV1NVcUF3SE1IZW1MY1l6aGxsY2NyVU42WGJLbEpjSXhWQXFUcUNkT1VNdmV5eTVPSERMVFVsOFRuSnVNWHI4U1Z5MlNrdmlCeTB3cStjVjcrUmpDY05XSmVvRzdmRXNtK2x3eXRrM1Q1bGpscGRrSW9kdzQrY0pFazYyb3J0RFBlT1BHRmpwMDgvOEFObUp2RktwVXBSMlRPREpHYm5DVk40QXhUdGNtV3RDQk1DUzRTbHptTVJBRmN4V01HWk9PQ3hEOGkxSCt0UG9UQ1dXMW9CQW5ZaWp2Rms0VCtVcFduekpqellZZlQxNVpmYlNGenlVRUVLU09PRUdoMGZFNGl4WVZKa3lzUGV5MVNub0NrQSsyUlU0ejVnRGpFTjZXK3lwVCtHVmZsTDRpa1pON1FkNDUrVmJVbEpRdDBvS3FLVmxtK2JtajhkUjA3eWIzTk9HVjlWdVNPejNma21TVXFRRlZKTkJxeko1a2FaRGZHekt2SDkwUjNkamtxY2dZNTAxTzB0aDdvV3pwRldhbTRWY3ozUmJaY3BBU21sRWs0YWg5ckNlb09VWkZzdDZaNHh5eWxhVU1DSEtEam9LbGFSU280Vk9zYXUyV25mQTd5UkxXeVRNS1RqSkF4REVuRVhZYjNwbzhXTHBrRk1vcGQyZkxlY0pQckhJMm04cGttV2dMbG5ET0NzQUMwdXdES0piRUtFNWJtcUdNVnBkOVQwS3NvUk1XbEV4ZTJtaENnSnJFVkRwTFU2Q05mREQwT1RLT0FPV2RKNFpnYitVUEFRNUx1UytRSnpaK0drWnliY2tiSVM1QXJTcFpuenp6M3crMFhpMk1BVlNsWnJrNkFnNkYyT01lQmpqemRlSzBtOFVLbWQwZ3VwS2hpVCtXaEljYVVhSGRuTFF0VWhKZXJxcWFrN2FzM2pueGFab014ZU11a0tLSEpJR3dDSFNUaE5YMGliczlhVmhObEFVeVZMbmhZWU1wZ3NqUnd4R2theTNNYi9yK3pHeXUza3FPcGVOc3l3Y3dEemptTEhNSld0eVdETkhUZ3h3M3R2V2lDVWc2Sjhva1RaMDZEd0pqeTN0QlprZnZOb0pTbHpNTlNuK0VheDFkK3pBTEhacWtPWllHSE1udWxNQlVmWWplT083SXpiMDZhYkxZR3Fzajd4M2M0NXZzUTZoTTJsTUFqZC9Id2lPMHFVbTdiUmhXdkVIWlJkS2g3SEVrYnM0cS9zOG5FekppY1JJRXNVZWo5NHZUZTN4ajBUSGo0OC84eG41anRTaFg1dkVEMGFNNitTb1NsZzRTTUN0Q05EclZqSE85dkw5bUlWM1VzcVNFZ0Zha0ZsRXFxQTdnZ014b2F2RkxzcGY2NW9YSW1LV29GQ2lncnFvRkx1a2tra2huTmNtOFBIUEpPV25XK082Mlc1YlFVSmxsUTJ0b0tLWDNLSnc4TmM5Tlk2YVJha3NqQzJGU1JoYkxlQU9rZWRydkg4ZE1zRXVsUnJYVkJVNDZOR3phYldzaEJER1hqYVlLdWtadW5tZGRDZU1mU3d4M2gwOGZLUzl1bkFjZDRvTmdXUTdtb1B0WlpoMjhJeXIxbEVxbDRTVllBUytaT1E4bnorTHhOWnJld0VvNkZZVVZGOFRFRjJPaEFQakdMZnQ4aEttQklxS2pWdDI0RGR4NXhlRHBobjJkTG5qQ0NKaUFhWnVOTjR6THc1RnFtdlNlQ04zZUg0R012R3dHMGtDbnY4TjJud2l1cTBFS3pIa1k4ZHZUN2Y0OXJYYUtZdFVwU2xLS2xKV25MaVErUXJrUHZLcGJaajJkWWNBaFNlZFZaeFF2VGFVRTBxbXVMTE01dnlpcGJaYUUyZFRoSlU2U2NqVEVrWmpxL3dCWTNPNUh5djhBa2FtZGthWVVwS2dseVN3SXplcE9YQnFhYVJQWUZoRTJZMUVncVlNQ3hBTGJKejVSemhtU2dFSENFbmdNeGlKalZzdHRBSlJpQlFjWUtXRk1pcXBhdGNubzQzeGRXK25HV2I3ZGl1M0x6TXlvRFAzU1BpVlJBdTNxL3dDb3FuOEtCNnhGWjVpWmhERnd3MEFCNGtnblFqd2d2R3lHVXNvV1V2UWdvcUdWaVlIS293bkxmSENiK1k5LzhOeUZOdVZYYm1kQ0I2UWh0cC9OTi84QTAvOEFHS2dyUkpkUlVsSXhBTU1XdXIvV0U5bkVtWVFWSVZnSlFBeFpLRk8ybnROMGlwdkhseFBuV3dETlV6cXY1SmlHeld0TTBrSnF3ZmFVUlJuM0N2RDZSUE5sS0NlOENrNFFyQ1VNSEtXRGtuT3IrY1Y1aUViUVluQ0ZIU3VFRXRscXpkWTFMTmZ0SlpiL0FJVXJSZUVzUFFhL25PWEl3ejk5UWNrandtZXBpdGRWdVZOWE1Rc0kyVWs3QVVraGlBMjBTNHJ6cEZ4UlR1UCtZZjhBYkdzdVBxUk1iTDJpTThFVVNud1BxWVdMeHNpVGovRUNTZ3NFdm1DU0Jzc3h5MTNWZ2pMbmZManYwNUswMmlrb0FFc1Q0RWd2NC9DSUo5VWlsWFVjK203Z0lsdkl0TlFQNFFmNmxmS0VzZGtYTUNjQTBZbmRreFo2NnhaaEhHNTJxc3lhcno0dTdidGRZZUx2SUMxS0N4UUtabEQyUWFCOHp5anBMRGRLSk8wUmlVYzFIanUzQ0k1aWl0UnozZEs2OUQ1UjFra1p0dGN6WmI2dEFEb1Vwa3BTb2hnZG5Fb1UzaGlsZ2Z5NkROTEhhNWtwU1VxbXpGbVlrRU1Td0JPZThxWVBsMWpwWlZ6SUNDZ2U5TEV1cDkwWW15MXFZV1RjUlFVTGxuYWxwbUJJVVNRNnhRUG1sSVBQV05JNXEzejVzMFNrcEtpWlF3QmlNa3NrSEFtcVN4TGtzNzhJbXR0MjJxWElsVEZTcGd3S1Z0a0w5b3FCU1NWSkZYR1lKSEdyUTNzNVlWeTdlRTRWNFhXbDFnakVHSUJjaXJxQU1keFo3M21XaGM2eXFsZ0pra2JUazQ4VlJpQnB1UFNGaEs1aTVyL25HMGhLMlVoVHB5WnRuRWs4d3dIV04yK0xkM2Rva3BBeEptQ2NxWndRSmFhRGM1U0s4T01XSmx5cE9TUU9JK1VWTGYyZksyTFlsSkJ3dVMvSjN5ZU1manhYbFVQWnU4MDJvYlFZa2tFUG1NSXlMRFF0SFdXYXl5d1VZUTJBa3BBb0hVQ0NhWnU1amtMdDdQMmlVUVVvcWw2YUZ4OTZ4dnlmM25XUi9VM3ppWmVPWmZKamx4bnB1MkpMVFppbk8xaDEzUGx1anJUTUFxU3czbU9GczRtdUNaSmY5U2ZVaU5HOUZ6SjB0Y3Z1bERFR2ZFaWxRZnpSeW5oL2JkOGpWbTNEWlp5bFRDbkVWRWtsTXhiRWpaUHNxYlJ1a1g1MTNTMXkweWxBNEVOaERtbUVZUlhNMGprdXhsbHRGa3NxWkswaGFncGFpcFN5NXhyS3FzRlZyV3Nib3RjOGtVbEFhakVvdnlPRU41eHFlUDhBYWMvMHYvOEFDcFhjcWtNZTdYbUhQRFhQUVJIZEZ4U0xNVktsSklLZ3hkUk5IZldJRE9uSDNwWS9sVWZVUlJzTjJ6SmE4WXRNd3VTNlZGU2sxNEtXV2JUZEY0WFd0cHovQUU1bnQ1Tkg3MU1CQi84QWpOTUwreWxtY0hXTTNzcE9IZkpiOHM3L0FFTGowSzBXTlN3UXFZYTVsS0VBdHpJSmlzTHFTRTRPOG1sTmZlUzljNjRYamovMSsvZnp0MS9QMXJYeHA1M2FyVWtLUk5BRGt1K0hNWVRSUjMxQTZ4czNQYXpNT09XZ2xBY0Z5a09BNFpuNTFqZUhZK3kva1dlY3hma3hEUmJzM1p5UkxUaFFoU1VuUVRKalZmOEFpNG54ajI0K1RMR2FqeTNHVnlGNjM2a0xKU2lZMHVpcUpMRUFJMmlDek9OZUVZMTIyNUU2MG9MQWdFTWxkUVM3Vkd2SDZ4NlRMN1BXWVltbEkyd1F0NjR3YUhHL3RQeGVGbDNCWjAreklsRGxMUjhvZmt5V1J6Rmd2MEMwelpKbG9CQndFbFFTQ1FBb0hDRUZpeGpNL3dDWUJhVVRGWVVvVWdVUUZZc1JkbWZDUGhIb1lzQ0FLSVNCd1NCNlF2Y0Q3YU03cmZLdkhyTWlaUG1sRXlYTmxnZ3NVcFZvWEcwVXRWaDR4bzJ5NVprbVROd0lDc3NKWFZScU1qaUFGVHU5M25IcHhzd2lOZGtUcVBJUTdTdktwblpKREFLN3paQnFrcWM3Z1FDekRnQkVndVh1bU12R3IvRWZHbFJPMmxBZEpiWk95Szg0OU5WWTBuUWVVUXF1OUowSTVFd2wxVXZibGJ0c1lYSlVrcXdGU0NqOU95QTlhMDV3K3gzV0pTRjQ1NW1PeW5PSWtCSUxnWWxLTmMyZk40NkJkM043eDZ4WG5XQndSaWR3elA2eExKV3BubE5kc0F5a1dpU3J1WitGeWxsdGtReW5TSEcrSDNkZEJsb0tWVGpNSldWWWlLbDBvU3hkUmYyWTBwTjBKbHBaQ01LWGZaQUFmTEpOSVZjZ2FwSFRDRDhJY0l2NU10NzJ4THd1eGxLbkdjUWtNb3BPTWhrcEFPeUZNOU4zakRWWHBaaVZFVHFrTG9VTDk1Skc3akd0YmJBaWJMVkxVRk1jMnd1SzZGb3psZG1MUHZYMWh3aFBKbEhOOW41cUpjMVJtTFNrS1FvT3lxRTFxNGpUVmFaSC9XSGdZbG5kajVLbE9GcURaakVHT2ZYKzBNVjJSbEQzajUvTVJPRVdlU3owa0ZzbHJKd0ZKTGs4V0o1Y1lJYlliakVsWlVoUkxobXJvWHpCZmQ0UVJxWXh6dElMaFNvaFMxT1FHb0cxSjM4WTBwTjFwRkFWVXlydWl4SUVYcGZyL2Y1Um5TN1VQK0dnNnE4WUJkQ0FYcjFKSERUcEdrRjA2RS9LSEZBZW9HZTRhL1dMbzJyMmV3cEhMcVltblNNQmJDNDBPaCsvdlI1MER4OWZyRm16S0hzcURqUTd2cjk3d1J0ay91eVZyQ2x5Z2NJMlNwamhMZ2hodnpyRnV6MlZDRkxXbENRcVkyTTFxVWhnNGRzcVJvcmxCR2c0Rmg5L2VvaDZWUnEzZnRKMHJKSjBIZ0lYQXM2SHdIeWkzQkdSVEZuWHg4Ujg0ZWl6SzN0MStVV29rU1lwdENpVXJlbno5QkU2SmUveWh6eElFSGNZZ2FKY0txbWJDSEZKSDJJZmhJcWZuOElCcWVrT2hSTTQrWHpoU1J1OVBLQVNGeGNUQUczZmZRdzhJT1lIbDgvbkFNeFFxUWQwUFNTTlc1TjZRaWlEbVFlUVAwZ0VZL1pBK01JdEc4RHdmNFFLdzdqNC93QjRRcUEwOGZvWW9ZeVJ1OFByQTRQMGNla0xpSm80aEZoV1JmclNBUmFUcVBFaUdFY3ZCL01RMHlRTS9JcWhpaW5SL0w2d0F0WTNud1B6aUphaHo1ay9LSG1adTlmbjZSR3VlcjgxZUgwRUFpa244b0hHbnJFYWs4UU9YL2pBUW82UHlhRUVnNmpxUzNrQVRBUnJiVnowOVNURVdNRFR4ZjVDRm1GSXpKSjBZWWFkYy9DRS9lQm9NUDhBVWZPQWF3VmtrSGxUNE5FY3l6RFV0MUh3WW1Icm1QN3g2NWVFUXFQRWVYeWdLaytRTkZFajlJaXRNa0VaVjhCOFNJdktCSm9BVHdQeU1OL2RpYXEyUnpyMEVVWmk4YWZ6ZENQbkNSYW56MFN3VHRGdFNTdzZEU0NHMFFTVmZJYy92MWk2bGJQd0huOXRHZkttSjRsdVVhQUNRa2tnNUlWVTZyVXdGTnpSQlB2SEQ1eEpucm1QdjR4V2xXaDFGZ01ob2Q2dDhTeWJTV1FYYkoyQUdZNGNXZ3EzTFMrV284Q1B2eWlWRXNuTU42SEp3K254NnhVN3hSSlM3bWhGZkR6QmlkQ1NXT0VzUlduZy9tUENDTDBsZE1LdklpbTdrTTJPbGVNSXFYaHpQa1g0L3dCdVhDS3dRWGJaY2IxQ280Z1Yrb2k1TFdrakNWQlc3TWRIVlFFWkIrVUZNU29jUzRvd0ZlVG55TUpQbWhJb2hTMzNLSG05ZWtLdEFUcVMvQmdkN1BVRUdoQll2ME1JbVlNeHlkUlBtS1JCRWkyTFAvMStaSzR2eTV3MUE4SytlZk9JVXJQNVFDMlZIL2xLdldIQ2FyU2c0VThXcW5uQVdpbFdhU1NQRDdFTktUcXc1cUQrWmlBck84dnord2ZqRTh1ZTRaVzBPci9NZmRZQmNJMUk4L3ZyRGtxU0RRbm9HODNyRGpaZ3pwY0RjVW55K25qQ0d6c0tsSUhVdjBIMWdoM2VEVURtL3dBZ0hoNlZqUU56RC9IS0dEQ1BlSjVEMUpwNVFvV244cjdnVC9ZSG84QS9hMEwvQUtTM2xTRUNDZEQ0UTBXZzVBQWNBSytMZktIb3RDaHFUNEdBWHVDTTZjeUI1WndCSWVxL0FFL0ZoQUZKT2FlbytXc0lVQTVLcnVWUm9vRnFUb0QxcDVDRU13YUFEby94aEZ5bEQzWDVHRkZtVVJrM09qUURDdFI5N283UkdVbmQ1ZktKVlNVaWlsLzVRL25wRERhRUpPeWwvd0JTdmlCcEJVQWZUeWlRV2RXWllEK05oQ0t0aGQzSFFmWmlOY3dITlBtUWZXQWNwQ0JtcC8wZy9GUmJ5aUF6RWpRZGF3eFdGNkU4aUg4V01OVWg4bEE5VytQemdDWk9KOTg4bVllVVZseXR4QjYvT0JVdFFGUjFhSXk1MXo0ZkNrQTVTRmpKMjRFdDRpSVROUDhBY0Era1dKVmlvVktVdzN1TS9nazhDUVliTnRLRUJrNGxjeVNQT3ZnQWVNQXlYS1VyM0J6TGp3WXdUWmN0UHRLYzdrbW5VL1ppQmR1V1h4R2gwUDNYcVRFQzU0L0szSlg5eEFUcnRZWms3QTRBRW5xNytVVUpwcjdUay9tZDRjVkpybVBQMWlDWUJsaUhJdUlvaXRDU1VxR0lNeEJaV25wQ1EyZElMRm1QNldQa0t3UVJVUmtldndqYXRTaXl2MXAvMEF3UVJCREk5czhrL3dDNk5pNzVTU2dPa0htQm9hUXNFQXRvV1FvQUVnTWNqeEVWeXNsQ25KUHQrUkxRa0VCWm1lNzErRU9zM3ZjLzlvZ2dnTldhTmhmNlpLdXBKQlBNaWp4VlB0ZFBXQ0NJRVY3S3VEdHdiSnQwUG1GbEpiakJCQVhMdlFDU0NBUTRvZWtYYlpzcDJhWlpVMTRRUVJSUktpVjFyVFdOR3hWQWVya2d2cUFLUEJCRUdkYWFIcjZ3NGUwQnZlRmdnQ1dLckc3TGhuQ3lqK0crdS9YWFdDQ0FuVHA5NzRKU1FWZ2Fib0lJRFJtSkFDbUFIS0lyVU5ua21DQ0tNbTAwd2dhNXhHc2JhUm8yWGhCQkFNQTJvWWMxY29JSUtyempseWhRTnB1UHlnZ2dJSlNqaU5kVDZ4ZldkbEIxSlk4UlNoM3dRUUZHOHY4QUVVTnpBY0F3b04wWm1uV0NDQ0loN0lnWDdMOElJSUtycjlrY25pRDVRUVJSUnRLamdKMWIxRUVFRUIvLzJRPT1cIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiUHJpbWEgyJhjb2FsxIMgUm9tw6JuZWFzY8SDXCIsXHJcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZTogXCJNdXpldVwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8yd0NFQUFrR0J4TVRFaFVURXhNVkZoVVdGeFlYR0JjWUZ4Z1pHQmdZRnhnWUdCMFlGeGNZSFNnZ0dCb2xIUllhSVRFaEpTa3JMaTR1Rng4ek9ETXROeWd0TGlzQkNnb0tEZzBPR3hBUUd5OGxIeVV0TFMwdExTOHZMUzB0TFM4dExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExmL0FBQkVJQU1JQkF3TUJJZ0FDRVFFREVRSC94QUFjQUFBQkJRRUJBUUFBQUFBQUFBQUFBQUFGQUFJREJBWUJCd2oveEFCQUVBQUJBZ1FEQlFVR0JRTUNCZ01BQUFBQkFoRUFBeEloQkRGQkJTSlJZWEVHRXpLQmtVS2hzY0hSOEFjVUkxTGhZcEx4RlhJa016Umpnc05Eb3JML3hBQWFBUUFEQVFFQkFRQUFBQUFBQUFBQUFBQUJBZ01BQkFVRy84UUFMaEVBQWdJQ0FnRUNCUVFCQlFFQUFBQUFBQUVDRVFNaEVqRUVJa0VUTW1GeGdRVWpVZkNSUXFIQjRmRVUvOW9BREFNQkFBSVJBeEVBUHdEemFidEJJU1NrN3prZE9iNnZGWFo3cEtWRWJxbE1IOEowT1JETS93QWVFVmNJdEFYdmdoUFJ5NHVMZFEzUXhjd2toYTVnQ2tLb2ZKTmlBWGJUbWZVeHowbzZDZWg3T3d0S0FIMGM4WE9ibUppaStVQ3RpWXhFdE5LaXFvbkkrSzVzRkY4NzVNTW9NU1NUdkczTG54ajBjSGt4blNYL0FJVGxDaHBrOG9qS1l0Q2JIQ0JIWW15ZEZZaUhDSkZ0RWJReGprY0loN1FtZ2dHVXgybUh0Q2FNWVlFd3FZZTBKb3dSbE1LbUh0Q2FNQVpUSGFZZTBKb3hpT21GVEVqUnhvd1JsTUttSkdoTkFNUjB3Z21KR2luajVyV2NBYXZrMmVjUThqTjhPTmpSalpZS2s2a0J0ZlBXRWxRc09wSE9Ca25Fb2NBRjZ0NFdHZGxaUGQ4L1RMS0hvbXFTNUZ3N0h5ekwyR3Z1anlvK2UwMWZSVjR3aVVSeW1Ib0lJdHdCanJSN0VKcVVVMFJhb2pwamxNU3RIR2hyQlJIVEhLWWxhT05Cc3hIVENpUm9VRUZHTG5GQ1poSVNncXBERmdVbTcydmM2Y282aWZVV1FVaEtUdktTYVNYZndsVjNPV1JnUnM3Rk5ORGtNUVE5bWUxeVlzWXVRRVZJUWxTKzhaU2RBR09kUEI4dUlBNXg4MDRVNloxV1hjTmpWOThKYVhVcDJmeEJLUDNYMXVieHRrNGhLYVVqZUxEL0FER0cyVHN4Y3M5NG9WRmxNbHhkcmE1amx6alE3THhGYWt1RlZPSEJHUkFkczdmejBqb3daWXdrb3dXMzJ4WkxXdytlUWlNeElNNGV1Vkh0clJFcm1PQVJKVENwaGhSalFtaDlNZHBnbUdOQ2FKS1lWTVl4SFRIV2g3UjFveGlPbUZURWxNSm94aU9tTzB3OW83VEdNUk5DYUpLWTdUQU1SdEhHaVdtRlRBQ1JXZ1hqWlJOU0ZDcEo1Z1dPZzRuMGk5aTFzNC9kWjcydHVzRzRnNjZjb0N5cHEzVlVsZ2xWaVdVQW5tZk84ZUY1dmtySXVOYlRPakhHdGxPVGgxeXpTRmJnekQwa0d3dnd5YStvaTkzd0FLbE8xVFczZDVnUURlN2pod2dMdENiTlI0VTdyUFVvZ1VnTlkzZHdkTllVbWZrb2wwckFmTWxOZ3o5V1BtSTRuQnlWajNScGNMaWVJMFpQMHQ1Um9OaDdQTTVZU0E0QWRUSFRyeE9VWXZCWXFwWEVYemNOcmEydkQ3UHBQNFpZcVRXcENsRUxLUlpXcXIyVGF6QzdkT2NVeDU4bVAwcC85RzR4N1lFeG1Ib1dwUDdWRWZiUkJUR203WjRJSm1pWWtic3dadG1wTEIvUnZTTTgwZTlneWM4YWtRbXFkRVRSeG9sYU9VeFlRamFGRDJoUVFIbW13c0N4S3B5U0VweVNRem5rL1RoQnVaTnJRVmlXRXU1RGk5blVHcUxnWk1XTVZOcXo2QVVGU1JWNGFXSlpydWRDNTQ4bWdWZ0prNVphbXBJRFVsUlRZZ3NSekRGdUVmTnRPZnJaMGx2SFkwSzhOYkZPK1J3VUxCMnNISSt5WXZka0p4NzVLU29qdkxwSllnc0RZaHpwYk8wRDhIc2lZYWd1WUVpV1F5UzRKY1dBSkQ1S05tYS9PSnFTWjdJTlV3R3BZTjBnQmlQTmpwd3p1MFd4VGpDU3IyTTBlanpKTFJ4Q3RJWmhKaWlnTy9DNEQrNkprb2VQY2k3Vm5PeGlwWjRSeW1KV0k0d3FqREppa1ZNSm9rYUVFd3dCalFtaVNtR3FVQVFEbWN2S05aaHJSMW9mVEhhWXhpTm9WTVNVd3FZeGlPbU90RWxNS21NWWlhT3RFbE1jSkFoSnpqRlhKME5HTGZReG9WTWNtVFFQNXkrc1ZQekR1TkRrVWtNUzJRT1pMTWVGNDgvTitwNDRhanN2SHhwZStnUjJuN3lXcEswRWtHeWdTOVBRWmdINHR5WVluRmxTMW9YdXBXQUFvWEtnb2dNTDN1RHE4YUdZcE15V3RLbUdoQnRrQmZwZlBKNHgvd0NaZWVKYXFkd3FDVk1BQUNscmh3Y3dPUGs3eDVjOG54MjUxVExPQ2l0TXVLcVNwU1ZsVXlrQ2swc0dMbnlaaGJRbmpGSVNRWmRxVkJTaXBURUFwRGtrQzQvcHpqUlRjTTZBa2tGUlNMWGQyMVpWMkxhUUF3K0ZwQ2xUU251MXJKcEF1U2FidWNuWTI1eExITlAvQUdGYUpzRlM3TUFsUkJHUnVMVlcwSVZ3emVOWnNYRWpEeTFLQ1htcklTeUVoeUE3Z0V1ZkpoazcyalBZV1VsSkFBQVNDd0NnV05oNGkxOHpac3lCcEJuWjJGRTZZbEt5cEtWVExLU09KOFlBZTNpOUJvSVdjdlVNamZZVENxbTdQVXBZWFdDVnBxS2l3UzRwRlZ3QUhIbDBqTUtVT0lqMHpEZmx3a1NFcUUyamNVU1Fxa2l4ZW83c1lIYUdFTXFZdVdmWkpIbHA3bWoyUDArZEp3L0pISXZjSDFjQVQ1TjhXamwrQTh6OUlzVXh5bVBUSWxlbFhFZjJuNndvbnBoUmpIamtxYTVjcEsxR3pOWnlDRGxxOTdRZjJmcytaS0pVcFNBUURZcVRtMlJCT2Q4akVNaWVnVG1XUWxURWtzRW5nMW52NXZ4aXB0YWZMUVJMa3FyM25VV0pMc0xwSkFhd0licDVmUFNibStLT2hCS2JqeXRSbHpGZ0pkd3RHVDU1c0RkbVpvczRCWUtpaVhTaFNpeWxGbk9sMUMvRXR4SFdCTWpaQ3lFa01FS0NYUzdLWGUyVGtGenB4YmpIZHI0c1M5eVVGSlZjRkp1UXcwSkdSOWM3eG9RZzVKTG96dWowckNzMU4yVFp6cTNCOCtzV0tCb1l6ZlpqSG51NWFDSEpEcUljaFBCeGtDYitrYVVKajNzY3VVVXptZW1JS01jYUhORWMyY2xMT2M0YVUxRld3VTJQQ1k3VERoSFFJYXdEUW1JWnN2ZlJtTEswRnhiay9wQlRadUJNMllsQXMrWjRKR1orOVdqVmJVMlZLbWdTZ0VCYUVnb0NWRHZVRElGU1Q0aysrOXM0NC9KOHVPRnBkbGNlUGxzdzlNS21KVjRTZExKRTVGQkFGbkJHdDNHblZvNFNPSWpvaG54emp5VEZsamtuVkRHaFV3ak1HbDRhVkhpM1NPZko1K0tIVy9zVmg0MDVmUWNSRWFwbzB2OEFEMWlOU3NqZTdaODc2eHdLamh5L3FXUjZpcU9pSGlSWGV4eEpPZnA5WTdpRVhCTCtGT3AwQUh5aHBNU1RTQ2xCemRQTSsyditJOCtVNVNkeWRuU29wZEZWU0JjSHB4NXhuTVhpQkpVcEtsQUtVUVJZWkU1Qmh4dmJKOVkweVFjemMrN1dLRzBjQWhmNmhRbXNhcXM5aEVuWGJGeVJ0V0QxbFlROW5JWjJmTFE1ZXZBY29HVE1JS2xURGRMQU1sNmdwVFVxWmpvQ1BNRGhFUjJrWlNqMzRVbE9TUUxrbCt1VE1QOEFFUzFHY2xTWmRTbElTU3E3SkJCZGkrWXpBdmZwREtNby9iK1RudXkrVnBtTXBKb0tDa0txVW9WZUhKbVoyeUhPMENaektJUGZWTXBZUzI2UXR5ZkU0SkFha2RZZ1JpNWhVQXBCQlNDb2szSkJVRWtock8rclptQ016Q3l4THJVQWJKS3MzTjA4R1kzSmYxNXNsOE5pOWpKOHgwVkxLZ0hxSjRseURZWmtPUFNDV3lzU3B1OHc2bUtBazFLSUxQYld3YjQ5SUd5WjRtSHV5dFZaU0dRVXNsS2RRVkU4QnFJN2haVTBCTXRZQ1VrTUZGS2xKNmthdVg5SDVrY2IrNXJQUmZ3NGtUak9Ld3hscGNVbFRLTCswTHRtb3FJSDdpSE40Tzl0OEkweE13RFBkUFVYSHVmMGdiK0hPQW5CUU15WW1sS2xFSUZDbFhjQTJkazN5NVpXamFkcE1JSnNwU1ExUTNnTlhGL2hiempyOGFmQ1NsOVRTVnFqellwampSS1JIQ0k5NnpsSXFZVVNVd294anl6QUh1a3JtZ3BaMlNraHdlYlpuaDZtSUU3UmtWaFpscGNoeUV1QzlzdEd6SEcyY1U1dTBEU2tBSllGNlhkSnVkRGwvaUtpSklXb3NhYjJERXVUeHZiaFo0OE5ZN3R5TGhxVmpETlVvcFNrbEtYQ2FxUUtUYWthbTV0MDR3T3hFdGF5Vk1ibG1PWUx0VFlaMjRES0x5ZGlrM1NlN0RFRnpkdFEzdERMWDFnbGcxaVVRaytKSkdSWUx6WlJ6dU9mRGpDODR4K1VOQlBzbGhWb1UzZW5JQ2hzdmFVQWVBSlBxOGJRQ01ac3pGeWt2Tm5MVFNseUFYS3lUU3pzSHpZWDRDTkRzSGFZeEZhd1NCWUJKYXc0bHRTWGowZkRuTGo2KzJSbjNvS05HYTJ6ak44N3BJQkF0Zkk4dVlqUVk2YlFncWJLTWhPTHF1WEp5R1l0bmM2WitjUS9Vc21vdy9JK0Jkc0p5Tm9MQ3hva0FPNE5uSUJmcDllYmFPVVhBSXlNWXVXaVdTeWkyU2k1VXpXTEpUcVNRTStCalk3TW5CYUFwSU5Od0hzUzJyYVJYd01uN2FUWU15MmFQc2hLVVo0SUJwQU5YQmlMUDVnZWtiVXlRTWtodzVIVWpOK01RYkx3Q1pTRUpBWWdCK2FtRGt4Y01jWGs1RmxseXI2RHhWS2p6YnRoS21JeFJtS05sb1N3eWFsK0daNDhtZ09pZUZGZ3A5TC9BRnpqYjl2c0hWSkMvd0JoNTVLdHB6Q1k4eWtsVlFCRFh6dXh2eEJqa08zRzdpZ3dRd3lQbGY4QWxvWk1VeFpuTFBrdzRad3AwOElEczVPUUdwYkp6YjFpdEtydis1Vnp3VHdBYmgvTUlVSFlaTERUUFF2a1dpVWtRMUVrQURXRVZpTTJhaU9mTVlQOEx4SEtVVFo3QjJEY1NTZlVreEhQeHNwUGltSkhubGJRUlFuOXA1S2JKSkovenhqYk0wSEFnNS9mbEVXUGxKVW1raHRBYkFoK0JPUjVpQW1FN1FLbXFvUWdBSDJsTFlDeHVlT1FzRHAxaGszOHlVcXFuSlRNYzBzQVdHZEt0Um1RTFd0NUkzVHBnY2t1d2ZNd2lwQ3U4SVVVaXFyTmRuU2tPd082QW85SGZXS0pCVmlGSlJaRkJXc3BPYk9BUTVES1lnY2JIckYxQzUwc2dyV1ZHd1lxWUg5d0RscWh1dGtMdEFQYndXa2hnRWtwS1ZnV0ZzaHlaejYrY2RHUDFTT1NiWHNhbVFaZGxQVlFuamttcDJZNjI2MmdGaTltL3dETUNsa0FNYlBleHZTUzF5TXZmckFYQjdTN3NrZ09TbWtoeU1nenZjNWZ3MFhaKzEyRXVjQ2txVlVsYU0yU0ZFcHYwTGVrTkhET0QwLzcySnlzS0ZXK2tkMms5MlNDYnV0SVl1czZraTc4MmpkOWtNUkxtVFdtcGNwU1ppeXBpTW51aHc2VUZSM1E3OFJIbStCeDROS2xLQUlJQ2pjRWlteEdZZDFFRnhvSUt6c1NFQlJja3R2Sk5pMlRwYklVL0RXSnlUaTBncG0vMmZ0ZEtWVENtYkxYS1NWQkl0S3VrTFprZ1pFbHJNWFBOelBoOXZMWE9WT2xsalFBVXNWN29BcVZ4QTB6MTFqemFXWENjdjNKRHBlbmlDUFBLTjMrSDJCUlBucFNGS1pMckpCWnlMVTUrZVhIcUZiZkpJTmhMRnlpQzdGbGJ3czJmS0s1RWJmdFhnS3BZV0xsUHcxK3NZMm1QZThiTHpoVDdXam5uR25vaHBqc1BhRkhUWWxIejZxWS9ud3Q3aEJUQTdKbWhhU1hUdTFnNU53ZDhpOFNmbFpTRmkrWEVQbHJ6TC80aXZQeDZnc2xKSWMrZjM5SThoeWN0UkxoenZKcVhyU2lrQ29GZ041d05BV0xFOGZLS09JbWlncUFMbTVjZ1ppd0ExR3VRTm81TzJxNkdGeUV1ZlZ2bEZFTGU1SUo0TmtPZWtTakI5dEdDT0IyZE1tMFBTbVdSVTU1R2s4NnVYQnVzZXA3THdrdVVnUzBESUI3WE5zeVJhUEpFWStaVWhDVktzMU43QzlnQWJBUEhxMnc4TDNNbE5TdDVRYzFLMU4yZVBRd05XVG1WdHE3VVN5NVZ3bzJCWXNxOXc0OEpBMGpMNG1lcmVDVWhSTGxuYTJoMHl0ZUxtT20xVDFocnRjblE1aG1QM3l5aTVzN1lDNWlhbHJNdVNCZGY3cjNvU015VHJIbmVWazVaZGxzVWRBL1oyelY0aGRFc1ZLLytvZW8zNEM0MTBqMGZzanM4Q2RMbFZDYXBKSldRQUpVc0l6U2hJOGFuc1ZISitOZ0dHS1RMUjNVaElseXVUVnIwZFN2UElldWtTYkFDMXpDZzRneVJZSVRJU1N0ZGk0cTB5NUNJeHlTK1c5Ri9ocEt6MWpGNCtWS0R6SmlFRCtwUUh4Z0JpTzNHSGNwa0ptNGhYL2JRYWY3emFLT0M3S3l3WC9MS1dyOStJbUFuclNLdmxCMUd6MXBUdlRVUzBqU1doS1FQL0taVVI1TkRjaWRJeGZhN2JPUG1TUytIVEtscWExVlN6ZkpSQUlBMXRxMFkzRFltY2wzbG01ekJCOTJjZW5kb2RueTNSZFMxRzlTbHFYcG81WWVVQ3BHRGxCWUN5QUR4SStkb1Z1TkZZMnVqQzRuR3FTcnZDQ0JrQXhjQzFxU3pBNXY4V3RGUDdRVzNVQzM5Vi9RUjZOMm83TDB5KzlrZ3FwRzhFc0MzN2dBR0xkSTg4eFhkcXpBUCs1SVB2RVNiUldNckJVL2JrMDJDbVBBSi9rL0NLeTF6MSt5cFhVcUE5Q3dqU1MwcEFzdzZNSXE0aFNldnFZeWtoclpuRHM5Zjdrb2YrcC9jSVgrbThWS1BSUHpMUVZtNGtESWZMNFJXNzRxSURaL2VaaCtaTjJOdzZVUzBrcFNFcUdyaHlDWGN0ZHg4Tklzakh2THFVZ24ycTZXSkFKQmZpWDV4UXg2VnBOelpuZlJ1dld6eFJPS0llc2xhRlg0MGtGd1J5ZlNOd1U5a1pxdGgvWldJQkZUdW9LREFJRmcxUUxseHJiazJSdEQ1cktTNVNONjE5NUtUZTdGbTkyVVVjQk9Ta29tcFNvR1lEY28vVFRTa2lxbDgyQTlCbEUwemF0YWxXU0JjcUxKcFRNeXYxRDJiVVJKd2ZKMEpZQzdRWUVNS1dxZHdsQ2JNU2JidnRYR2JPM0dCZUcyZlVpb2tBdmtTeXIyRzZwcW5JekI0eHV0bnRTVkw3c0ZDbnl5QUYwam5DeCtEckpYUWhTRHUzVDdJSVpnclhJKzdyZVBsT1BwZitRT0pnWmN3b1NGT3gwRFpPOTcyMHQ5dnBNT0pobzd5Z3E4UVc0QVdDR0FGbkpaN1FUbllKUUZVbE10ayt6dTc1TGtsU0czWDRKYTl0V2dSaU5qcktqVWxLVUVNVFU3S0k5Z0FtOVhIcGFIZVdPVDZBcWl4Tm5GSzFTMUlBVGtsWXp1QUF4MUFjeHEreFcxUHl5MHJLUXNPZGJpOXlPYk1OREFIYWdRaElTUzRDUUFCZXpNU0FOTFA1SGdJZHMzRktTVGtRd0xwYTlJZTdGeGtIRWMwbTVSdEI5ejNGSGFuRHprTlVBVFlwVUNEMGJYeWpOWXlUUXRTUmNBMjZHNDkwWkREWW9ZaWJMVDNkS1FVZ2hDUUNxb3VTNmk5UTBHVitjYWZFYkk3c1ZTc1hZWDdxY2hTVkVETUlxWW55ZU96eGZJY0piOXpUZ3BMUnhRUEtGRXdoUjdObktmT3M1SkJOM3VYenoxaDZKWlYxaDZabzFTNWV4dkRqTGU5VzliU1BQYkxDa1M2WEp0WTJiT0prVGlxNVpqWXMxWGx3aXQzNUxBWjhlTHgyZExDY2pVK280NmlBMWZZU2ZCSi9VVG5iUjI5OGF4SVNVdjgrdVVaQ1hQWUUzZlRseisrTVhkbUxKVldic2ZNOGdmbEFiYVFBN2dzV2hOUzVxMUVDd1FrVktiTE5qU1ByRXVKN2JoSUNFUzFNa01rS3NBT1R1ZldLZXl5QXRhZzlKUzdFNU1kUFgzZXFtNDlGSklJOFhMUzdPOS9QbEhLNmN0cXlzWjEwUlRlMG1KWGtRa2NtSHhnLzhBaHVaaTlwNFVyVVZiNU55VGtoZkdNZmhTU1ZCT1F5MFBtQkc4L0NWSi93QlJscElTNVRNWWtPVUVJSnFTSHpZRk45RkdLVGlrdElkU2JXejA3dHh0NmZoRlM1cVM2S3dnU3dQR2JrdmJnQ1BTQzNiQ1dsV0dVb2tzbEpXa0IzS2dIRmhuL01aMzhVbHFsL2xWSk8rWndaZVNrMGxQaHUxMzlIalU5b3BRUmhaeFJVQ0VFZzFGd2VJYzV4eHVMNHV3cHExUmdleiswUVVJU3Rkd1ZVak0wNXNlRjN0QVh0RmlKbjVvNWxPN1FFN3hwQUR1QmNYcWdsMk5sZ0pWem1Menp5RUM5ci85WXM1YjZQZ2tRczFVRWkwZm1aNm9uR21YZ1ZMbEFxVWhHNkdKTDVCMDVzSHk0Q1BLRnpCTkJDcVNTNWNNQzU2UnZNWGlFeXNEUFU5RktmRUhCRGtBM0hXRHV5dXp1SFFsSDZTQ1VwRzhVZ2xSYTZpNDlCL0RUbEZ5YVFxa29XLzVQSUpPRE5JSEtJc2RnVnBEbVd0aTk2ZDBBWmtrNURuSHZrckRwVDRVcEhRQWZDQWZhUU91V0xNeXFnV1lnZ2hpL1dMUXhiMks4OTlJOEY3OUpVRWdvS2lRQUFxb2trc3pBY2Vlc2JFZGhKeVFETVZKUVNtcGxMekRPV3NYL2lNeGhKQ1VUSmJKL3dEa2ttMU9UcTFCUDIwZTI3YWtDZmgxSmxxQ1psQ1VoVlNSN09WUWRzN2hudVJxOFVuU2pvMG0wenhYYXBSTEpST3NwS2lrNTFkR1VMQVd0d2dWSjJiZFM2ZThVcFZTUStWMzF5TVNkb3NTdVlzMW8vVVNkOEZ3b215WFZ2RzVLYW1IRTZRL1pncHBXRXFKeUtVZ3FZYVhCc2JHSnVMaEhUSlM3TE4wL3ByL0FPV2ZZWWtseFloSU45VzZqbERNVmhwSXc1TXNLUUVna1hkMG05enhaOVJsRjQ0dXNLVHUwa0pVZjNQdkRqWnVXdWVrVWhzdVdsRzZsWnVCdkVrQnI2NWEzaVVaVjNvREFtRXg2bHFsQkNBV0FxS2trZ2xOZ3djdWJock83Q0RlTDJ3c3lWR2dwSXo5bmdTYVNOelBUckdleFdMVEltQklwVUU3eVdmZFVSbVdBZFFjdGRtT3NFRmJibVRKWVdnT3BGenVqMmtoMjZFR09xZVBrMCtPaFV3ckxuS21TMExVYXF3cHlCNFNBYVRZQWtOU05ZSDRQYklYS0tWMlVFT2tHenNsbUQzVnFMWkdPYlBuS0RwSUtHRlljRDJya2xyVTI4UGxGZ1QwcHJXa2dqd2trT3hXR3RWWWh5YkRqRXVLVGFyN0JzR0ZLeE0vVUozeWRCL1VXQUl5c2NtTG5WNG5STG1WbEpBWUFYRGlwM0Q3dG1JZlRoQkRaK0VsRWd6VklCVUJNTHJCQUpTNUpZT0dJeURzd2lUWXM5RTRxSzFGa3FZTWx3b0hVbTVCRmkzWGpGSnRwWFFLTmQyUjJQTmx5MHpMbEJJQ3FRbXNONGdvc29Ca3FPZWo1TkYzSDRsWW1tVFkxSXFGM0xPUTRaUkQ2RXM5b2c3SDQrWDNyR2NxVWxTY3drWmczQ25jY1RVUVdGblp3VDNhUmNnWWlUTFhOUTRTQVpoU0F3S244WnM3TGZQWG5DNDVwTG1QVjZzQUJPSisxSSthSVVCWnUzcHIyV20xdE5MUG5IWTlENDhQNVpIZ3p5aWt0Wmg5ODRZRkVYaXlxZW9CeXg1WFlqcEVhcG9LYmNYcGJUSndkSXlzeFRxSU1jQml3dEFVemVqUTBTakZMUmg4a1pFaTJyUWN3K0xsVWQwZ0ZPcEpJYzhSQVNSTEpMY3RJc1lkUDNsRXA3TWFUQlNXU1ZxREZRWUN6czd0OTJnQnRXUUFwU2trQU94QXRmcXdHc0c1K0pFeGtzbDJMQU83TWJoV1JEc09FRDhYZ0JRSmlmQVhBSTlrZ3NRZk1SSEF2VnQwMzBQOWpaZmc3c0NSUGxZdWJQQklRWklTeGE1N3duUi8yNVI2RjJYMkxoa2JSVXVRZ2dJQUNUdm01UW9LY2trYWozZWVML0MvSDA0S2VndHZUa0RQMlFoOHN4ZVBTT3d1RkZNeWNsRExKS0ZHb2tLcFlnaEpESnNidDV3a3JjMlUvd0JJL3dERVJTekxreTBTeXJ2SnFBU0FDUUF0QllhM0lHV2dNRisxUi80U2QvcytZanVNbnNVbFpTQ0xwZEx0bzQzb3hIYUxhYzJhdFNVVFZVaXpBa0IraGNRclNkMHdKZEZic3hJcFE1MUtpT2hNQ05yNFkvbXlHdXBhQ09ocGczc3ZEclJtc2tYczRzZDMrbUNrdVdDUVNIUEVzVDZ0Q1pJTHBzdENUN29vZHJYL0FOUHhJR3FOT0FXa2srZ0pqMG1TTjBYZXd2eDV4ak1ZVTl6TXJTRkpvVVZKSUJDZ0FYQkQzQmpZWVNaVWdIa0lFYXVoY3QwVFJrOXNCOFphaXFsUUFVa09mMDM4V2JBdC9kR3RnWHREWWN1Y3VwYUVIcWdFNU5tYy9TTHVORVV6dzZaSVBlc0FibVJrQ1NQRVhZYUM3dHgxaS8ycDdiclVRSmNwRW8wTW9zQXNsUEJYc3BCRnRkZUVlcDdXN015VEpXbEtFT1VsSWRFc0FFZ3BDbkNIY084ZUpkcnV6YzJVcE14UWRJQ2ExSUlWdm1weE1zR05RSUliUTM0VGNVM1RLT1Y3Um5NZml5cnZGazByWGNYSk4zTFBtMlhwRmpZOGpFSlNWeTFWTHNWQlRwREM5S1NjMWRQcEZqczloa0tKVVZCMWFVandnc2N4YmxGa2JJbnlWcVJMWCttWFVFa2V5b2xtVWJGV1Y5ZVR3czhpM0RYNUVhdlpWbFNadFNsTWtGU0FHRmdsU20zanlzVHd1YndiTmtCTTRWRm1WY2J4RE9sMURteHRaM2laRXRMcUlDbEtGeXhTQTQzaUwzMGUyV2NaamJjeFVxZUZFaGtFbGd0U2szSU80VGQyU0xFa0RqeGpIOTZWR2ZwMkR1MUV0bG1oSnBRQWtrZzN6cE5SenNNNG0yQnRNU3ltV1VsTmpVN3ViS3lCc0hxNFpEbkI3R3k1VTlOWktnRkpLYVNvTW9saUZadSt2bVlGNHFTRWdpZWtCT1FtQnJnbmhZWkpIVVIwd3lLVU9FbC9mK1JYL0k3RUJSQklTbHJGMVVoZEp6dUNDUTEyUEFjR2hiUGtvVURXL3dDMjVJWjdzUWVkMjV4TXVTa3JNeVdIcEtRdEtra0tJQ1J2QnJIbzJSTjRqN1FTaUpWU0F4Y0tVUndDVHBwYk5zNFZTdW85V0FLNHJBeUZrQWhLbFVqZHp0azRQQWt2bGIzbnNxVUphQ0VKcFRtS2VsM0daeXpQR00zZ05zb1pRS0Vwc0FGTzFoeE9oZlhtMFgwN1dRdVN4SkJwWWI1cUpMT0ErYkFNRHloSllaclR1aHVTTkRoNXlFQUdYdTJOMjhWZzRack9kR0VSeko2bGo5UWxUWkJuc2FUWitYeWdiZ1o5YWdoSkNSYTVCQ1dGTE96bk94NXZGamFCS0RTVkV2WTBrRWVFWENoWm41OGVjVFVHblFVN0pWNDFSSktWTFNITzZEU0JmSURRUW9IL0FKOWVsWkdsemw1Qm81RnFtSFpqKytJMGNjM2FHQlFKREpJNDZ2SFZNQStaNi9LR2lZV0xPUGxIb1VSSjFLSGhBRDg0cnFKeXUzWE9FaFY3M1BGNG1UU2V1bHZsRzZDUnBuSFFmZlBqRmlVS2lMVzVHT0dXa0E1UFk4cytvK3pITU10c2dJVjlhQUdVN0xDa0pVdlJ3S2VvWW5oZC9XSXBPMU83d3hsak1xVUFPQ1RjbjN4S25FdElxcWR0MXJabFNzMzVETVJuMXFjeEtFT2VwZXpIVW5IbzMvNGZrSER6QTZnODEzUzFtUWpVOVQ3bzlzN0Q0OUNwSGRoZ3BEa2hya0UySjBKejhnSThTL0R6L3Axbi91cS8vQ0k5ZTdDRklsdTQzaW85V1pPdlNKNXA4Ykt4anlSZDdWcklJYXV5VDRVdU5jelNXakFZR2FTa2sxT1ZFN3dZK2hBK0ViUDhRZTB3d2tzSUNWS1dzT1d5U09Lam85N2NqR1B3ZU9SUGxDYWppeWh3UE1hSCtJU0swWkJYQllwSzdwVVNidTRJL2JrK21jUG5iU1ZLSTNha25uY2RJR2JHVm45OElzNDlYaDgvbEU1eXQyV2pHdEJ6QjQ2WE9TUUM3Z2dwT2JHMXhHbDJKaVNSU1RsbGFQTVFTQ0ZKTEVheHA5Z2JaS2pjTW9laXVMUXNXMXVJWnh0VXpldWVQd2hYNG4zZlNJNUUwS1NGREl4SkhVc2tuMVp4MEsvRSs3NlI1SCtLV0NhYzNlbElJcUtLaUF1cW9Fc2xMUHVuZUwrSWNvOWNhUEsveGlUSjNWS3NwQlNWSGpZc0J3TGMyenRDWkhMWFkwRHlLVmdWcFdvQW1naGdBV1VjbkFZdG8zUzhhbnVab1RVcXdzRk9tcHlySmxhR3d6RG5scm50cVRVa0dZaGY3U2cyWStKS3ZPclRpSWsyUHR5Z0VUWFNGa2thcEEzUTJwQkplOFR5eG5PS2trQzBtTEVZcW1idkthYTdPbE5xR2NDck1LSnpQTThJT3lPN1VDaWNDcDBXZExoUnVmVGROK0xSVXhPR0U0RktHV3RuREZ3ekVnbTJvUHY2d053ZUpWMzVUUEpDd0FBa0tZQjJ1R3orRm9SeDV4MTJ2OC9nUFFSbllLVktZcHJjQW5NdUhkTzdjQUZ1R211Y0R0b0JPSWs3czEyS1hMKzFsdmNMZStEbjVVWnBKQktSdlBVNE4ySWYzd0htYk1SVVpjeFNncWFRb0FJM1NRTGJ3RmptZVhLQmltcnR0MmhXZ1pzaGMyU2xaSWVXcFFDMVhKenVybXpBazlZTDdLeDZaeVRLc1VyQlFxd3NLYzZ2UE5obEF6QjdTL0x0SktTYUhDblRVTEd6QU5ucjAxY3d6Wk9HN3lhSndDVWlvbGc5N2s4YmEvU09uSkZTVGxKZlpnVEl0bTRHZEtXVWdnRzRBczdtM01CMkI1aUNQK2lGWVpSU0Z0bTNoSllraExYc1RrYmRZay9LcVJOQ0FpcENnNmxraXBJQnNvS0xGdzRGM3lpZFV3eXdGS0E5bW9qZHVXdWwvRU9qYXdzOGttN1RWbW9od3N0Y2xacVdDS2liRFBldWFiczU1eE9tWXEvNlpxQmV4MHZaeDdMMzhoZXpSYlNzS21BQUVFSlZad1hJQmF4RE9TUmx4eUxSWkdEQ3pZc0RZZ2huTHNlZDdXZjJ0WWo4VGUwT2tDdTdrbTYxTHFMUHZHRkJ3OWxKdWdRMmpoUjk3d29wK1NsTThtS3pIVXJJeWgwakRxV29JUUhVb3NCR3Q3TWRnWnVLbXJRcFZDVSsxWlRseUd0YlRyZDJqMHBTakZiT2RKc3lOVm1hSkpFdFJMRFBxUG5CM2EzWkNaSm1tVjNpRnFTQVMxUVlGK0laN2UrRzlyK3pSd1MwSXJyS3BTRnFkTkxGVjZSMGhlY1hwUHNOQTZaZ3lrT1ZGMnk1bUhiRW5vVE9sQ1lrS1FWcENuSUc2U0FRNmlFZ2N6cEVXRm5LV1VvY1pwU0xCN3FBK2NNbTRWMWxJdmRRdHdEL0FDRVpMMmtaSTJQNGg5bC95aktsSVVKS2pjMm9EM1N3ZW9aa0VtemtObTBZaVk0SkJESGhsSHV1STJ6TlVNRUowcElYT2xVekV6R0JjQ2xYZVMxRjJMVkN4WUtMdG5IbVBhZkIxN1JuZ0N5aVpqNU9DeEpIcVlqaHllekhsRGVoMkJ4YTVXeks1YWlsUm5FT0cxTGE5STlSN1A3V0FLWmFsVXk1YVNWaHpkUzFib0REalNZd3V6cE10R0ZNc3BjYjZnRkFLRGx5UHRvdDdFeFg2eVNzMnFTVjhDQXNaalZtSG0wUnl5VWxhTFJpNHVtZWpkc0ZDYWhSWW1vTVMxckJZVUg4aUl3SFpraVZNbnl3MUNpR0ZRY0VBNVBmaDZRZjdRN1VxU3dkbDFxTDU3eG1uVEt4K01aYkJ0M3h0bC9FSkZ0Yk1sZWpUN0VWWS9mQ0xXT1hsNXhRMk1iR0xHT1ZjUktYUlJka1pWRnJCcklBSXpkNG9LVkZuQ3EzZldOajdEazZOMTJaMnNEdW5JKzVYME1IdHNwZkR6cmtIdTFrRktpa2doSklJVUM2VHpqelBDNG9vVUZEekhLTnhJMnhMbVllWW1zVkdXc0JpSDhKMDR4MFkzeGxUNk9lY2IyankzWkcxY1grYWtKL056bG83K1FsdS9VUXBKV2dLY0UzczdqckI3OFl1emkxb005SzFGckJMRlZ5OVNqb2tOWWRPY0FqaFNuR1lZRUtTMC9Da0pWb3lwVDJld3VHR2pSNmwyeGxJVktwVzdFdFpWSXZiZTVlK0ZsTDAzOVRQNWo1aXhoQmxoU2pTRTdvUUJxd2RUalJ3ZlRoQWZ2QXBia2xqbnFXNWFQSHBIYmZZTWtZY3FUWXluQ2FiSkxxRGtocnZmMWp6VlNHanN4ZktSa3FadE96b3c2MUFZZFMwTFNBU29sUnFPVEZJWUhPM3VlNGliRjBvclVoZi9FQWhTcWdNaFpnUUhBZTl1SXZBL3Nqc3NwbXpLaHZKU0FVdUdJVUh0eDZ1R2p1M01QTkJNNllvQmdFMkw3dGdRUUJkeW9QNVJ4engvdTFldjdvUHNIWmF3RkNxemdlSE5iRXZscTVKWVIyWk5yUVUwT3hDazFFVitiRTd6QU5ZUEFEWiswVTNRcWFEY0JCdXgzTTNKdGMzaWdOb3JDd3RIZUxRVWtKM1dJenR3TEhVWi9DZi96TnMzSTA4OVVwQjczdXdzcVNDVkpja0VPNFVNckE1anBBZloyMjVmZUZDZ0phY3crYjZna2xtemJKM2dyc25hQW5oU2xzbHp3c3BXVitiTmZvT0VDZHQ5bVZ1WnFCdXFKS2d6Qkk4bkpPWk5vMlBpbTRaTk0yK3czTTJtaEFTbW9YSXVOWEpmNWE2Q0c3UkFWS1V5WENHcU5WVlNWSk5XNjI2QTQvdE1aS2VWVEZFMUpxVFlNR2V3TGhQTXY4WTBHd01UaUV5eW9pcEtTcEpmTVpXSTFUdkU2NVEwL0g0TGxIc05saVRZcHFDRHVtaFY3aFJkbkZpWE9mOVJpMHRLbFRnUWtnVTZDNmptT3VlbCtzVnRrb1VxcEtVRUlja2gzWkxCeWs4aWN4ZGpCN1p1SWZkV2lxa3FGSUxaS0FGd2I3b1lSR1duYkNpV1gyZnNIbXpYWVB1dGRyaGlYRjRVZWtZTmpMUVhKZEl1Yzh0ZWNLTHB1aDlueTdzbFlFMUpMc0Njczhqckdyd20zY1FnTkptaVVudk84MEpLMlNMa2k0M0J1bHdiZ3VDWXlzdVJUY0VFbmhFNlNZNzV4VWlLYlFiUWdkNTNpcHhtTFVYVzRJU1E3MGxTaUxXR1F5c0lXMDBpZW9xbUxXWGJlc0FBQUFBSGNuTGhBbEVTdjE5WVI0L2V4aWJENFhEeWxvbUF6U1VxU3B0MW5TUVE5citzSCt5bUp3cUp4V3RESkFVYWxwQ2lsWjFCT1Qzc0l6b25BSHdqemMvT0ZNeEpWbWJjTWdPZ0ZvVndrL2NDMGFqdFYydDc1VXZ1cHN4MEF1cTdQWmd4c2RibDR5K3pzVk1NOEtXYWl5azNJRmlsbXZhSTJFSTlJMFlxS0RiWVRWdEJwU0F6dW5QTHpncnNTY3kwbm1rNTZWMysra1pDWVNUY1c1WjVla2FyQjdVbGlqZXVLTFoyU29XaEpZMVdpa2Ntd3ppWmxRZk1iMy9zaXJoUnZxSjAxNDVSRE0yakxwenV4ZlBJMThPc1d0bktTdEpWZTZpQjBEUk9VYjBobzY3Q3V6WnlVcExtSXNadE5EM1ZrRDlZcXpiSk5JTHRhemk3K3NaUDhBVVVTQURtMXdiZVdjVCtHMzJNNXBiUnJWN1RSYmVGL24vaUx1Rng2QUFLZzcvSG5IbnM5UzA2S0doZlErUk9rV05tNDFxUVFxeHpiNzVRZmd0YlFQaWN0TTlJRTlKeVVQVVJSNzRwV1NORGJYNHhSa0FLQUlPY1M5eW9hKytFYmswUEZSTmpKMlBMbXBSakN0WVU2RnE0QXl5TjNLd1pBRVFkcE8xM2ZrSm9LVXBMNXU1NDVDQld3ZHVHVTh0ZDVaY1V1MmIzOVRGTEdDVUN2ZUJGbWJSNzhYdGxFbnpYMkdTaS91VmUwR0pUT2tMbHBERlExeTB2N293R0k3UHptTmttMmlodzV0R3dYTUVRTFhIVEROSkNTeFJZVXdaUWxLV0thbUJOdzdtNUhyRlBiMGl1UXNBT1djZGZMN09VRDFUSWhWTWpjbTNiQjhOVlFQMnBzcjlBRlFBbXBjcUNSKzdpRzVlc0RObTdRbXlVcVlxQUlMRE5JVXo1Rnc4YTNaNnhXZ3FGeWZOaGQzNFdGbTRRQjdSTlVvSkxBTGNBQWl4RGtuek1VaGs1K2lTT2VVYURFdVRMU2tUNVlBVVFBUTRVRXNqMkNIQmRRSHhpM3M2Y3NUYUZNU0pTU1UzekpzR2RuWThOUnpqUDdBeGNzWWVZaFp1Vk93WjdBQzRhd3NBT1pQR0R2NGVoQ3NUTkswbFFYU2xJczFnUVhlOWlCbDg0bkxIcVYreGxzSW8yWWp4Snc3N2hIZVplSFY3aHd3OC9RRTltWU5Ta3AzU1VxTjdnM0RnS0xXNCtSR2JXMTI2ek1XNE44b2dscmxvc0hTQi9TcGgxTFdqbmF2YlpUaVpqc0xzZGFnSnRSQ1NxY2dnTjdLbEl5TDN0N3hHdncvWnhLWnhtdlpTMUxZQm1LaTQ4dVVabnM1dFFZZVV0QjNsR2JOV2lXbnhLN3lZVkJ5YkMxK2hqYjdIeHhteWd0U0NnM0JTYnMxdUF0RlBTMkJVWEEwY2hla0tLQlBsRUF4SWlhb2FtSFVSTkl3YWxBcXlRTTFITGhiakhmWkZFZ21qNytFUEV5SVpvRmdsMkdUNnZtVzBoSWpHWk1rdzhRMEs1RDArc09RSVd6RHdOWEVPQWpnVEVxVVFyQ2NTa1JJRWZmM2xIVUpqb0VBSWloOVlta1RGSThLaUEvay9TSWtuV09sWERQNzFoR0VmM3N4eW9MVnZaNU5aOG9ZaXQ2Z3RRUEl0L0VOTXdnT1Q2Q0dxVnE4QXd5Zmh5cFZSV3FyaTdSMVdIY01wYWoxUDBoc3lkVGZQaTBXcENrbDkwbHViK2tIWUR1SFdVTlNvMnl2bEZ0TzE1b2MxT0cxR1hUbjlJaDc2VFlpdXJrM0xJazh4Rktjc0tDbWR4WmkxejFlRjRqV1h2OEFVRkZ4bng2L2Z3aUw4eStrRGNJVkpiT05ac3RZV2k2UmZrT1AwaWVTZncxMEJUYkFINTVpMTRiTjJtV3M1alU0blpTRkFBb0RuSmd4Z1hON09wY2xLenlITDV3aThpRDdNM0l6NXhLZ1hCTitNZC9QazZSb1oyeEVzMmRnQmI3dmVCT043UHFIZ3ZmTWl3SGx6aWtNMk9XZ1hJTFlJcG5pVWhLNlppVXZ4cDlseS9BNmRJcVl2RG1hZ0pVcElOYW5ZQXEzU29XZTdYOURIT3lFdnU4WVV6RGtsUTRnM1NRM1VYalo3V2xZZFEvVFFBU1VyU1FtNGQzTlhtL21ZbE9zYjE5dzhialo1bWNJQXFZRWdxb1lsUXRTQXFuZTZ1STBQWi9iQ3BLVWxNdEdTcnM1M2lmNDVRU1ZoTjViak5CUVNDNUlxQlNTNFp4dmV1c1JUY0ZMWHVsQkpRbElUN0xnYXVHRDM5MEdXZFNqc0QwRzVIYWlhc09SU2Y4QWFXK2tWTVJqWnFxdjFXZXgzaVJjR3hCTzdGSVNXVlNCVGJ5NjVOeno5WW5TaXhJR1RXc3lyQzF6cDdvNW0zN0M4bU1tQllUdUJMMkFQTzNEbGFDK3c5cnpKUlVraFZKc0RVVkcxZzRKYXplZkhTQmMwNWNybjQzOThXQllNSFBISThnNzlPZXNJMjZNbXdvZTFreityKzB3b0VGWEZQdVB5aFJyZjFOeVo1d2tYRUVkcGhxUUxDeFlXRDBKTHRDaFI3UUVVaER5ZmhDaFF3Ui8xaXpKRnY4QXlFS0ZBTXlmRnBBV1c0L0tIeWtqdXlkYWhmeU1LRkNNSTJYcDV4MUdzS0ZBUVRpY3ZQNlF6UXgyRkFNUlRMbS9FdzJha0FXdG5DaFFvQ29zN3A4b0lZWHdUZjhBYVBuQ2hRejZHaDBMSEJsSmJoOHhGakNEZDh2bkNoUXBpbE44WG1maEJuWXlqSElVUXpmSVQ5elV5ellkZm9Zamw2d29VZVovSlI5SFVKQmQ5Q2x1V1dYckhFZUgxK0poUW9xdWgwT2t5eCtZbDJHWjA2Ull4UTNoem1JQjZYdEhZVWFQeW9lUHlnL2FpUlVxdzA5NGhMU0tVMjBQdWVGQ2d2Mkl6N0hwR2ZuOFJESmlSUUMzRDRHRkNoVjJMN0VTTG92ZDVaZm51alBqRWM0TVMxdDBmQ0ZDZ3JzRExjdFJiTXdvVUtFZlpObi8yUT09XCIsXHJcbiAgICAgICAgICAgICAgICB0aHVtYm5haWw6IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndDRUFBa0dCeE1URWhVVEV4TVZGaFVXRnhZWEdCY1lGeGdaR0JnWUZ4Z1lHQjBZRnhjWUhTZ2dHQm9sSFJZYUlURWhKU2tyTGk0dUZ4OHpPRE10TnlndExpc0JDZ29LRGcwT0d4QVFHeThsSHlVdExTMHRMUzh2TFMwdExTOHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMZi9BQUJFSUFNSUJBd01CSWdBQ0VRRURFUUgveEFBY0FBQUJCUUVCQVFBQUFBQUFBQUFBQUFBRkFBSURCQVlCQndqL3hBQkFFQUFCQWdRREJRVUdCUU1DQmdNQUFBQUJBaEVBQXhJaEJERkJCU0pSWVhFR0V6S0JrVUtoc2NIUjhBY1VJMUxoWXBMeEZYSWtNelJqZ3NORG9yTC94QUFhQVFBREFRRUJBUUFBQUFBQUFBQUFBQUFCQWdNQUJBVUcvOFFBTGhFQUFnSUNBZ0VDQlFRQkJRRUFBQUFBQUFFQ0VRTWhFakVFSWtFVE1tRnhnUVVqVWZDUlFxSEI0ZkVVLzlvQURBTUJBQUlSQXhFQVB3RHphYnRCSVNTazd6a2RPYjZ2RlhaN3BLVkVicWxNSDhKME9SRE0vd0FlRVZjSXRBWHZnaFBSeTR1TGRRM1F4Y3draGE1Z0NrS29mSk5pQVhiVG1mVXh6MG82Q2VoN093dEtBSDBjOFhPYm1KaWkrVUN0aVl4RXROS2lxb25JK0s1c0ZGODc1TU1vTVNTVHZHM0xueGowY0hreG5TWC9BSVRsQ2hwazhvaktZdENiSENCSFlteWRGWWlIQ0pGdEViUXhqa2NJaDdRbWdnR1V4Mm1IdENhTVlZRXdxWWUwSm93UmxNS21IdENhTUFaVEhhWWUwSm94aU9tRlRFalJ4b3dSbE1LbUpHaE5BTVIwd2dtSkdpbmo1cldjQWF2azJlY1E4ak44T05qUmpaWUtrNmtCdGZQV0VsUXNPcEhPQmtuRW9jQUY2dDRXR2RsWlBkOC9UTEtIb21xUzVGdzdIeXpMMkd2dWp5bytlMDFmUlY0d2lVUnltSG9JSXR3QmpyUjdFSnFVVTBSYW9qcGpsTVN0SEdockJSSFRIS1lsYU9OQnN4SFRDaVJvVUVGR0xuRkNaaElTZ3FwREZnVW03MnZjNmNvNmlmVVdRVWhLVHZLU2FTWGZ3bFYzT1dSZ1JzN0ZOTkRrTVFROW1lMXlZc1l1UUVWSVFsUys4WlNkQUdPZFBCOHVJQTV4ODA0VTZaMVdYY05qVjk4SmFYVXAyZnhCS1AzWDF1Ynh0azRoS2FVamVMRC9BREdHMlRzeGNzOTRvVkZsTWx4ZHJhNWpsempRN0x4RmFrdUZWT0hCR1JBZHM3Znowam93Wll3a293VzMyeFpMV3crZVFpTXhJTTRldVZIdHJSRXJtT0FSSlRDcGhoUmpRbWg5TWRwZ21HTkNhSktZVk1ZeEhUSFdoN1Ixb3hpT21GVEVsTUpveGlPbU8wdzlvN1RHTVJOQ2FKS1k3VEFNUnRIR2lXbUZUQUNSV2dYalpSTlNGQ3BKNWdXT2c0bjBpOWkxczQvZFo3MnR1c0c0ZzY2Y29DeXBxM1ZVbGdsVmlXVUFubWZPOGVGNXZrckl1TmJUT2pIR3RsT1RoMXl6U0ZiZ3pEMGtHd3Z3eWErb2k5M3dBS2xPMVRXM2Q1Z1FEZTdqaHdnTHRDYk5SNFU3clBVb2dVZ05ZM2R3ZE5ZVW1ma29sMHJBZk1sTmd6OVdQbUk0bkJ5VmozUnBjTGllSTBaUDB0NVJvTmg3UE01WVNBNEFkVEhUcnhPVVl2QllxcFhFWHpjTnJhMnZEN1BwUDRaWXFUV3BDbEVMS1JaV3FyMlRhekM3ZE9jVXg1OG1QMHAvOUc0eDdZRXhtSG9XcFA3VkVmYlJCVEdtN1o0SUptaVlrYnN3WnRtcExCL1J2U004MGU5Z3ljOGFrUW1xZEVUUnhvbGFPVXhZUWphRkQyaFFRSG1td3NDeEtweVNFcHlTUXpuay9UaEJ1Wk5yUVZpV0V1NURpOW5VR3FMZ1pNV01WTnF6NkFVRlNSVjRhV0pacnVkQzU0OG1nVmdKazVaYW1wSURVbFJUWWdzUnpERnVFZk50T2ZyWjBsdkhZMEs4TmJGTytSd1VMQjJzSEkreVl2ZGtKeDc1S1NvanZMcEpZZ3NEWWh6cGJPMEQ4SHNpWWFndVlFaVdReVM0SmNXQUpENUtObWEvT0pxU1o3SU5Vd0dwWU4wZ0JpUE5qcHd6dTBXeFRqQ1NyMk0wZWp6SkxSeEN0SVpoSmlpZ08vQzREKzZKa29lUGNpN1ZuT3hpcFo0UnltSldJNHdxakRKaWtWTUpva2FFRXd3QmpRbWlTbUdxVUFRRG1jdktOWmhyUjFvZlRIYVl4aU5vVk1TVXdxWXhpT21PdEVsTUttTVlpYU90RWxNY0pBaEp6akZYSjBOR0xmUXhvVk1jbVRRUDV5K3NWUHpEdU5Ea1VrTVMyUU9aTE1lRjQ4L04rcDQ0YWpzdkh4cGUrZ1Iybjd5V3BLMEVrR3lnUzlQUVpnSDR0eVlZbkZsUzFvWHVwV0FBb1hLZ29nTUwzdURxOGFHWXBNeVd0S21HaEJ0a0JmcGZQSjR4L3dDWmVlSmFxZHdxQ1ZNQUFDbHJod2N3T1BrN3g1YzhueDI1MVRMT0NpdE11S3FTcFNWbFV5a0NrMHNHTG55WmhiUW5qRklTUVpkcVZCU2lwVEVBcERra0M0L3B6alJUY002QWtrRlJTTFhkMjFaVjJMYVFBdytGcENsVFNudTFySnBBdVNhYnVjblkyNXhMSE5QL0FHRmFKc0ZTN01BbFJCR1J1TFZXMElWd3plTlpzWEVqRHkxS0NYbXJJU3lFaHlBN2dFdWZKaGs3MmpQWVdVbEpBQUFTQ3dDZ1dOaDRpMTh6WnN5QnBCbloyRkU2WWxLeXBLVlRMS1NPSjhZQWUzaTlCb0lXY3ZVTWpmWVRDcW03UFVwWVhXQ1ZwcUtpd1M0cEZWd0FISGwwak1LVU9JajB6RGZsd2tTRXFFMmpjVVNRcWtpeGVvN3NZSGFHRU1xWXVXZlpKSGxwN21qMlAwK2RKdy9KSEl2Y0gxY0FUNU44V2psK0E4ejlJc1V4eW1QVElsZWxYRWYybjZ3b25waFJqSGprcWE1Y3BLMUd6Tlp5Q0RscTk3UWYyZnMrWktKVXBTQVFEWXFUbTJSQk9kOGpFTWllZ1RtV1FsVEVrc0VuZzFudjV2eGlwdGFmTFFSTGtxcjNuVVdKTHNMcEpBYXdJYnA1ZlBTYm0rS09oQktianl0Umx6RmdKZHd0R1Q1NXNEZG1ab3M0QllLaWlYU2hTaXlsRm5PbDFDL0V0eEhXQk1qWkN5RWtNRUtDWFM3S1hlMlRrRnpweGJqSGRyNHNTOXlVRkpWY0ZKdVF3MEpHUjljN3hvUWc1SkxvenVqMHJDczFOMlRaenEzQjgrc1dLQm9ZemZaakhudTVhQ0hKRHFJY2hQQnhrQ2Ira2FVSmozc2N1VVV6bWVtSUtNY2FITkVjMmNsTE9jNGFVMUZXd1UyUENZN1REaEhRSWF3RFFtSVpzdmZSbUxLMEZ4YmsvcEJUWnVCTTJZbEFzK1o0SkdaKzlXalZiVTJWS21nU2dFQmFFZ29DVkR2VURJRlNUNGsrKzlzNDQvSjh1T0ZwZGxjZVBsc3c5TUttSlY0U2RMSkU1RkJBRm5CR3QzR25WbzRTT0lqb2hueHpqeVRGbGprblZER2hVd2pNR2w0YVZIaTNTT2ZKNStLSFcvc1ZoNDA1ZlFjUkVhcG8wdjhBRDFpTlNzamU3Wjg3Nnh3S2poeS9xV1I2aXFPaUhpUlhleHhKT2ZwOVk3aUVYQkwrRk9wMEFIeWhwTVNUU0NsQnpkUE0rMnYrSTgrVTVTZHlkblNvcGRGVlNCY0hweDV4bk1YaUJKVXBLbEFLVVFSWVpFNUJoeHZiSjlZMHlRY3pjKzdXS0cwY0FoZjZoUW1zYXFzOWhFblhiRnlSdFdEMWxZUTluSVoyZkxRNWV2QWNvR1RNSUtsVERkTEFNbDZncFRVcVpqb0NQTURoRVIya1pTajM0VWxPU1FMa2wrdVRNUDhBRVMxR2NsU1pkU2xJU1NxN0pCQmRpK1l6QXZmcERLTW8vYitUbnV5K1ZwbU1wSm9LQ2tLcVVvVmVISm1aMnlITzBDWnpLSVBmVk1wWVMyNlF0eWZFNEpBYWtkWWdSaTVoVUFwQkJTQ29rM0pCVUVraHJPK3JabUNNekN5eExyVUFiSktzM04wOEdZM0pmMTVzbDhOaTlqSjh4MFZMS2dIcUo0bHlEWVprT1BTQ1d5c1NwdTh3Nm1LQWsxS0lMUGJXd2I0OUlHeVo0bUh1eXRWWlNHUVVzbEtkUVZFOEJxSTdoWlUwQk10WUNVa01GRktsSjZrYXVYOUg1a2NiKzVyUFJmdzRrVGpPS3d4bHBjVWxUS0wrMEx0bW9xSUg3aUhONE85dDhJMHhNd0RQZFBVWEh1ZjBnYitIT0FuQlFNeVltbEtsRUlGQ2xYY0EyZGszeTVaV2phZHBNSUpzcFNRMVEzZ05YRi9oYnpqcjhhZkNTbDlUU1ZxanpZcGpqUktSSENJOTZ6bElxWVVTVXdveGp5ekFIdWtybWdwWjJTa2h3ZWJabmg2bUlFN1JrVmhabHBjaHlFdUM5c3RHekhHMmNVNXUwRFNrQUpZRjZYZEp1ZERsL2lLaUpJV29zYWIyREV1VHh2YmhaNDhOWTd0eUxocVZqRE5Vb3BTa2xLWENhcVFLVGFrYW01dDA0d094RXRheVZNYmxtT1lMdFRZWjI0REtMeWRpazNTZTdERUZ6ZHRRM3RETFgxZ2xnMWlVUWsrSkpHUllMelpSenVPZkRqQzg0eCtVTkJQc2xoVm9VM2VuSUNoc3ZhVUFlQUpQcThiUUNNWnN6Rnlrdk5uTFRTbHlBWEt5VFN6c0h6WVg0Q05Ec0hhWXhGYXdTQllCSmF3NGx0U1hqMGZEbkxqNisyUm4zb0tOR2EyempOODdwSUJBdGZJOHVZalFZNmJRZ3FiS01oT0xxdVhKeUdZdG5jNlorY1EvVXNtb3cvSStCZHNKeU5vTEN4b2tBTzRObklCZnA5ZWJhT1VYQUl5TVl1V2lXU3lpMlNpNVV6V0xKVHFTUU0rQmpZN01uQmFBcElOTndIc1MycmFSWHdNbjdhVFlNeTJhUHNoS1VaNElCcEFOWEJpTFA1Z2VrYlV5UU1raHc1SFVqTitNUWJMd0NaU0VKQVlnQithbURreGNNY1hrNUZsbHlyNkR4VktqemJ0aEttSXhSbUtObG9Td3lhbCtHWjQ4bWdPaWVGRmdwOUwvQUZ6amI5dnNIVkpDL3dCaDU1S3RwekNZOHlrbFZRQkRYenV4dnhCamtPM0c3aWd3UXd5UGxmOEFsb1pNVXhabkxQa3c0WndwMDhJRHM1T1FHcGJKemIxaXRLcnYrNVZ6d1R3QWJoL01JVUhZWkxEVFBRdmtXaVVrUTFFa0FEV0VWaU0yYWlPZk1ZUDhMeEhLVVRaN0IyRGNTU2ZVa3hIUHhzcFBpbUpIbmxiUVJRbjlwNUtiSkpKL3p4amJNMEhBZzUvZmxFV1BsSlVta2h0QWJBaCtCT1I1aUFtRTdRS21xb1FnQUgybExZQ3h1ZU9Rc0RwMWhrMzh5VXFxbkpUTWMwc0FXR2RLdFJtUUxXdDVJM1RwZ2NrdXdmTXdpcEN1OElVVWlxck5kblNrT3dPNkFvOUhmV0tKQlZpRkpSWkZCV3NwT2JPQVE1REtZZ2NiSHJGMUM1MHNncldWR3dZcVlIOXdEbHFodXRrTHRBUGJ3V2toZ0VrcEtWZ1dGc2h5Wno2K2NkR1AxU09TYlhzYW1RWmRsUFZRbmprbXAyWTYyNjJnRmk5bS93RE1DbGtBTWJQZXh2U1MxeU12ZnJBWEI3Uzdza2dPU21raHlNZ3p2YzVmdzBYWisxMkV1Y0NrcVZVbGFNMlNGRXB2MExla05IRE9EMC83Mkp5c0tGVytrZDJrOTJTQ2J1dElZdXM2a2k3ODJqZDlrTVJMbVRXbXBjcFNaaXlwaU1udWh3NlVGUjNRNzhSSG0rQng0TktsS0FJSUNqY0VpbXhHWWQxRUZ4b0lLenNTRUJSY2t0dkpOaTJUcGJJVS9EV0p5VGkwZ3BtLzJmdGRLVlRDbWJMWEtTVkJJdEt1a0xaa2daRWxyTVhQTnpQaDl2TFhPVk9sbGpRQVVzVjdvQXFWeEEwejExanphV1hDY3YzSkRwZW5pQ1BQS04zK0gyQlJQbnBTRktaTHJKQlp5TFU1K2VYSHFGYmZKSU5oTEZ5aUM3Rmxid3MyZktLNUViZnRYZ0twWVdMbFB3MStzWTJtUGU4Ykx6aFQ3V2pubkdub2hwanNQYUZIVFlsSHo2cVkvbnd0N2hCVEE3Sm1oYVNYVHUxZzVOd2Q4aThTZmxaU0ZpK1hFUGxyekwvNGl2UHg2Z3NsSkljK2YzOUk4aHljdFJMaHp2SnFYclNpa0NvRmdONXdOQVdMRThmS0tPSW1pZ3FBTG01Y2daaXdBMUd1UU5vNU8ycTZHRnlFdWZWdmxGRUxlNUlKNE5rT2VrU2pCOXRHQ09CMmRNbTBQU21XUlU1NUdrODZ1WEJ1c2VwN0x3a3VVZ1MwRElCN1hOc3lSYVBKRVkrWlVoQ1ZLczFON0M5Z0FiQVBIcTJ3OEwzTWxOU3Q1UWMxSzFOMmVQUXdOV1RtVnRxN1VTeTVWd28yQllzcTl3NDhKQTBqTDRtZXJlQ1VoUkxsbmEyaDB5dGVMbU9tMVQxaHJ0Y25RNWhtUDN5eWk1czdZQzVpYWxyTXVTQmRmN3Izb1NNeVRySG5lVms1WmRsc1VkQS9aMnpWNGhkRXNWSy8rb2VvMzRDNDEwajBmc2pzOENkTGxWQ2FwSkpXUUFKVXNJelNoSThhbnNWSEorTmdHR0tUTFIzVWhJbHl1VFZyMGRTdlBJZXVrU2JBQzF6Q2c0Z3lSWUlUSVNTdGRpNHEweTVDSXh5UytXOUYvaHBLejFqRjQrVktEekppRUQrcFFIeGdCaU8zR0hjcGtKbTRoWC9iUWFmN3phS09DN0t5d1gvTEtXcjkrSW1BbnJTS3ZsQjFHejFwVHZUVVMwalNXaEtRUC9LWlVSNU5EY2lkSXhmYTdiT1BtU1MrSFRLbHFhMVZTemZKUkFJQTF0cTBZM0RZbWNsM2xtNXpCQjkyY2VuZG9kbnkzUmRTMUc5U2xxWHBvNVllVUNwR0RsQllDeUFEeEkrZG9WdU5GWTJ1akM0bkdxU3J2Q0NCa0F4Y0MxcVN6QTV2OFd0RlA3UVczVUMzOVYvUVI2TjJvN0wweSs5a2dxcEc4RXNDMzdnQUdMZEk4OHhYZHF6QVArNUlQdkVTYlJXTXJCVS9iazAyQ21QQUovay9DS3kxejEreXBYVXFBOUN3alNTMHBBc3c2TUlxNGhTZXZxWXlraHJabkRzOWY3a29mK3AvY0lYK204VktQUlB6TFFWbTRrRElmTDRSVzc0cUlEWi9lWmgrWk4yTnc2VVMwa3BTRXFHcmh5Q1hjdGR4OE5Jc2pIdkxxVWduMnE2V0pBSkJmaVg1eFF4NlZwTnpabmZSdXZXenhST0tJZXNsYUZYNDBrRndSeWZTTndVOWtacXRoL1pXSUJGVHVvS0RBSUZnMVFMbHhyYmsyUnRENXJLUzVTTjYxOTVLVGU3Rm05MlVVY0JPU2tvbXBTb0dZRGNvL1RUU2tpcWw4MkE5QmxFMHphdGFsV1NCY3FMSnBUTXl2MUQyYlVSSndmSjBKWUM3UVlFTUtXcWR3bENiTVNiYnZ0WEdiTzNHQmVHMmZVaW9rQXZrU3lyMkc2cHFuSXpCNHh1dG50U1ZMN3NGQ255eUFGMGpuQ3grRHJKWFFoU0R1M1Q3SUlaZ3JYSSs3cmVQbE9QcGYrUU9KZ1pjd29TRk94MERaTzk3MjB0OXZwTU9KaG83eWdxOFFXNEFXQ0dBRm5KWjdRVG5ZSlFGVWxNdGsrenU3NUxrbFNHM1g0SmE5dFdnUmlOanJLalVsS1VFTVRVN0tJOWdBbTlYSHBhSGVXT1Q2QXFpeE5uRksxUzFJQVRrbFl6dUFBeDFBY3hxK3hXMVB5eTByS1FzT2RiaTl5T2JNTkRBSGFnUWhJU1M0Q1FBQmV6TVNBTkxQNUhnSWRzM0ZLU1RrUXdMcGE5SWU3RnhrSEVjMG01UnRCOXozRkhhbkR6a05VQVRZcFVDRDBiWHlqTll5VFF0U1JjQTI2RzQ5MFpERFlvWWliTFQzZEtRVWdoQ1FDcW91UzZpOVEwR1YrY2FmRWJJN3NWU3NYWVg3cWNoU1ZFRE1JcVlueWVPenhmSWNKYjl6VGdwTFJ4UVBLRkV3aFI3Tm5LZk9zNUpCTjN1WHp6MWg2SlpWMWg2Wm8xUzVleHZEakxlOVc5YlNQUGJMQ2tTNlhKdFkyYk9Ka1RpcTVaallzMVhsd2l0MzVMQVo4ZUx4MmRMQ2NqVStvNDZpQTFmWVNmQkovVVRuYlIyOThheElTVXY4K3VVWkNYUFlFM2ZUbHorK01YZG1MSlZXYnNmTThnZmxBYmFRQTdnc1doTlM1cTFFQ3dRa1ZLYkxOalNQckV1SjdiaElDRVMxTWtNa0tzQU9UdWZXS2V5eUF0YWc5SlM3RTVNZFBYM2VxbTQ5RkpJSThYTFM3TzkvUGxISzZjdHF5c1oxMFJUZTBtSlhrUWtjbUh4Zy84QWh1Wmk5cDRVclVWYjVOeVRraGZHTWZoU1NWQk9ReTBQbUJHOC9DVkovd0JSbHBJUzVUTVlrT1VFSUpxU0h6WUZOOUZHS1Rpa3RJZFNiV3owN3R4dDZmaEZTNXFTNkt3Z1N3UEdia3ZiZ0NQU0MzYkNXbFdHVW9rc2xKV2tCM0tnSEZobi9NWjM4VWxxbC9sVkpPK1p3WmVTazBsUGh1MTM5SGpVOW9wUVJoWnhSVUNFRWcxRndlSWM1eHh1TDR1d3BxMVJnZXorMFFVSVN0ZHdWVWpNMDVzZUYzdEFYdEZpSm41bzVsTzdRRTd4cEFEdUJjWHFnbDJObGdKVnptTHp6eUVDOXIvOVlzNWI2UGdrUXMxVUVpMGZtWjZvbkdtWGdWTGxBcVVoRzZHSkw1QjA1c0h5NENQS0Z6Qk5CQ3FTUzVjTUM1NlJ2TVhpRXlzRFBVOUZLZkVIQkRrQTNIV0R1eXV6dUhRbEg2U0NVcEc4VWdsUmE2aTQ5Qi9EVGxGeWFRcWtvVy81UElKT0ROSUhLSXNkZ1ZwRG1XdGk5NmQwQVprazVEbkh2a3JEcFQ0VXBIUUFmQ0FmYVFPdVdMTXlxZ1dZZ2doaS9XTFF4YjJLODk5SThGNzlKVUVnb0tpUUFBcW9ra3N6QWNlZXNiRWRoSnlRRE1WSlFTbXBsTHpET1dzWC9pTXhoSkNVVEpiSi93RGtrbTFPVHExQlAyMGUyN2FrQ2ZoMUpscUNabENVaFZTUjdPVlFkczdobnVScThVblNqbzBtMHp4WGFwUkxKUk9zcEtpazUxZEdVTEFXdHdnVkoyYmRTNmU4VXBWU1ErVjMxeU1TZG9zU3VZczFvL1VTZDhGd29teVhWdkc1S2FtSEU2US9aZ3BwV0VxSnlLVWdxWWFYQnNiR0p1TGhIVEpTN0xOMC9wci9BT1dmWVlrbHhZaElOOVc2amxETVZocEl3NU1zS1FFZ2tYZDBtOXp4WjlSbEY0NHVzS1R1MGtKVWYzUHZEalp1V3Vla1Voc3VXbEc2bFp1QnZFa0JyNjVhM2lVWlYzb0RBbUV4NmxxbEJDQVdBcUtra2dsTmd3Y3ViaHJPN0NEZUwyd3N5VkdncEl6OW5nU2FTTnpQVHJHZXhXTFRJbUJJcFVFN3lXZmRVUm1XQWRRY3RkbU9zRUZiYm1USllXZ09wRnp1ajJraDI2RUdPcWVQazArT2hVd3JMbkttUzBMVWFxd3B5QjRTQWFUWUFrTlNOWUg0UGJJWEtLVjJVRU9rR3pzbG1EM1ZxTFpHT2JQbktEcElLR0ZZY0QycmtsclUyOFBsRmdUMHByV2tnandra094V0d0VlloeWJEakV1S1RhcjdCc0dGS3hNL1VKM3lkQi9VV0FJeXNjbUxuVjRuUkxtVmxKQVlBWERpcDNEN3RtSWZUaEJEWitFbEVnelZJQlVCTUxyQkFKUzVKWU9HSXlEc3dpVFlzOUU0cUsxRmtxWU1sd29IVW01QkZpM1hqRkp0cFhRS05kMlIyUE5seTB6TGxCSUNxUW1zTjRnb3NvQmtxT2VqNU5GM0g0bFltbVRZMUlxRjNMT1E0WlJENkVzOW9nN0g0K1gzckdjcVVsU2N3a1pnM0NuY2NUVVFXRm5ad1QzYVJjZ1lpVExYTlE0U0FaaFNBd0tuOFpzN0xmUFhuQzQ1cExtUFY2c0FCT0orMUkrYUlVQlp1M3ByMldtMXROTFBuSFk5RDQ4UDVaSGd6eWlrdFpoOTg0WUZFWGl5cWVvQnl4NVhZanBFYXBvS2JjWHBiVEp3ZEl5c3hUcUlNY0Jpd3RBVXplalEwU2pGTFJoOGtaRWkyclFjdytMbFVkMGdGT3BKSWM4UkFTUkxKTGN0SXNZZFAzbEVwN01hVEJTV1NWcURGUVlDenM3dDkyZ0J0V1FBcFNra0FPeEF0ZnF3R3NHNStKRXhrc2wyTEFPN01iaFdSRHNPRUQ4WGdCUUppZkFYQUk5a2dzUWZNUkhBdlZ0MDMwUDlqWmZnN3NDUlBsWXViUEJJUVpJU3hhNTd3blIvMjVSNkYyWDJMaGtiUlV1UWdnSUFDVHZtNVFvS2Nra2FqM2VlTC9DL0gwNEtlZ3R2VGtEUDJRaDhzeGVQU093dUZGTXljbERMSktGR29rS3BZZ2hKREpzYnQ1d2tyYzJVL3dCSS93REVSU3pMa3kwU3lydkpxQVNBQ1FBdEJZYTNJR1dnTUYrMVIvNFNkL3MrWWp1TW5zVWxaU0NMcGRMdG80M294SGFMYWMyYXRTVVRWVWl6QWtCK2hjUXJTZDB3SmRGYnN4SXBRNTFLaU9oTUNOcjRZL215R3VwYUNPaHBnM3N2RHJSbXNrWHM0c2QzK21Da3VXQ1FTSFBFc1Q2dENaSUxwc3RDVDdvb2RyWC9BTlB4SUdxTk9BV2trK2dKajBtU04wWGV3dng1eGpNWVU5ek1yU0ZKb1VWSklCQ2dBWEJEM0JqWVlTWlVnSGtJRWF1aGN0MFRSazlzQjhaYWlxbFFBVWtPZjAzOFdiQXQvZEd0Z1h0RFljdWN1cGFFSHFnRTVObWMvU0x1TkVVenc2WklQZXNBYm1Sa0NTUEVYWWFDN3R4MWkvMnA3YnJVUUpjcEVvME1vc0FzbFBCWHNwQkZ0ZGVFZXA3VzdNeVRKV2xLRU9VbElkRXNBRWdwQ25DSGNPOGVKZHJ1emMyVXBNeFFkSUNhMUlJVnZtcHhNc0dOUUlJYlEzNFRjVTNUS09WN1JuTWZpeXJ2RmswclhjWEpOM0xQbTJYcEZqWThqRUpTVnkxVkxzVkJUcERDOUtTYzFkUHBGanM5aGtLSlVWQjFhVWp3Z3NjeGJsRmtiSW55VnFSTFgrbVhVRWtleW9sbVViRldWOWVUd3M4aTNEWDVFYXZaVmxTWnRTbE1rRlNBR0ZnbFNtM2p5c1R3dWJ3Yk5rQk00VkZtVmNieERPbDFEbXh0WjNpWkV0THFJQ2xLRnl4U0E0M2lMMzBlMldjWmpiY3hVcWVGRWhrRWxndFNrM0lPNFRkMlNMRWtEanhqSDk2VkdmcDJEdTFFdGxtaEpwUUFra2czenBOUnpzTTRtMkJ0TVN5bVdVbE5qVTd1Ykt5QnNIcTRaRG5CN0d5NVU5TlpLZ0ZKS2FTb01vbGlGWnUrdm1ZRjRxU0VnaWVrQk9RbUJyZ25oWVpKSFVSMHd5S1VPRWwvZitSWC9JN0VCUkJJU2xyRjFVaGRKenVDQ1ExMlBBY0doYlBrb1VEVy93QzI1SVo3c1FlZDI1eE11U2tyTXlXSHBLUXRLa2tLSUNSdkJySG8yUk40ajdRU2lKVlNBeGNLVVJ3Q1RwcGJOczRWU3VvOVdBSzRyQXlGa0FoS2xVamR6dGs0UEFrdmxiM25zcVVKYUNFSnBUbUtlbDNHWnl6UEdNM2dOc29aUUtFcHNBRk8xaHhPaGZYbTBYMDdXUXVTeEpCcFliNXFKTE9BK2JBTUR5aEpZWnJUdWh1U05EaDV5RUFHWHUyTjI4Vmc0WnJPZEdFUnpKNmxqOVFsVFpCbnNhVForWHlnYmdaOWFnaEpDUmE1QkNXRkxPem5PeDV2RmphQktEU1ZFdlkwa0VlRVhDaFpuNThlY1RVR25RVTdKVjQxUkpLVkxTSE82RFNCZklEUVFvSC9BSjllbFpHbHpsNUJvNUZxbUhaaisrSTBjYzNhR0JRSkRKSTQ2dkhWTUErWjYvS0dpWVdMT1BsSG9VUkoxS0hoQUQ4NHJxSnl1M1hPRWhWNzNQRjRtVFNldWx2bEc2Q1JwbkhRZmZQakZpVUtpTFc1R09HV2tBNVBZOHMrbyt6SE1NdHNnSVY5YUFHVTdMQ2tKVXZSd0tlb1luaGQvV0lwTzFPN3d4bGpNcVVBT0NUY24zeEtuRXRJcXFkdDFyWmxTczM1RE1SbjFxY3hLRU9lcGV6SFVuSG8zLzRma0hEekE2ZzgxM1MxbVFqVTlUN285czdENDlDcEhkaGdwRGtocmtFMkowSno4Z0k4Uy9Eei9wMW4vdXEvL0NJOWU3Q0ZJbHU0M2lvOVdaT3ZTSjVwOGJLeGp5UmQ3VnJJSWF1eVQ0VXVOY3pTV2pBWUdhU2trMU9WRTd3WStoQStFYlA4UWUwd3drc0lDVktXc09XeVNPS2pvOTdjakdQd2VPUlBsQ2FqaXlod1BNYUgrSVNLMFpCWEJZcEs3cFVTYnU0SS9iayttY1BuYlNWS0kzYWtubmNkSUdiR1ZuOThJczQ5WGg4L2xFNXl0MldqR3RCekI0NlhPU1FDN2dncE9iRzF4R2wySmlTUlNUbGxhUE1RU0NGSkxFYXhwOWdiWktqY01vZWl1TFFzVzF1SVp4dFV6ZXVlUHdoWDRuM2ZTSTVFMEtTRkRJeEpIVXNrbjFaeDBLL0UrNzZSNUgrS1dDYWMzZWxJSXFLS2lBdXFvRXNsTFB1bmVMK0ljbzljYVBLL3hpVEozVktzcEJTVkhqWXNCd0xjMnp0Q1pITFhZMER5S1ZnVnBXb0FtZ2hnQVdVY25BWXRvM1M4YW51Wm9UVXF3c0ZPbXB5ckpsYUd3ekRubHJudHFUVWtHWWhmN1NnMlkrSkt2T3JUaUlrMlB0eWdFVFhTRmtrYXBBM1EycEJKZThUeXhuT0tra0MwbUxFWXFtYnZLYWE3T2xOcUdjQ3JNS0p6UE04SU95TzdVQ2ljQ3AwV2RMaFJ1ZlRkTitMUlV4T0dFNEZLR1d0bkRGd3pFZ20yb1B2NndOd2VKVjM1VFBKQ3dBQWtLWUIydUd6K0ZvUng1eDEydjgvZ1BRUm5ZS1ZLWXByY0FuTXVIZE83Y0FGdUdtdWNEdG9CT0lrN3MxMktYTCsxbHZjTGUrRG41VVpwSkJLUnZQVTROMklmM3dIbWJNUlVaY3hTZ3FhUW9BSTNTUUxid0ZqbWVYS0JpbXJ0dDJoV2dac2hjMlNsWkllV3BRQzFYSnp1cm16QWs5WUw3S3g2WnlUS3NVckJRcXdzS2M2dlBOaGxBekI3Uy9MdEpLU2FIQ25UVUxHekFObnIwMWN3elpPRzd5YUp3Q1Vpb2xnOTdrOGJhL1NPbkpGU1RsSmZaZ1RJdG00R2RLV1VnZ0c0QXM3bTNNQjJCNWlDUCtpRllaUlNGdG0zaEpZa2hMWHNUa2JkWWsvS3FSTkNBaXBDZzZsa2lwSUJzb0tMRnc0RjN5aWRVd3l3RktBOW1vamR1V3VsL0VPamF3czhrbTdUVm1vaHdzdGNsWnFXQ0tpYkRQZXVhYnM1NXhPbVlxLzZacUJleDB2Wng3TDM4aGV6UmJTc0ttQUFFRUpWWndYSUJheERPU1JseHlMUlpHREN6WXNEWWdobkxzZWQ3V2YydFlqOFRlME9rQ3U3a202MUxxTFB2R0ZCdzlsSnVnUTJqaFI5N3dvcCtTbE04bUt6SFVySXloMGpEcVdvSVFIVW9zQkd0N01kZ1p1S21yUXBWQ1UrMVpUbHlHdGJUcmQyajBwU2pGYk9kSnN5TlZtYUpKRXRSTERQcVBuQjNhM1pDWkptbVYzaUZxU0FTMVFZRitJWjdlK0c5cit6UndTMElycktwU0ZxZE5MRlY2UjBoZWNYcFBzTkE2Wmd5a09WRjJ5NW1IYkVub1RPbENZa0tRVnBDbklHNlNBUTZpRWdjenBFV0ZuS1dVb2NacFNMQjdxQStjTW00VjFsSXZkUXR3RC9BQ0VaTDJrWkkyUDRoOWwveWpLbElVSktqYzJvRDNTd2VvWmtFbXprTm0wWWlZNEpCREhobEh1dUkyek5VTUVKMHBJWE9sVXpFekdCY0NsWGVTMUYyTFZDeFlLTHRuSG1QYWZCMTdSbmdDeWlaajVPQ3hKSHFZamh5ZXpIbERlaDJCeGE1V3pLNWFpbFJuRU9HMUxhOUk5UjdQN1dBS1phbFV5NWFTVmh6ZFMxYm9ERGpTWXd1enBNdEdGTXNwY2I2Z0ZBS0RseVB0b3Q3RXhYNnlTczJxU1Y4Q0FzWmpWbUhtMFJ5eVVsYUxSaTR1bWVqZHNGQ2FoUlltb01TMXJCWVVIOGlJd0haa2lWTW55dzFDaUdGUWNFQTVQZmg2UWY3UTdVcVN3ZGwxcUw1N3htblRLeCtNWmJCdDN4dGwvRUpGdGJNbGVqVDdFVlkvZkNMV09YbDV4UTJNYkdMR09WY1JLWFJSZGtaVkZyQnJJQUl6ZDRvS1ZGbkNxM2ZXTmo3RGs2TjEyWjJzRHVuSSs1WDBNSHRzcGZEenJrSHUxa0ZLaWtnaEpJSVVDNlR6anpQQzRvb1VGRHpIS054STJ4TG1ZZVltc1ZHV3NCaUg4SjA0eDBZM3hsVDZPZWNiMmp5M1pHMWNYK2FrSi9OemxvNytRbHUvVVFwSldnS2NFM3M3anJCNzhZdXppMW9NOUsxRnJCTEZWeTlTam9rTllkT2NBamhTbkdZWUVLUzAvQ2tKVm95cFQyZXd1R0dqUjZsMnhsSVZLcFc3RXRaVkl2YmU1ZStGbEwwMzlUUDVqNWl4aEJsaFNqU0U3b1FCcXdkVGpSd2ZUaEFmdkFwYmtsam5xVzVhUEhwSGJmWU1rWWNxVFl5bkNhYkpMcURraHJ2ZjFqelZTR2pzeGZLUmtxWnRPem93NjFBWWRTMExTQVNvbFJxT1RGSVlITzN1ZTRpYkYwb3JVaGYvRUFoU3FnTWhaZ1FIQWU5dUl2QS9zanNzcG16S2h2SlNBVXVHSVVIdHg2dUdqdTNNUE5CTTZZb0JnRTJMN3RnUVFCZHlvUDVSeHp4L3UxZXY3b1BzSFphd0ZDcXpnZUhOYkV2bHE1SllSMlpOclFVME94Q2sxRVYrYkU3ekFOWVBBRForMFUzUXFhRGNCQnV4M00zSnRjM2lnTm9yQ3d0SGVMUVVrSjNXSXp0d0xIVVovQ2Yvek5zM0kwODlVcEI3M3V3c3FTQ1ZKY2tFTzRVTXJBNWpwQWZaMjI1ZmVGQ2dKYWN3K2I2Z2tsbXpiSjNncnNuYUFuaFNsc2x6d3NwV1YrYk5mb09FQ2R0OW1WdVpxQnVxSktnekJJOG5KT1pObzJQaW00Wk5NMit3M00ybWhBU21vWEl1TlhKZjVhNkNHN1JBVktVeVhDR3FOVlZTVkpOVzYyNkE0L3RNWktlVlRGRTFKcVRZTUdld0xoUE12OFkwR3dNVGlFeXlvaXBLU3BKZk1aV0kxVHZFNjVRMC9INExsSHNObGlUWXBxQ0R1bWhWN2hSZG5GaVhPZjlSaTB0S2xUZ1FrZ1U2QzZqbU91ZWwrc1Z0a29VcXBLVUVJY2toM1pMQnlrOGljeGRqQjdadUlmZFdpcWtxRklMWktBRndiN29ZUkdXbmJDaVdYMmZzSG16WFlQdXRkcmhpWEY0VWVrWU5qTFFYSmRJdWM4dGVjS0xwdWg5bnk3c2xZRTFKTHNDY3M4anJHcndtM2NRZ05KbWlVbnZPODBKSzJTTGtpNDNCdWx3Ymd1Q1l5c3VSVGNFRW5oRTZTWTc1eFVpS2JRYlFnZDUzaXB4bUxVWFc0SVNRNzBsU2lMV0dReXNJVzAwaWVvcW1MV1hiZXNBQUFBQUhjbkxoQWxFU3YxOVlSNC9leGliRDRYRHlsb21BelNVcVNwdDFuU1FROXIrc0greW1Kd3FKeFd0REpBVWFscENpbFoxQk9UM3NJem9uQUh3anpjL09GTXhKVm1iY01nT2dGb1Z3ay9jQzBhanRWMnQ3NVV2dXBzeDBBdXE3UFpneHNkYmw0eSt6c1ZNTThLV2FpeWszSUZpbG12YUkyRUk5STBZcUtEYllUVnRCcFNBenVuUEx6Z3JzU2N5MG5tazU2VjMrK2taQ1lTVGNXNVo1ZWthckI3VWxpamV1S0xaMlNvV2hKWTFXaWtjbXd6aVpsUWZNYjMvc2lyaFJ2cUowMTQ1UkRNMmpMcHp1eGZQSTE4T3NXdG5LU3RKVmU2aUIwRFJPVWIwaG82N0N1elp5VXBMbUlzWnRORDNWa0Q5WXF6YkpOSUx0YXppNytzWlA4QVVVU0FEbTF3YmVXY1QrRzMyTTVwYlJyVjdUUmJlRi9uL2lMdUZ4NkFBS2c3L0huSG5zOVMwNktHaGZRK1JPa1dObTQxcVFRcXh6Yjc1UWZndGJRUGljdE05SUU5SnlVUFVSUjc0cFdTTkRiWDR4UmtBS0FJT2NTOXlvYSsrRWJrMFBGUk5qSjJQTG1wUmpDdFlVNkZxNEF5eU4zS3daQUVRZHBPMTNma0pvS1VwTDV1NTQ1Q0JXd2R1R1U4dGQ1WmNVdTJiMzlURkxHQ1VDdmVCRm1iUjc4WHRsRW56WDJHU2kvdVZlMEdKVE9rTGxwREZRMXkwdjdvd0dJN1B6bU5rbTJpaHc1dEd3WE1FUUxYSFRETkpDU3hSWVV3WlFsS1dLYW1CTnc3bTVIckZQYjBpdVFzQU9XY2RmTDdPVUQxVEloVk1qY20zYkI4TlZRUDJwc3I5QUZRQW1wY3FDUis3aUc1ZXNETm03UW15VXFZcUFJTEROSVV6NUZ3OGEzWjZ4V2dxRnlmTmhkMzRXRm00UUI3Uk5Vb0pMQUxjQUFpeERrbnpNVWhrNStpU09lVWFERXVUTFNrVDVZQVVRQVE0VUVzajJDSEJkUUh4aTNzNmNzVGFGTVNKU1NVM3pKc0dkblk4TlJ6alA3QXhjc1llWWhadVZPd1o3QUM0YXdzQU9aUEdEdjRlaENzVE5LMGxRWFNsSXMxZ1FYZTlpQmw4NG5MSHFWK3hsc0lvMllqeEp3NzdoSGVaZUhWN2h3dzgvUUU5bVlOU2twM1NVcU43ZzNEZ0tMVzQrUkdiVzEyNnpNVzROOG9nbHJsb3NIU0IvU3BoMUxXam5hdmJaVGlaanNMc2RhZ0p0UkNTcWNnZ043S2xJeUwzdDd4R3Z3L1p4S1p4bXZaUzFMWUJtS2k0OHVVWm5zNXRRWWVVdEIzbEdiTldpV254Szd5WVZCeWJDMStoamI3SHh4bXlndFNDZzNCU2JzMXVBdEZQUzJCVVhBMGNoZWtLS0JQbEVBeElpYW9hbUhVUk5Jd2FsQXF5UU0xSExoYmpIZlpGRWdtajcrRVBFeUlab0ZnbDJHVDZ2bVcwaElqR1pNa3c4UTBLNUQwK3NPUUlXekR3TlhFT0FqZ1RFcVVRckNjU2tSSUVmZjNsSFVKam9FQUlpaDlZbWtURkk4S2lBL2svU0lrbldPbFhEUDcxaEdFZjNzeHlvTFZ2WjVOWjhvWWl0Nmd0UVBJdC9FTk13Z09UNkNHcVZxOEF3eWZoeXBWUldxcmk3UjFXSGNNcGFqMVAwaHN5ZFRmUGkwV3BDa2w5MGx1YitrSFlEdUhXVU5TbzJ5dmxGdE8xNW9jMU9HMUdYVG45SWg3NlRZaXVyazNMSWs4eEZLY3NLQ21keFppMXoxZUY0aldYdjhBVUZGeG54Ni9md2lMOHkra0RjSVZKYk9OWnN0WVdpNlJma09QMGllU2Z3MTBCVGJBSDU1aTE0Yk4ybVdzNWpVNG5aU0ZBQW9EbkpneGdYTjdPcGNsS3p5SEw1d2k4aUQ3TTNJejV4S2dYQk4rTWQvUGs2Um9aMnhFczJkZ0JiN3ZlQk9ON1BxSGd2Zk1pd0hsemlrTTJPV2dYSUxZSXBuaVVoSzZaaVV2eHA5bHkvQTZkSXFZdkRtYWdKVXBJTmFuWUFxM1NvV2U3WDlESE95RXZ1OFlVekRrbFE0ZzNTUTNVWGpaN1dsWWRRL1RRQVNVclNRbTRkM05YbS9tWWxPc2IxOXc4YmpaNW1jSUFxWUVncW9ZbFF0U0FxbmU2dUkwUFovYkNwS1VsTXRHU3JzNTNpZjQ1UVNWaE41YmpOQlFTQzVJcUJTUzRaeHZldXNSVGNGTFh1bEJKUWxJVDdMZ2F1R0QzOTBHV2RTanNEMEc1SGFpYXNPUlNmOEFhVytrVk1SalpxcXYxV2V4M2lSY0d4Qk83RklTV1ZTQlRieTY1Tnp6OVluU2l4SUdUV3N5ckMxenA3bzVtMzdDOG1NbUJZVHVCTDJBUE8zRGxhQyt3OXJ6SlJVa2hWSnNEVVZHMWc0SmF6ZWZIU0JjMDVjcm40Mzk4V0JZTUhQSEk4Zzc5T2VzSTI2TW13b2Uxa3orciswd29FRlhGUHVQeWhScmYxTnlaNXdrWEVFZHBocVFMQ3hZV0QwSkx0Q2hSN1FFVWhEeWZoQ2hRd1IvMWl6SkZ2OEF5RUtGQU15ZkZwQVdXNC9LSHlranV5ZGFoZnlNS0ZDTUkyWHA1eDFHc0tGQVFUaWN2UDZRelF4MkZBTVJUTG0vRXcyYWtBV3RuQ2hRb0NvczdwOG9JWVh3VGY4QWFQbkNoUXo2R2gwTEhCbEpiaDh4RmpDRGQ4dm5DaFFwaWxOOFhtZmhCbll5akhJVVF6ZklUOXpVeXpZZGZvWWpsNndvVWVaL0pSOUhVSkJkOUNsdVdXWHJIRWVIMStKaFFvcXVoME9reXgrWWwyR1owNlJZeFEzaHptSUI2WHRIWVVhUHlvZVB5Zy9haVJVcXcwOTRoTFNLVTIwUHVlRkNndjJJejdIcEdmbjhSREppUlFDM0Q0R0ZDaFYyTDdFU0xvdmQ1WmZudWpQakVjNE1TMXQwZkNGQ2dyc0RMY3RSYk13b1VLRWZaTm4vMlE9PVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJGaWxhcm1vbmljYSBCcmHImW92XCIsXHJcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZTogXCJGaWxhcm1vbmljYVwiLFxyXG4gICAgICAgICAgICAgICAgbGluazogXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBpbWFnZTogXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8yd0NFQUFrR0J4TVNFaFVTRXhNVkZoVVhHQmNYR0JjWEdCY1dGeGdYRlJVWEZoY1ZGUmNhSGlnZ0dCb2xIaFVWSVRFaEpTa3JMaTR1Rng4ek9ETXROeWd0TGlzQkNnb0tEZzBPR2hBUUd5MG1IeVV0THkwdExTMHZMUzB0TGkwdExTMHRLeTB0TFMwdExTMHRMUzB0TFMwckxTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExmL0FBQkVJQUxjQkV3TUJJZ0FDRVFFREVRSC94QUFiQUFBQkJRRUJBQUFBQUFBQUFBQUFBQUFGQUFJREJBWUJCLy9FQUVFUUFBSUJBZ1FEQmdNRkJnUUdBd0VBQUFFQ0VRQURCQkloTVFWQlVRWVRJbUZ4a1RLQm9VSlNzY0hSRkJVall1SHdNM0tTb2xPQ3N0TGk4UlpEd2dmL3hBQWFBUUFEQVFFQkFRQUFBQUFBQUFBQUFBQUFBUUlEQkFVRy84UUFLQkVBQWdJQ0FnSUNBUVFEQVFBQUFBQUFBQUVDRVFNaEVqRVRVU0pCWVJReWdiR1JvZkFFLzlvQURBTUJBQUlSQXhFQVB3QVMxZEZOYzA1VFh6N1BwRVNMWE1ReGlCdWRKNkhrYTZ0TlY1YjAvRS8wbjNwb0dXcnVDZXlRbHhXVXdJRENESEkxQmRRTUlJQkI2MU5ldnMwWmlUQWdUcm9PVlJEZWh2ZWdTMXNyWURCSllMRkpHZlNDWmdEZVBlcmk2MEY3V2Q2ajJXdHF4Q2hnMENkVEJJTWVTMDNEY2NUSk9ZQW4rNXJTY0pOSjltY1p4aTJ1Z3pjYmxUSm9QKzlrKzhQY1Z6OTdwOTlmY1VLREJ6WHNMazAwdFFvOFl0L2ZYM0ZOUEdMZjMxOXhSd2ZvT2NmWVRacWFHb1dPTElUQVlFbnpGRXNNd090SnByc2FrbjBUb25XcEs0RFNxRFE3U0FycEFBazA2eStZU0FZODlQbjZWU2lTNUhHMEVnRW5wVEVzc1NDeDIyVWJUNTlhdVc3SlBwVnEzYUEvV3JTSVpYdFlZbmZUOGF0SWdHd3A0RlBDMDBpV3lxOGt3QlQ3V0c2MUsxd0NvOHhQcFZwRXRuTGpCVHA5S2tiRXJ5cTl4ZE1PRXQ5eVdMUjQ4MjA2YmZYNlVISzAyaVV4NzRnR21tb3lsY0JpZ0J4RmNwd05jSW9HY3BVb3JvRkFoc1YxYlpOUzIwbzd3UGlDV2MwVzB1TWRCSUxSNkFVMGhObWU3azEyano0RzZ4TGR5ZGRlUStuS2xRSXc0dVRVeU5VTnUzb0tkM1I1VnlVZGlMS21yR0ZTMTNSa1AzcE1neU11V05tRVRtMjFtaHdVa2hXT1VFZ0VtZEJPcHE3ZGhXS2gxZURHWlpnK1ltRFQ2UXUySW1wOElBUEVmbDY4cXIyMXpHS3RYRHJwc05xUzFzcnZReDB6QWc4OStSMTg2eU9MN0lPQ2NyZ0NUR2FUb1lpWTI1OWRoVy80VGdzNUxOOEkrcC9Tb09KcnJXbU9jb2JSbmxoR2VtZWZqc2xkL3dDSW5zMVBQWkYvK0tzZjVUK3RhdWFSYXIvVVQ5bVg2Ykg2TXAvOFJiWCtNSjVlRS9YV2t2Wkk4NzNzblA4QTFWcUdha3F6dlIrb243R3YvTmo5R2F0OWt6L3h1djJJMTVmYXFLMWpIdzl6dXJ2eWJrdzVFZjM1VnJxcThRd0tYbHl1T3NIbXBJaVJTV1p5MVBvYndLTzRhWnpDWGM0a1ZjdFJ5MTVmMHFsd3poeHQyeGJKT2gzR2tqOHFMWWZDQUNJZ2RCVThWOUZKdjdJQll6RWFUSHNLdVc4T0J2cWFtVlkwRlBDOWFwSVRZMENwQW5XbW01RzFSbGlhcEloc2xhNkJ0VVRPVFNDMDRMVkNJd0tjRnA5TkxVQWNJcHVXa1hwOXE1cm9KTkFpd2VGWE83RndvY2hNQm8wbXFWNjFHOWJMaEhDNzE5QUhjcmJHeWpYMm5RVU03UWNJc284QytvZ2FxSWU0V2t6SjF5amFxclZrY3QwWlI3c0hULzNVdHU2RDY5S0o0dnMvM1NMZUthUDhMTVpZL3BRekpxTktUUlNkaVo2cTNjYXE2RmhQVGMrd3E0OXNFRUhucDcxSGg3Q1cvZ1FBOWR6NzBoc2w0UGJONTRLT0ZpY3gwQk9tZ0hQblcxd043QzRZZU4xQjZEeE43Q1RXTGU4eDBreDAyRlJSVHNUVm8zajl0c09EQXQzQ09zTCtiVXF3Y1Vxcm15UEZFcjI3TkU4RGdwT3RWa3E5aDNyak80bTRodzRFYkNnMk40YUYybWpqWGlLZ3hWMEVHZWxLeDBDTUt1VlBNaysyMVBGUUV3ZktuREVBVXV4OUJpMWpjcWdEbFZERjNacW0rSzlhaWU2VFZXUlE5bXBoYW95VFhVTklaS3E5YWttb3dhbVMzMXBkajZPS0pydHRobXk3bm4wSHFlVlRJblNwN1dIQXExRWhzcDRQSHFicjJ2dExsK1laUWZ6cTVjeGx0ZmlkUjh4UTdqM0JPL0FhMlFsMGFCdFFDc3psWWozSDlhSFlYc2V5bVh2L0FDUmZPZDJQNVYwUmpCcTJ6bmxLYWRKQnEzeHl5eHlxNmsrdS9wMXF5TDA4NkVYZXkxa3FBR2NFZmFPVWsrb2dUUTl1RVl5eHJhZnZGNmYrTGZrYXFvL1RKNVNYYU5VaWF6UHk1VklCV1d3L2FOa09XOWJaVDZINnFkUjlhTllQaTl1NThMQStYTWVvcE9MUTFOTUpCYWF3TkV1QTR0bkpzMndEbklWdkRualhjL2RBOVJSRGpIQzdOclEzZ3ovZEVhZkliZk9pdFdISlhSbDN1UlRGSFNmbVpvaGl1ejRRbzF3RmxmeExKa1JQSWJEZXI5NUxWaThDbjhSQkIxRVQxRUhhaWgyQmJQREx0NWdsc3dUNVNmbE9sRXVFOEtXMWZ5M0NWWW5Lek9aalhuMEZQdmNSaThidHNaTlpVRGxWWEZZdHJqRm1NazZrMDlDMnk5eDNFdUhhMHQ0dGJHZ3luS3ArUTMrYzBHVVJUMjFwc1Vtd1NDZGdkNWJiUGRWY2c4S3RMRStTallVSWRha21uMnJKWXhRQlZOTkJvdGorR2kyWURxK2t5a241YlRRVEY0aEUzUDhBZnB2UlFXVEVWeUtnc1luYVJvZGordFRzNHBET1JTcXMzRWJZTUYxa2VZcFVDc3VxbFc3SzFkdmNNWlRCQkZNRmlLd2FPbE1ndWlxV0liUTFmdkxWQy9VVVVVWEZRc2xXeWxPV3dUeW9BSHNLN2xxOWZ3VFNBQnFlVlQvdWE3R1lvMFRsMk8vU21sWXJvRTVhNHkxYXZZWmxKQkVFYmcxR2JkRkRzZllTcmFXZXRMRERvS0lwZ21pWW1yakd5SlNvcXF2U25DcjFxMmduT3JiR0kwaHVST2hrVldLaXRPTkdmS3hrbXA3dDhGRlhJb0t6NGhPWnArOXJ5cUlpbWsweENDMWFUQVhDbWNLY3N4TWFURXhWUlNhTzhGeEZpM3JmWm02SXNtVDU4dmMwSVRkSUFZcTJwRU9vSTh3Q0I3N1VLZkMyTVA4QXh3SURGUVlNcnJNSFhsODYwM0dzVmF2UEsyUW9HMmJYZitVYWZqVld6aEJkUGR0a3luU0hnSnByck9nMi9DcVQraE5Yc2l3UGEvRFdReXU0WldVaktoSThSMkp5L25RN0NjZXMzREN0cjBiUSszT3V0MmV3K2NzeVpqNWtrZXcwSTlacm1ON1BZZTZQZ0NIa3llRSsyeCtZcXZpUjgrd3N1S0pqWGJhcHNiZlYybFVDQ0JvQ1NQWFhXc2kzQzhYWTFzM0JkWDdyYU44cE1mVWVsWGVGY1V1WEpWclRJeW1DR2tmTVNOUlNhOURVdDdEYVdpZGdUNlUxbElvbDJlNzBIdkxoN3ExcXJzRDRvUDJZVUdaNlRWamliWVJ5RnRCenl6Tk1ldXBuNlVxSHkzUUFhNE90TU4zb0tLVytBMmJkNEM2SGROdzRrazlHWE55bXU0ZkVXYlljTWl0SUlVazZxZXZuUlFXQkMxMGtoYlpJSDJwQUczdjlLTzhHNFlTaHZYUktxZkZsa2dkQnJGV3VBNHNPR3NybWRHak1FeWd5TlI0anRVdkV1RzRpemFJVmZDWThPZlErdXdwMEs5azEvdE5hQ0czYXcwZ2dnNWlCb1JHeS9yVlhoZUJ0WGJkeitEbGNDVkNCVlh6ekZ0YUNXN040dHFWVWVXcDI5T3RhN2dIRGJlOXp4SG9USXAyMnlhU1dqSFluRFJNa0NxaWxUc3cwMHIwYmkvQ01PNTB0QXUyZzU4b2dMdHk1VmllSjRSRVlyQ2dqY0RTQ09vcE5VVkdWZzA0VlB1TDdDbFRoQTBCcnRTTTladVl5MWN1QWxBUlZKK0NJNXVRWUoxUWNoNjFuTFBFSU5XVzR3UnNkYXllUnQ3UmZnY2YyT2dYeFd3RWdCZ3pTUTZnRVpTREcvT2Q5S0ZsWnFiSDM1YWVacUt4enFHN05vcWppMkt2WVd4VUttckZ1L0ZTV2p0eHdNUmI4c24vVlcxZmpDQVJwdUQ4eHpyemk3ZW03UG1QcFZoOFVhYWJYUm5QSEdmN2d0MjF4NlhIaEZXR3lsakF6WmxuVUhsTTYrZ3JNcXRUWFduZWtvcW0yK3dqRlJWSW13eWFpdEhoWXJQMkJxUFVmalJpMWNxNEV6TG1Lc3FScFFDOVoybzFjdWFWUXVyTWYzeU5hR1lNTnN6NVVpQUtJZDNVdjdNRHlvb0FkWlJTUkpnVHFRSmdkWTUwbnRpVEdvNVZadjRRY3FxT3JDZ0IzY25lRFRUcFJQaDNGTGRwU0xnTnptRkw1VkJpSklHNStWRDc5MUhhUUFKNURXZ1ZrUXVEMW83dy9BTGN0K1B1N1VHYzd0QlA4c1NCVlhFY0d1SXZlQlNVNU5HV2ZrZGFkZ01KYVpHTngwdHdmaUpMSFVhTGxIcFRTRTNyUU00amgyRGtXN2lGZXNFL29QclZIaTFpL2xEV1NNNno0VzJZSGxNaUQ2NlVTWmtWdEhMTDFWWW4vQUZVUnh2R2JUcmxGaGl4R3J2Y0piYU52NjBJR1k5YnZFaGJJNzIxQklKdGJBeDV4djg2SzRDM2RlQm15bm5wTmR0VzBBT2dCMGdsaVlITWE3OHZhckFzT0VOd0U1UWNwSTBFa1RFME4yQ2pScnNOdzZ5dG4rSzV1Tjk1enQ1S09sWjNGOE90dExxRktxd0U2UUNkUitGQ3I5MHNjekVzZXByaXZIS2l3VVRROE80bmJ3NFVqeFNKaFlrUVlnajdOVDhVN1VoamxWU1Ywa3pCNVNJajFGQU1MaUxldmV6R1V4bEtqeGNwbmxWRzVkSFg4YUwwSEZYWVgvZW9XN25DQW9ESVZ0eU9qRWZsVlRGY1RkbUpEbFFTZkNwSUFIVFNoeHVpbzJ4QUhUNW1sWTZMOWpGRld6aG1ERFlnbWZlcmRyQ202dHk1SytIVnN6QU1aNkE2azBEWEZBN1FmVFd1dGlUMWoyb3NLTEpQbFNxZ2NVUHZqM3BVaGg0SFdvNUpNMTNOVExna0FhN2pZa2JhOHVWWUhRUkRyVWxrNkdvM3J0czZVaGtwYXVCNlpYS0FJdnRWTE5RcnZVdE1RcWV0Y0ZPRkFFMW5jZXRFVk5Eckh4Q3I0cldIUmxQc216YVUwamIrK1ZObW5IbFdoQjBDcGtOUWlwQWFBSkhBTlZybG1RYW5tdTBnQkY3Q0RXcW5jbFRvU1BTamwycTF5MERURUNiNGM2bG1iL01TZnhxQmNUbDNnZktpVnhLRjQxS1FGMFk5Y2hVckxFZ2h0UVFCTWlOdGRQYXFwdmpwUWNzWk9wOTZxVzhjRGQ3c3FkWk1uK1dsZGo2TkNjVUIwOTY0ZUlhUm1IeTFvUmg3b0pZUjhKajEvU3A4MVRaWEV0TmpmTSt4cU00cnlQemlnR0w0M2xMaUl5c0ZHeG5lWjEwbVByVTNEdUlaMUI2YUdZblRtWXEzR1NWa0tVVzZDNXhCNkQzL3BUR3Z0NWZYOWFyUGlBQm1MQUFiNmJpb3I5OEFocDM4SUU2TVRCL0NJK2RKSnNwdEl0czdIbjlCUVhHOE11TzBxNFZmVS9wUlF3SkdjTWN4RUFiYURicVBPb3J1SUNrQWg5ZWlNZnFCSHVhRTVKNkZKUmEyVWNCd3RyYlpqY25RaU5mMW9sa0hTcmQ3Q0txWjF6RXNRUnRwSTJQMXFzbHBqOW44cVVtMjlqaWtsU09aYVZTL3M3ZFBxUDFwVkJab2dhUk5ObXVrMW1ha053NjExTnFpdXJKNSs4VTBXdk52OVIvV2dDeEZLS0hZbkdMYmRVSmFXRTduYVlxdmdiWnQ0aTROU3R6K0lyYTc4MW5iejlLcmlUWVN0Ym1weFZleHovdm5VNHFSamhUNmpyb3BnV01OOFEvdmxWNnFHRitLcnRhdzZNcDlrbFBxSnpBUHBXZnhIRWJ1WkVidTJETVJxazdJemRmNWFwdWlLTk5YYUU0UEhYR3VLalpZSU93SU9nOWFLelFuWU5VUFduQTB3R25Vd0dPZGFoY1UzRjRsVWtzd0hseitRb1BpZU9pU0VIb1czOWhURVg4UlFxNmN4aWhsL2lWMTJpV1U5VzBVZ2JCY3ZPcVZ0N2hsZ3p6bE01NG1aMUZ1QnZ0dlJURnlRZEdBVGZYM3FGZUVXZytlRG1FL2FQUGZTaHFYcmhEUTF3QVFSbmpPZkpNdW5MbjFwclhMaHpBTTZxTlJuK002ZkNwVXh5K3RUd2ZzcnlSOUJwY0hiRW5MdVpPcDFQWGVuL3N5ZmRGWjVicnZLS3pLUGlsODB6b0l6Qi9uRlNZU3pkdk9MTnBidmkrOW1Zam5PWU9JR2cvczB2Ry9ZZVZlZ28zQzdHdjhBQnQ2bVRLZ3lkZFQxT3A5NmRid2xwZEZ0b3ZvcWo4QlYvaDNBTFZnVGRZM2JoRUZjN0cyRDVrblgwR25tYWhmQ1d3NUlRRDBtTnVRcUpTK3JOSXh2ZEdkN1RJcEZ0ZEpMSFFEbGxNL2xWREZZUWQ1YlNQQ0ZYNlQrZ3JZL3N5ZmRIdFVkL0JXanExdERBNXFEb05hY2NpUXBZMnpCY0VGd1lyTXdjQTU5U0RHL1UrbGJIdlFlWXE5dzdDSmVDaTNiVXp5eWpTTkpQSUNpallMRDRlUWx1Mjk0L0UrUllYcUJwcWY3OHFlVEp6ZDBUanh1Q3F6enJoNWNYN21kbUlCT1hNeElnbWRKT25LdEV1SVg3dzk2SGNad0FONWlBb0JnL0F1NUd0TlhEa0FhcjdSN0FiVmN2bnNpTDRhQzM3UXZVVnloZ1FjMjE5UC9BQ3BWUGpSWGtacXdhUk5SWWErcnFHVXlDSkJxUmpXQjAyUUx6cHhOY3Q4NnA4WHd4dTJtdEtZWndBSTE1ZzdjOXFGWDJOS1QxRld3MWFzNGUvYkM1VmNnZkdHMUIzMWpsODZDY1FsSGx2Q3R0d0ZFeG1raGMwZElPMVppeng1TUozbHF6bnptUVhKakt5L1pnanlQek5EYnZFcmx6K0pjL2l4b0RjSmJVa0V3Wm4ycnE4T2psODI2UFFMVGdBa2tBRGNrd1BlcStMNHhiVElCTnpNU0IzZVZnSWdrc1pBRzRvWmY0Qmk4VllXNW10aTFxNFZpUXpMdURFYkFUSFdhT1d1RzJVdzlxVk1vUXhBSXp1eEFKR1dkaWZscHZXWEJMdGw4MjMxb3NVNFZReFBGYmRzTTEwaE1wV1FNeEF6YkRxVG9hcEh0WmhSLzloLzBQK2xTc2NuMGlua2l1MmFQQ2ZGOHFlMk9VWGhaZ3lWelRwSFBUZVowNlVFNG54UnJlR2E5YUJ6RlZ5eXBueHNvbkwxZ2t3YUE0THRJNmdYcmlscms1Vm53ako5b05BMms2R0pueXJXRVh4TTV5WEtqMEs4ZkMzb2Z3ck5ZMXd0eTBTUUZCY2trd0IvRFlhKzlXeDJsdzdXUy9lQUU2WllZc0Q4aHFQT2duRUxCeHlCYkJEQWc2ekFuU0o1eEkrbERqdFdKUzA2N0R2Q2NVbHk0clcyVmhEYWd6eUZIZ2F4M1pUczlld1Jkcm9CekRUSVpYUWFTU0JCMVAwb2x4RzdpYmhQZGpJcCt5R0dvTWFFenlvcFJ0SU9UYVRhRE4vR29reWRRQ1k1NlVGdmRwUStaRk9RaUFkQm1CSW53dFBRamxRYkgyTHFnbDBBMDFKWlBMWFhlaFNjSHhSYzN3akcyWUpsWlB3d1BBUnQ1MDByZlltOWFRYXZzV21UbUo1eko5NXFMTEEyWWVaQi9HcUQzU2dsMHkvNWtqOENLTTJ1emd4ZHBBU3R0R2hpUk9ZamNRcGtENW1xSnB2b2dXdzIvL2Q5TkthVWdpU0k1em0vU244UzdQWGNJb0lJZTFNSyt4MTFBY2NqeTAwMCtWVnYyaUNScUJyQjd3ekhLUWY3MW9ZRmhtVDc0L3dCMzZVMXd2L0VCK1ovU3U0ZHkwQWQ1dnVMZ0kxMG5RVEh2UmpoTEcyOGdra243WWtqZlVTTkRVeWx4S2pGeUc0SHMrZml2RW91NEFnM0c5QVI0UjVuMm93SFZGeVcxQ0x6QTNiemR0Mi9DbXV4T3BNbnFhelBIT0xsYjlwVlpncXQvRXkvYTIwT25MWG56ckw1VGRHdFJnckQ5eDZFWW5Gc0hJQUIyL0NwVTRrSHVNaXFZQ2hzK2tHWTBqY0hYNkdxMTgrS29hcnMwVEt1TDRrd1pJMGd5d25RcVozbXEvYUxIM2podTl0cVJiN3hGTnhTUnZNQStwQUI5Zk9yNHdpUHFTd01nZUdOZ0NkWkhtYWt4cFA3SzJIVFMyckc0UWRTN0I4OHR0cG9BQU5vSFBXdG9jVlRNTW5KMnJBWFlMaVY4WDc2cTdDMWxJeXlTRkpjWmNzN0dBMm82VnFjVmkxUVFZTFJvSkgxNlZtZUR2M1daNFVGbFZRQWtDWnpabUs2c2RUcVorS3U0Zkd1N09ibHN5dlR4RWlla2FSK2RQUHR1U0p3YWlreTgySmxpWEtrbU54TVJ5M3B0L0hBYUFMTWJnZjFvYnd1NjFyT3BSbURzempML0FEZFJCTTFKY1JYR1Z4Y1lHUENVRGU0bXFVZlpMbDZLdDNpc0V4RERySXBVOXVJcGJKUkxZQ2c2QmtCT3VwblR6cmxhVitET3phOEs0UzFxMGxza1NxZ0gxalg2MWNPQlBYNlVVVkJUd29ybGF0MmRhMHFSbThCWjcyMkhSaEI1RmRRZGlERFVIVmJqWXdXMVlmSGxKSU9paU01QW5vQ2FNOEN4RnV3K0t0dXdBVzZ6Q1R0bVB3Z2RBbmRlOVpiZ0hhSFBlYkxrUjJpRGRCSUpkOVFJWVFTWTY3OHFwNG0zcGFMdzU0d2kzSjdhcEk5UTRad0RCV21OMWJLbTYrcHVONG1KTzhUb3N4eWlzejI2N0kyN2gvYWJCRW9CbnNFUXR3QmlTVks3TWRRZXZsekpjTDRvemZ3cm9WWCt5VlBnWWhaS2lkUTBTMEhlRDBJcVRHWWxFUDhBRVlLakEvRVFKNUh6TzRyYTJqbjBaMWUwdUhuSmZ0NWROUXlEWWpRYVRLK1EzMm9IMnE3VzJqZGpEV25WaUZZczBOQlpROExaQkNqZm1kT2xDMDRVbCs2MW0xZUdkVzhCWWtnd1RHWnRUcU5JM242d1liaDEvRDNuTFdPOHVSQzVXTURPSFV0SzZtSTErdTlPR0RHdHN4bm1tK3Y4bG5pR0liRk1saTlmdDIyWHhGaXVYT3pBWlJrSkVFWmlOSkcrMVcrRzlpSkNPOTJSb1N1U0pFN0U1anZWZTNoTGY3UjMyTHVoMUJsTFFhWVl4bzZrNWxYUWN0ZEpPbXV2d2VNSnNvQUIzaHlKRXlvWjlKSjAwR3NqVFZTS2M1TktvaWhGU2R6Tk5nemJVQUtxZ3h1ZmlQditWUTR5elplU1VHZnJBTTlKbXN4ZHRYY3B1ZDg4QUVoWXQ1Y3UrdmgwTWMrWG5Hc1YzaVp0bGN3azVvSkFpUVVMSzBjdmhJanFEV1BFNnVacnNUY1ZMWlBoRUtZMkd3MG9Kd1Z4WnRMYmtiWnRCdVg4VXo4NkQ5bjhOYkYyNERhMHUrUHhoV2hpekVFSG93SStZMjFxN3grNWxZS2hnNUN4aVBDcVJvQnlKekFhOHZTbngzU0pVL3RoY2NST3NIOC9wUW5pR0d0NVd1QWtMSVpsVFF5VEJ5UkVBeURIclE1TUdSQjcyNW1KQVBqSkhpSVV3cDAwbWZsVi9COEN1bEFWdlJCSTJJMVVsU1FaMjBQeU5KclErVHVnZnczQVc3VndYU1djbktVTHdWeXVGSVlUcUdHcS9oV3BiaUdUeEVoZlBRVmtNZHhHM1p2SXQ2K2pBTTJZSWM1QktuL0V5aVFKTmNUaTJFWmk5MjliSThXVlQ0b0dZZ0FDSjJBTzMydklSZkJ2WkhraXRCbnRGWi9hQXVWYmJpWmVDdWRsOE8yeG1KRy9UV3J2Q0x1NWdoZDFrUjRlV2gyR2hyekRqUEYxZTVjTmxHQ3NRTTNpQjhNNVlFd3VrRDVWcHVGY1p0M0xLSUhBelpBNEpHWUVFWndaNUdEOGpWUEZKRVJ6UmJvMU9PNDVaMFIvR2paZ1JsSlZpQUNzRWpLZFlPaG9PbkZ1R09wWTJ5Z0J5a2taWVBUNHFxY1FOeTYySDdpNWJ6b0M1N3g0RzZITUR0bWtFZjJhdHZlNGhtWU5aVzViQUpVeGJmTWVoQXFaS2kxS3lhMjNEMklGdThVSkVnUm1rRVNDQXluNlZjNGZZc0E1bHhWdGhJNUtwMG5wRlo1K0toZjRsN2h3Vmdjc2l5VllhYmhsNWNxaHU0dmhvUGR2aHpiTnpLZkE3aWRkUFF5VFV1TjYzL1lLVmIxL1J2MHRJZjhBN0ZQb1IrdFlqam5aNjYxMjY3WDdZVExjdURMbUo4QUJDc3NBQW1BTkNaaVlwcjRQQTNZVk1UZnRsQkVBcVlIODJoSitkU1hlRWFscmVNbFNEL0MrQ2ROZ1pwUnFKVW01QVBCY2NzaDFjTXdnQVFSdEFnYWpsVzhQQTJjQjBkQ0dBSTNHaEVqa2V0ZWV0Mlh4akJBYll1UkNpR0hoVVRvV25iMHJUNFhHY1NzMjROcG1DZ0FLQWphQ0JwbGoreFcyWlJrbFJqaGxKTjJXMktXMzd0cnR2TU5ZRGF4QkhQblZERjhXdGhDc2pNWmthekRiUnlOUGJ0UmNBejM4TEVHUEZiWUh5STMwOHhVdHZ0ZllaQTdXeGxPazV2T05tQWlzZU5mUnJ6djdBMW5GQkVKa1NGVXhDc1R1TXZseU5QdytLS3N6RFhOSGlCQUVjaHlrZVZHdjNuZzdna1d4NjVFWWU0TkRFNGRoZ3hLNHFBVE9Scll5aldZQUFBRlUrRXRTRkdVNE80a2VJc29kVGVYckJWeDlRQ0tyTDRoQVlBVHV6SUJQTW1XbXRRTUZnbjBtM1BrNVg2WnE0M1puRE44SmNlalQrTTBKb1RUc3lXSzRwWnpIbWRKMDV3SnBVQTdRV2haeE4yM3FRckdENUhVVDU2MHE3RmhUUnhTelNUYVBkNjRibm5WYkE0b1hMYVhNcFhNb2FEdUpFd2FtTDE1OUhwcG1WNDdoclA3Uzk5MFFoYkxNL2dWaVNtV1RxQ0NjcktQenJKL3Y2eWwzdkxhZUFObUF5SXAzdEhMNzJ6L3I2VnJPMDFxNExlSmNKSWUyNEdza1oxdHBBRzUvdzUrZGVaV0dLdHBLdHVOd1oyMDh6TVYxWWttaml5eWFZVnQ5cjhVRG1Ecm1rTk9VYnFUSHFOVHYxb2Z4WGpWL0VzR3YzV2Nyb0pnQUFrSFFLQU53UGFvYmdLa2pLQWZNRG55Zyt0R2NCd1U1VVo4aUs2M3ZFTlNTcENsQkdtY1NkUEk3Nm10dml0bVB5bHF3WHduRzVIZ1FGTXlPc0F4UHpxOE9LTm5LTzJhMlRCSElkQ1BTbHg3RGtZeGdHVmpsQkpVWlJJdHdkQ2Q5SUk2OGhWRTJ1OGNLcEprYnhFQWJzZklhKzFKcUxkL2dFNUxYNUx1T3ZXTFRaVUJZalJzeG1DT2dBVWZVMWNlOWZ2NGN2YkhkakRNdHc4bTErRmwwR2dLQ0JIUHlvUGpjVERQbFZQRVF3YUphR0diUW5hUXdxWHMrWHUzSHRsekJzMzRCWTVaN3BvMHAxcXd2ZEZtMzJ0eFFUdTVSbElJMVRYWGVDSTZtbGhPTVhMdUp0M2JwQmhoNFZsZHAyVmZFWTNqbWRPZEd1eW1FdGpDdGV1VzdiS0Z6RTNDZElhNGRCQkcyVWUxVSt4bURscnVKWk5RcDdzZFMrZFdLanlpQjZtcGJpcjBXbEoxdnMyL0FMaU9DVjFHU3pvUkVFSkd4MUJrVjU3eCs5ZHcrT3ZzckRNekUrSVNDamdNQWZJYUQvbHJZOW43d3Rrbzg1amJzNlRNTWxzQng1SFVIemswSDdaWWdMaWNOZVVRVUl6SFROQmZ3d0R2SGo1YzZ5aHFiUnJrM0JQMENjVjJpdjNnbHEyaVczYUZsU1N6TWZBSW5SWm4rdGVyWU5WdFcwUmRGUlFvbm9vajhxOHJ4MW51OFVNeC93VVc2ZHBCYkVaMlZRc1pvNzAxdUwzRWkxb20yVllzdmhrRXFaSFB5cFpVcVZEd3QyNzdQTThOZzJ4VjE3azVWZTYyc1RCZlBjMWtnYUJUdVJ1SzdpK0NGRlo4NmxCbWpVQnpsZFUxU1RsTXNOSk5hanN0Z253OEs2cklaN2dZYS9ZVkFEMDNhcW5hUmpjQ0FJNXpQY3paSmdqdmcyb0drd05DUnlIUVZ0NVBsUzZNUEZVYmZab3YvQU9kMmJkdkJHNDRuTzd1ZjhxZUFEL1lUODZGOXIrQ0phc0l3Q0J5QjRnb1VscFFRUUYxSkxiaytkRWVES2k0VmJTWmdDREliVWpNWllmaUtzY1R3UDdUa1Z5Y29NbURHZ2tqWC9NRnJIbFU3TitGd1MvQkZ3L3N1aVNyWmd5cWdsZkdEb2RUejNuWUFWTis1b2IrSGZUTjBNbzM0ejlLTVdTUXhZbmNLUGFkL2VwN2hEQ0dBSTZFQWo2MWxMYnMyaXFWQVh1Y2JiMkxIMGJOOUdxcGY0aGRIK05ZUmgvTmIvTWFVYy9ZMEh3RjdmK1JpQi9wTXI5S2F3dmpaMHVEbzY1VC9BS2wwL3dCdElabTBmQnNXUDdQa0xBaGpiYmNIZVJwVmRlQ1lQS3kyNzkyMW1qNGdUbEk2R05QZWorSmREL2pZUWorWkl1RDEwZ2oycW9NSmc3bndYc2g2RXhyNk5UVW1TNG9vRHMvZjd0Ull4TnQzQitJblVqWFE3OVI3VXJ2NzBzb3BDbTQydVlCcFdKMGlhdlhPemo3cTZzUFA5UlVCczR1MFpCZU9pdG1Ic2FFMTZCcCsyTXY5cXNSWlJHdTJ5WkF6TGsxVXhydEdsTWJ0VGhiaUJydGkyVmJTU0I5UkI2R3B2My9lV0E0VTljNlFmcEZNeFBFc0xjMHZZWlNPcXdmMC9HaFVEYkdvT0czVUlXMlVSdENVMEgrMCtuS2xoK0E0UUt5MnI1QWJreG1OSTBtS1ljQncrNWJOdFhlMHA1YSt2T1FOcVpoT3lZV1RheFBlQWpRRWhvOHhCMHA5cDdKcW10RExYWkc2ckJseEl1S1Bza2VYM2dhb1kvaHVNc2t1VlFwTzZreUJQOWFsdDluc2RiY0hPSFFIV0RySHpINTAzaVBFc1pZWVpVdUZZMTBZd2ZyNVZXM0txVEowbzN0ZjkvSms4ZGR6M0dicWVaMTZhMHExbGp0UGRaUVNBRHpsUk9oalhTbFc2elNTcmljN3d3azc1ZjZQVkJhQXBGUlVwRk1LMXhub0VMb1AvZFp2ajJkN2x1M2F5S2ZHek1STUxDb2NvNWtoeVBuV3BhM05VYnZERUxaL3RSbG5YYVpqZnJUVG9tU3RIbWZHdUFsc1FZSmk0eGxqcUFUNG9BM0FoVDE1Vlp0OEl1QTIwa2xWWXlSSk1aVG9CeVV4N3RXK3VjSXRzeXNabFRJOWNwWFhyb3hxZExDcnNBUHBXbmtkVVorRlhaNTQzWXU1ZXVGMmNJdkxUTVFCOHdQL0FIUmRPeHR0VXlDN2M4L2hBUHJBbVBLYTE3VkUxSjVKTWF4Uld6QVgrd1RsdjhaUXVuMlNXZ0FDSW1PWFdyRDlrN1ZpMjVYT3pzcFROdkdmd2tnRGJldG95MDByUjVaQzhNZlJoVzRZeTRaOE9BV1V0bUdiUWdpSTIzMm1yWENEZEZ1M0FpTGFydEIwMko5NjFqMjZpN21rNXRsTEdsMEFPRjRPNmpzN3ZKZUorUWdhVkZ4cmdvdnNwSUo2NjdBQm9BNTdtdEliVk5ObWtwTmJHNEpxbVkyL3dWZ3hkVmw5TlNUc0NwLy9BQ0tsNExZeENNVlpJdG1ZZ2lGNWlOWmp5OUsxbmRWMFc2Zk4xVEY0MG5hS0Z1eWVkU0pnbEFpUDdPdFhNbExMVTJWUlh0NFlMb0FCNlZLbHVwSXBSUllVZFUwOFBUQlhab0dQelVzMU1tdUdnUkxucURFWWRMbnhvcmVvMTk5NjdOZG1nQWMzQjFVemFlNWFQOHJFajVnL3JUYzJNdDdNbDBkQ0liOHZ4TkVzMUltZ0FXM0hGMnYyV1R6SWtmV0tqTm5CWGZ1cVQveUdpMmJsVlBFOE1zdjhTQ2VvOFA0VUJRUHZkbGxPcVhENVRxS0dZbnMvaUUrR0Q1Z3dmclJLN3dSMU0yTHpLZWhtUGRmMHB2N2JqYlh4b0xnNmdULzB3ZmNVeVdCbHhXTXMvYXVqMThZK3NpcDdQYTI4TkhWSEhwbFAwMjlxS1crMDFzNlhFS25ueittOVRtNWhMM05ENitFL1duL0JOZW1DL3dENVduUERmN2gvMjBxdkhzeGh6cUFma3hqOGE1VCtJZkk5Qk5OTktsV1pzTk5NTktsUUExaFVUQ2xTcGlPUlhDdEtsU0dNS1V3clNwVUFNWVUyS1ZLZ1FpSzVGS2xRTTRCWEtWS2dCaHJrVXFWQWpzVXBybEtnQkdrS1ZLZ0RrMHBwVXFCQ3BVcVZNRHNWd2lsU29BWVRUU2FWS2dCcGFtNXE3U3BBUlg3Q1hOSFJXOVFEN0hsUXUvMmV0SDRDeUgvVVBZNi9XdTBxZGcwbURMblp5N09qV3lQK1lmU0tWS2xUNU1qZ2ovL1pcIixcclxuICAgICAgICAgICAgICAgIHRodW1ibmFpbDogXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8yd0NFQUFrR0J4TVNFaFVTRXhNVkZoVVhHQmNYR0JjWEdCY1dGeGdYRlJVWEZoY1ZGUmNhSGlnZ0dCb2xIaFVWSVRFaEpTa3JMaTR1Rng4ek9ETXROeWd0TGlzQkNnb0tEZzBPR2hBUUd5MG1IeVV0THkwdExTMHZMUzB0TGkwdExTMHRLeTB0TFMwdExTMHRMUzB0TFMwckxTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExmL0FBQkVJQUxjQkV3TUJJZ0FDRVFFREVRSC94QUFiQUFBQkJRRUJBQUFBQUFBQUFBQUFBQUFGQUFJREJBWUJCLy9FQUVFUUFBSUJBZ1FEQmdNRkJnUUdBd0VBQUFFQ0VRQURCQkloTVFWQlVRWVRJbUZ4a1RLQm9VSlNzY0hSRkJVall1SHdNM0tTb2xPQ3N0TGk4UlpEd2dmL3hBQWFBUUFEQVFFQkFRQUFBQUFBQUFBQUFBQUFBUUlEQkFVRy84UUFLQkVBQWdJQ0FnSUNBUVFEQVFBQUFBQUFBQUVDRVFNaEVqRVRVU0pCWVJReWdiR1JvZkFFLzlvQURBTUJBQUlSQXhFQVB3QVMxZEZOYzA1VFh6N1BwRVNMWE1ReGlCdWRKNkhrYTZ0TlY1YjAvRS8wbjNwb0dXcnVDZXlRbHhXVXdJRENESEkxQmRRTUlJQkI2MU5ldnMwWmlUQWdUcm9PVlJEZWh2ZWdTMXNyWURCSllMRkpHZlNDWmdEZVBlcmk2MEY3V2Q2ajJXdHF4Q2hnMENkVEJJTWVTMDNEY2NUSk9ZQW4rNXJTY0pOSjltY1p4aTJ1Z3pjYmxUSm9QKzlrKzhQY1Z6OTdwOTlmY1VLREJ6WHNMazAwdFFvOFl0L2ZYM0ZOUEdMZjMxOXhSd2ZvT2NmWVRacWFHb1dPTElUQVlFbnpGRXNNd090SnByc2FrbjBUb25XcEs0RFNxRFE3U0FycEFBazA2eStZU0FZODlQbjZWU2lTNUhHMEVnRW5wVEVzc1NDeDIyVWJUNTlhdVc3SlBwVnEzYUEvV3JTSVpYdFlZbmZUOGF0SWdHd3A0RlBDMDBpV3lxOGt3QlQ3V0c2MUsxd0NvOHhQcFZwRXRuTGpCVHA5S2tiRXJ5cTl4ZE1PRXQ5eVdMUjQ4MjA2YmZYNlVISzAyaVV4NzRnR21tb3lsY0JpZ0J4RmNwd05jSW9HY3BVb3JvRkFoc1YxYlpOUzIwbzd3UGlDV2MwVzB1TWRCSUxSNkFVMGhObWU3azEyano0RzZ4TGR5ZGRlUStuS2xRSXc0dVRVeU5VTnUzb0tkM1I1VnlVZGlMS21yR0ZTMTNSa1AzcE1neU11V05tRVRtMjFtaHdVa2hXT1VFZ0VtZEJPcHE3ZGhXS2gxZURHWlpnK1ltRFQ2UXUySW1wOElBUEVmbDY4cXIyMXpHS3RYRHJwc05xUzFzcnZReDB6QWc4OStSMTg2eU9MN0lPQ2NyZ0NUR2FUb1lpWTI1OWRoVy80VGdzNUxOOEkrcC9Tb09KcnJXbU9jb2JSbmxoR2VtZWZqc2xkL3dDSW5zMVBQWkYvK0tzZjVUK3RhdWFSYXIvVVQ5bVg2Ykg2TXAvOFJiWCtNSjVlRS9YV2t2Wkk4NzNzblA4QTFWcUdha3F6dlIrb243R3YvTmo5R2F0OWt6L3h1djJJMTVmYXFLMWpIdzl6dXJ2eWJrdzVFZjM1VnJxcThRd0tYbHl1T3NIbXBJaVJTV1p5MVBvYndLTzRhWnpDWGM0a1ZjdFJ5MTVmMHFsd3poeHQyeGJKT2gzR2tqOHFMWWZDQUNJZ2RCVThWOUZKdjdJQll6RWFUSHNLdVc4T0J2cWFtVlkwRlBDOWFwSVRZMENwQW5XbW01RzFSbGlhcEloc2xhNkJ0VVRPVFNDMDRMVkNJd0tjRnA5TkxVQWNJcHVXa1hwOXE1cm9KTkFpd2VGWE83RndvY2hNQm8wbXFWNjFHOWJMaEhDNzE5QUhjcmJHeWpYMm5RVU03UWNJc284QytvZ2FxSWU0V2t6SjF5amFxclZrY3QwWlI3c0hULzNVdHU2RDY5S0o0dnMvM1NMZUthUDhMTVpZL3BRekpxTktUUlNkaVo2cTNjYXE2RmhQVGMrd3E0OXNFRUhucDcxSGg3Q1cvZ1FBOWR6NzBoc2w0UGJONTRLT0ZpY3gwQk9tZ0hQblcxd043QzRZZU4xQjZEeE43Q1RXTGU4eDBreDAyRlJSVHNUVm8zajl0c09EQXQzQ09zTCtiVXF3Y1Vxcm15UEZFcjI3TkU4RGdwT3RWa3E5aDNyak80bTRodzRFYkNnMk40YUYybWpqWGlLZ3hWMEVHZWxLeDBDTUt1VlBNaysyMVBGUUV3ZktuREVBVXV4OUJpMWpjcWdEbFZERjNacW0rSzlhaWU2VFZXUlE5bXBoYW95VFhVTklaS3E5YWttb3dhbVMzMXBkajZPS0pydHRobXk3bm4wSHFlVlRJblNwN1dIQXExRWhzcDRQSHFicjJ2dExsK1laUWZ6cTVjeGx0ZmlkUjh4UTdqM0JPL0FhMlFsMGFCdFFDc3psWWozSDlhSFlYc2V5bVh2L0FDUmZPZDJQNVYwUmpCcTJ6bmxLYWRKQnEzeHl5eHlxNmsrdS9wMXF5TDA4NkVYZXkxa3FBR2NFZmFPVWsrb2dUUTl1RVl5eHJhZnZGNmYrTGZrYXFvL1RKNVNYYU5VaWF6UHk1VklCV1d3L2FOa09XOWJaVDZINnFkUjlhTllQaTl1NThMQStYTWVvcE9MUTFOTUpCYWF3TkV1QTR0bkpzMndEbklWdkRualhjL2RBOVJSRGpIQzdOclEzZ3ovZEVhZkliZk9pdFdISlhSbDN1UlRGSFNmbVpvaGl1ejRRbzF3RmxmeExKa1JQSWJEZXI5NUxWaThDbjhSQkIxRVQxRUhhaWgyQmJQREx0NWdsc3dUNVNmbE9sRXVFOEtXMWZ5M0NWWW5Lek9aalhuMEZQdmNSaThidHNaTlpVRGxWWEZZdHJqRm1NazZrMDlDMnk5eDNFdUhhMHQ0dGJHZ3luS3ArUTMrYzBHVVJUMjFwc1Vtd1NDZGdkNWJiUGRWY2c4S3RMRStTallVSWRha21uMnJKWXhRQlZOTkJvdGorR2kyWURxK2t5a241YlRRVEY0aEUzUDhBZnB2UlFXVEVWeUtnc1luYVJvZGordFRzNHBET1JTcXMzRWJZTUYxa2VZcFVDc3VxbFc3SzFkdmNNWlRCQkZNRmlLd2FPbE1ndWlxV0liUTFmdkxWQy9VVVVVWEZRc2xXeWxPV3dUeW9BSHNLN2xxOWZ3VFNBQnFlVlQvdWE3R1lvMFRsMk8vU21sWXJvRTVhNHkxYXZZWmxKQkVFYmcxR2JkRkRzZllTcmFXZXRMRERvS0lwZ21pWW1yakd5SlNvcXF2U25DcjFxMmduT3JiR0kwaHVST2hrVldLaXRPTkdmS3hrbXA3dDhGRlhJb0t6NGhPWnArOXJ5cUlpbWsweENDMWFUQVhDbWNLY3N4TWFURXhWUlNhTzhGeEZpM3JmWm02SXNtVDU4dmMwSVRkSUFZcTJwRU9vSTh3Q0I3N1VLZkMyTVA4QXh3SURGUVlNcnJNSFhsODYwM0dzVmF2UEsyUW9HMmJYZitVYWZqVld6aEJkUGR0a3luU0hnSnByck9nMi9DcVQraE5Yc2l3UGEvRFdReXU0WldVaktoSThSMkp5L25RN0NjZXMzREN0cjBiUSszT3V0MmV3K2NzeVpqNWtrZXcwSTlacm1ON1BZZTZQZ0NIa3llRSsyeCtZcXZpUjgrd3N1S0pqWGJhcHNiZlYybFVDQ0JvQ1NQWFhXc2kzQzhYWTFzM0JkWDdyYU44cE1mVWVsWGVGY1V1WEpWclRJeW1DR2tmTVNOUlNhOURVdDdEYVdpZGdUNlUxbElvbDJlNzBIdkxoN3ExcXJzRDRvUDJZVUdaNlRWamliWVJ5RnRCenl6Tk1ldXBuNlVxSHkzUUFhNE90TU4zb0tLVytBMmJkNEM2SGROdzRrazlHWE55bXU0ZkVXYlljTWl0SUlVazZxZXZuUlFXQkMxMGtoYlpJSDJwQUczdjlLTzhHNFlTaHZYUktxZkZsa2dkQnJGV3VBNHNPR3NybWRHak1FeWd5TlI0anRVdkV1RzRpemFJVmZDWThPZlErdXdwMEs5azEvdE5hQ0czYXcwZ2dnNWlCb1JHeS9yVlhoZUJ0WGJkeitEbGNDVkNCVlh6ekZ0YUNXN040dHFWVWVXcDI5T3RhN2dIRGJlOXp4SG9USXAyMnlhU1dqSFluRFJNa0NxaWxUc3cwMHIwYmkvQ01PNTB0QXUyZzU4b2dMdHk1VmllSjRSRVlyQ2dqY0RTQ09vcE5VVkdWZzA0VlB1TDdDbFRoQTBCcnRTTTladVl5MWN1QWxBUlZKK0NJNXVRWUoxUWNoNjFuTFBFSU5XVzR3UnNkYXllUnQ3UmZnY2YyT2dYeFd3RWdCZ3pTUTZnRVpTREcvT2Q5S0ZsWnFiSDM1YWVacUt4enFHN05vcWppMkt2WVd4VUttckZ1L0ZTV2p0eHdNUmI4c24vVlcxZmpDQVJwdUQ4eHpyemk3ZW03UG1QcFZoOFVhYWJYUm5QSEdmN2d0MjF4NlhIaEZXR3lsakF6WmxuVUhsTTYrZ3JNcXRUWFduZWtvcW0yK3dqRlJWSW13eWFpdEhoWXJQMkJxUFVmalJpMWNxNEV6TG1Lc3FScFFDOVoybzFjdWFWUXVyTWYzeU5hR1lNTnN6NVVpQUtJZDNVdjdNRHlvb0FkWlJTUkpnVHFRSmdkWTUwbnRpVEdvNVZadjRRY3FxT3JDZ0IzY25lRFRUcFJQaDNGTGRwU0xnTnptRkw1VkJpSklHNStWRDc5MUhhUUFKNURXZ1ZrUXVEMW83dy9BTGN0K1B1N1VHYzd0QlA4c1NCVlhFY0d1SXZlQlNVNU5HV2ZrZGFkZ01KYVpHTngwdHdmaUpMSFVhTGxIcFRTRTNyUU00amgyRGtXN2lGZXNFL29QclZIaTFpL2xEV1NNNno0VzJZSGxNaUQ2NlVTWmtWdEhMTDFWWW4vQUZVUnh2R2JUcmxGaGl4R3J2Y0piYU52NjBJR1k5YnZFaGJJNzIxQklKdGJBeDV4djg2SzRDM2RlQm15bm5wTmR0VzBBT2dCMGdsaVlITWE3OHZhckFzT0VOd0U1UWNwSTBFa1RFME4yQ2pScnNOdzZ5dG4rSzV1Tjk1enQ1S09sWjNGOE90dExxRktxd0U2UUNkUitGQ3I5MHNjekVzZXByaXZIS2l3VVRROE80bmJ3NFVqeFNKaFlrUVlnajdOVDhVN1VoamxWU1Ywa3pCNVNJajFGQU1MaUxldmV6R1V4bEtqeGNwbmxWRzVkSFg4YUwwSEZYWVgvZW9XN25DQW9ESVZ0eU9qRWZsVlRGY1RkbUpEbFFTZkNwSUFIVFNoeHVpbzJ4QUhUNW1sWTZMOWpGRld6aG1ERFlnbWZlcmRyQ202dHk1SytIVnN6QU1aNkE2azBEWEZBN1FmVFd1dGlUMWoyb3NLTEpQbFNxZ2NVUHZqM3BVaGg0SFdvNUpNMTNOVExna0FhN2pZa2JhOHVWWUhRUkRyVWxrNkdvM3J0czZVaGtwYXVCNlpYS0FJdnRWTE5RcnZVdE1RcWV0Y0ZPRkFFMW5jZXRFVk5Eckh4Q3I0cldIUmxQc216YVUwamIrK1ZObW5IbFdoQjBDcGtOUWlwQWFBSkhBTlZybG1RYW5tdTBnQkY3Q0RXcW5jbFRvU1BTamwycTF5MERURUNiNGM2bG1iL01TZnhxQmNUbDNnZktpVnhLRjQxS1FGMFk5Y2hVckxFZ2h0UVFCTWlOdGRQYXFwdmpwUWNzWk9wOTZxVzhjRGQ3c3FkWk1uK1dsZGo2TkNjVUIwOTY0ZUlhUm1IeTFvUmg3b0pZUjhKajEvU3A4MVRaWEV0TmpmTSt4cU00cnlQemlnR0w0M2xMaUl5c0ZHeG5lWjEwbVByVTNEdUlaMUI2YUdZblRtWXEzR1NWa0tVVzZDNXhCNkQzL3BUR3Z0NWZYOWFyUGlBQm1MQUFiNmJpb3I5OEFocDM4SUU2TVRCL0NJK2RKSnNwdEl0czdIbjlCUVhHOE11TzBxNFZmVS9wUlF3SkdjTWN4RUFiYURicVBPb3J1SUNrQWg5ZWlNZnFCSHVhRTVKNkZKUmEyVWNCd3RyYlpqY25RaU5mMW9sa0hTcmQ3Q0txWjF6RXNRUnRwSTJQMXFzbHBqOW44cVVtMjlqaWtsU09aYVZTL3M3ZFBxUDFwVkJab2dhUk5ObXVrMW1ha053NjExTnFpdXJKNSs4VTBXdk52OVIvV2dDeEZLS0hZbkdMYmRVSmFXRTduYVlxdmdiWnQ0aTROU3R6K0lyYTc4MW5iejlLcmlUWVN0Ym1weFZleHovdm5VNHFSamhUNmpyb3BnV01OOFEvdmxWNnFHRitLcnRhdzZNcDlrbFBxSnpBUHBXZnhIRWJ1WkVidTJETVJxazdJemRmNWFwdWlLTk5YYUU0UEhYR3VLalpZSU93SU9nOWFLelFuWU5VUFduQTB3R25Vd0dPZGFoY1UzRjRsVWtzd0hseitRb1BpZU9pU0VIb1czOWhURVg4UlFxNmN4aWhsL2lWMTJpV1U5VzBVZ2JCY3ZPcVZ0N2hsZ3p6bE01NG1aMUZ1QnZ0dlJURnlRZEdBVGZYM3FGZUVXZytlRG1FL2FQUGZTaHFYcmhEUTF3QVFSbmpPZkpNdW5MbjFwclhMaHpBTTZxTlJuK002ZkNwVXh5K3RUd2ZzcnlSOUJwY0hiRW5MdVpPcDFQWGVuL3N5ZmRGWjVicnZLS3pLUGlsODB6b0l6Qi9uRlNZU3pkdk9MTnBidmkrOW1Zam5PWU9JR2cvczB2Ry9ZZVZlZ28zQzdHdjhBQnQ2bVRLZ3lkZFQxT3A5NmRid2xwZEZ0b3ZvcWo4QlYvaDNBTFZnVGRZM2JoRUZjN0cyRDVrblgwR25tYWhmQ1d3NUlRRDBtTnVRcUpTK3JOSXh2ZEdkN1RJcEZ0ZEpMSFFEbGxNL2xWREZZUWQ1YlNQQ0ZYNlQrZ3JZL3N5ZmRIdFVkL0JXanExdERBNXFEb05hY2NpUXBZMnpCY0VGd1lyTXdjQTU5U0RHL1UrbGJIdlFlWXE5dzdDSmVDaTNiVXp5eWpTTkpQSUNpallMRDRlUWx1Mjk0L0UrUllYcUJwcWY3OHFlVEp6ZDBUanh1Q3F6enJoNWNYN21kbUlCT1hNeElnbWRKT25LdEV1SVg3dzk2SGNad0FONWlBb0JnL0F1NUd0TlhEa0FhcjdSN0FiVmN2bnNpTDRhQzM3UXZVVnloZ1FjMjE5UC9BQ3BWUGpSWGtacXdhUk5SWWErcnFHVXlDSkJxUmpXQjAyUUx6cHhOY3Q4NnA4WHd4dTJtdEtZWndBSTE1ZzdjOXFGWDJOS1QxRld3MWFzNGUvYkM1VmNnZkdHMUIzMWpsODZDY1FsSGx2Q3R0d0ZFeG1raGMwZElPMVppeng1TUozbHF6bnptUVhKakt5L1pnanlQek5EYnZFcmx6K0pjL2l4b0RjSmJVa0V3Wm4ycnE4T2psODI2UFFMVGdBa2tBRGNrd1BlcStMNHhiVElCTnpNU0IzZVZnSWdrc1pBRzRvWmY0Qmk4VllXNW10aTFxNFZpUXpMdURFYkFUSFdhT1d1RzJVdzlxVk1vUXhBSXp1eEFKR1dkaWZscHZXWEJMdGw4MjMxb3NVNFZReFBGYmRzTTEwaE1wV1FNeEF6YkRxVG9hcEh0WmhSLzloLzBQK2xTc2NuMGlua2l1MmFQQ2ZGOHFlMk9VWGhaZ3lWelRwSFBUZVowNlVFNG54UnJlR2E5YUJ6RlZ5eXBueHNvbkwxZ2t3YUE0THRJNmdYcmlscms1Vm53ako5b05BMms2R0pueXJXRVh4TTV5WEtqMEs4ZkMzb2Z3ck5ZMXd0eTBTUUZCY2trd0IvRFlhKzlXeDJsdzdXUy9lQUU2WllZc0Q4aHFQT2duRUxCeHlCYkJEQWc2ekFuU0o1eEkrbERqdFdKUzA2N0R2Q2NVbHk0clcyVmhEYWd6eUZIZ2F4M1pUczlld1Jkcm9CekRUSVpYUWFTU0JCMVAwb2x4RzdpYmhQZGpJcCt5R0dvTWFFenlvcFJ0SU9UYVRhRE4vR29reWRRQ1k1NlVGdmRwUStaRk9RaUFkQm1CSW53dFBRamxRYkgyTHFnbDBBMDFKWlBMWFhlaFNjSHhSYzN3akcyWUpsWlB3d1BBUnQ1MDByZlltOWFRYXZzV21UbUo1eko5NXFMTEEyWWVaQi9HcUQzU2dsMHkvNWtqOENLTTJ1emd4ZHBBU3R0R2hpUk9ZamNRcGtENW1xSnB2b2dXdzIvL2Q5TkthVWdpU0k1em0vU244UzdQWGNJb0lJZTFNSyt4MTFBY2NqeTAwMCtWVnYyaUNScUJyQjd3ekhLUWY3MW9ZRmhtVDc0L3dCMzZVMXd2L0VCK1ovU3U0ZHkwQWQ1dnVMZ0kxMG5RVEh2UmpoTEcyOGdra243WWtqZlVTTkRVeWx4S2pGeUc0SHMrZml2RW91NEFnM0c5QVI0UjVuMm93SFZGeVcxQ0x6QTNiemR0Mi9DbXV4T3BNbnFhelBIT0xsYjlwVlpncXQvRXkvYTIwT25MWG56ckw1VGRHdFJnckQ5eDZFWW5Gc0hJQUIyL0NwVTRrSHVNaXFZQ2hzK2tHWTBqY0hYNkdxMTgrS29hcnMwVEt1TDRrd1pJMGd5d25RcVozbXEvYUxIM2podTl0cVJiN3hGTnhTUnZNQStwQUI5Zk9yNHdpUHFTd01nZUdOZ0NkWkhtYWt4cFA3SzJIVFMyckc0UWRTN0I4OHR0cG9BQU5vSFBXdG9jVlRNTW5KMnJBWFlMaVY4WDc2cTdDMWxJeXlTRkpjWmNzN0dBMm82VnFjVmkxUVFZTFJvSkgxNlZtZUR2M1daNFVGbFZRQWtDWnpabUs2c2RUcVorS3U0Zkd1N09ibHN5dlR4RWlla2FSK2RQUHR1U0p3YWlreTgySmxpWEtrbU54TVJ5M3B0L0hBYUFMTWJnZjFvYnd1NjFyT3BSbURzempML0FEZFJCTTFKY1JYR1Z4Y1lHUENVRGU0bXFVZlpMbDZLdDNpc0V4RERySXBVOXVJcGJKUkxZQ2c2QmtCT3VwblR6cmxhVitET3phOEs0UzFxMGxza1NxZ0gxalg2MWNPQlBYNlVVVkJUd29ybGF0MmRhMHFSbThCWjcyMkhSaEI1RmRRZGlERFVIVmJqWXdXMVlmSGxKSU9paU01QW5vQ2FNOEN4RnV3K0t0dXdBVzZ6Q1R0bVB3Z2RBbmRlOVpiZ0hhSFBlYkxrUjJpRGRCSUpkOVFJWVFTWTY3OHFwNG0zcGFMdzU0d2kzSjdhcEk5UTRad0RCV21OMWJLbTYrcHVONG1KTzhUb3N4eWlzejI2N0kyN2gvYWJCRW9CbnNFUXR3QmlTVks3TWRRZXZsekpjTDRvemZ3cm9WWCt5VlBnWWhaS2lkUTBTMEhlRDBJcVRHWWxFUDhBRVlLakEvRVFKNUh6TzRyYTJqbjBaMWUwdUhuSmZ0NWROUXlEWWpRYVRLK1EzMm9IMnE3VzJqZGpEV25WaUZZczBOQlpROExaQkNqZm1kT2xDMDRVbCs2MW0xZUdkVzhCWWtnd1RHWnRUcU5JM242d1liaDEvRDNuTFdPOHVSQzVXTURPSFV0SzZtSTErdTlPR0RHdHN4bm1tK3Y4bG5pR0liRk1saTlmdDIyWHhGaXVYT3pBWlJrSkVFWmlOSkcrMVcrRzlpSkNPOTJSb1N1U0pFN0U1anZWZTNoTGY3UjMyTHVoMUJsTFFhWVl4bzZrNWxYUWN0ZEpPbXV2d2VNSnNvQUIzaHlKRXlvWjlKSjAwR3NqVFZTS2M1TktvaWhGU2R6Tk5nemJVQUtxZ3h1ZmlQditWUTR5elplU1VHZnJBTTlKbXN4ZHRYY3B1ZDg4QUVoWXQ1Y3UrdmgwTWMrWG5Hc1YzaVp0bGN3azVvSkFpUVVMSzBjdmhJanFEV1BFNnVacnNUY1ZMWlBoRUtZMkd3MG9Kd1Z4WnRMYmtiWnRCdVg4VXo4NkQ5bjhOYkYyNERhMHUrUHhoV2hpekVFSG93SStZMjFxN3grNWxZS2hnNUN4aVBDcVJvQnlKekFhOHZTbngzU0pVL3RoY2NST3NIOC9wUW5pR0d0NVd1QWtMSVpsVFF5VEJ5UkVBeURIclE1TUdSQjcyNW1KQVBqSkhpSVV3cDAwbWZsVi9COEN1bEFWdlJCSTJJMVVsU1FaMjBQeU5KclErVHVnZnczQVc3VndYU1djbktVTHdWeXVGSVlUcUdHcS9oV3BiaUdUeEVoZlBRVmtNZHhHM1p2SXQ2K2pBTTJZSWM1QktuL0V5aVFKTmNUaTJFWmk5MjliSThXVlQ0b0dZZ0FDSjJBTzMydklSZkJ2WkhraXRCbnRGWi9hQXVWYmJpWmVDdWRsOE8yeG1KRy9UV3J2Q0x1NWdoZDFrUjRlV2gyR2hyekRqUEYxZTVjTmxHQ3NRTTNpQjhNNVlFd3VrRDVWcHVGY1p0M0xLSUhBelpBNEpHWUVFWndaNUdEOGpWUEZKRVJ6UmJvMU9PNDVaMFIvR2paZ1JsSlZpQUNzRWpLZFlPaG9PbkZ1R09wWTJ5Z0J5a2taWVBUNHFxY1FOeTYySDdpNWJ6b0M1N3g0RzZITUR0bWtFZjJhdHZlNGhtWU5aVzViQUpVeGJmTWVoQXFaS2kxS3lhMjNEMklGdThVSkVnUm1rRVNDQXluNlZjNGZZc0E1bHhWdGhJNUtwMG5wRlo1K0toZjRsN2h3Vmdjc2l5VllhYmhsNWNxaHU0dmhvUGR2aHpiTnpLZkE3aWRkUFF5VFV1TjYzL1lLVmIxL1J2MHRJZjhBN0ZQb1IrdFlqam5aNjYxMjY3WDdZVExjdURMbUo4QUJDc3NBQW1BTkNaaVlwcjRQQTNZVk1UZnRsQkVBcVlIODJoSitkU1hlRWFscmVNbFNEL0MrQ2ROZ1pwUnFKVW01QVBCY2NzaDFjTXdnQVFSdEFnYWpsVzhQQTJjQjBkQ0dBSTNHaEVqa2V0ZWV0Mlh4akJBYll1UkNpR0hoVVRvV25iMHJUNFhHY1NzMjROcG1DZ0FLQWphQ0JwbGoreFcyWlJrbFJqaGxKTjJXMktXMzd0cnR2TU5ZRGF4QkhQblZERjhXdGhDc2pNWmthekRiUnlOUGJ0UmNBejM4TEVHUEZiWUh5STMwOHhVdHZ0ZllaQTdXeGxPazV2T05tQWlzZU5mUnJ6djdBMW5GQkVKa1NGVXhDc1R1TXZseU5QdytLS3N6RFhOSGlCQUVjaHlrZVZHdjNuZzdna1d4NjVFWWU0TkRFNGRoZ3hLNHFBVE9Scll5aldZQUFBRlUrRXRTRkdVNE80a2VJc29kVGVYckJWeDlRQ0tyTDRoQVlBVHV6SUJQTW1XbXRRTUZnbjBtM1BrNVg2WnE0M1puRE44SmNlalQrTTBKb1RUc3lXSzRwWnpIbWRKMDV3SnBVQTdRV2haeE4yM3FRckdENUhVVDU2MHE3RmhUUnhTelNUYVBkNjRibm5WYkE0b1hMYVhNcFhNb2FEdUpFd2FtTDE1OUhwcG1WNDdoclA3Uzk5MFFoYkxNL2dWaVNtV1RxQ0NjcktQenJKL3Y2eWwzdkxhZUFObUF5SXAzdEhMNzJ6L3I2VnJPMDFxNExlSmNKSWUyNEdza1oxdHBBRzUvdzUrZGVaV0dLdHBLdHVOd1oyMDh6TVYxWWttaml5eWFZVnQ5cjhVRG1Ecm1rTk9VYnFUSHFOVHYxb2Z4WGpWL0VzR3YzV2Nyb0pnQUFrSFFLQU53UGFvYmdLa2pLQWZNRG55Zyt0R2NCd1U1VVo4aUs2M3ZFTlNTcENsQkdtY1NkUEk3Nm10dml0bVB5bHF3WHduRzVIZ1FGTXlPc0F4UHpxOE9LTm5LTzJhMlRCSElkQ1BTbHg3RGtZeGdHVmpsQkpVWlJJdHdkQ2Q5SUk2OGhWRTJ1OGNLcEprYnhFQWJzZklhKzFKcUxkL2dFNUxYNUx1T3ZXTFRaVUJZalJzeG1DT2dBVWZVMWNlOWZ2NGN2YkhkakRNdHc4bTErRmwwR2dLQ0JIUHlvUGpjVERQbFZQRVF3YUphR0diUW5hUXdxWHMrWHUzSHRsekJzMzRCWTVaN3BvMHAxcXd2ZEZtMzJ0eFFUdTVSbElJMVRYWGVDSTZtbGhPTVhMdUp0M2JwQmhoNFZsZHAyVmZFWTNqbWRPZEd1eW1FdGpDdGV1VzdiS0Z6RTNDZElhNGRCQkcyVWUxVSt4bURscnVKWk5RcDdzZFMrZFdLanlpQjZtcGJpcjBXbEoxdnMyL0FMaU9DVjFHU3pvUkVFSkd4MUJrVjU3eCs5ZHcrT3ZzckRNekUrSVNDamdNQWZJYUQvbHJZOW43d3Rrbzg1amJzNlRNTWxzQng1SFVIemswSDdaWWdMaWNOZVVRVUl6SFROQmZ3d0R2SGo1YzZ5aHFiUnJrM0JQMENjVjJpdjNnbHEyaVczYUZsU1N6TWZBSW5SWm4rdGVyWU5WdFcwUmRGUlFvbm9vajhxOHJ4MW51OFVNeC93VVc2ZHBCYkVaMlZRc1pvNzAxdUwzRWkxb20yVllzdmhrRXFaSFB5cFpVcVZEd3QyNzdQTThOZzJ4VjE3azVWZTYyc1RCZlBjMWtnYUJUdVJ1SzdpK0NGRlo4NmxCbWpVQnpsZFUxU1RsTXNOSk5hanN0Z253OEs2cklaN2dZYS9ZVkFEMDNhcW5hUmpjQ0FJNXpQY3paSmdqdmcyb0drd05DUnlIUVZ0NVBsUzZNUEZVYmZab3YvQU9kMmJkdkJHNDRuTzd1ZjhxZUFEL1lUODZGOXIrQ0phc0l3Q0J5QjRnb1VscFFRUUYxSkxiaytkRWVES2k0VmJTWmdDREliVWpNWllmaUtzY1R3UDdUa1Z5Y29NbURHZ2tqWC9NRnJIbFU3TitGd1MvQkZ3L3N1aVNyWmd5cWdsZkdEb2RUejNuWUFWTis1b2IrSGZUTjBNbzM0ejlLTVdTUXhZbmNLUGFkL2VwN2hEQ0dBSTZFQWo2MWxMYnMyaXFWQVh1Y2JiMkxIMGJOOUdxcGY0aGRIK05ZUmgvTmIvTWFVYy9ZMEh3RjdmK1JpQi9wTXI5S2F3dmpaMHVEbzY1VC9BS2wwL3dCdElabTBmQnNXUDdQa0xBaGpiYmNIZVJwVmRlQ1lQS3kyNzkyMW1qNGdUbEk2R05QZWorSmREL2pZUWorWkl1RDEwZ2oycW9NSmc3bndYc2g2RXhyNk5UVW1TNG9vRHMvZjd0Ull4TnQzQitJblVqWFE3OVI3VXJ2NzBzb3BDbTQydVlCcFdKMGlhdlhPemo3cTZzUFA5UlVCczR1MFpCZU9pdG1Ic2FFMTZCcCsyTXY5cXNSWlJHdTJ5WkF6TGsxVXhydEdsTWJ0VGhiaUJydGkyVmJTU0I5UkI2R3B2My9lV0E0VTljNlFmcEZNeFBFc0xjMHZZWlNPcXdmMC9HaFVEYkdvT0czVUlXMlVSdENVMEgrMCtuS2xoK0E0UUt5MnI1QWJreG1OSTBtS1ljQncrNWJOdFhlMHA1YSt2T1FOcVpoT3lZV1RheFBlQWpRRWhvOHhCMHA5cDdKcW10RExYWkc2ckJseEl1S1Bza2VYM2dhb1kvaHVNc2t1VlFwTzZreUJQOWFsdDluc2RiY0hPSFFIV0RySHpINTAzaVBFc1pZWVpVdUZZMTBZd2ZyNVZXM0txVEowbzN0ZjkvSms4ZGR6M0dicWVaMTZhMHExbGp0UGRaUVNBRHpsUk9oalhTbFc2elNTcmljN3d3azc1ZjZQVkJhQXBGUlVwRk1LMXhub0VMb1AvZFp2ajJkN2x1M2F5S2ZHek1STUxDb2NvNWtoeVBuV3BhM05VYnZERUxaL3RSbG5YYVpqZnJUVG9tU3RIbWZHdUFsc1FZSmk0eGxqcUFUNG9BM0FoVDE1Vlp0OEl1QTIwa2xWWXlSSk1aVG9CeVV4N3RXK3VjSXRzeXNabFRJOWNwWFhyb3hxZExDcnNBUHBXbmtkVVorRlhaNTQzWXU1ZXVGMmNJdkxUTVFCOHdQL0FIUmRPeHR0VXlDN2M4L2hBUHJBbVBLYTE3VkUxSjVKTWF4Uld6QVgrd1RsdjhaUXVuMlNXZ0FDSW1PWFdyRDlrN1ZpMjVYT3pzcFROdkdmd2tnRGJldG95MDByUjVaQzhNZlJoVzRZeTRaOE9BV1V0bUdiUWdpSTIzMm1yWENEZEZ1M0FpTGFydEIwMko5NjFqMjZpN21rNXRsTEdsMEFPRjRPNmpzN3ZKZUorUWdhVkZ4cmdvdnNwSUo2NjdBQm9BNTdtdEliVk5ObWtwTmJHNEpxbVkyL3dWZ3hkVmw5TlNUc0NwLy9BQ0tsNExZeENNVlpJdG1ZZ2lGNWlOWmp5OUsxbmRWMFc2Zk4xVEY0MG5hS0Z1eWVkU0pnbEFpUDdPdFhNbExMVTJWUlh0NFlMb0FCNlZLbHVwSXBSUllVZFUwOFBUQlhab0dQelVzMU1tdUdnUkxucURFWWRMbnhvcmVvMTk5NjdOZG1nQWMzQjFVemFlNWFQOHJFajVnL3JUYzJNdDdNbDBkQ0liOHZ4TkVzMUltZ0FXM0hGMnYyV1R6SWtmV0tqTm5CWGZ1cVQveUdpMmJsVlBFOE1zdjhTQ2VvOFA0VUJRUHZkbGxPcVhENVRxS0dZbnMvaUUrR0Q1Z3dmclJLN3dSMU0yTHpLZWhtUGRmMHB2N2JqYlh4b0xnNmdULzB3ZmNVeVdCbHhXTXMvYXVqMThZK3NpcDdQYTI4TkhWSEhwbFAwMjlxS1crMDFzNlhFS25ueittOVRtNWhMM05ENitFL1duL0JOZW1DL3dENVduUERmN2gvMjBxdkhzeGh6cUFma3hqOGE1VCtJZkk5Qk5OTktsV1pzTk5NTktsUUExaFVUQ2xTcGlPUlhDdEtsU0dNS1V3clNwVUFNWVUyS1ZLZ1FpSzVGS2xRTTRCWEtWS2dCaHJrVXFWQWpzVXBybEtnQkdrS1ZLZ0RrMHBwVXFCQ3BVcVZNRHNWd2lsU29BWVRUU2FWS2dCcGFtNXE3U3BBUlg3Q1hOSFJXOVFEN0hsUXUvMmV0SDRDeUgvVVBZNi9XdTBxZGcwbURMblp5N09qV3lQK1lmU0tWS2xUNU1qZ2ovL1pcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgfVxyXG5dO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHBhcnRlbmVyaV90YWJsZTtcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuaW1wb3J0IENhcmRzIGZyb20gJy4uL2NvbW1vbi9wb3J0b2ZvbGl1L2NhcmQnXHJcblxyXG4vLyBDb21wb25lbnRzXHJcbmltcG9ydCB7IENvbnRhaW5lciwgUm93LCBDb2wgfSBmcm9tIFwicmVhY3QtZ3JpZC1zeXN0ZW1cIjtcclxuaW1wb3J0IEhlYWRsaW5lIGZyb20gXCIuLi8uLi9jb21wb25lbnRzL2NvbW1vbi9IZWFkbGluZVwiO1xyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBQYXJ0ZW5lcmkoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cInNlY3Rpb24gc2VjdGlvbi1wb3J0Zm9saW8gc2VjdGlvbi1wb3J0Zm9saW8tMSBiZy1ncmFkaWVudC1zaWRlIG92ZXJsYXktY29sb3JcIj5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYmctY29sb3IgYmctZGFyay02MFwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkaXNwbGF5LXNwYWNpbmdcIj5cclxuICAgICAgICAgICAgICAgIDxDb250YWluZXIgY2xhc3NOYW1lPVwiY29udGFpbmVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPEhlYWRsaW5lIGxhYmVsPVwiUG9ydGZvbGlvXCIgdGl0bGU9XCJMZXQncyBTZWUgT3VyIHBvcnRmb2xpb1wiIGRpdmlkZXJfMT17dHJ1ZX0gcG9zaXRpb249XCJjZW50ZXJcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxDYXJkcyAvPlxyXG4gICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICA8L0NvbnRhaW5lcj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9zZWN0aW9uPlxyXG4gICAgKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUGFydGVuZXJpOyIsImZ1bmN0aW9uIHRvVmFsKG1peCkge1xuXHR2YXIgaywgeSwgc3RyPScnO1xuXG5cdGlmICh0eXBlb2YgbWl4ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbWl4ID09PSAnbnVtYmVyJykge1xuXHRcdHN0ciArPSBtaXg7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG1peCA9PT0gJ29iamVjdCcpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShtaXgpKSB7XG5cdFx0XHRmb3IgKGs9MDsgayA8IG1peC5sZW5ndGg7IGsrKykge1xuXHRcdFx0XHRpZiAobWl4W2tdKSB7XG5cdFx0XHRcdFx0aWYgKHkgPSB0b1ZhbChtaXhba10pKSB7XG5cdFx0XHRcdFx0XHRzdHIgJiYgKHN0ciArPSAnICcpO1xuXHRcdFx0XHRcdFx0c3RyICs9IHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoayBpbiBtaXgpIHtcblx0XHRcdFx0aWYgKG1peFtrXSkge1xuXHRcdFx0XHRcdHN0ciAmJiAoc3RyICs9ICcgJyk7XG5cdFx0XHRcdFx0c3RyICs9IGs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3RyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG5cdHZhciBpPTAsIHRtcCwgeCwgc3RyPScnO1xuXHR3aGlsZSAoaSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRpZiAodG1wID0gYXJndW1lbnRzW2krK10pIHtcblx0XHRcdGlmICh4ID0gdG9WYWwodG1wKSkge1xuXHRcdFx0XHRzdHIgJiYgKHN0ciArPSAnICcpO1xuXHRcdFx0XHRzdHIgKz0geFxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gc3RyO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIGFzc2lnbj1PYmplY3QuYXNzaWduLmJpbmQoT2JqZWN0KTttb2R1bGUuZXhwb3J0cz1hc3NpZ247bW9kdWxlLmV4cG9ydHMuZGVmYXVsdD1tb2R1bGUuZXhwb3J0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC1hc3NpZ24uanMubWFwIiwiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9wb3J0Zm9saW9cIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCJHOlxcXFxNRE1heFxcXFxnbyBicmFzb3ZcXFxcc2l0ZV9uZXh0anNcXFxcZ29idi1zaXRlXFxcXHBhZ2VzXFxcXHBvcnRmb2xpby5qc1wiKTtcbiAgICAgIH1cbiAgICBdKTtcbiAgIiwiaW1wb3J0IFJlYWN0LCB7IENoaWxkcmVuIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQge1xuICBhZGRCYXNlUGF0aCxcbiAgYWRkTG9jYWxlLFxuICBpc0xvY2FsVVJMLFxuICBOZXh0Um91dGVyLFxuICBQcmVmZXRjaE9wdGlvbnMsXG4gIHJlc29sdmVIcmVmLFxufSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJy4vcm91dGVyJ1xuXG50eXBlIFVybCA9IHN0cmluZyB8IFVybE9iamVjdFxudHlwZSBSZXF1aXJlZEtleXM8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdLT86IHt9IGV4dGVuZHMgUGljazxULCBLPiA/IG5ldmVyIDogS1xufVtrZXlvZiBUXVxudHlwZSBPcHRpb25hbEtleXM8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdLT86IHt9IGV4dGVuZHMgUGljazxULCBLPiA/IEsgOiBuZXZlclxufVtrZXlvZiBUXVxuXG5leHBvcnQgdHlwZSBMaW5rUHJvcHMgPSB7XG4gIGhyZWY6IFVybFxuICBhcz86IFVybFxuICByZXBsYWNlPzogYm9vbGVhblxuICBzY3JvbGw/OiBib29sZWFuXG4gIHNoYWxsb3c/OiBib29sZWFuXG4gIHBhc3NIcmVmPzogYm9vbGVhblxuICBwcmVmZXRjaD86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2Vcbn1cbnR5cGUgTGlua1Byb3BzUmVxdWlyZWQgPSBSZXF1aXJlZEtleXM8TGlua1Byb3BzPlxudHlwZSBMaW5rUHJvcHNPcHRpb25hbCA9IE9wdGlvbmFsS2V5czxMaW5rUHJvcHM+XG5cbmxldCBjYWNoZWRPYnNlcnZlcjogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbmNvbnN0IGxpc3RlbmVycyA9IG5ldyBNYXA8RWxlbWVudCwgKCkgPT4gdm9pZD4oKVxuY29uc3QgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPVxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlciA6IG51bGxcbmNvbnN0IHByZWZldGNoZWQ6IHsgW2NhY2hlS2V5OiBzdHJpbmddOiBib29sZWFuIH0gPSB7fVxuXG5mdW5jdGlvbiBnZXRPYnNlcnZlcigpOiBJbnRlcnNlY3Rpb25PYnNlcnZlciB8IHVuZGVmaW5lZCB7XG4gIC8vIFJldHVybiBzaGFyZWQgaW5zdGFuY2Ugb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaWYgYWxyZWFkeSBjcmVhdGVkXG4gIGlmIChjYWNoZWRPYnNlcnZlcikge1xuICAgIHJldHVybiBjYWNoZWRPYnNlcnZlclxuICB9XG5cbiAgLy8gT25seSBjcmVhdGUgc2hhcmVkIEludGVyc2VjdGlvbk9ic2VydmVyIGlmIHN1cHBvcnRlZCBpbiBicm93c2VyXG4gIGlmICghSW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICByZXR1cm4gKGNhY2hlZE9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgIChlbnRyaWVzKSA9PiB7XG4gICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgIGlmICghbGlzdGVuZXJzLmhhcyhlbnRyeS50YXJnZXQpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjYiA9IGxpc3RlbmVycy5nZXQoZW50cnkudGFyZ2V0KSFcbiAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMCkge1xuICAgICAgICAgIGNhY2hlZE9ic2VydmVyLnVub2JzZXJ2ZShlbnRyeS50YXJnZXQpXG4gICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShlbnRyeS50YXJnZXQpXG4gICAgICAgICAgY2IoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sXG4gICAgeyByb290TWFyZ2luOiAnMjAwcHgnIH1cbiAgKSlcbn1cblxuY29uc3QgbGlzdGVuVG9JbnRlcnNlY3Rpb25zID0gKGVsOiBFbGVtZW50LCBjYjogKCkgPT4gdm9pZCkgPT4ge1xuICBjb25zdCBvYnNlcnZlciA9IGdldE9ic2VydmVyKClcbiAgaWYgKCFvYnNlcnZlcikge1xuICAgIHJldHVybiAoKSA9PiB7fVxuICB9XG5cbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbClcbiAgbGlzdGVuZXJzLnNldChlbCwgY2IpXG4gIHJldHVybiAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgIH1cbiAgICBsaXN0ZW5lcnMuZGVsZXRlKGVsKVxuICB9XG59XG5cbmZ1bmN0aW9uIHByZWZldGNoKFxuICByb3V0ZXI6IE5leHRSb3V0ZXIsXG4gIGhyZWY6IHN0cmluZyxcbiAgYXM6IHN0cmluZyxcbiAgb3B0aW9ucz86IFByZWZldGNoT3B0aW9uc1xuKTogdm9pZCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuXG4gIGlmICghaXNMb2NhbFVSTChocmVmKSkgcmV0dXJuXG4gIC8vIFByZWZldGNoIHRoZSBKU09OIHBhZ2UgaWYgYXNrZWQgKG9ubHkgaW4gdGhlIGNsaWVudClcbiAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYSBwcmVmZXRjaCBlcnJvciBoZXJlIHNpbmNlIHdlIG1heSBiZVxuICAvLyBsb2FkaW5nIHdpdGggcHJpb3JpdHkgd2hpY2ggY2FuIHJlamVjdCBidXQgd2UgZG9uJ3RcbiAgLy8gd2FudCB0byBmb3JjZSBuYXZpZ2F0aW9uIHNpbmNlIHRoaXMgaXMgb25seSBhIHByZWZldGNoXG4gIHJvdXRlci5wcmVmZXRjaChocmVmLCBhcywgb3B0aW9ucykuY2F0Y2goKGVycikgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyByZXRocm93IHRvIHNob3cgaW52YWxpZCBVUkwgZXJyb3JzXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH0pXG4gIC8vIEpvaW4gb24gYW4gaW52YWxpZCBVUkkgY2hhcmFjdGVyXG4gIHByZWZldGNoZWRbaHJlZiArICclJyArIGFzXSA9IHRydWVcbn1cblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50KSB7XG4gIGNvbnN0IHsgdGFyZ2V0IH0gPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxBbmNob3JFbGVtZW50XG4gIHJldHVybiAoXG4gICAgKHRhcmdldCAmJiB0YXJnZXQgIT09ICdfc2VsZicpIHx8XG4gICAgZXZlbnQubWV0YUtleSB8fFxuICAgIGV2ZW50LmN0cmxLZXkgfHxcbiAgICBldmVudC5zaGlmdEtleSB8fFxuICAgIGV2ZW50LmFsdEtleSB8fCAvLyB0cmlnZ2VycyByZXNvdXJjZSBkb3dubG9hZFxuICAgIChldmVudC5uYXRpdmVFdmVudCAmJiBldmVudC5uYXRpdmVFdmVudC53aGljaCA9PT0gMilcbiAgKVxufVxuXG5mdW5jdGlvbiBsaW5rQ2xpY2tlZChcbiAgZTogUmVhY3QuTW91c2VFdmVudCxcbiAgcm91dGVyOiBOZXh0Um91dGVyLFxuICBocmVmOiBzdHJpbmcsXG4gIGFzOiBzdHJpbmcsXG4gIHJlcGxhY2U/OiBib29sZWFuLFxuICBzaGFsbG93PzogYm9vbGVhbixcbiAgc2Nyb2xsPzogYm9vbGVhbixcbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2Vcbik6IHZvaWQge1xuICBjb25zdCB7IG5vZGVOYW1lIH0gPSBlLmN1cnJlbnRUYXJnZXRcblxuICBpZiAobm9kZU5hbWUgPT09ICdBJyAmJiAoaXNNb2RpZmllZEV2ZW50KGUpIHx8ICFpc0xvY2FsVVJMKGhyZWYpKSkge1xuICAgIC8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxuICAgIHJldHVyblxuICB9XG5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgLy8gIGF2b2lkIHNjcm9sbCBmb3IgdXJscyB3aXRoIGFuY2hvciByZWZzXG4gIGlmIChzY3JvbGwgPT0gbnVsbCkge1xuICAgIHNjcm9sbCA9IGFzLmluZGV4T2YoJyMnKSA8IDBcbiAgfVxuXG4gIC8vIHJlcGxhY2Ugc3RhdGUgaW5zdGVhZCBvZiBwdXNoIGlmIHByb3AgaXMgcHJlc2VudFxuICByb3V0ZXJbcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdwdXNoJ10oaHJlZiwgYXMsIHsgc2hhbGxvdywgbG9jYWxlIH0pLnRoZW4oXG4gICAgKHN1Y2Nlc3M6IGJvb2xlYW4pID0+IHtcbiAgICAgIGlmICghc3VjY2VzcykgcmV0dXJuXG4gICAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKVxuICAgICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKClcbiAgICAgIH1cbiAgICB9XG4gIClcbn1cblxuZnVuY3Rpb24gTGluayhwcm9wczogUmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48TGlua1Byb3BzPikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVByb3BFcnJvcihhcmdzOiB7XG4gICAgICBrZXk6IHN0cmluZ1xuICAgICAgZXhwZWN0ZWQ6IHN0cmluZ1xuICAgICAgYWN0dWFsOiBzdHJpbmdcbiAgICB9KSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHByb3AgdHlwZTogVGhlIHByb3AgXFxgJHthcmdzLmtleX1cXGAgZXhwZWN0cyBhICR7YXJncy5leHBlY3RlZH0gaW4gXFxgPExpbms+XFxgLCBidXQgZ290IFxcYCR7YXJncy5hY3R1YWx9XFxgIGluc3RlYWQuYCArXG4gICAgICAgICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IFwiXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIlxuICAgICAgICAgICAgOiAnJylcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgIGNvbnN0IHJlcXVpcmVkUHJvcHNHdWFyZDogUmVjb3JkPExpbmtQcm9wc1JlcXVpcmVkLCB0cnVlPiA9IHtcbiAgICAgIGhyZWY6IHRydWUsXG4gICAgfSBhcyBjb25zdFxuICAgIGNvbnN0IHJlcXVpcmVkUHJvcHM6IExpbmtQcm9wc1JlcXVpcmVkW10gPSBPYmplY3Qua2V5cyhcbiAgICAgIHJlcXVpcmVkUHJvcHNHdWFyZFxuICAgICkgYXMgTGlua1Byb3BzUmVxdWlyZWRbXVxuICAgIHJlcXVpcmVkUHJvcHMuZm9yRWFjaCgoa2V5OiBMaW5rUHJvcHNSZXF1aXJlZCkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gJ2hyZWYnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9wc1trZXldID09IG51bGwgfHxcbiAgICAgICAgICAodHlwZW9mIHByb3BzW2tleV0gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwcm9wc1trZXldICE9PSAnb2JqZWN0JylcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2Agb3IgYG9iamVjdGAnLFxuICAgICAgICAgICAgYWN0dWFsOiBwcm9wc1trZXldID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHByb3BzW2tleV0sXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCBfOiBuZXZlciA9IGtleVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuICAgIGNvbnN0IG9wdGlvbmFsUHJvcHNHdWFyZDogUmVjb3JkPExpbmtQcm9wc09wdGlvbmFsLCB0cnVlPiA9IHtcbiAgICAgIGFzOiB0cnVlLFxuICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgIHNoYWxsb3c6IHRydWUsXG4gICAgICBwYXNzSHJlZjogdHJ1ZSxcbiAgICAgIHByZWZldGNoOiB0cnVlLFxuICAgICAgbG9jYWxlOiB0cnVlLFxuICAgIH0gYXMgY29uc3RcbiAgICBjb25zdCBvcHRpb25hbFByb3BzOiBMaW5rUHJvcHNPcHRpb25hbFtdID0gT2JqZWN0LmtleXMoXG4gICAgICBvcHRpb25hbFByb3BzR3VhcmRcbiAgICApIGFzIExpbmtQcm9wc09wdGlvbmFsW11cbiAgICBvcHRpb25hbFByb3BzLmZvckVhY2goKGtleTogTGlua1Byb3BzT3B0aW9uYWwpID0+IHtcbiAgICAgIGNvbnN0IHZhbFR5cGUgPSB0eXBlb2YgcHJvcHNba2V5XVxuXG4gICAgICBpZiAoa2V5ID09PSAnYXMnKSB7XG4gICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09ICdzdHJpbmcnICYmIHZhbFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYHN0cmluZ2Agb3IgYG9iamVjdGAnLFxuICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnbG9jYWxlJykge1xuICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgJyxcbiAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBrZXkgPT09ICdyZXBsYWNlJyB8fFxuICAgICAgICBrZXkgPT09ICdzY3JvbGwnIHx8XG4gICAgICAgIGtleSA9PT0gJ3NoYWxsb3cnIHx8XG4gICAgICAgIGtleSA9PT0gJ3Bhc3NIcmVmJyB8fFxuICAgICAgICBrZXkgPT09ICdwcmVmZXRjaCdcbiAgICAgICkge1xuICAgICAgICBpZiAocHJvcHNba2V5XSAhPSBudWxsICYmIHZhbFR5cGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2Bib29sZWFuYCcsXG4gICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCBfOiBuZXZlciA9IGtleVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBUaGlzIGhvb2sgaXMgaW4gYSBjb25kaXRpb25hbCBidXQgdGhhdCBpcyBvayBiZWNhdXNlIGBwcm9jZXNzLmVudi5OT0RFX0VOVmAgbmV2ZXIgY2hhbmdlc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIGNvbnN0IGhhc1dhcm5lZCA9IFJlYWN0LnVzZVJlZihmYWxzZSlcbiAgICBpZiAocHJvcHMucHJlZmV0Y2ggJiYgIWhhc1dhcm5lZC5jdXJyZW50KSB7XG4gICAgICBoYXNXYXJuZWQuY3VycmVudCA9IHRydWVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ05leHQuanMgYXV0by1wcmVmZXRjaGVzIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdmlld3BvcnQuIFRoZSBwcmVmZXRjaCBhdHRyaWJ1dGUgaXMgbm8gbG9uZ2VyIG5lZWRlZC4gTW9yZTogaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvcHJlZmV0Y2gtdHJ1ZS1kZXByZWNhdGVkJ1xuICAgICAgKVxuICAgIH1cbiAgfVxuICBjb25zdCBwID0gcHJvcHMucHJlZmV0Y2ggIT09IGZhbHNlXG5cbiAgY29uc3QgW2NoaWxkRWxtLCBzZXRDaGlsZEVsbV0gPSBSZWFjdC51c2VTdGF0ZTxFbGVtZW50PigpXG5cbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKClcbiAgY29uc3QgcGF0aG5hbWUgPSAocm91dGVyICYmIHJvdXRlci5wYXRobmFtZSkgfHwgJy8nXG5cbiAgY29uc3QgeyBocmVmLCBhcyB9ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSByZXNvbHZlSHJlZihwYXRobmFtZSwgcHJvcHMuaHJlZiwgdHJ1ZSlcbiAgICByZXR1cm4ge1xuICAgICAgaHJlZjogcmVzb2x2ZWRIcmVmLFxuICAgICAgYXM6IHByb3BzLmFzXG4gICAgICAgID8gcmVzb2x2ZUhyZWYocGF0aG5hbWUsIHByb3BzLmFzKVxuICAgICAgICA6IHJlc29sdmVkQXMgfHwgcmVzb2x2ZWRIcmVmLFxuICAgIH1cbiAgfSwgW3BhdGhuYW1lLCBwcm9wcy5ocmVmLCBwcm9wcy5hc10pXG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoXG4gICAgICBwICYmXG4gICAgICBJbnRlcnNlY3Rpb25PYnNlcnZlciAmJlxuICAgICAgY2hpbGRFbG0gJiZcbiAgICAgIGNoaWxkRWxtLnRhZ05hbWUgJiZcbiAgICAgIGlzTG9jYWxVUkwoaHJlZilcbiAgICApIHtcbiAgICAgIC8vIEpvaW4gb24gYW4gaW52YWxpZCBVUkkgY2hhcmFjdGVyXG4gICAgICBjb25zdCBpc1ByZWZldGNoZWQgPSBwcmVmZXRjaGVkW2hyZWYgKyAnJScgKyBhc11cbiAgICAgIGlmICghaXNQcmVmZXRjaGVkKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5Ub0ludGVyc2VjdGlvbnMoY2hpbGRFbG0sICgpID0+IHtcbiAgICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfSwgW3AsIGNoaWxkRWxtLCBocmVmLCBhcywgcm91dGVyXSlcblxuICBsZXQgeyBjaGlsZHJlbiwgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUgfSA9IHByb3BzXG4gIC8vIERlcHJlY2F0ZWQuIFdhcm5pbmcgc2hvd24gYnkgcHJvcFR5cGUgY2hlY2suIElmIHRoZSBjaGlsZHJlbiBwcm92aWRlZCBpcyBhIHN0cmluZyAoPExpbms+ZXhhbXBsZTwvTGluaz4pIHdlIHdyYXAgaXQgaW4gYW4gPGE+IHRhZ1xuICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJykge1xuICAgIGNoaWxkcmVuID0gPGE+e2NoaWxkcmVufTwvYT5cbiAgfVxuXG4gIC8vIFRoaXMgd2lsbCByZXR1cm4gdGhlIGZpcnN0IGNoaWxkLCBpZiBtdWx0aXBsZSBhcmUgcHJvdmlkZWQgaXQgd2lsbCB0aHJvdyBhbiBlcnJvclxuICBjb25zdCBjaGlsZDogYW55ID0gQ2hpbGRyZW4ub25seShjaGlsZHJlbilcbiAgY29uc3QgY2hpbGRQcm9wczoge1xuICAgIG9uTW91c2VFbnRlcj86IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyXG4gICAgb25DbGljazogUmVhY3QuTW91c2VFdmVudEhhbmRsZXJcbiAgICBocmVmPzogc3RyaW5nXG4gICAgcmVmPzogYW55XG4gIH0gPSB7XG4gICAgcmVmOiAoZWw6IGFueSkgPT4ge1xuICAgICAgaWYgKGVsKSBzZXRDaGlsZEVsbShlbClcblxuICAgICAgaWYgKGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PT0gJ29iamVjdCcgJiYgY2hpbGQucmVmKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQucmVmID09PSAnZnVuY3Rpb24nKSBjaGlsZC5yZWYoZWwpXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaGlsZC5yZWYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgY2hpbGQucmVmLmN1cnJlbnQgPSBlbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkNsaWNrOiAoZTogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xuICAgICAgaWYgKGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNoaWxkLnByb3BzLm9uQ2xpY2soZSlcbiAgICAgIH1cbiAgICAgIGlmICghZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIGxpbmtDbGlja2VkKGUsIHJvdXRlciwgaHJlZiwgYXMsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlKVxuICAgICAgfVxuICAgIH0sXG4gIH1cblxuICBpZiAocCkge1xuICAgIGNoaWxkUHJvcHMub25Nb3VzZUVudGVyID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcbiAgICAgIGlmICghaXNMb2NhbFVSTChocmVmKSkgcmV0dXJuXG4gICAgICBpZiAoY2hpbGQucHJvcHMgJiYgdHlwZW9mIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIoZSlcbiAgICAgIH1cbiAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHsgcHJpb3JpdHk6IHRydWUgfSlcbiAgICB9XG4gIH1cblxuICAvLyBJZiBjaGlsZCBpcyBhbiA8YT4gdGFnIGFuZCBkb2Vzbid0IGhhdmUgYSBocmVmIGF0dHJpYnV0ZSwgb3IgaWYgdGhlICdwYXNzSHJlZicgcHJvcGVydHkgaXNcbiAgLy8gZGVmaW5lZCwgd2Ugc3BlY2lmeSB0aGUgY3VycmVudCAnaHJlZicsIHNvIHRoYXQgcmVwZXRpdGlvbiBpcyBub3QgbmVlZGVkIGJ5IHRoZSB1c2VyXG4gIGlmIChwcm9wcy5wYXNzSHJlZiB8fCAoY2hpbGQudHlwZSA9PT0gJ2EnICYmICEoJ2hyZWYnIGluIGNoaWxkLnByb3BzKSkpIHtcbiAgICBjaGlsZFByb3BzLmhyZWYgPSBhZGRCYXNlUGF0aChcbiAgICAgIGFkZExvY2FsZShcbiAgICAgICAgYXMsXG4gICAgICAgIHR5cGVvZiBsb2NhbGUgIT09ICd1bmRlZmluZWQnID8gbG9jYWxlIDogcm91dGVyICYmIHJvdXRlci5sb2NhbGUsXG4gICAgICAgIHJvdXRlciAmJiByb3V0ZXIuZGVmYXVsdExvY2FsZVxuICAgICAgKVxuICAgIClcbiAgfVxuXG4gIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGNoaWxkUHJvcHMpXG59XG5cbmV4cG9ydCBkZWZhdWx0IExpbmtcbiIsIi8qKlxuICogUmVtb3ZlcyB0aGUgdHJhaWxpbmcgc2xhc2ggb2YgYSBwYXRoIGlmIHRoZXJlIGlzIG9uZS4gUHJlc2VydmVzIHRoZSByb290IHBhdGggYC9gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhdGguZW5kc1dpdGgoJy8nKSAmJiBwYXRoICE9PSAnLycgPyBwYXRoLnNsaWNlKDAsIC0xKSA6IHBhdGhcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSB0cmFpbGluZyBzbGFzaCBvZiBhIHBhdGggYWNjb3JkaW5nIHRvIHRoZSBgdHJhaWxpbmdTbGFzaGAgb3B0aW9uXG4gKiBpbiBgbmV4dC5jb25maWcuanNgLlxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2ggPSBwcm9jZXNzLmVudi5fX05FWFRfVFJBSUxJTkdfU0xBU0hcbiAgPyAocGF0aDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICAgIGlmICgvXFwuW14vXStcXC8/JC8udGVzdChwYXRoKSkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aClcbiAgICAgIH0gZWxzZSBpZiAocGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgIHJldHVybiBwYXRoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGF0aCArICcvJ1xuICAgICAgfVxuICAgIH1cbiAgOiByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaFxuIiwiLyogZ2xvYmFsIHdpbmRvdyAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFJvdXRlciwgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXInXG5pbXBvcnQgeyBSb3V0ZXJDb250ZXh0IH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0J1xuXG50eXBlIENsYXNzQXJndW1lbnRzPFQ+ID0gVCBleHRlbmRzIG5ldyAoLi4uYXJnczogaW5mZXIgVSkgPT4gYW55ID8gVSA6IGFueVxuXG50eXBlIFJvdXRlckFyZ3MgPSBDbGFzc0FyZ3VtZW50czx0eXBlb2YgUm91dGVyPlxuXG50eXBlIFNpbmdsZXRvblJvdXRlckJhc2UgPSB7XG4gIHJvdXRlcjogUm91dGVyIHwgbnVsbFxuICByZWFkeUNhbGxiYWNrczogQXJyYXk8KCkgPT4gYW55PlxuICByZWFkeShjYjogKCkgPT4gYW55KTogdm9pZFxufVxuXG5leHBvcnQgeyBSb3V0ZXIsIE5leHRSb3V0ZXIgfVxuXG5leHBvcnQgdHlwZSBTaW5nbGV0b25Sb3V0ZXIgPSBTaW5nbGV0b25Sb3V0ZXJCYXNlICYgTmV4dFJvdXRlclxuXG5jb25zdCBzaW5nbGV0b25Sb3V0ZXI6IFNpbmdsZXRvblJvdXRlckJhc2UgPSB7XG4gIHJvdXRlcjogbnVsbCwgLy8gaG9sZHMgdGhlIGFjdHVhbCByb3V0ZXIgaW5zdGFuY2VcbiAgcmVhZHlDYWxsYmFja3M6IFtdLFxuICByZWFkeShjYjogKCkgPT4gdm9pZCkge1xuICAgIGlmICh0aGlzLnJvdXRlcikgcmV0dXJuIGNiKClcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMucmVhZHlDYWxsYmFja3MucHVzaChjYilcbiAgICB9XG4gIH0sXG59XG5cbi8vIENyZWF0ZSBwdWJsaWMgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBvZiB0aGUgcm91dGVyIGluIHRoZSBzaW5nbGV0b25Sb3V0ZXJcbmNvbnN0IHVybFByb3BlcnR5RmllbGRzID0gW1xuICAncGF0aG5hbWUnLFxuICAncm91dGUnLFxuICAncXVlcnknLFxuICAnYXNQYXRoJyxcbiAgJ2NvbXBvbmVudHMnLFxuICAnaXNGYWxsYmFjaycsXG4gICdiYXNlUGF0aCcsXG4gICdsb2NhbGUnLFxuICAnbG9jYWxlcycsXG4gICdkZWZhdWx0TG9jYWxlJyxcbl1cbmNvbnN0IHJvdXRlckV2ZW50cyA9IFtcbiAgJ3JvdXRlQ2hhbmdlU3RhcnQnLFxuICAnYmVmb3JlSGlzdG9yeUNoYW5nZScsXG4gICdyb3V0ZUNoYW5nZUNvbXBsZXRlJyxcbiAgJ3JvdXRlQ2hhbmdlRXJyb3InLFxuICAnaGFzaENoYW5nZVN0YXJ0JyxcbiAgJ2hhc2hDaGFuZ2VDb21wbGV0ZScsXG5dXG5jb25zdCBjb3JlTWV0aG9kRmllbGRzID0gW1xuICAncHVzaCcsXG4gICdyZXBsYWNlJyxcbiAgJ3JlbG9hZCcsXG4gICdiYWNrJyxcbiAgJ3ByZWZldGNoJyxcbiAgJ2JlZm9yZVBvcFN0YXRlJyxcbl1cblxuLy8gRXZlbnRzIGlzIGEgc3RhdGljIHByb3BlcnR5IG9uIHRoZSByb3V0ZXIsIHRoZSByb3V0ZXIgZG9lc24ndCBoYXZlIHRvIGJlIGluaXRpYWxpemVkIHRvIHVzZSBpdFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNpbmdsZXRvblJvdXRlciwgJ2V2ZW50cycsIHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiBSb3V0ZXIuZXZlbnRzXG4gIH0sXG59KVxuXG51cmxQcm9wZXJ0eUZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAvLyBIZXJlIHdlIG5lZWQgdG8gdXNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBiZWNhdXNlLCB3ZSBuZWVkIHRvIHJldHVyblxuICAvLyB0aGUgcHJvcGVydHkgYXNzaWduZWQgdG8gdGhlIGFjdHVhbCByb3V0ZXJcbiAgLy8gVGhlIHZhbHVlIG1pZ2h0IGdldCBjaGFuZ2VkIGFzIHdlIGNoYW5nZSByb3V0ZXMgYW5kIHRoaXMgaXMgdGhlXG4gIC8vIHByb3BlciB3YXkgdG8gYWNjZXNzIGl0XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsIGZpZWxkLCB7XG4gICAgZ2V0KCkge1xuICAgICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCkgYXMgYW55XG4gICAgICByZXR1cm4gcm91dGVyW2ZpZWxkXSBhcyBzdHJpbmdcbiAgICB9LFxuICB9KVxufSlcblxuY29yZU1ldGhvZEZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAvLyBXZSBkb24ndCByZWFsbHkga25vdyB0aGUgdHlwZXMgaGVyZSwgc28gd2UgYWRkIHRoZW0gbGF0ZXIgaW5zdGVhZFxuICA7KHNpbmdsZXRvblJvdXRlciBhcyBhbnkpW2ZpZWxkXSA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgIGNvbnN0IHJvdXRlciA9IGdldFJvdXRlcigpIGFzIGFueVxuICAgIHJldHVybiByb3V0ZXJbZmllbGRdKC4uLmFyZ3MpXG4gIH1cbn0pXG5cbnJvdXRlckV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHkoKCkgPT4ge1xuICAgIFJvdXRlci5ldmVudHMub24oZXZlbnQsICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBldmVudEZpZWxkID0gYG9uJHtldmVudC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke2V2ZW50LnN1YnN0cmluZyhcbiAgICAgICAgMVxuICAgICAgKX1gXG4gICAgICBjb25zdCBfc2luZ2xldG9uUm91dGVyID0gc2luZ2xldG9uUm91dGVyIGFzIGFueVxuICAgICAgaWYgKF9zaW5nbGV0b25Sb3V0ZXJbZXZlbnRGaWVsZF0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBfc2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKC4uLmFyZ3MpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHdoZW4gcnVubmluZyB0aGUgUm91dGVyIGV2ZW50OiAke2V2ZW50RmllbGR9YClcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGAke2Vyci5tZXNzYWdlfVxcbiR7ZXJyLnN0YWNrfWApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9KVxufSlcblxuZnVuY3Rpb24gZ2V0Um91dGVyKCk6IFJvdXRlciB7XG4gIGlmICghc2luZ2xldG9uUm91dGVyLnJvdXRlcikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgJ05vIHJvdXRlciBpbnN0YW5jZSBmb3VuZC5cXG4nICtcbiAgICAgICdZb3Ugc2hvdWxkIG9ubHkgdXNlIFwibmV4dC9yb3V0ZXJcIiBpbnNpZGUgdGhlIGNsaWVudCBzaWRlIG9mIHlvdXIgYXBwLlxcbidcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgfVxuICByZXR1cm4gc2luZ2xldG9uUm91dGVyLnJvdXRlclxufVxuXG4vLyBFeHBvcnQgdGhlIHNpbmdsZXRvblJvdXRlciBhbmQgdGhpcyBpcyB0aGUgcHVibGljIEFQSS5cbmV4cG9ydCBkZWZhdWx0IHNpbmdsZXRvblJvdXRlciBhcyBTaW5nbGV0b25Sb3V0ZXJcblxuLy8gUmVleHBvcnQgdGhlIHdpdGhSb3V0ZSBIT0NcbmV4cG9ydCB7IGRlZmF1bHQgYXMgd2l0aFJvdXRlciB9IGZyb20gJy4vd2l0aC1yb3V0ZXInXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3V0ZXIoKTogTmV4dFJvdXRlciB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KFJvdXRlckNvbnRleHQpXG59XG5cbi8vIElOVEVSTkFMIEFQSVNcbi8vIC0tLS0tLS0tLS0tLS1cbi8vIChkbyBub3QgdXNlIGZvbGxvd2luZyBleHBvcnRzIGluc2lkZSB0aGUgYXBwKVxuXG4vLyBDcmVhdGUgYSByb3V0ZXIgYW5kIGFzc2lnbiBpdCBhcyB0aGUgc2luZ2xldG9uIGluc3RhbmNlLlxuLy8gVGhpcyBpcyB1c2VkIGluIGNsaWVudCBzaWRlIHdoZW4gd2UgYXJlIGluaXRpbGl6aW5nIHRoZSBhcHAuXG4vLyBUaGlzIHNob3VsZCAqKm5vdCoqIHVzZSBpbnNpZGUgdGhlIHNlcnZlci5cbmV4cG9ydCBjb25zdCBjcmVhdGVSb3V0ZXIgPSAoLi4uYXJnczogUm91dGVyQXJncyk6IFJvdXRlciA9PiB7XG4gIHNpbmdsZXRvblJvdXRlci5yb3V0ZXIgPSBuZXcgUm91dGVyKC4uLmFyZ3MpXG4gIHNpbmdsZXRvblJvdXRlci5yZWFkeUNhbGxiYWNrcy5mb3JFYWNoKChjYikgPT4gY2IoKSlcbiAgc2luZ2xldG9uUm91dGVyLnJlYWR5Q2FsbGJhY2tzID0gW11cblxuICByZXR1cm4gc2luZ2xldG9uUm91dGVyLnJvdXRlclxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBgd2l0aFJvdXRlcmAgcm91dGVyIGluc3RhbmNlXG5leHBvcnQgZnVuY3Rpb24gbWFrZVB1YmxpY1JvdXRlckluc3RhbmNlKHJvdXRlcjogUm91dGVyKTogTmV4dFJvdXRlciB7XG4gIGNvbnN0IF9yb3V0ZXIgPSByb3V0ZXIgYXMgYW55XG4gIGNvbnN0IGluc3RhbmNlID0ge30gYXMgYW55XG5cbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB1cmxQcm9wZXJ0eUZpZWxkcykge1xuICAgIGlmICh0eXBlb2YgX3JvdXRlcltwcm9wZXJ0eV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBpbnN0YW5jZVtwcm9wZXJ0eV0gPSBPYmplY3QuYXNzaWduKFxuICAgICAgICBBcnJheS5pc0FycmF5KF9yb3V0ZXJbcHJvcGVydHldKSA/IFtdIDoge30sXG4gICAgICAgIF9yb3V0ZXJbcHJvcGVydHldXG4gICAgICApIC8vIG1ha2VzIHN1cmUgcXVlcnkgaXMgbm90IHN0YXRlZnVsXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGluc3RhbmNlW3Byb3BlcnR5XSA9IF9yb3V0ZXJbcHJvcGVydHldXG4gIH1cblxuICAvLyBFdmVudHMgaXMgYSBzdGF0aWMgcHJvcGVydHkgb24gdGhlIHJvdXRlciwgdGhlIHJvdXRlciBkb2Vzbid0IGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gdXNlIGl0XG4gIGluc3RhbmNlLmV2ZW50cyA9IFJvdXRlci5ldmVudHNcblxuICBjb3JlTWV0aG9kRmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgaW5zdGFuY2VbZmllbGRdID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgICByZXR1cm4gX3JvdXRlcltmaWVsZF0oLi4uYXJncylcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGluc3RhbmNlXG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBOZXh0Q29tcG9uZW50VHlwZSwgTmV4dFBhZ2VDb250ZXh0IH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3V0aWxzJ1xuaW1wb3J0IHsgTmV4dFJvdXRlciwgdXNlUm91dGVyIH0gZnJvbSAnLi9yb3V0ZXInXG5cbmV4cG9ydCB0eXBlIFdpdGhSb3V0ZXJQcm9wcyA9IHtcbiAgcm91dGVyOiBOZXh0Um91dGVyXG59XG5cbmV4cG9ydCB0eXBlIEV4Y2x1ZGVSb3V0ZXJQcm9wczxQPiA9IFBpY2s8XG4gIFAsXG4gIEV4Y2x1ZGU8a2V5b2YgUCwga2V5b2YgV2l0aFJvdXRlclByb3BzPlxuPlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3aXRoUm91dGVyPFxuICBQIGV4dGVuZHMgV2l0aFJvdXRlclByb3BzLFxuICBDID0gTmV4dFBhZ2VDb250ZXh0XG4+KFxuICBDb21wb3NlZENvbXBvbmVudDogTmV4dENvbXBvbmVudFR5cGU8QywgYW55LCBQPlxuKTogUmVhY3QuQ29tcG9uZW50VHlwZTxFeGNsdWRlUm91dGVyUHJvcHM8UD4+IHtcbiAgZnVuY3Rpb24gV2l0aFJvdXRlcldyYXBwZXIocHJvcHM6IGFueSkge1xuICAgIHJldHVybiA8Q29tcG9zZWRDb21wb25lbnQgcm91dGVyPXt1c2VSb3V0ZXIoKX0gey4uLnByb3BzfSAvPlxuICB9XG5cbiAgV2l0aFJvdXRlcldyYXBwZXIuZ2V0SW5pdGlhbFByb3BzID0gQ29tcG9zZWRDb21wb25lbnQuZ2V0SW5pdGlhbFByb3BzXG4gIC8vIFRoaXMgaXMgbmVlZGVkIHRvIGFsbG93IGNoZWNraW5nIGZvciBjdXN0b20gZ2V0SW5pdGlhbFByb3BzIGluIF9hcHBcbiAgOyhXaXRoUm91dGVyV3JhcHBlciBhcyBhbnkpLm9yaWdHZXRJbml0aWFsUHJvcHMgPSAoQ29tcG9zZWRDb21wb25lbnQgYXMgYW55KS5vcmlnR2V0SW5pdGlhbFByb3BzXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgbmFtZSA9XG4gICAgICBDb21wb3NlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb3NlZENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJ1xuICAgIFdpdGhSb3V0ZXJXcmFwcGVyLmRpc3BsYXlOYW1lID0gYHdpdGhSb3V0ZXIoJHtuYW1lfSlgXG4gIH1cblxuICByZXR1cm4gV2l0aFJvdXRlcldyYXBwZXJcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBUb2tlbml6ZSBpbnB1dCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGxleGVyKHN0cikge1xuICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGFyID0gc3RyW2ldO1xuICAgICAgICBpZiAoY2hhciA9PT0gXCIqXCIgfHwgY2hhciA9PT0gXCIrXCIgfHwgY2hhciA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJNT0RJRklFUlwiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiRVNDQVBFRF9DSEFSXCIsIGluZGV4OiBpKyssIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIntcIikge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIk9QRU5cIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIn1cIikge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkNMT1NFXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gXCJcIjtcbiAgICAgICAgICAgIHZhciBqID0gaSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoaiA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGopO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBgMC05YFxuICAgICAgICAgICAgICAgIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIGBBLVpgXG4gICAgICAgICAgICAgICAgICAgIChjb2RlID49IDY1ICYmIGNvZGUgPD0gOTApIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIGBhLXpgXG4gICAgICAgICAgICAgICAgICAgIChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTIyKSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBgX2BcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9PT0gOTUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSArPSBzdHJbaisrXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNaXNzaW5nIHBhcmFtZXRlciBuYW1lIGF0IFwiICsgaSk7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiTkFNRVwiLCBpbmRleDogaSwgdmFsdWU6IG5hbWUgfSk7XG4gICAgICAgICAgICBpID0gajtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIihcIikge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMTtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gXCJcIjtcbiAgICAgICAgICAgIHZhciBqID0gaSArIDE7XG4gICAgICAgICAgICBpZiAoc3RyW2pdID09PSBcIj9cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXR0ZXJuIGNhbm5vdCBzdGFydCB3aXRoIFxcXCI/XFxcIiBhdCBcIiArIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGogPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cltqXSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiArPSBzdHJbaisrXSArIHN0cltqKytdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0cltqXSA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHJbal0gPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJbaiArIDFdICE9PSBcIj9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhcHR1cmluZyBncm91cHMgYXJlIG5vdCBhbGxvd2VkIGF0IFwiICsgaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0dGVybiArPSBzdHJbaisrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5iYWxhbmNlZCBwYXR0ZXJuIGF0IFwiICsgaSk7XG4gICAgICAgICAgICBpZiAoIXBhdHRlcm4pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1pc3NpbmcgcGF0dGVybiBhdCBcIiArIGkpO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIlBBVFRFUk5cIiwgaW5kZXg6IGksIHZhbHVlOiBwYXR0ZXJuIH0pO1xuICAgICAgICAgICAgaSA9IGo7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiQ0hBUlwiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgIH1cbiAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiRU5EXCIsIGluZGV4OiBpLCB2YWx1ZTogXCJcIiB9KTtcbiAgICByZXR1cm4gdG9rZW5zO1xufVxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBmb3IgdGhlIHJhdyB0b2tlbnMuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKHN0ciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIHRva2VucyA9IGxleGVyKHN0cik7XG4gICAgdmFyIF9hID0gb3B0aW9ucy5wcmVmaXhlcywgcHJlZml4ZXMgPSBfYSA9PT0gdm9pZCAwID8gXCIuL1wiIDogX2E7XG4gICAgdmFyIGRlZmF1bHRQYXR0ZXJuID0gXCJbXlwiICsgZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8IFwiLyM/XCIpICsgXCJdKz9cIjtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGtleSA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBwYXRoID0gXCJcIjtcbiAgICB2YXIgdHJ5Q29uc3VtZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGlmIChpIDwgdG9rZW5zLmxlbmd0aCAmJiB0b2tlbnNbaV0udHlwZSA9PT0gdHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0b2tlbnNbaSsrXS52YWx1ZTtcbiAgICB9O1xuICAgIHZhciBtdXN0Q29uc3VtZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRyeUNvbnN1bWUodHlwZSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YXIgX2EgPSB0b2tlbnNbaV0sIG5leHRUeXBlID0gX2EudHlwZSwgaW5kZXggPSBfYS5pbmRleDtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgXCIgKyBuZXh0VHlwZSArIFwiIGF0IFwiICsgaW5kZXggKyBcIiwgZXhwZWN0ZWQgXCIgKyB0eXBlKTtcbiAgICB9O1xuICAgIHZhciBjb25zdW1lVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHdoaWxlICgodmFsdWUgPSB0cnlDb25zdW1lKFwiQ0hBUlwiKSB8fCB0cnlDb25zdW1lKFwiRVNDQVBFRF9DSEFSXCIpKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICB3aGlsZSAoaSA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSB0cnlDb25zdW1lKFwiQ0hBUlwiKTtcbiAgICAgICAgdmFyIG5hbWUgPSB0cnlDb25zdW1lKFwiTkFNRVwiKTtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSB0cnlDb25zdW1lKFwiUEFUVEVSTlwiKTtcbiAgICAgICAgaWYgKG5hbWUgfHwgcGF0dGVybikge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGNoYXIgfHwgXCJcIjtcbiAgICAgICAgICAgIGlmIChwcmVmaXhlcy5pbmRleE9mKHByZWZpeCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcGF0aCArPSBwcmVmaXg7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGF0aCk7XG4gICAgICAgICAgICAgICAgcGF0aCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgICAgICAgICAgICBzdWZmaXg6IFwiXCIsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogcGF0dGVybiB8fCBkZWZhdWx0UGF0dGVybixcbiAgICAgICAgICAgICAgICBtb2RpZmllcjogdHJ5Q29uc3VtZShcIk1PRElGSUVSXCIpIHx8IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gY2hhciB8fCB0cnlDb25zdW1lKFwiRVNDQVBFRF9DSEFSXCIpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHBhdGggKz0gdmFsdWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGF0aCk7XG4gICAgICAgICAgICBwYXRoID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3BlbiA9IHRyeUNvbnN1bWUoXCJPUEVOXCIpO1xuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGNvbnN1bWVUZXh0KCk7XG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gdHJ5Q29uc3VtZShcIk5BTUVcIikgfHwgXCJcIjtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuXzEgPSB0cnlDb25zdW1lKFwiUEFUVEVSTlwiKSB8fCBcIlwiO1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IGNvbnN1bWVUZXh0KCk7XG4gICAgICAgICAgICBtdXN0Q29uc3VtZShcIkNMT1NFXCIpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVfMSB8fCAocGF0dGVybl8xID8ga2V5KysgOiBcIlwiKSxcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBuYW1lXzEgJiYgIXBhdHRlcm5fMSA/IGRlZmF1bHRQYXR0ZXJuIDogcGF0dGVybl8xLFxuICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgICAgIHN1ZmZpeDogc3VmZml4LFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyOiB0cnlDb25zdW1lKFwiTU9ESUZJRVJcIikgfHwgXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtdXN0Q29uc3VtZShcIkVORFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZShzdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdG9rZW5zVG9GdW5jdGlvbihwYXJzZShzdHIsIG9wdGlvbnMpLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGU7XG4vKipcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb0Z1bmN0aW9uKHRva2Vucywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIHJlRmxhZ3MgPSBmbGFncyhvcHRpb25zKTtcbiAgICB2YXIgX2EgPSBvcHRpb25zLmVuY29kZSwgZW5jb2RlID0gX2EgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9IDogX2EsIF9iID0gb3B0aW9ucy52YWxpZGF0ZSwgdmFsaWRhdGUgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iO1xuICAgIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICAgIHZhciBtYXRjaGVzID0gdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpJFwiLCByZUZsYWdzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcGF0aCA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGEgPyBkYXRhW3Rva2VuLm5hbWVdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIG9wdGlvbmFsID0gdG9rZW4ubW9kaWZpZXIgPT09IFwiP1wiIHx8IHRva2VuLm1vZGlmaWVyID09PSBcIipcIjtcbiAgICAgICAgICAgIHZhciByZXBlYXQgPSB0b2tlbi5tb2RpZmllciA9PT0gXCIqXCIgfHwgdG9rZW4ubW9kaWZpZXIgPT09IFwiK1wiO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXBlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFxcXCJcIiArIHRva2VuLm5hbWUgKyBcIlxcXCIgdG8gbm90IHJlcGVhdCwgYnV0IGdvdCBhbiBhcnJheVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFxcXCJcIiArIHRva2VuLm5hbWUgKyBcIlxcXCIgdG8gbm90IGJlIGVtcHR5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZSAmJiAhbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYWxsIFxcXCJcIiArIHRva2VuLm5hbWUgKyBcIlxcXCIgdG8gbWF0Y2ggXFxcIlwiICsgdG9rZW4ucGF0dGVybiArIFwiXFxcIiwgYnV0IGdvdCBcXFwiXCIgKyBzZWdtZW50ICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudCArIHRva2VuLnN1ZmZpeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gZW5jb2RlKFN0cmluZyh2YWx1ZSksIHRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGUgJiYgIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBtYXRjaCBcXFwiXCIgKyB0b2tlbi5wYXR0ZXJuICsgXCJcXFwiLCBidXQgZ290IFxcXCJcIiArIHNlZ21lbnQgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudCArIHRva2VuLnN1ZmZpeDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25hbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciB0eXBlT2ZNZXNzYWdlID0gcmVwZWF0ID8gXCJhbiBhcnJheVwiIDogXCJhIHN0cmluZ1wiO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFxcXCJcIiArIHRva2VuLm5hbWUgKyBcIlxcXCIgdG8gYmUgXCIgKyB0eXBlT2ZNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xufVxuZXhwb3J0cy50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvbjtcbi8qKlxuICogQ3JlYXRlIHBhdGggbWF0Y2ggZnVuY3Rpb24gZnJvbSBgcGF0aC10by1yZWdleHBgIHNwZWMuXG4gKi9cbmZ1bmN0aW9uIG1hdGNoKHN0ciwgb3B0aW9ucykge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgdmFyIHJlID0gcGF0aFRvUmVnZXhwKHN0ciwga2V5cywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlZ2V4cFRvRnVuY3Rpb24ocmUsIGtleXMsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5tYXRjaCA9IG1hdGNoO1xuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIG1hdGNoIGZ1bmN0aW9uIGZyb20gYHBhdGgtdG8tcmVnZXhwYCBvdXRwdXQuXG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvRnVuY3Rpb24ocmUsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IG9wdGlvbnMuZGVjb2RlLCBkZWNvZGUgPSBfYSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0gOiBfYTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBhdGhuYW1lKSB7XG4gICAgICAgIHZhciBtID0gcmUuZXhlYyhwYXRobmFtZSk7XG4gICAgICAgIGlmICghbSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHBhdGggPSBtWzBdLCBpbmRleCA9IG0uaW5kZXg7XG4gICAgICAgIHZhciBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgIGlmIChtW2ldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2kgLSAxXTtcbiAgICAgICAgICAgIGlmIChrZXkubW9kaWZpZXIgPT09IFwiKlwiIHx8IGtleS5tb2RpZmllciA9PT0gXCIrXCIpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5Lm5hbWVdID0gbVtpXS5zcGxpdChrZXkucHJlZml4ICsga2V5LnN1ZmZpeCkubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlKHZhbHVlLCBrZXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2tleS5uYW1lXSA9IGRlY29kZShtW2ldLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcGF0aDogcGF0aCwgaW5kZXg6IGluZGV4LCBwYXJhbXM6IHBhcmFtcyB9O1xuICAgIH07XG59XG5leHBvcnRzLnJlZ2V4cFRvRnVuY3Rpb24gPSByZWdleHBUb0Z1bmN0aW9uO1xuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfC9cXFxcXSkvZywgXCJcXFxcJDFcIik7XG59XG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGZsYWdzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLnNlbnNpdGl2ZSA/IFwiXCIgOiBcImlcIjtcbn1cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cChwYXRoLCBrZXlzKSB7XG4gICAgaWYgKCFrZXlzKVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICAgIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKTtcbiAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IGksXG4gICAgICAgICAgICAgICAgcHJlZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgIHN1ZmZpeDogXCJcIixcbiAgICAgICAgICAgICAgICBtb2RpZmllcjogXCJcIixcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAocGF0aHMsIGtleXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFydHMgPSBwYXRocy5tYXAoZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIHBhdGhUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKS5zb3VyY2U7IH0pO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86XCIgKyBwYXJ0cy5qb2luKFwifFwiKSArIFwiKVwiLCBmbGFncyhvcHRpb25zKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRva2Vuc1RvUmVnZXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBrZXlzLCBvcHRpb25zKTtcbn1cbi8qKlxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdleHAodG9rZW5zLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgX2EgPSBvcHRpb25zLnN0cmljdCwgc3RyaWN0ID0gX2EgPT09IHZvaWQgMCA/IGZhbHNlIDogX2EsIF9iID0gb3B0aW9ucy5zdGFydCwgc3RhcnQgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBfYyA9IG9wdGlvbnMuZW5kLCBlbmQgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLCBfZCA9IG9wdGlvbnMuZW5jb2RlLCBlbmNvZGUgPSBfZCA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0gOiBfZDtcbiAgICB2YXIgZW5kc1dpdGggPSBcIltcIiArIGVzY2FwZVN0cmluZyhvcHRpb25zLmVuZHNXaXRoIHx8IFwiXCIpICsgXCJdfCRcIjtcbiAgICB2YXIgZGVsaW1pdGVyID0gXCJbXCIgKyBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgXCIvIz9cIikgKyBcIl1cIjtcbiAgICB2YXIgcm91dGUgPSBzdGFydCA/IFwiXlwiIDogXCJcIjtcbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRva2VucyBhbmQgY3JlYXRlIG91ciByZWdleHAgc3RyaW5nLlxuICAgIGZvciAodmFyIF9pID0gMCwgdG9rZW5zXzEgPSB0b2tlbnM7IF9pIDwgdG9rZW5zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc18xW19pXTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKGVuY29kZSh0b2tlbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGVzY2FwZVN0cmluZyhlbmNvZGUodG9rZW4ucHJlZml4KSk7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gZXNjYXBlU3RyaW5nKGVuY29kZSh0b2tlbi5zdWZmaXgpKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi5wYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleXMpXG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHByZWZpeCB8fCBzdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLm1vZGlmaWVyID09PSBcIitcIiB8fCB0b2tlbi5tb2RpZmllciA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2QgPSB0b2tlbi5tb2RpZmllciA9PT0gXCIqXCIgPyBcIj9cIiA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZSArPSBcIig/OlwiICsgcHJlZml4ICsgXCIoKD86XCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpKD86XCIgKyBzdWZmaXggKyBwcmVmaXggKyBcIig/OlwiICsgdG9rZW4ucGF0dGVybiArIFwiKSkqKVwiICsgc3VmZml4ICsgXCIpXCIgKyBtb2Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZSArPSBcIig/OlwiICsgcHJlZml4ICsgXCIoXCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpXCIgKyBzdWZmaXggKyBcIilcIiArIHRva2VuLm1vZGlmaWVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSArPSBcIihcIiArIHRva2VuLnBhdHRlcm4gKyBcIilcIiArIHRva2VuLm1vZGlmaWVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBwcmVmaXggKyBzdWZmaXggKyBcIilcIiArIHRva2VuLm1vZGlmaWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQpIHtcbiAgICAgICAgaWYgKCFzdHJpY3QpXG4gICAgICAgICAgICByb3V0ZSArPSBkZWxpbWl0ZXIgKyBcIj9cIjtcbiAgICAgICAgcm91dGUgKz0gIW9wdGlvbnMuZW5kc1dpdGggPyBcIiRcIiA6IFwiKD89XCIgKyBlbmRzV2l0aCArIFwiKVwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGVuZFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGlzRW5kRGVsaW1pdGVkID0gdHlwZW9mIGVuZFRva2VuID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IGRlbGltaXRlci5pbmRleE9mKGVuZFRva2VuW2VuZFRva2VuLmxlbmd0aCAtIDFdKSA+IC0xXG4gICAgICAgICAgICA6IC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgIGVuZFRva2VuID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghc3RyaWN0KSB7XG4gICAgICAgICAgICByb3V0ZSArPSBcIig/OlwiICsgZGVsaW1pdGVyICsgXCIoPz1cIiArIGVuZHNXaXRoICsgXCIpKT9cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRW5kRGVsaW1pdGVkKSB7XG4gICAgICAgICAgICByb3V0ZSArPSBcIig/PVwiICsgZGVsaW1pdGVyICsgXCJ8XCIgKyBlbmRzV2l0aCArIFwiKVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVnRXhwKHJvdXRlLCBmbGFncyhvcHRpb25zKSk7XG59XG5leHBvcnRzLnRva2Vuc1RvUmVnZXhwID0gdG9rZW5zVG9SZWdleHA7XG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBjYW4gYmUgcGFzc2VkIGluIGZvciB0aGUga2V5cywgd2hpY2ggd2lsbCBob2xkIHRoZVxuICogcGxhY2Vob2xkZXIga2V5IGRlc2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIHVzaW5nIGAvdXNlci86aWRgLCBga2V5c2Agd2lsbFxuICogY29udGFpbiBgW3sgbmFtZTogJ2lkJywgZGVsaW1pdGVyOiAnLycsIG9wdGlvbmFsOiBmYWxzZSwgcmVwZWF0OiBmYWxzZSB9XWAuXG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApXG4gICAgICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCBrZXlzKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSlcbiAgICAgICAgcmV0dXJuIGFycmF5VG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHN0cmluZ1RvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5wYXRoVG9SZWdleHAgPSBwYXRoVG9SZWdleHA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvKlxuTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSBKYXNvbiBNaWxsZXIgKGh0dHBzOi8vamFzb25mb3JtYXQuY29tLylcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cblxuLy8gVGhpcyBmaWxlIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvbWl0dC9ibG9iL3YxLjEuMy9zcmMvaW5kZXguanNcbi8vIEl0J3MgYmVlbiBlZGl0ZWQgZm9yIHRoZSBuZWVkcyBvZiB0aGlzIHNjcmlwdFxuLy8gU2VlIHRoZSBMSUNFTlNFIGF0IHRoZSB0b3Agb2YgdGhlIGZpbGVcblxudHlwZSBIYW5kbGVyID0gKC4uLmV2dHM6IGFueVtdKSA9PiB2b2lkXG5cbmV4cG9ydCB0eXBlIE1pdHRFbWl0dGVyID0ge1xuICBvbih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpOiB2b2lkXG4gIG9mZih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpOiB2b2lkXG4gIGVtaXQodHlwZTogc3RyaW5nLCAuLi5ldnRzOiBhbnlbXSk6IHZvaWRcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWl0dCgpOiBNaXR0RW1pdHRlciB7XG4gIGNvbnN0IGFsbDogeyBbczogc3RyaW5nXTogSGFuZGxlcltdIH0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgcmV0dXJuIHtcbiAgICBvbih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpIHtcbiAgICAgIDsoYWxsW3R5cGVdIHx8IChhbGxbdHlwZV0gPSBbXSkpLnB1c2goaGFuZGxlcilcbiAgICB9LFxuXG4gICAgb2ZmKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcikge1xuICAgICAgaWYgKGFsbFt0eXBlXSkge1xuICAgICAgICBhbGxbdHlwZV0uc3BsaWNlKGFsbFt0eXBlXS5pbmRleE9mKGhhbmRsZXIpID4+PiAwLCAxKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbWl0KHR5cGU6IHN0cmluZywgLi4uZXZ0czogYW55W10pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICAgIDsoYWxsW3R5cGVdIHx8IFtdKS5zbGljZSgpLm1hcCgoaGFuZGxlcjogSGFuZGxlcikgPT4ge1xuICAgICAgICBoYW5kbGVyKC4uLmV2dHMpXG4gICAgICB9KVxuICAgIH0sXG4gIH1cbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IE5leHRSb3V0ZXIgfSBmcm9tICcuL3JvdXRlci9yb3V0ZXInXG5cbmV4cG9ydCBjb25zdCBSb3V0ZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxOZXh0Um91dGVyPihudWxsIGFzIGFueSlcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdSb3V0ZXJDb250ZXh0J1xufVxuIiwiLyogZ2xvYmFsIF9fTkVYVF9EQVRBX18gKi9cbi8vIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGVcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQge1xuICBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCxcbiAgcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gsXG59IGZyb20gJy4uLy4uLy4uL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2gnXG5pbXBvcnQgeyBHb29kUGFnZUNhY2hlLCBTdHlsZVNoZWV0VHVwbGUgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcGFnZS1sb2FkZXInXG5pbXBvcnQgeyBkZW5vcm1hbGl6ZVBhZ2VQYXRoIH0gZnJvbSAnLi4vLi4vc2VydmVyL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aCdcbmltcG9ydCBtaXR0LCB7IE1pdHRFbWl0dGVyIH0gZnJvbSAnLi4vbWl0dCdcbmltcG9ydCB7XG4gIEFwcENvbnRleHRUeXBlLFxuICBmb3JtYXRXaXRoVmFsaWRhdGlvbixcbiAgZ2V0TG9jYXRpb25PcmlnaW4sXG4gIGdldFVSTCxcbiAgbG9hZEdldEluaXRpYWxQcm9wcyxcbiAgTmV4dFBhZ2VDb250ZXh0LFxuICBTVCxcbn0gZnJvbSAnLi4vdXRpbHMnXG5pbXBvcnQgeyBpc0R5bmFtaWNSb3V0ZSB9IGZyb20gJy4vdXRpbHMvaXMtZHluYW1pYydcbmltcG9ydCB7IHBhcnNlUmVsYXRpdmVVcmwgfSBmcm9tICcuL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybCdcbmltcG9ydCB7IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkgfSBmcm9tICcuL3V0aWxzL3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHJlc29sdmVSZXdyaXRlcyBmcm9tICcuL3V0aWxzL3Jlc29sdmUtcmV3cml0ZXMnXG5pbXBvcnQgeyBnZXRSb3V0ZU1hdGNoZXIgfSBmcm9tICcuL3V0aWxzL3JvdXRlLW1hdGNoZXInXG5pbXBvcnQgeyBnZXRSb3V0ZVJlZ2V4IH0gZnJvbSAnLi91dGlscy9yb3V0ZS1yZWdleCdcbmltcG9ydCBlc2NhcGVQYXRoRGVsaW1pdGVycyBmcm9tICcuL3V0aWxzL2VzY2FwZS1wYXRoLWRlbGltaXRlcnMnXG5cbmludGVyZmFjZSBUcmFuc2l0aW9uT3B0aW9ucyB7XG4gIHNoYWxsb3c/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG59XG5cbmludGVyZmFjZSBOZXh0SGlzdG9yeVN0YXRlIHtcbiAgdXJsOiBzdHJpbmdcbiAgYXM6IHN0cmluZ1xuICBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9uc1xufVxuXG50eXBlIEhpc3RvcnlTdGF0ZSA9IG51bGwgfCB7IF9fTjogZmFsc2UgfSB8ICh7IF9fTjogdHJ1ZSB9ICYgTmV4dEhpc3RvcnlTdGF0ZSlcblxuY29uc3QgYmFzZVBhdGggPSAocHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCBhcyBzdHJpbmcpIHx8ICcnXG5cbmZ1bmN0aW9uIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignUm91dGUgQ2FuY2VsbGVkJyksIHtcbiAgICBjYW5jZWxsZWQ6IHRydWUsXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGFkZFBhdGhQcmVmaXgocGF0aDogc3RyaW5nLCBwcmVmaXg/OiBzdHJpbmcpIHtcbiAgcmV0dXJuIHByZWZpeCAmJiBwYXRoLnN0YXJ0c1dpdGgoJy8nKVxuICAgID8gcGF0aCA9PT0gJy8nXG4gICAgICA/IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKHByZWZpeClcbiAgICAgIDogYCR7cHJlZml4fSR7cGF0aH1gXG4gICAgOiBwYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRMb2NhbGUoXG4gIHBhdGg6IHN0cmluZyxcbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2UsXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbikge1xuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgIHJldHVybiBsb2NhbGUgJiYgbG9jYWxlICE9PSBkZWZhdWx0TG9jYWxlICYmICFwYXRoLnN0YXJ0c1dpdGgoJy8nICsgbG9jYWxlKVxuICAgICAgPyBhZGRQYXRoUHJlZml4KHBhdGgsICcvJyArIGxvY2FsZSlcbiAgICAgIDogcGF0aFxuICB9XG4gIHJldHVybiBwYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxMb2NhbGUocGF0aDogc3RyaW5nLCBsb2NhbGU/OiBzdHJpbmcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICByZXR1cm4gbG9jYWxlICYmIHBhdGguc3RhcnRzV2l0aCgnLycgKyBsb2NhbGUpXG4gICAgICA/IHBhdGguc3Vic3RyKGxvY2FsZS5sZW5ndGggKyAxKSB8fCAnLydcbiAgICAgIDogcGF0aFxuICB9XG4gIHJldHVybiBwYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNCYXNlUGF0aChwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIHBhdGggPT09IGJhc2VQYXRoIHx8IHBhdGguc3RhcnRzV2l0aChiYXNlUGF0aCArICcvJylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEJhc2VQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIHdlIG9ubHkgYWRkIHRoZSBiYXNlcGF0aCBvbiByZWxhdGl2ZSB1cmxzXG4gIHJldHVybiBhZGRQYXRoUHJlZml4KHBhdGgsIGJhc2VQYXRoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsQmFzZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhdGguc2xpY2UoYmFzZVBhdGgubGVuZ3RoKSB8fCAnLydcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHdoZXRoZXIgYSBnaXZlbiB1cmwgaXMgcm91dGFibGUgYnkgdGhlIE5leHQuanMgcm91dGVyIChicm93c2VyIG9ubHkpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMb2NhbFVSTCh1cmw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAodXJsLnN0YXJ0c1dpdGgoJy8nKSkgcmV0dXJuIHRydWVcbiAgdHJ5IHtcbiAgICAvLyBhYnNvbHV0ZSB1cmxzIGNhbiBiZSBsb2NhbCBpZiB0aGV5IGFyZSBvbiB0aGUgc2FtZSBvcmlnaW5cbiAgICBjb25zdCBsb2NhdGlvbk9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgICBjb25zdCByZXNvbHZlZCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbk9yaWdpbilcbiAgICByZXR1cm4gcmVzb2x2ZWQub3JpZ2luID09PSBsb2NhdGlvbk9yaWdpbiAmJiBoYXNCYXNlUGF0aChyZXNvbHZlZC5wYXRobmFtZSlcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbnR5cGUgVXJsID0gVXJsT2JqZWN0IHwgc3RyaW5nXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnBvbGF0ZUFzKFxuICByb3V0ZTogc3RyaW5nLFxuICBhc1BhdGhuYW1lOiBzdHJpbmcsXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuKSB7XG4gIGxldCBpbnRlcnBvbGF0ZWRSb3V0ZSA9ICcnXG5cbiAgY29uc3QgZHluYW1pY1JlZ2V4ID0gZ2V0Um91dGVSZWdleChyb3V0ZSlcbiAgY29uc3QgZHluYW1pY0dyb3VwcyA9IGR5bmFtaWNSZWdleC5ncm91cHNcbiAgY29uc3QgZHluYW1pY01hdGNoZXMgPVxuICAgIC8vIFRyeSB0byBtYXRjaCB0aGUgZHluYW1pYyByb3V0ZSBhZ2FpbnN0IHRoZSBhc1BhdGhcbiAgICAoYXNQYXRobmFtZSAhPT0gcm91dGUgPyBnZXRSb3V0ZU1hdGNoZXIoZHluYW1pY1JlZ2V4KShhc1BhdGhuYW1lKSA6ICcnKSB8fFxuICAgIC8vIEZhbGwgYmFjayB0byByZWFkaW5nIHRoZSB2YWx1ZXMgZnJvbSB0aGUgaHJlZlxuICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIHRha2UgcHJpb3JpdHk7IGFsc28gbmVlZCB0byBjaGFuZ2UgaW4gdGhlIHJvdXRlci5cbiAgICBxdWVyeVxuXG4gIGludGVycG9sYXRlZFJvdXRlID0gcm91dGVcbiAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmtleXMoZHluYW1pY0dyb3VwcylcblxuICBpZiAoXG4gICAgIXBhcmFtcy5ldmVyeSgocGFyYW0pID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IGR5bmFtaWNNYXRjaGVzW3BhcmFtXSB8fCAnJ1xuICAgICAgY29uc3QgeyByZXBlYXQsIG9wdGlvbmFsIH0gPSBkeW5hbWljR3JvdXBzW3BhcmFtXVxuXG4gICAgICAvLyBzdXBwb3J0IHNpbmdsZS1sZXZlbCBjYXRjaC1hbGxcbiAgICAgIC8vIFRPRE86IG1vcmUgcm9idXN0IGhhbmRsaW5nIGZvciB1c2VyLWVycm9yIChwYXNzaW5nIGAvYClcbiAgICAgIGxldCByZXBsYWNlZCA9IGBbJHtyZXBlYXQgPyAnLi4uJyA6ICcnfSR7cGFyYW19XWBcbiAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICByZXBsYWNlZCA9IGAkeyF2YWx1ZSA/ICcvJyA6ICcnfVske3JlcGxhY2VkfV1gXG4gICAgICB9XG4gICAgICBpZiAocmVwZWF0ICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkgdmFsdWUgPSBbdmFsdWVdXG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIChvcHRpb25hbCB8fCBwYXJhbSBpbiBkeW5hbWljTWF0Y2hlcykgJiZcbiAgICAgICAgLy8gSW50ZXJwb2xhdGUgZ3JvdXAgaW50byBkYXRhIFVSTCBpZiBwcmVzZW50XG4gICAgICAgIChpbnRlcnBvbGF0ZWRSb3V0ZSA9XG4gICAgICAgICAgaW50ZXJwb2xhdGVkUm91dGUhLnJlcGxhY2UoXG4gICAgICAgICAgICByZXBsYWNlZCxcbiAgICAgICAgICAgIHJlcGVhdFxuICAgICAgICAgICAgICA/ICh2YWx1ZSBhcyBzdHJpbmdbXSkubWFwKGVzY2FwZVBhdGhEZWxpbWl0ZXJzKS5qb2luKCcvJylcbiAgICAgICAgICAgICAgOiBlc2NhcGVQYXRoRGVsaW1pdGVycyh2YWx1ZSBhcyBzdHJpbmcpXG4gICAgICAgICAgKSB8fCAnLycpXG4gICAgICApXG4gICAgfSlcbiAgKSB7XG4gICAgaW50ZXJwb2xhdGVkUm91dGUgPSAnJyAvLyBkaWQgbm90IHNhdGlzZnkgYWxsIHJlcXVpcmVtZW50c1xuXG4gICAgLy8gbi5iLiBXZSBpZ25vcmUgdGhpcyBlcnJvciBiZWNhdXNlIHdlIGhhbmRsZSB3YXJuaW5nIGZvciB0aGlzIGNhc2UgaW5cbiAgICAvLyBkZXZlbG9wbWVudCBpbiB0aGUgYDxMaW5rPmAgY29tcG9uZW50IGRpcmVjdGx5LlxuICB9XG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHJlc3VsdDogaW50ZXJwb2xhdGVkUm91dGUsXG4gIH1cbn1cblxuZnVuY3Rpb24gb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSwgcGFyYW1zOiBzdHJpbmdbXSkge1xuICBjb25zdCBmaWx0ZXJlZFF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSA9IHt9XG5cbiAgT2JqZWN0LmtleXMocXVlcnkpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmICghcGFyYW1zLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGZpbHRlcmVkUXVlcnlba2V5XSA9IHF1ZXJ5W2tleV1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBmaWx0ZXJlZFF1ZXJ5XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgYSBnaXZlbiBoeXBlcmxpbmsgd2l0aCBhIGNlcnRhaW4gcm91dGVyIHN0YXRlIChiYXNlUGF0aCBub3QgaW5jbHVkZWQpLlxuICogUHJlc2VydmVzIGFic29sdXRlIHVybHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlSHJlZihcbiAgY3VycmVudFBhdGg6IHN0cmluZyxcbiAgaHJlZjogVXJsLFxuICByZXNvbHZlQXM/OiBib29sZWFuXG4pOiBzdHJpbmcge1xuICAvLyB3ZSB1c2UgYSBkdW1teSBiYXNlIHVybCBmb3IgcmVsYXRpdmUgdXJsc1xuICBjb25zdCBiYXNlID0gbmV3IFVSTChjdXJyZW50UGF0aCwgJ2h0dHA6Ly9uJylcbiAgY29uc3QgdXJsQXNTdHJpbmcgPVxuICAgIHR5cGVvZiBocmVmID09PSAnc3RyaW5nJyA/IGhyZWYgOiBmb3JtYXRXaXRoVmFsaWRhdGlvbihocmVmKVxuICB0cnkge1xuICAgIGNvbnN0IGZpbmFsVXJsID0gbmV3IFVSTCh1cmxBc1N0cmluZywgYmFzZSlcbiAgICBmaW5hbFVybC5wYXRobmFtZSA9IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKGZpbmFsVXJsLnBhdGhuYW1lKVxuICAgIGxldCBpbnRlcnBvbGF0ZWRBcyA9ICcnXG5cbiAgICBpZiAoXG4gICAgICBpc0R5bmFtaWNSb3V0ZShmaW5hbFVybC5wYXRobmFtZSkgJiZcbiAgICAgIGZpbmFsVXJsLnNlYXJjaFBhcmFtcyAmJlxuICAgICAgcmVzb2x2ZUFzXG4gICAgKSB7XG4gICAgICBjb25zdCBxdWVyeSA9IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoZmluYWxVcmwuc2VhcmNoUGFyYW1zKVxuXG4gICAgICBjb25zdCB7IHJlc3VsdCwgcGFyYW1zIH0gPSBpbnRlcnBvbGF0ZUFzKFxuICAgICAgICBmaW5hbFVybC5wYXRobmFtZSxcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5XG4gICAgICApXG5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkQXMgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgcGF0aG5hbWU6IHJlc3VsdCxcbiAgICAgICAgICBoYXNoOiBmaW5hbFVybC5oYXNoLFxuICAgICAgICAgIHF1ZXJ5OiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnksIHBhcmFtcyksXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIG9yaWdpbiBkaWRuJ3QgY2hhbmdlLCBpdCBtZWFucyB3ZSByZWNlaXZlZCBhIHJlbGF0aXZlIGhyZWZcbiAgICBjb25zdCByZXNvbHZlZEhyZWYgPVxuICAgICAgZmluYWxVcmwub3JpZ2luID09PSBiYXNlLm9yaWdpblxuICAgICAgICA/IGZpbmFsVXJsLmhyZWYuc2xpY2UoZmluYWxVcmwub3JpZ2luLmxlbmd0aClcbiAgICAgICAgOiBmaW5hbFVybC5ocmVmXG5cbiAgICByZXR1cm4gKHJlc29sdmVBc1xuICAgICAgPyBbcmVzb2x2ZWRIcmVmLCBpbnRlcnBvbGF0ZWRBcyB8fCByZXNvbHZlZEhyZWZdXG4gICAgICA6IHJlc29sdmVkSHJlZikgYXMgc3RyaW5nXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gKHJlc29sdmVBcyA/IFt1cmxBc1N0cmluZ10gOiB1cmxBc1N0cmluZykgYXMgc3RyaW5nXG4gIH1cbn1cblxuY29uc3QgUEFHRV9MT0FEX0VSUk9SID0gU3ltYm9sKCdQQUdFX0xPQURfRVJST1InKVxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtMb2FkaW5nRXJyb3IoZXJyOiBFcnJvcik6IEVycm9yIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsIFBBR0VfTE9BRF9FUlJPUiwge30pXG59XG5cbmZ1bmN0aW9uIHByZXBhcmVVcmxBcyhyb3V0ZXI6IE5leHRSb3V0ZXIsIHVybDogVXJsLCBhczogVXJsKSB7XG4gIC8vIElmIHVybCBhbmQgYXMgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uLFxuICAvLyB3ZSdsbCBmb3JtYXQgdGhlbSBpbnRvIHRoZSBzdHJpbmcgdmVyc2lvbiBoZXJlLlxuICByZXR1cm4ge1xuICAgIHVybDogYWRkQmFzZVBhdGgocmVzb2x2ZUhyZWYocm91dGVyLnBhdGhuYW1lLCB1cmwpKSxcbiAgICBhczogYXMgPyBhZGRCYXNlUGF0aChyZXNvbHZlSHJlZihyb3V0ZXIucGF0aG5hbWUsIGFzKSkgOiBhcyxcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBCYXNlUm91dGVyID0ge1xuICByb3V0ZTogc3RyaW5nXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGFzUGF0aDogc3RyaW5nXG4gIGJhc2VQYXRoOiBzdHJpbmdcbiAgbG9jYWxlPzogc3RyaW5nXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIE5leHRSb3V0ZXIgPSBCYXNlUm91dGVyICZcbiAgUGljazxcbiAgICBSb3V0ZXIsXG4gICAgfCAncHVzaCdcbiAgICB8ICdyZXBsYWNlJ1xuICAgIHwgJ3JlbG9hZCdcbiAgICB8ICdiYWNrJ1xuICAgIHwgJ3ByZWZldGNoJ1xuICAgIHwgJ2JlZm9yZVBvcFN0YXRlJ1xuICAgIHwgJ2V2ZW50cydcbiAgICB8ICdpc0ZhbGxiYWNrJ1xuICA+XG5cbmV4cG9ydCB0eXBlIFByZWZldGNoT3B0aW9ucyA9IHtcbiAgcHJpb3JpdHk/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIFByaXZhdGVSb3V0ZUluZm8gPSB7XG4gIENvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICBzdHlsZVNoZWV0czogU3R5bGVTaGVldFR1cGxlW11cbiAgX19OX1NTRz86IGJvb2xlYW5cbiAgX19OX1NTUD86IGJvb2xlYW5cbiAgcHJvcHM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIGVycj86IEVycm9yXG4gIGVycm9yPzogYW55XG59XG5cbmV4cG9ydCB0eXBlIEFwcFByb3BzID0gUGljazxQcml2YXRlUm91dGVJbmZvLCAnQ29tcG9uZW50JyB8ICdlcnInPiAmIHtcbiAgcm91dGVyOiBSb3V0ZXJcbn0gJiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG5leHBvcnQgdHlwZSBBcHBDb21wb25lbnQgPSBDb21wb25lbnRUeXBlPEFwcFByb3BzPlxuXG50eXBlIFN1YnNjcmlwdGlvbiA9IChkYXRhOiBQcml2YXRlUm91dGVJbmZvLCBBcHA6IEFwcENvbXBvbmVudCkgPT4gUHJvbWlzZTx2b2lkPlxuXG50eXBlIEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2sgPSAoc3RhdGU6IE5leHRIaXN0b3J5U3RhdGUpID0+IGJvb2xlYW5cblxudHlwZSBDb21wb25lbnRMb2FkQ2FuY2VsID0gKCgpID0+IHZvaWQpIHwgbnVsbFxuXG50eXBlIEhpc3RvcnlNZXRob2QgPSAncmVwbGFjZVN0YXRlJyB8ICdwdXNoU3RhdGUnXG5cbmNvbnN0IG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uID1cbiAgcHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiAmJlxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAnc2Nyb2xsUmVzdG9yYXRpb24nIGluIHdpbmRvdy5oaXN0b3J5XG5cbmNvbnN0IFNTR19EQVRBX05PVF9GT1VORF9FUlJPUiA9ICdTU0cgRGF0YSBOT1RfRk9VTkQnXG5cbmZ1bmN0aW9uIGZldGNoUmV0cnkodXJsOiBzdHJpbmcsIGF0dGVtcHRzOiBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgLy8gQ29va2llcyBhcmUgcmVxdWlyZWQgdG8gYmUgcHJlc2VudCBmb3IgTmV4dC5qcycgU1NHIFwiUHJldmlldyBNb2RlXCIuXG4gICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gICAgLy9cbiAgICAvLyA+IGBmZXRjaGAgd29u4oCZdCBzZW5kIGNvb2tpZXMsIHVubGVzcyB5b3Ugc2V0IHRoZSBjcmVkZW50aWFscyBpbml0XG4gICAgLy8gPiBvcHRpb24uXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxuICAgIC8vXG4gICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcbiAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXG4gICAgLy8gPiBvcHRpb24gaW5zdGVhZCBvZiByZWx5aW5nIG9uIHRoZSBkZWZhdWx0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xuICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICB9KS50aGVuKChyZXMpID0+IHtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgaWYgKGF0dGVtcHRzID4gMSAmJiByZXMuc3RhdHVzID49IDUwMCkge1xuICAgICAgICByZXR1cm4gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzIC0gMSlcbiAgICAgIH1cbiAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgLy8gVE9ETzogaGFuZGxlIHJlbG9hZGluZyBpbiBkZXZlbG9wbWVudCBmcm9tIGZhbGxiYWNrIHJldHVybmluZyAyMDBcbiAgICAgICAgLy8gdG8gb24tZGVtYW5kLWVudHJ5LWhhbmRsZXIgY2F1c2luZyBpdCB0byByZWxvYWQgcGVyaW9kaWNhbGx5XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihTU0dfREFUQV9OT1RfRk9VTkRfRVJST1IpXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc2ApXG4gICAgfVxuICAgIHJldHVybiByZXMuanNvbigpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGZldGNoTmV4dERhdGEoZGF0YUhyZWY6IHN0cmluZywgaXNTZXJ2ZXJSZW5kZXI6IGJvb2xlYW4pIHtcbiAgcmV0dXJuIGZldGNoUmV0cnkoZGF0YUhyZWYsIGlzU2VydmVyUmVuZGVyID8gMyA6IDEpLmNhdGNoKChlcnI6IEVycm9yKSA9PiB7XG4gICAgLy8gV2Ugc2hvdWxkIG9ubHkgdHJpZ2dlciBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb24gaWYgdGhpcyB3YXMgY2F1c2VkXG4gICAgLy8gb24gYSBjbGllbnQtc2lkZSB0cmFuc2l0aW9uLiBPdGhlcndpc2UsIHdlJ2QgZ2V0IGludG8gYW4gaW5maW5pdGVcbiAgICAvLyBsb29wLlxuXG4gICAgaWYgKCFpc1NlcnZlclJlbmRlcikge1xuICAgICAgbWFya0xvYWRpbmdFcnJvcihlcnIpXG4gICAgfVxuICAgIHRocm93IGVyclxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3V0ZXIgaW1wbGVtZW50cyBCYXNlUm91dGVyIHtcbiAgcm91dGU6IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBhc1BhdGg6IHN0cmluZ1xuICBiYXNlUGF0aDogc3RyaW5nXG5cbiAgLyoqXG4gICAqIE1hcCBvZiBhbGwgY29tcG9uZW50cyBsb2FkZWQgaW4gYFJvdXRlcmBcbiAgICovXG4gIGNvbXBvbmVudHM6IHsgW3BhdGhuYW1lOiBzdHJpbmddOiBQcml2YXRlUm91dGVJbmZvIH1cbiAgLy8gU3RhdGljIERhdGEgQ2FjaGVcbiAgc2RjOiB7IFthc1BhdGg6IHN0cmluZ106IG9iamVjdCB9ID0ge31cbiAgc3ViOiBTdWJzY3JpcHRpb25cbiAgY2xjOiBDb21wb25lbnRMb2FkQ2FuY2VsXG4gIHBhZ2VMb2FkZXI6IGFueVxuICBfYnBzOiBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrIHwgdW5kZWZpbmVkXG4gIGV2ZW50czogTWl0dEVtaXR0ZXJcbiAgX3dyYXBBcHA6IChBcHA6IEFwcENvbXBvbmVudCkgPT4gYW55XG4gIGlzU3NyOiBib29sZWFuXG4gIGlzRmFsbGJhY2s6IGJvb2xlYW5cbiAgX2luRmxpZ2h0Um91dGU/OiBzdHJpbmdcbiAgX3NoYWxsb3c/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZ1xuICBsb2NhbGVzPzogc3RyaW5nW11cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuXG4gIHN0YXRpYyBldmVudHM6IE1pdHRFbWl0dGVyID0gbWl0dCgpXG5cbiAgY29uc3RydWN0b3IoXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICB7XG4gICAgICBpbml0aWFsUHJvcHMsXG4gICAgICBwYWdlTG9hZGVyLFxuICAgICAgQXBwLFxuICAgICAgd3JhcEFwcCxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIGluaXRpYWxTdHlsZVNoZWV0cyxcbiAgICAgIGVycixcbiAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgIGlzRmFsbGJhY2ssXG4gICAgICBsb2NhbGUsXG4gICAgICBsb2NhbGVzLFxuICAgICAgZGVmYXVsdExvY2FsZSxcbiAgICB9OiB7XG4gICAgICBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvblxuICAgICAgaW5pdGlhbFByb3BzOiBhbnlcbiAgICAgIHBhZ2VMb2FkZXI6IGFueVxuICAgICAgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gICAgICBpbml0aWFsU3R5bGVTaGVldHM6IFN0eWxlU2hlZXRUdXBsZVtdXG4gICAgICBBcHA6IEFwcENvbXBvbmVudFxuICAgICAgd3JhcEFwcDogKEFwcDogQXBwQ29tcG9uZW50KSA9PiBhbnlcbiAgICAgIGVycj86IEVycm9yXG4gICAgICBpc0ZhbGxiYWNrOiBib29sZWFuXG4gICAgICBsb2NhbGU/OiBzdHJpbmdcbiAgICAgIGxvY2FsZXM/OiBzdHJpbmdbXVxuICAgICAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICAgIH1cbiAgKSB7XG4gICAgLy8gcmVwcmVzZW50cyB0aGUgY3VycmVudCBjb21wb25lbnQga2V5XG4gICAgdGhpcy5yb3V0ZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuXG4gICAgLy8gc2V0IHVwIHRoZSBjb21wb25lbnQgY2FjaGUgKGJ5IHJvdXRlIGtleXMpXG4gICAgdGhpcy5jb21wb25lbnRzID0ge31cbiAgICAvLyBXZSBzaG91bGQgbm90IGtlZXAgdGhlIGNhY2hlLCBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGNhdXNlIGlzc3VlcyB3aGVuIHdoZW4gZ29pbmcgYmFjayBhbmRcbiAgICAvLyBjb21lIGFnYWluIHRvIHRoZSBlcnJvcmVkIHBhZ2UuXG4gICAgaWYgKHBhdGhuYW1lICE9PSAnL19lcnJvcicpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50c1t0aGlzLnJvdXRlXSA9IHtcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBzdHlsZVNoZWV0czogaW5pdGlhbFN0eWxlU2hlZXRzLFxuICAgICAgICBwcm9wczogaW5pdGlhbFByb3BzLFxuICAgICAgICBlcnIsXG4gICAgICAgIF9fTl9TU0c6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTRyxcbiAgICAgICAgX19OX1NTUDogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NQLFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY29tcG9uZW50c1snL19hcHAnXSA9IHtcbiAgICAgIENvbXBvbmVudDogQXBwIGFzIENvbXBvbmVudFR5cGUsXG4gICAgICBzdHlsZVNoZWV0czogW1xuICAgICAgICAvKiAvX2FwcCBkb2VzIG5vdCBuZWVkIGl0cyBzdHlsZXNoZWV0cyBtYW5hZ2VkICovXG4gICAgICBdLFxuICAgIH1cblxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIFJvdXRlci5yb3V0ZXIuZXZlbnRzXG4gICAgLy8gVE9ETzogU2hvdWxkIGJlIHJlbW92ZSB0aGUgZm9sbG93aW5nIG1ham9yIHZlcnNpb24gYXMgaXQgd2FzIG5ldmVyIGRvY3VtZW50ZWRcbiAgICB0aGlzLmV2ZW50cyA9IFJvdXRlci5ldmVudHNcblxuICAgIHRoaXMucGFnZUxvYWRlciA9IHBhZ2VMb2FkZXJcbiAgICB0aGlzLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlcbiAgICAvLyBpZiBhdXRvIHByZXJlbmRlcmVkIGFuZCBkeW5hbWljIHJvdXRlIHdhaXQgdG8gdXBkYXRlIGFzUGF0aFxuICAgIC8vIHVudGlsIGFmdGVyIG1vdW50IHRvIHByZXZlbnQgaHlkcmF0aW9uIG1pc21hdGNoXG4gICAgdGhpcy5hc1BhdGggPVxuICAgICAgLy8gQHRzLWlnbm9yZSB0aGlzIGlzIHRlbXBvcmFyaWx5IGdsb2JhbCAoYXR0YWNoZWQgdG8gd2luZG93KVxuICAgICAgaXNEeW5hbWljUm91dGUocGF0aG5hbWUpICYmIF9fTkVYVF9EQVRBX18uYXV0b0V4cG9ydCA/IHBhdGhuYW1lIDogYXNcbiAgICB0aGlzLmJhc2VQYXRoID0gYmFzZVBhdGhcbiAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvblxuICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIHRoaXMuX3dyYXBBcHAgPSB3cmFwQXBwXG4gICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgIC8vIGJhY2sgZnJvbSBleHRlcm5hbCBzaXRlXG4gICAgdGhpcy5pc1NzciA9IHRydWVcblxuICAgIHRoaXMuaXNGYWxsYmFjayA9IGlzRmFsbGJhY2tcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZVxuICAgICAgdGhpcy5sb2NhbGVzID0gbG9jYWxlc1xuICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gbWFrZSBzdXJlIFwiYXNcIiBkb2Vzbid0IHN0YXJ0IHdpdGggZG91YmxlIHNsYXNoZXMgb3IgZWxzZSBpdCBjYW5cbiAgICAgIC8vIHRocm93IGFuIGVycm9yIGFzIGl0J3MgY29uc2lkZXJlZCBpbnZhbGlkXG4gICAgICBpZiAoYXMuc3Vic3RyKDAsIDIpICE9PSAnLy8nKSB7XG4gICAgICAgIC8vIGluIG9yZGVyIGZvciBgZS5zdGF0ZWAgdG8gd29yayBvbiB0aGUgYG9ucG9wc3RhdGVgIGV2ZW50XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gcmVnaXN0ZXIgdGhlIGluaXRpYWwgcm91dGUgdXBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSwgcXVlcnkgfSksXG4gICAgICAgICAgZ2V0VVJMKClcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLm9uUG9wU3RhdGUpXG5cbiAgICAgIC8vIGVuYWJsZSBjdXN0b20gc2Nyb2xsIHJlc3RvcmF0aW9uIGhhbmRsaW5nIHdoZW4gYXZhaWxhYmxlXG4gICAgICAvLyBvdGhlcndpc2UgZmFsbGJhY2sgdG8gYnJvd3NlcidzIGRlZmF1bHQgaGFuZGxpbmdcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gJ21hbnVhbCdcblxuICAgICAgICAgIGxldCBzY3JvbGxEZWJvdW5jZVRpbWVvdXQ6IHVuZGVmaW5lZCB8IE5vZGVKUy5UaW1lb3V0XG5cbiAgICAgICAgICBjb25zdCBkZWJvdW5jZWRTY3JvbGxTYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNjcm9sbERlYm91bmNlVGltZW91dCkgY2xlYXJUaW1lb3V0KHNjcm9sbERlYm91bmNlVGltZW91dClcblxuICAgICAgICAgICAgc2Nyb2xsRGVib3VuY2VUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgdXJsLCBhczogY3VyQXMsIG9wdGlvbnMgfSA9IGhpc3Rvcnkuc3RhdGVcbiAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgY3VyQXMsXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgX05fWDogd2luZG93LnNjcm9sbFgsXG4gICAgICAgICAgICAgICAgICBfTl9ZOiB3aW5kb3cuc2Nyb2xsWSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9LCAxMClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZGVib3VuY2VkU2Nyb2xsU2F2ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uUG9wU3RhdGUgPSAoZTogUG9wU3RhdGVFdmVudCk6IHZvaWQgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gZS5zdGF0ZSBhcyBIaXN0b3J5U3RhdGVcblxuICAgIGlmICghc3RhdGUpIHtcbiAgICAgIC8vIFdlIGdldCBzdGF0ZSBhcyB1bmRlZmluZWQgZm9yIHR3byByZWFzb25zLlxuICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXG4gICAgICAvLyAgMi4gV2hlbiB0aGUgVVJMIGNoYW5nZWQgd2l0aCAjXG4gICAgICAvL1xuICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cbiAgICAgIC8vIChhcyBpdCdzIGFscmVhZHkgY2hhbmdlZClcbiAgICAgIC8vIEJ1dCB3ZSBjYW4gc2ltcGx5IHJlcGxhY2UgdGhlIHN0YXRlIHdpdGggdGhlIG5ldyBjaGFuZ2VzLlxuICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxuICAgICAgLy8gU28sIGRvaW5nIHRoZSBmb2xsb3dpbmcgZm9yICgxKSBkb2VzIG5vIGhhcm0uXG4gICAgICBjb25zdCB7IHBhdGhuYW1lLCBxdWVyeSB9ID0gdGhpc1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSwgcXVlcnkgfSksXG4gICAgICAgIGdldFVSTCgpXG4gICAgICApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIXN0YXRlLl9fTikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgeyB1cmwsIGFzLCBvcHRpb25zIH0gPSBzdGF0ZVxuXG4gICAgY29uc3QgeyBwYXRobmFtZSB9ID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgcmUtcmVuZGVyIG9uIGluaXRpYWwgbG9hZCxcbiAgICAvLyBjYW4gYmUgY2F1c2VkIGJ5IG5hdmlnYXRpbmcgYmFjayBmcm9tIGFuIGV4dGVybmFsIHNpdGVcbiAgICBpZiAodGhpcy5pc1NzciAmJiBhcyA9PT0gdGhpcy5hc1BhdGggJiYgcGF0aG5hbWUgPT09IHRoaXMucGF0aG5hbWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cbiAgICAvLyBUaGV5IHdpbGwgdGhlbiBiZSByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGhlIGV2ZW50LlxuICAgIGlmICh0aGlzLl9icHMgJiYgIXRoaXMuX2JwcyhzdGF0ZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY2hhbmdlKFxuICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICB1cmwsXG4gICAgICBhcyxcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgc2hhbGxvdzogb3B0aW9ucy5zaGFsbG93ICYmIHRoaXMuX3NoYWxsb3csXG4gICAgICAgIGxvY2FsZTogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlLFxuICAgICAgfSlcbiAgICApXG4gIH1cblxuICByZWxvYWQoKTogdm9pZCB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gIH1cblxuICAvKipcbiAgICogR28gYmFjayBpbiBoaXN0b3J5XG4gICAqL1xuICBiYWNrKCkge1xuICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHB1c2hTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqL1xuICBwdXNoKHVybDogVXJsLCBhczogVXJsID0gdXJsLCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgOyh7IHVybCwgYXMgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSlcbiAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3B1c2hTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBgcmVwbGFjZVN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovXG4gIHJlcGxhY2UodXJsOiBVcmwsIGFzOiBVcmwgPSB1cmwsIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zID0ge30pIHtcbiAgICA7KHsgdXJsLCBhcyB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKVxuICAgIHJldHVybiB0aGlzLmNoYW5nZSgncmVwbGFjZVN0YXRlJywgdXJsLCBhcywgb3B0aW9ucylcbiAgfVxuXG4gIGFzeW5jIGNoYW5nZShcbiAgICBtZXRob2Q6IEhpc3RvcnlNZXRob2QsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYXM6IHN0cmluZyxcbiAgICBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9uc1xuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoIWlzTG9jYWxVUkwodXJsKSkge1xuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmxcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICB0aGlzLmxvY2FsZSA9IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMubG9jYWxlXG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdGlvbnMubG9jYWxlID0gdGhpcy5sb2NhbGVcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBub3JtYWxpemVMb2NhbGVQYXRoLFxuICAgICAgfSA9IHJlcXVpcmUoJy4uL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGgnKVxuXG4gICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gbm9ybWFsaXplTG9jYWxlUGF0aChhcywgdGhpcy5sb2NhbGVzKVxuXG4gICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGVcbiAgICAgICAgdXJsID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKG9wdGlvbnMgYXMgYW55KS5faCkge1xuICAgICAgdGhpcy5pc1NzciA9IGZhbHNlXG4gICAgfVxuICAgIC8vIG1hcmtpbmcgcm91dGUgY2hhbmdlcyBhcyBhIG5hdmlnYXRpb24gc3RhcnQgZW50cnlcbiAgICBpZiAoU1QpIHtcbiAgICAgIHBlcmZvcm1hbmNlLm1hcmsoJ3JvdXRlQ2hhbmdlJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5GbGlnaHRSb3V0ZSkge1xuICAgICAgdGhpcy5hYm9ydENvbXBvbmVudExvYWQodGhpcy5faW5GbGlnaHRSb3V0ZSlcbiAgICB9XG5cbiAgICBhcyA9IGFkZExvY2FsZShhcywgb3B0aW9ucy5sb2NhbGUsIHRoaXMuZGVmYXVsdExvY2FsZSlcbiAgICBjb25zdCBjbGVhbmVkQXMgPSBkZWxMb2NhbGUoXG4gICAgICBoYXNCYXNlUGF0aChhcykgPyBkZWxCYXNlUGF0aChhcykgOiBhcyxcbiAgICAgIHRoaXMubG9jYWxlXG4gICAgKVxuICAgIHRoaXMuX2luRmxpZ2h0Um91dGUgPSBhc1xuXG4gICAgLy8gSWYgdGhlIHVybCBjaGFuZ2UgaXMgb25seSByZWxhdGVkIHRvIGEgaGFzaCBjaGFuZ2VcbiAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXG5cbiAgICAvLyBXQVJOSU5HOiBgX2hgIGlzIGFuIGludGVybmFsIG9wdGlvbiBmb3IgaGFuZGluZyBOZXh0LmpzIGNsaWVudC1zaWRlXG4gICAgLy8gaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS4gSXQgbWF5IGNoYW5nZSBhdFxuICAgIC8vIGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgIGlmICghKG9wdGlvbnMgYXMgYW55KS5faCAmJiB0aGlzLm9ubHlBSGFzaENoYW5nZShjbGVhbmVkQXMpKSB7XG4gICAgICB0aGlzLmFzUGF0aCA9IGNsZWFuZWRBc1xuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlU3RhcnQnLCBhcylcbiAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdGhlIHJlc29sdmVkIGhyZWYgd2hlbiBvbmx5IGEgaGFzaCBjaGFuZ2U/XG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucylcbiAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGNsZWFuZWRBcylcbiAgICAgIHRoaXMubm90aWZ5KHRoaXMuY29tcG9uZW50c1t0aGlzLnJvdXRlXSlcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZUNvbXBsZXRlJywgYXMpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIFRoZSBidWlsZCBtYW5pZmVzdCBuZWVkcyB0byBiZSBsb2FkZWQgYmVmb3JlIGF1dG8tc3RhdGljIGR5bmFtaWMgcGFnZXNcbiAgICAvLyBnZXQgdGhlaXIgcXVlcnkgcGFyYW1ldGVycyB0byBhbGxvdyBlbnN1cmluZyB0aGV5IGNhbiBiZSBwYXJzZWQgcHJvcGVybHlcbiAgICAvLyB3aGVuIHJld3JpdHRlbiB0b1xuICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KClcbiAgICBjb25zdCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzIH0gPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIucHJvbWlzZWRCdWlsZE1hbmlmZXN0XG5cbiAgICBsZXQgcGFyc2VkID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG5cbiAgICBsZXQgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHBhcnNlZFxuXG4gICAgcGFyc2VkID0gdGhpcy5fcmVzb2x2ZUhyZWYocGFyc2VkLCBwYWdlcykgYXMgdHlwZW9mIHBhcnNlZFxuXG4gICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lXG4gICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgfVxuXG4gICAgLy8gdXJsIGFuZCBhcyBzaG91bGQgYWx3YXlzIGJlIHByZWZpeGVkIHdpdGggYmFzZVBhdGggYnkgdGhpc1xuICAgIC8vIHBvaW50IGJ5IGVpdGhlciBuZXh0L2xpbmsgb3Igcm91dGVyLnB1c2gvcmVwbGFjZSBzbyBzdHJpcCB0aGVcbiAgICAvLyBiYXNlUGF0aCBmcm9tIHRoZSBwYXRobmFtZSB0byBtYXRjaCB0aGUgcGFnZXMgZGlyIDEtdG8tMVxuICAgIHBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgID8gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goZGVsQmFzZVBhdGgocGF0aG5hbWUpKVxuICAgICAgOiBwYXRobmFtZVxuXG4gICAgLy8gSWYgYXNrZWQgdG8gY2hhbmdlIHRoZSBjdXJyZW50IFVSTCB3ZSBzaG91bGQgcmVsb2FkIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAvLyAobm90IGxvY2F0aW9uLnJlbG9hZCgpIGJ1dCByZWxvYWQgZ2V0SW5pdGlhbFByb3BzIGFuZCBvdGhlciBOZXh0LmpzIHN0dWZmcylcbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gc2V0IHRoZSBtZXRob2QgPSByZXBsYWNlU3RhdGUgYWx3YXlzXG4gICAgLy8gYXMgdGhpcyBzaG91bGQgbm90IGdvIGludG8gdGhlIGhpc3RvcnkgKFRoYXQncyBob3cgYnJvd3NlcnMgd29yaylcbiAgICAvLyBXZSBzaG91bGQgY29tcGFyZSB0aGUgbmV3IGFzUGF0aCB0byB0aGUgY3VycmVudCBhc1BhdGgsIG5vdCB0aGUgdXJsXG4gICAgaWYgKCF0aGlzLnVybElzTmV3KGNsZWFuZWRBcykpIHtcbiAgICAgIG1ldGhvZCA9ICdyZXBsYWNlU3RhdGUnXG4gICAgfVxuXG4gICAgbGV0IHJvdXRlID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG4gICAgY29uc3QgeyBzaGFsbG93ID0gZmFsc2UgfSA9IG9wdGlvbnNcblxuICAgIC8vIHdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgYXMgdmFsdWUgdXNpbmcgcmV3cml0ZXMgZm9yIGR5bmFtaWMgU1NHXG4gICAgLy8gcGFnZXMgdG8gYWxsb3cgYnVpbGRpbmcgdGhlIGRhdGEgVVJMIGNvcnJlY3RseVxuICAgIGxldCByZXNvbHZlZEFzID0gYXNcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKSB7XG4gICAgICByZXNvbHZlZEFzID0gcmVzb2x2ZVJld3JpdGVzKFxuICAgICAgICBwYXJzZVJlbGF0aXZlVXJsKGFzKS5wYXRobmFtZSxcbiAgICAgICAgcGFnZXMsXG4gICAgICAgIGJhc2VQYXRoLFxuICAgICAgICByZXdyaXRlcyxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIChwOiBzdHJpbmcpID0+IHRoaXMuX3Jlc29sdmVIcmVmKHsgcGF0aG5hbWU6IHAgfSwgcGFnZXMpLnBhdGhuYW1lIVxuICAgICAgKVxuXG4gICAgICBpZiAocmVzb2x2ZWRBcyAhPT0gYXMpIHtcbiAgICAgICAgY29uc3QgcG90ZW50aWFsSHJlZiA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKFxuICAgICAgICAgIHRoaXMuX3Jlc29sdmVIcmVmKFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkLCB7IHBhdGhuYW1lOiByZXNvbHZlZEFzIH0pLFxuICAgICAgICAgICAgcGFnZXMsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICkucGF0aG5hbWUhXG4gICAgICAgIClcblxuICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgIGlmIChwYWdlcy5pbmNsdWRlcyhwb3RlbnRpYWxIcmVmKSkge1xuICAgICAgICAgIHJvdXRlID0gcG90ZW50aWFsSHJlZlxuICAgICAgICAgIHBhdGhuYW1lID0gcG90ZW50aWFsSHJlZlxuICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc29sdmVkQXMgPSBkZWxMb2NhbGUoZGVsQmFzZVBhdGgocmVzb2x2ZWRBcyksIHRoaXMubG9jYWxlKVxuXG4gICAgaWYgKGlzRHluYW1pY1JvdXRlKHJvdXRlKSkge1xuICAgICAgY29uc3QgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKHJlc29sdmVkQXMpXG4gICAgICBjb25zdCBhc1BhdGhuYW1lID0gcGFyc2VkQXMucGF0aG5hbWVcblxuICAgICAgY29uc3Qgcm91dGVSZWdleCA9IGdldFJvdXRlUmVnZXgocm91dGUpXG4gICAgICBjb25zdCByb3V0ZU1hdGNoID0gZ2V0Um91dGVNYXRjaGVyKHJvdXRlUmVnZXgpKGFzUGF0aG5hbWUpXG4gICAgICBjb25zdCBzaG91bGRJbnRlcnBvbGF0ZSA9IHJvdXRlID09PSBhc1BhdGhuYW1lXG4gICAgICBjb25zdCBpbnRlcnBvbGF0ZWRBcyA9IHNob3VsZEludGVycG9sYXRlXG4gICAgICAgID8gaW50ZXJwb2xhdGVBcyhyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpXG4gICAgICAgIDogKHt9IGFzIHsgcmVzdWx0OiB1bmRlZmluZWQ7IHBhcmFtczogdW5kZWZpbmVkIH0pXG5cbiAgICAgIGlmICghcm91dGVNYXRjaCB8fCAoc2hvdWxkSW50ZXJwb2xhdGUgJiYgIWludGVycG9sYXRlZEFzLnJlc3VsdCkpIHtcbiAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlUmVnZXguZ3JvdXBzKS5maWx0ZXIoXG4gICAgICAgICAgKHBhcmFtKSA9PiAhcXVlcnlbcGFyYW1dXG4gICAgICAgIClcblxuICAgICAgICBpZiAobWlzc2luZ1BhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgYCR7XG4gICAgICAgICAgICAgICAgc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgICAgID8gYEludGVycG9sYXRpbmcgaHJlZmBcbiAgICAgICAgICAgICAgICAgIDogYE1pc21hdGNoaW5nIFxcYGFzXFxgIGFuZCBcXGBocmVmXFxgYFxuICAgICAgICAgICAgICB9IGZhaWxlZCB0byBtYW51YWxseSBwcm92aWRlIGAgK1xuICAgICAgICAgICAgICAgIGB0aGUgcGFyYW1zOiAke21pc3NpbmdQYXJhbXMuam9pbihcbiAgICAgICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICAgICApfSBpbiB0aGUgXFxgaHJlZlxcYCdzIFxcYHF1ZXJ5XFxgYFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIChzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICA/IGBUaGUgcHJvdmlkZWQgXFxgaHJlZlxcYCAoJHt1cmx9KSB2YWx1ZSBpcyBtaXNzaW5nIHF1ZXJ5IHZhbHVlcyAoJHttaXNzaW5nUGFyYW1zLmpvaW4oXG4gICAgICAgICAgICAgICAgICAnLCAnXG4gICAgICAgICAgICAgICAgKX0pIHRvIGJlIGludGVycG9sYXRlZCBwcm9wZXJseS4gYFxuICAgICAgICAgICAgICA6IGBUaGUgcHJvdmlkZWQgXFxgYXNcXGAgdmFsdWUgKCR7YXNQYXRobmFtZX0pIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSBcXGBocmVmXFxgIHZhbHVlICgke3JvdXRlfSkuIGApICtcbiAgICAgICAgICAgICAgYFJlYWQgbW9yZTogaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvJHtcbiAgICAgICAgICAgICAgICBzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICAgICAgPyAnaHJlZi1pbnRlcnBvbGF0aW9uLWZhaWxlZCdcbiAgICAgICAgICAgICAgICAgIDogJ2luY29tcGF0aWJsZS1ocmVmLWFzJ1xuICAgICAgICAgICAgICB9YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzaG91bGRJbnRlcnBvbGF0ZSkge1xuICAgICAgICBhcyA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHBhcnNlZEFzLCB7XG4gICAgICAgICAgICBwYXRobmFtZTogaW50ZXJwb2xhdGVkQXMucmVzdWx0LFxuICAgICAgICAgICAgcXVlcnk6IG9taXRQYXJtc0Zyb21RdWVyeShxdWVyeSwgaW50ZXJwb2xhdGVkQXMucGFyYW1zISksXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWVyZ2UgcGFyYW1zIGludG8gYHF1ZXJ5YCwgb3ZlcndyaXRpbmcgYW55IHNwZWNpZmllZCBpbiBzZWFyY2hcbiAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgcm91dGVNYXRjaClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlU3RhcnQnLCBhcylcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyhcbiAgICAgICAgcm91dGUsXG4gICAgICAgIHBhdGhuYW1lLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgYXMsXG4gICAgICAgIHNoYWxsb3dcbiAgICAgIClcbiAgICAgIGxldCB7IGVycm9yLCBwcm9wcywgX19OX1NTRywgX19OX1NTUCB9ID0gcm91dGVJbmZvXG5cbiAgICAgIC8vIGhhbmRsZSByZWRpcmVjdCBvbiBjbGllbnQtdHJhbnNpdGlvblxuICAgICAgaWYgKFxuICAgICAgICAoX19OX1NTRyB8fCBfX05fU1NQKSAmJlxuICAgICAgICBwcm9wcyAmJlxuICAgICAgICAocHJvcHMgYXMgYW55KS5wYWdlUHJvcHMgJiZcbiAgICAgICAgKHByb3BzIGFzIGFueSkucGFnZVByb3BzLl9fTl9SRURJUkVDVFxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gKHByb3BzIGFzIGFueSkucGFnZVByb3BzLl9fTl9SRURJUkVDVFxuXG4gICAgICAgIC8vIGNoZWNrIGlmIGRlc3RpbmF0aW9uIGlzIGludGVybmFsIChyZXNvbHZlcyB0byBhIHBhZ2UpIGFuZCBhdHRlbXB0XG4gICAgICAgIC8vIGNsaWVudC1uYXZpZ2F0aW9uIGlmIGl0IGlzIGZhbGxpbmcgYmFjayB0byBoYXJkIG5hdmlnYXRpb24gaWZcbiAgICAgICAgLy8gaXQncyBub3RcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZEhyZWYgPSBwYXJzZVJlbGF0aXZlVXJsKGRlc3RpbmF0aW9uKVxuICAgICAgICAgIHRoaXMuX3Jlc29sdmVIcmVmKHBhcnNlZEhyZWYsIHBhZ2VzKVxuXG4gICAgICAgICAgaWYgKHBhZ2VzLmluY2x1ZGVzKHBhcnNlZEhyZWYucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UobWV0aG9kLCBkZXN0aW5hdGlvbiwgZGVzdGluYXRpb24sIG9wdGlvbnMpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkZXN0aW5hdGlvblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge30pXG4gICAgICB9XG5cbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnYmVmb3JlSGlzdG9yeUNoYW5nZScsIGFzKVxuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICB1cmwsXG4gICAgICAgIGFkZExvY2FsZShhcywgb3B0aW9ucy5sb2NhbGUsIHRoaXMuZGVmYXVsdExvY2FsZSksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIClcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgYXBwQ29tcDogYW55ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudFxuICAgICAgICA7KHdpbmRvdyBhcyBhbnkpLm5leHQuaXNQcmVyZW5kZXJlZCA9XG4gICAgICAgICAgYXBwQ29tcC5nZXRJbml0aWFsUHJvcHMgPT09IGFwcENvbXAub3JpZ0dldEluaXRpYWxQcm9wcyAmJlxuICAgICAgICAgICEocm91dGVJbmZvLkNvbXBvbmVudCBhcyBhbnkpLmdldEluaXRpYWxQcm9wc1xuICAgICAgfVxuXG4gICAgICBhd2FpdCB0aGlzLnNldChyb3V0ZSwgcGF0aG5hbWUhLCBxdWVyeSwgY2xlYW5lZEFzLCByb3V0ZUluZm8pLmNhdGNoKFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIGlmIChlLmNhbmNlbGxlZCkgZXJyb3IgPSBlcnJvciB8fCBlXG4gICAgICAgICAgZWxzZSB0aHJvdyBlXG4gICAgICAgIH1cbiAgICAgIClcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVycm9yLCBjbGVhbmVkQXMpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiAmJiAnX05fWCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygob3B0aW9ucyBhcyBhbnkpLl9OX1gsIChvcHRpb25zIGFzIGFueSkuX05fWSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUNvbXBsZXRlJywgYXMpXG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIGNoYW5nZVN0YXRlKFxuICAgIG1ldGhvZDogSGlzdG9yeU1ldGhvZCxcbiAgICB1cmw6IHN0cmluZyxcbiAgICBhczogc3RyaW5nLFxuICAgIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zID0ge31cbiAgKTogdm9pZCB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuYClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnlbbWV0aG9kXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgV2FybmluZzogd2luZG93Lmhpc3RvcnkuJHttZXRob2R9IGlzIG5vdCBhdmFpbGFibGVgKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWV0aG9kICE9PSAncHVzaFN0YXRlJyB8fCBnZXRVUkwoKSAhPT0gYXMpIHtcbiAgICAgIHRoaXMuX3NoYWxsb3cgPSBvcHRpb25zLnNoYWxsb3dcbiAgICAgIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0oXG4gICAgICAgIHtcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgYXMsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBfX046IHRydWUsXG4gICAgICAgIH0gYXMgSGlzdG9yeVN0YXRlLFxuICAgICAgICAvLyBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBpZ25vcmVzIHRoaXMgcGFyYW1ldGVyLCBhbHRob3VnaCB0aGV5IG1heSB1c2UgaXQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgLy8gUGFzc2luZyB0aGUgZW1wdHkgc3RyaW5nIGhlcmUgc2hvdWxkIGJlIHNhZmUgYWdhaW5zdCBmdXR1cmUgY2hhbmdlcyB0byB0aGUgbWV0aG9kLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGlzdG9yeS9yZXBsYWNlU3RhdGVcbiAgICAgICAgJycsXG4gICAgICAgIGFzXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgaGFuZGxlUm91dGVJbmZvRXJyb3IoXG4gICAgZXJyOiBFcnJvciAmIHsgY29kZTogYW55OyBjYW5jZWxsZWQ6IGJvb2xlYW4gfSxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgICBhczogc3RyaW5nLFxuICAgIGxvYWRFcnJvckZhaWw/OiBib29sZWFuXG4gICk6IFByb21pc2U8UHJpdmF0ZVJvdXRlSW5mbz4ge1xuICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAvLyBidWJibGUgdXAgY2FuY2VsbGF0aW9uIGVycm9yc1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgaWYgKFBBR0VfTE9BRF9FUlJPUiBpbiBlcnIgfHwgbG9hZEVycm9yRmFpbCkge1xuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyLCBhcylcblxuICAgICAgLy8gSWYgd2UgY2FuJ3QgbG9hZCB0aGUgcGFnZSBpdCBjb3VsZCBiZSBvbmUgb2YgZm9sbG93aW5nIHJlYXNvbnNcbiAgICAgIC8vICAxLiBQYWdlIGRvZXNuJ3QgZXhpc3RzXG4gICAgICAvLyAgMi4gUGFnZSBkb2VzIGV4aXN0IGluIGEgZGlmZmVyZW50IHpvbmVcbiAgICAgIC8vICAzLiBJbnRlcm5hbCBlcnJvciB3aGlsZSBsb2FkaW5nIHRoZSBwYWdlXG5cbiAgICAgIC8vIFNvLCBkb2luZyBhIGhhcmQgcmVsb2FkIGlzIHRoZSBwcm9wZXIgd2F5IHRvIGRlYWwgd2l0aCB0aGlzLlxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhc1xuXG4gICAgICAvLyBDaGFuZ2luZyB0aGUgVVJMIGRvZXNuJ3QgYmxvY2sgZXhlY3V0aW5nIHRoZSBjdXJyZW50IGNvZGUgcGF0aC5cbiAgICAgIC8vIFNvIGxldCdzIHRocm93IGEgY2FuY2VsbGF0aW9uIGVycm9yIHN0b3AgdGhlIHJvdXRpbmcgbG9naWMuXG4gICAgICB0aHJvdyBidWlsZENhbmNlbGxhdGlvbkVycm9yKClcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgbGV0IENvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICAgICAgbGV0IHN0eWxlU2hlZXRzOiBTdHlsZVNoZWV0VHVwbGVbXVxuICAgICAgbGV0IHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkXG4gICAgICBjb25zdCBzc2c0MDQgPSBlcnIubWVzc2FnZSA9PT0gU1NHX0RBVEFfTk9UX0ZPVU5EX0VSUk9SXG5cbiAgICAgIGlmIChzc2c0MDQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgbW9kOiBhbnlcbiAgICAgICAgICA7KHsgcGFnZTogQ29tcG9uZW50LCBzdHlsZVNoZWV0cywgbW9kIH0gPSBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KFxuICAgICAgICAgICAgJy80MDQnXG4gICAgICAgICAgKSlcblxuICAgICAgICAgIC8vIFRPRE86IHNob3VsZCB3ZSB0b2xlcmF0ZSB0aGVzZSBwcm9wcyBtaXNzaW5nIGFuZCBzdGlsbCByZW5kZXIgdGhlXG4gICAgICAgICAgLy8gcGFnZSBpbnN0ZWFkIG9mIGZhbGxpbmcgYmFjayB0byBfZXJyb3I/XG4gICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19OX1NTRykge1xuICAgICAgICAgICAgcHJvcHMgPSBhd2FpdCB0aGlzLl9nZXRTdGF0aWNEYXRhKFxuICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoJy80MDQnLCAnLzQwNCcsIHRydWUsIHRoaXMubG9jYWxlKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAgIC8vIG5vbi1mYXRhbCBmYWxsYmFjayB0byBfZXJyb3JcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBDb21wb25lbnQhID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygc3R5bGVTaGVldHMhID09PSAndW5kZWZpbmVkJ1xuICAgICAgKSB7XG4gICAgICAgIDsoeyBwYWdlOiBDb21wb25lbnQsIHN0eWxlU2hlZXRzIH0gPSBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KFxuICAgICAgICAgICcvX2Vycm9yJ1xuICAgICAgICApKVxuICAgICAgfVxuXG4gICAgICBjb25zdCByb3V0ZUluZm86IFByaXZhdGVSb3V0ZUluZm8gPSB7XG4gICAgICAgIHByb3BzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIHN0eWxlU2hlZXRzLFxuICAgICAgICBlcnI6IHNzZzQwNCA/IHVuZGVmaW5lZCA6IGVycixcbiAgICAgICAgZXJyb3I6IHNzZzQwNCA/IHVuZGVmaW5lZCA6IGVycixcbiAgICAgIH1cblxuICAgICAgaWYgKCFyb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIHtcbiAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgfSBhcyBhbnkpXG4gICAgICAgIH0gY2F0Y2ggKGdpcEVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6ICcsIGdpcEVycilcbiAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSB7fVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByb3V0ZUluZm9cbiAgICB9IGNhdGNoIChyb3V0ZUluZm9FcnIpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKHJvdXRlSW5mb0VyciwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgdHJ1ZSlcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRSb3V0ZUluZm8oXG4gICAgcm91dGU6IHN0cmluZyxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBhbnksXG4gICAgYXM6IHN0cmluZyxcbiAgICBzaGFsbG93OiBib29sZWFuID0gZmFsc2VcbiAgKTogUHJvbWlzZTxQcml2YXRlUm91dGVJbmZvPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhY2hlZFJvdXRlSW5mbyA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV1cblxuICAgICAgaWYgKHNoYWxsb3cgJiYgY2FjaGVkUm91dGVJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRSb3V0ZUluZm9cbiAgICAgIH1cblxuICAgICAgY29uc3Qgcm91dGVJbmZvOiBQcml2YXRlUm91dGVJbmZvID0gY2FjaGVkUm91dGVJbmZvXG4gICAgICAgID8gY2FjaGVkUm91dGVJbmZvXG4gICAgICAgIDogYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChyb3V0ZSkudGhlbigocmVzKSA9PiAoe1xuICAgICAgICAgICAgQ29tcG9uZW50OiByZXMucGFnZSxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzOiByZXMuc3R5bGVTaGVldHMsXG4gICAgICAgICAgICBfX05fU1NHOiByZXMubW9kLl9fTl9TU0csXG4gICAgICAgICAgICBfX05fU1NQOiByZXMubW9kLl9fTl9TU1AsXG4gICAgICAgICAgfSkpXG5cbiAgICAgIGNvbnN0IHsgQ29tcG9uZW50LCBfX05fU1NHLCBfX05fU1NQIH0gPSByb3V0ZUluZm9cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgfSA9IHJlcXVpcmUoJ3JlYWN0LWlzJylcbiAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFwiJHtwYXRobmFtZX1cImBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGFIcmVmOiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICAgICAgaWYgKF9fTl9TU0cgfHwgX19OX1NTUCkge1xuICAgICAgICBkYXRhSHJlZiA9IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZihcbiAgICAgICAgICBmb3JtYXRXaXRoVmFsaWRhdGlvbih7IHBhdGhuYW1lLCBxdWVyeSB9KSxcbiAgICAgICAgICBkZWxCYXNlUGF0aChhcyksXG4gICAgICAgICAgX19OX1NTRyxcbiAgICAgICAgICB0aGlzLmxvY2FsZVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb3BzID0gYXdhaXQgdGhpcy5fZ2V0RGF0YTxQcml2YXRlUm91dGVJbmZvPigoKSA9PlxuICAgICAgICBfX05fU1NHXG4gICAgICAgICAgPyB0aGlzLl9nZXRTdGF0aWNEYXRhKGRhdGFIcmVmISlcbiAgICAgICAgICA6IF9fTl9TU1BcbiAgICAgICAgICA/IHRoaXMuX2dldFNlcnZlckRhdGEoZGF0YUhyZWYhKVxuICAgICAgICAgIDogdGhpcy5nZXRJbml0aWFsUHJvcHMoXG4gICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgLy8gd2UgcHJvdmlkZSBBcHBUcmVlIGxhdGVyIHNvIHRoaXMgbmVlZHMgdG8gYmUgYGFueWBcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgICAgICAgIH0gYXMgYW55XG4gICAgICAgICAgICApXG4gICAgICApXG5cbiAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzXG4gICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0gcm91dGVJbmZvXG4gICAgICByZXR1cm4gcm91dGVJbmZvXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcihlcnIsIHBhdGhuYW1lLCBxdWVyeSwgYXMpXG4gICAgfVxuICB9XG5cbiAgc2V0KFxuICAgIHJvdXRlOiBzdHJpbmcsXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICBkYXRhOiBQcml2YXRlUm91dGVJbmZvXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuaXNGYWxsYmFjayA9IGZhbHNlXG5cbiAgICB0aGlzLnJvdXRlID0gcm91dGVcbiAgICB0aGlzLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlcbiAgICB0aGlzLmFzUGF0aCA9IGFzXG4gICAgcmV0dXJuIHRoaXMubm90aWZ5KGRhdGEpXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgcmVwbGFjaW5nIHJvdXRlciBzdGF0ZVxuICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcbiAgICovXG4gIGJlZm9yZVBvcFN0YXRlKGNiOiBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYnBzID0gY2JcbiAgfVxuXG4gIG9ubHlBSGFzaENoYW5nZShhczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmFzUGF0aCkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdCgnIycpXG4gICAgY29uc3QgW25ld1VybE5vSGFzaCwgbmV3SGFzaF0gPSBhcy5zcGxpdCgnIycpXG5cbiAgICAvLyBNYWtlcyBzdXJlIHdlIHNjcm9sbCB0byB0aGUgcHJvdmlkZWQgaGFzaCBpZiB0aGUgdXJsL2hhc2ggYXJlIHRoZSBzYW1lXG4gICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXJscyBhcmUgY2hhbmdlLCB0aGVyZSdzIG1vcmUgdGhhbiBhIGhhc2ggY2hhbmdlXG4gICAgaWYgKG9sZFVybE5vSGFzaCAhPT0gbmV3VXJsTm9IYXNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAvLyBUaGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBoYW5kbGUgYm90aCB0aGUgZW50ZXIgYW5kXG4gICAgLy8gbGVhdmUgaGFzaCA9PT0gJycgY2FzZXMuIFRoZSBpZGVudGl0eSBjYXNlIGZhbGxzIHRocm91Z2hcbiAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgIHJldHVybiBvbGRIYXNoICE9PSBuZXdIYXNoXG4gIH1cblxuICBzY3JvbGxUb0hhc2goYXM6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IFssIGhhc2hdID0gYXMuc3BsaXQoJyMnKVxuICAgIC8vIFNjcm9sbCB0byB0b3AgaWYgdGhlIGhhc2ggaXMganVzdCBgI2Agd2l0aCBubyB2YWx1ZVxuICAgIGlmIChoYXNoID09PSAnJykge1xuICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBGaXJzdCB3ZSBjaGVjayBpZiB0aGUgZWxlbWVudCBieSBpZCBpcyBmb3VuZFxuICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKVxuICAgIGlmIChpZEVsKSB7XG4gICAgICBpZEVsLnNjcm9sbEludG9WaWV3KClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIG5vIGVsZW1lbnQgd2l0aCB0aGUgaWQsIHdlIGNoZWNrIHRoZSBgbmFtZWAgcHJvcGVydHlcbiAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICBjb25zdCBuYW1lRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShoYXNoKVswXVxuICAgIGlmIChuYW1lRWwpIHtcbiAgICAgIG5hbWVFbC5zY3JvbGxJbnRvVmlldygpXG4gICAgfVxuICB9XG5cbiAgdXJsSXNOZXcoYXNQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hc1BhdGggIT09IGFzUGF0aFxuICB9XG5cbiAgX3Jlc29sdmVIcmVmKHBhcnNlZEhyZWY6IFVybE9iamVjdCwgcGFnZXM6IHN0cmluZ1tdLCBhcHBseUJhc2VQYXRoID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgcGF0aG5hbWUgfSA9IHBhcnNlZEhyZWZcbiAgICBjb25zdCBjbGVhblBhdGhuYW1lID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goXG4gICAgICBkZW5vcm1hbGl6ZVBhZ2VQYXRoKGFwcGx5QmFzZVBhdGggPyBkZWxCYXNlUGF0aChwYXRobmFtZSEpIDogcGF0aG5hbWUhKVxuICAgIClcblxuICAgIGlmIChjbGVhblBhdGhuYW1lID09PSAnLzQwNCcgfHwgY2xlYW5QYXRobmFtZSA9PT0gJy9fZXJyb3InKSB7XG4gICAgICByZXR1cm4gcGFyc2VkSHJlZlxuICAgIH1cblxuICAgIC8vIGhhbmRsZSByZXNvbHZpbmcgaHJlZiBmb3IgZHluYW1pYyByb3V0ZXNcbiAgICBpZiAoIXBhZ2VzLmluY2x1ZGVzKGNsZWFuUGF0aG5hbWUhKSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgcGFnZXMuc29tZSgocGFnZSkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaXNEeW5hbWljUm91dGUocGFnZSkgJiZcbiAgICAgICAgICBnZXRSb3V0ZVJlZ2V4KHBhZ2UpLnJlLnRlc3QoY2xlYW5QYXRobmFtZSEpXG4gICAgICAgICkge1xuICAgICAgICAgIHBhcnNlZEhyZWYucGF0aG5hbWUgPSBhcHBseUJhc2VQYXRoID8gYWRkQmFzZVBhdGgocGFnZSkgOiBwYWdlXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZEhyZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVmZXRjaCBwYWdlIGNvZGUsIHlvdSBtYXkgd2FpdCBmb3IgdGhlIGRhdGEgZHVyaW5nIHBhZ2UgcmVuZGVyaW5nLlxuICAgKiBUaGlzIGZlYXR1cmUgb25seSB3b3JrcyBpbiBwcm9kdWN0aW9uIVxuICAgKiBAcGFyYW0gdXJsIHRoZSBocmVmIG9mIHByZWZldGNoZWQgcGFnZVxuICAgKiBAcGFyYW0gYXNQYXRoIHRoZSBhcyBwYXRoIG9mIHRoZSBwcmVmZXRjaGVkIHBhZ2VcbiAgICovXG4gIGFzeW5jIHByZWZldGNoKFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzUGF0aDogc3RyaW5nID0gdXJsLFxuICAgIG9wdGlvbnM6IFByZWZldGNoT3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCBwYXJzZWQgPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcblxuICAgIGxldCB7IHBhdGhuYW1lIH0gPSBwYXJzZWRcblxuICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KClcblxuICAgIHBhcnNlZCA9IHRoaXMuX3Jlc29sdmVIcmVmKHBhcnNlZCwgcGFnZXMpIGFzIHR5cGVvZiBwYXJzZWRcblxuICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XG4gICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZVxuICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgIH1cblxuICAgIC8vIFByZWZldGNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgb24tZGVtYW5kLWVudHJpZXNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnBhZ2VMb2FkZXIucHJlZmV0Y2hEYXRhKFxuICAgICAgICB1cmwsXG4gICAgICAgIGFzUGF0aCxcbiAgICAgICAgdGhpcy5sb2NhbGUsXG4gICAgICAgIHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgKSxcbiAgICAgIHRoaXMucGFnZUxvYWRlcltvcHRpb25zLnByaW9yaXR5ID8gJ2xvYWRQYWdlJyA6ICdwcmVmZXRjaCddKHJvdXRlKSxcbiAgICBdKVxuICB9XG5cbiAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGU6IHN0cmluZyk6IFByb21pc2U8R29vZFBhZ2VDYWNoZT4ge1xuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNhbmNlbCA9ICh0aGlzLmNsYyA9ICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWVcbiAgICB9KVxuXG4gICAgY29uc3QgY29tcG9uZW50UmVzdWx0ID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmxvYWRQYWdlKHJvdXRlKVxuXG4gICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcihcbiAgICAgICAgYEFib3J0IGZldGNoaW5nIGNvbXBvbmVudCBmb3Igcm91dGU6IFwiJHtyb3V0ZX1cImBcbiAgICAgIClcbiAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuXG4gICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiBjb21wb25lbnRSZXN1bHRcbiAgfVxuXG4gIF9nZXREYXRhPFQ+KGZuOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG4gICAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZVxuICAgIH1cbiAgICB0aGlzLmNsYyA9IGNhbmNlbFxuICAgIHJldHVybiBmbigpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgIGNvbnN0IGVycjogYW55ID0gbmV3IEVycm9yKCdMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkJylcbiAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRTdGF0aWNEYXRhKGRhdGFIcmVmOiBzdHJpbmcpOiBQcm9taXNlPG9iamVjdD4ge1xuICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgfSA9IG5ldyBVUkwoZGF0YUhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMuc2RjW2NhY2hlS2V5XSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnNkY1tjYWNoZUtleV0pXG4gICAgfVxuICAgIHJldHVybiBmZXRjaE5leHREYXRhKGRhdGFIcmVmLCB0aGlzLmlzU3NyKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICB0aGlzLnNkY1tjYWNoZUtleV0gPSBkYXRhXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0pXG4gIH1cblxuICBfZ2V0U2VydmVyRGF0YShkYXRhSHJlZjogc3RyaW5nKTogUHJvbWlzZTxvYmplY3Q+IHtcbiAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZiwgdGhpcy5pc1NzcilcbiAgfVxuXG4gIGdldEluaXRpYWxQcm9wcyhcbiAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGUsXG4gICAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCB7IENvbXBvbmVudDogQXBwIH0gPSB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ11cbiAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHAgYXMgQXBwQ29tcG9uZW50KVxuICAgIGN0eC5BcHBUcmVlID0gQXBwVHJlZVxuICAgIHJldHVybiBsb2FkR2V0SW5pdGlhbFByb3BzPEFwcENvbnRleHRUeXBlPFJvdXRlcj4+KEFwcCwge1xuICAgICAgQXBwVHJlZSxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgIGN0eCxcbiAgICB9KVxuICB9XG5cbiAgYWJvcnRDb21wb25lbnRMb2FkKGFzOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jbGMpIHtcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSwgYXMpXG4gICAgICB0aGlzLmNsYygpXG4gICAgICB0aGlzLmNsYyA9IG51bGxcbiAgICB9XG4gIH1cblxuICBub3RpZnkoZGF0YTogUHJpdmF0ZVJvdXRlSW5mbyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnN1YihkYXRhLCB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10uQ29tcG9uZW50IGFzIEFwcENvbXBvbmVudClcbiAgfVxufVxuIiwiLy8gZXNjYXBlIGRlbGltaXRlcnMgdXNlZCBieSBwYXRoLXRvLXJlZ2V4cFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXNjYXBlUGF0aERlbGltaXRlcnMoc2VnbWVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHNlZ21lbnQucmVwbGFjZSgvWy8jP10vZywgKGNoYXI6IHN0cmluZykgPT4gZW5jb2RlVVJJQ29tcG9uZW50KGNoYXIpKVxufVxuIiwiLy8gRm9ybWF0IGZ1bmN0aW9uIG1vZGlmaWVkIGZyb20gbm9kZWpzXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCAqIGFzIHF1ZXJ5c3RyaW5nIGZyb20gJy4vcXVlcnlzdHJpbmcnXG5cbmNvbnN0IHNsYXNoZWRQcm90b2NvbHMgPSAvaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS9cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFVybCh1cmxPYmo6IFVybE9iamVjdCkge1xuICBsZXQgeyBhdXRoLCBob3N0bmFtZSB9ID0gdXJsT2JqXG4gIGxldCBwcm90b2NvbCA9IHVybE9iai5wcm90b2NvbCB8fCAnJ1xuICBsZXQgcGF0aG5hbWUgPSB1cmxPYmoucGF0aG5hbWUgfHwgJydcbiAgbGV0IGhhc2ggPSB1cmxPYmouaGFzaCB8fCAnJ1xuICBsZXQgcXVlcnkgPSB1cmxPYmoucXVlcnkgfHwgJydcbiAgbGV0IGhvc3Q6IHN0cmluZyB8IGZhbHNlID0gZmFsc2VcblxuICBhdXRoID0gYXV0aCA/IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKS5yZXBsYWNlKC8lM0EvaSwgJzonKSArICdAJyA6ICcnXG5cbiAgaWYgKHVybE9iai5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB1cmxPYmouaG9zdFxuICB9IGVsc2UgaWYgKGhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAofmhvc3RuYW1lLmluZGV4T2YoJzonKSA/IGBbJHtob3N0bmFtZX1dYCA6IGhvc3RuYW1lKVxuICAgIGlmICh1cmxPYmoucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB1cmxPYmoucG9ydFxuICAgIH1cbiAgfVxuXG4gIGlmIChxdWVyeSAmJiB0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnKSB7XG4gICAgcXVlcnkgPSBTdHJpbmcocXVlcnlzdHJpbmcudXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhxdWVyeSBhcyBQYXJzZWRVcmxRdWVyeSkpXG4gIH1cblxuICBsZXQgc2VhcmNoID0gdXJsT2JqLnNlYXJjaCB8fCAocXVlcnkgJiYgYD8ke3F1ZXJ5fWApIHx8ICcnXG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonXG5cbiAgaWYgKFxuICAgIHVybE9iai5zbGFzaGVzIHx8XG4gICAgKCghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29scy50ZXN0KHByb3RvY29sKSkgJiYgaG9zdCAhPT0gZmFsc2UpXG4gICkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpXG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lWzBdICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWVcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJ1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaFswXSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaFxuICBpZiAoc2VhcmNoICYmIHNlYXJjaFswXSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2hcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZW5jb2RlVVJJQ29tcG9uZW50KVxuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKVxuXG4gIHJldHVybiBgJHtwcm90b2NvbH0ke2hvc3R9JHtwYXRobmFtZX0ke3NlYXJjaH0ke2hhc2h9YFxufVxuIiwiLy8gSWRlbnRpZnkgL1twYXJhbV0vIGluIHJvdXRlIHN0cmluZ1xuY29uc3QgVEVTVF9ST1VURSA9IC9cXC9cXFtbXi9dKz9cXF0oPz1cXC98JCkvXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0R5bmFtaWNSb3V0ZShyb3V0ZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBURVNUX1JPVVRFLnRlc3Qocm91dGUpXG59XG4iLCJpbXBvcnQgeyBnZXRMb2NhdGlvbk9yaWdpbiB9IGZyb20gJy4uLy4uL3V0aWxzJ1xuaW1wb3J0IHsgc2VhcmNoUGFyYW1zVG9VcmxRdWVyeSB9IGZyb20gJy4vcXVlcnlzdHJpbmcnXG5cbmNvbnN0IERVTU1ZX0JBU0UgPSBuZXcgVVJMKFxuICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICdodHRwOi8vbicgOiBnZXRMb2NhdGlvbk9yaWdpbigpXG4pXG5cbi8qKlxuICogUGFyc2VzIHBhdGgtcmVsYXRpdmUgdXJscyAoZS5nLiBgL2hlbGxvL3dvcmxkP2Zvbz1iYXJgKS4gSWYgdXJsIGlzbid0IHBhdGgtcmVsYXRpdmVcbiAqIChlLmcuIGAuL2hlbGxvYCkgdGhlbiBhdCBsZWFzdCBiYXNlIG11c3QgYmUuXG4gKiBBYnNvbHV0ZSB1cmxzIGFyZSByZWplY3RlZCB3aXRoIG9uZSBleGNlcHRpb24sIGluIHRoZSBicm93c2VyLCBhYnNvbHV0ZSB1cmxzIHRoYXQgYXJlIG9uXG4gKiB0aGUgY3VycmVudCBvcmlnaW4gd2lsbCBiZSBwYXJzZWQgYXMgcmVsYXRpdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmVsYXRpdmVVcmwodXJsOiBzdHJpbmcsIGJhc2U/OiBzdHJpbmcpIHtcbiAgY29uc3QgcmVzb2x2ZWRCYXNlID0gYmFzZSA/IG5ldyBVUkwoYmFzZSwgRFVNTVlfQkFTRSkgOiBEVU1NWV9CQVNFXG4gIGNvbnN0IHtcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2hQYXJhbXMsXG4gICAgc2VhcmNoLFxuICAgIGhhc2gsXG4gICAgaHJlZixcbiAgICBvcmlnaW4sXG4gICAgcHJvdG9jb2wsXG4gIH0gPSBuZXcgVVJMKHVybCwgcmVzb2x2ZWRCYXNlKVxuICBpZiAoXG4gICAgb3JpZ2luICE9PSBEVU1NWV9CQVNFLm9yaWdpbiB8fFxuICAgIChwcm90b2NvbCAhPT0gJ2h0dHA6JyAmJiBwcm90b2NvbCAhPT0gJ2h0dHBzOicpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50OiBpbnZhbGlkIHJlbGF0aXZlIFVSTCcpXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBxdWVyeTogc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShzZWFyY2hQYXJhbXMpLFxuICAgIHNlYXJjaCxcbiAgICBoYXNoLFxuICAgIGhyZWY6IGhyZWYuc2xpY2UoRFVNTVlfQkFTRS5vcmlnaW4ubGVuZ3RoKSxcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgcGF0aFRvUmVnZXhwIGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9wYXRoLXRvLXJlZ2V4cCdcblxuZXhwb3J0IHsgcGF0aFRvUmVnZXhwIH1cblxuZXhwb3J0IGNvbnN0IG1hdGNoZXJPcHRpb25zOiBwYXRoVG9SZWdleHAuVG9rZW5zVG9SZWdleHBPcHRpb25zICZcbiAgcGF0aFRvUmVnZXhwLlBhcnNlT3B0aW9ucyA9IHtcbiAgc2Vuc2l0aXZlOiBmYWxzZSxcbiAgZGVsaW1pdGVyOiAnLycsXG59XG5cbmV4cG9ydCBjb25zdCBjdXN0b21Sb3V0ZU1hdGNoZXJPcHRpb25zOiBwYXRoVG9SZWdleHAuVG9rZW5zVG9SZWdleHBPcHRpb25zICZcbiAgcGF0aFRvUmVnZXhwLlBhcnNlT3B0aW9ucyA9IHtcbiAgLi4ubWF0Y2hlck9wdGlvbnMsXG4gIHN0cmljdDogdHJ1ZSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGN1c3RvbVJvdXRlID0gZmFsc2UpID0+IHtcbiAgcmV0dXJuIChwYXRoOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBrZXlzOiBwYXRoVG9SZWdleHAuS2V5W10gPSBbXVxuICAgIGNvbnN0IG1hdGNoZXJSZWdleCA9IHBhdGhUb1JlZ2V4cC5wYXRoVG9SZWdleHAoXG4gICAgICBwYXRoLFxuICAgICAga2V5cyxcbiAgICAgIGN1c3RvbVJvdXRlID8gY3VzdG9tUm91dGVNYXRjaGVyT3B0aW9ucyA6IG1hdGNoZXJPcHRpb25zXG4gICAgKVxuICAgIGNvbnN0IG1hdGNoZXIgPSBwYXRoVG9SZWdleHAucmVnZXhwVG9GdW5jdGlvbihtYXRjaGVyUmVnZXgsIGtleXMpXG5cbiAgICByZXR1cm4gKHBhdGhuYW1lOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkLCBwYXJhbXM/OiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IHBhdGhuYW1lID09IG51bGwgPyBmYWxzZSA6IG1hdGNoZXIocGF0aG5hbWUpXG4gICAgICBpZiAoIXJlcykge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKGN1c3RvbVJvdXRlKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAvLyB1bm5hbWVkIHBhcmFtcyBzaG91bGQgYmUgcmVtb3ZlZCBhcyB0aGV5XG4gICAgICAgICAgLy8gYXJlIG5vdCBhbGxvd2VkIHRvIGJlIHVzZWQgaW4gdGhlIGRlc3RpbmF0aW9uXG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkubmFtZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGRlbGV0ZSAocmVzLnBhcmFtcyBhcyBhbnkpW2tleS5uYW1lXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyAuLi5wYXJhbXMsIC4uLnJlcy5wYXJhbXMgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB7IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkgfSBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgcGFyc2VSZWxhdGl2ZVVybCB9IGZyb20gJy4vcGFyc2UtcmVsYXRpdmUtdXJsJ1xuaW1wb3J0ICogYXMgcGF0aFRvUmVnZXhwIGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9wYXRoLXRvLXJlZ2V4cCdcblxudHlwZSBQYXJhbXMgPSB7IFtwYXJhbTogc3RyaW5nXTogYW55IH1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJlcGFyZURlc3RpbmF0aW9uKFxuICBkZXN0aW5hdGlvbjogc3RyaW5nLFxuICBwYXJhbXM6IFBhcmFtcyxcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICBhcHBlbmRQYXJhbXNUb1F1ZXJ5OiBib29sZWFuLFxuICBiYXNlUGF0aDogc3RyaW5nXG4pIHtcbiAgbGV0IHBhcnNlZERlc3RpbmF0aW9uOiB7XG4gICAgcXVlcnk/OiBQYXJzZWRVcmxRdWVyeVxuICAgIHByb3RvY29sPzogc3RyaW5nXG4gICAgaG9zdG5hbWU/OiBzdHJpbmdcbiAgICBwb3J0Pzogc3RyaW5nXG4gIH0gJiBSZXR1cm5UeXBlPHR5cGVvZiBwYXJzZVJlbGF0aXZlVXJsPiA9IHt9IGFzIGFueVxuXG4gIGlmIChkZXN0aW5hdGlvbi5zdGFydHNXaXRoKCcvJykpIHtcbiAgICBwYXJzZWREZXN0aW5hdGlvbiA9IHBhcnNlUmVsYXRpdmVVcmwoZGVzdGluYXRpb24pXG4gIH0gZWxzZSB7XG4gICAgY29uc3Qge1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBzZWFyY2hQYXJhbXMsXG4gICAgICBoYXNoLFxuICAgICAgaG9zdG5hbWUsXG4gICAgICBwb3J0LFxuICAgICAgcHJvdG9jb2wsXG4gICAgICBzZWFyY2gsXG4gICAgICBocmVmLFxuICAgIH0gPSBuZXcgVVJMKGRlc3RpbmF0aW9uKVxuXG4gICAgcGFyc2VkRGVzdGluYXRpb24gPSB7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIHF1ZXJ5OiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KHNlYXJjaFBhcmFtcyksXG4gICAgICBoYXNoLFxuICAgICAgcHJvdG9jb2wsXG4gICAgICBob3N0bmFtZSxcbiAgICAgIHBvcnQsXG4gICAgICBzZWFyY2gsXG4gICAgICBocmVmLFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRlc3RRdWVyeSA9IHBhcnNlZERlc3RpbmF0aW9uLnF1ZXJ5XG4gIGNvbnN0IGRlc3RQYXRoID0gYCR7cGFyc2VkRGVzdGluYXRpb24ucGF0aG5hbWUhfSR7XG4gICAgcGFyc2VkRGVzdGluYXRpb24uaGFzaCB8fCAnJ1xuICB9YFxuICBjb25zdCBkZXN0UGF0aFBhcmFtS2V5czogcGF0aFRvUmVnZXhwLktleVtdID0gW11cbiAgcGF0aFRvUmVnZXhwLnBhdGhUb1JlZ2V4cChkZXN0UGF0aCwgZGVzdFBhdGhQYXJhbUtleXMpXG5cbiAgY29uc3QgZGVzdFBhdGhQYXJhbXMgPSBkZXN0UGF0aFBhcmFtS2V5cy5tYXAoKGtleSkgPT4ga2V5Lm5hbWUpXG5cbiAgbGV0IGRlc3RpbmF0aW9uQ29tcGlsZXIgPSBwYXRoVG9SZWdleHAuY29tcGlsZShcbiAgICBkZXN0UGF0aCxcbiAgICAvLyB3ZSBkb24ndCB2YWxpZGF0ZSB3aGlsZSBjb21waWxpbmcgdGhlIGRlc3RpbmF0aW9uIHNpbmNlIHdlIHNob3VsZFxuICAgIC8vIGhhdmUgYWxyZWFkeSB2YWxpZGF0ZWQgYmVmb3JlIHdlIGdvdCB0byB0aGlzIHBvaW50IGFuZCB2YWxpZGF0aW5nXG4gICAgLy8gYnJlYWtzIGNvbXBpbGluZyBkZXN0aW5hdGlvbnMgd2l0aCBuYW1lZCBwYXR0ZXJuIHBhcmFtcyBmcm9tIHRoZSBzb3VyY2VcbiAgICAvLyBlLmcuIC9zb21ldGhpbmc6aGVsbG8oLiopIC0+IC9hbm90aGVyLzpoZWxsbyBpcyBicm9rZW4gd2l0aCB2YWxpZGF0aW9uXG4gICAgLy8gc2luY2UgY29tcGlsZSB2YWxpZGF0aW9uIGlzIG1lYW50IGZvciByZXZlcnNpbmcgYW5kIG5vdCBmb3IgaW5zZXJ0aW5nXG4gICAgLy8gcGFyYW1zIGZyb20gYSBzZXBhcmF0ZSBwYXRoLXJlZ2V4IGludG8gYW5vdGhlclxuICAgIHsgdmFsaWRhdGU6IGZhbHNlIH1cbiAgKVxuICBsZXQgbmV3VXJsXG5cbiAgLy8gdXBkYXRlIGFueSBwYXJhbXMgaW4gcXVlcnkgdmFsdWVzXG4gIGZvciAoY29uc3QgW2tleSwgc3RyT3JBcnJheV0gb2YgT2JqZWN0LmVudHJpZXMoZGVzdFF1ZXJ5KSkge1xuICAgIGxldCB2YWx1ZSA9IEFycmF5LmlzQXJyYXkoc3RyT3JBcnJheSkgPyBzdHJPckFycmF5WzBdIDogc3RyT3JBcnJheVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgLy8gdGhlIHZhbHVlIG5lZWRzIHRvIHN0YXJ0IHdpdGggYSBmb3J3YXJkLXNsYXNoIHRvIGJlIGNvbXBpbGVkXG4gICAgICAvLyBjb3JyZWN0bHlcbiAgICAgIHZhbHVlID0gYC8ke3ZhbHVlfWBcbiAgICAgIGNvbnN0IHF1ZXJ5Q29tcGlsZXIgPSBwYXRoVG9SZWdleHAuY29tcGlsZSh2YWx1ZSwgeyB2YWxpZGF0ZTogZmFsc2UgfSlcbiAgICAgIHZhbHVlID0gcXVlcnlDb21waWxlcihwYXJhbXMpLnN1YnN0cigxKVxuICAgIH1cbiAgICBkZXN0UXVlcnlba2V5XSA9IHZhbHVlXG4gIH1cblxuICAvLyBhZGQgcGF0aCBwYXJhbXMgdG8gcXVlcnkgaWYgaXQncyBub3QgYSByZWRpcmVjdCBhbmQgbm90XG4gIC8vIGFscmVhZHkgZGVmaW5lZCBpbiBkZXN0aW5hdGlvbiBxdWVyeSBvciBwYXRoXG4gIGNvbnN0IHBhcmFtS2V5cyA9IE9iamVjdC5rZXlzKHBhcmFtcylcblxuICBpZiAoXG4gICAgYXBwZW5kUGFyYW1zVG9RdWVyeSAmJlxuICAgICFwYXJhbUtleXMuc29tZSgoa2V5KSA9PiBkZXN0UGF0aFBhcmFtcy5pbmNsdWRlcyhrZXkpKVxuICApIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBwYXJhbUtleXMpIHtcbiAgICAgIGlmICghKGtleSBpbiBkZXN0UXVlcnkpKSB7XG4gICAgICAgIGRlc3RRdWVyeVtrZXldID0gcGFyYW1zW2tleV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBzaG91bGRBZGRCYXNlUGF0aCA9IGRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoJy8nKSAmJiBiYXNlUGF0aFxuXG4gIHRyeSB7XG4gICAgbmV3VXJsID0gYCR7c2hvdWxkQWRkQmFzZVBhdGggPyBiYXNlUGF0aCA6ICcnfSR7ZGVzdGluYXRpb25Db21waWxlcihcbiAgICAgIHBhcmFtc1xuICAgICl9YFxuXG4gICAgY29uc3QgW3BhdGhuYW1lLCBoYXNoXSA9IG5ld1VybC5zcGxpdCgnIycpXG4gICAgcGFyc2VkRGVzdGluYXRpb24ucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgIHBhcnNlZERlc3RpbmF0aW9uLmhhc2ggPSBgJHtoYXNoID8gJyMnIDogJyd9JHtoYXNoIHx8ICcnfWBcbiAgICBkZWxldGUgcGFyc2VkRGVzdGluYXRpb24uc2VhcmNoXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubWVzc2FnZS5tYXRjaCgvRXhwZWN0ZWQgLio/IHRvIG5vdCByZXBlYXQsIGJ1dCBnb3QgYW4gYXJyYXkvKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVG8gdXNlIGEgbXVsdGktbWF0Y2ggaW4gdGhlIGRlc3RpbmF0aW9uIHlvdSBtdXN0IGFkZCBcXGAqXFxgIGF0IHRoZSBlbmQgb2YgdGhlIHBhcmFtIG5hbWUgdG8gc2lnbmlmeSBpdCBzaG91bGQgcmVwZWF0LiBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy9pbnZhbGlkLW11bHRpLW1hdGNoYFxuICAgICAgKVxuICAgIH1cbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIC8vIFF1ZXJ5IG1lcmdlIG9yZGVyIGxvd2VzdCBwcmlvcml0eSB0byBoaWdoZXN0XG4gIC8vIDEuIGluaXRpYWwgVVJMIHF1ZXJ5IHZhbHVlc1xuICAvLyAyLiBwYXRoIHNlZ21lbnQgdmFsdWVzXG4gIC8vIDMuIGRlc3RpbmF0aW9uIHNwZWNpZmllZCBxdWVyeSB2YWx1ZXNcbiAgcGFyc2VkRGVzdGluYXRpb24ucXVlcnkgPSB7XG4gICAgLi4ucXVlcnksXG4gICAgLi4ucGFyc2VkRGVzdGluYXRpb24ucXVlcnksXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5ld1VybCxcbiAgICBwYXJzZWREZXN0aW5hdGlvbixcbiAgfVxufVxuIiwiaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcblxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoXG4gIHNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zXG4pOiBQYXJzZWRVcmxRdWVyeSB7XG4gIGNvbnN0IHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSA9IHt9XG4gIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBxdWVyeVtrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcXVlcnlba2V5XSA9IHZhbHVlXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5W2tleV0pKSB7XG4gICAgICA7KHF1ZXJ5W2tleV0gYXMgc3RyaW5nW10pLnB1c2godmFsdWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5W2tleV0gPSBbcXVlcnlba2V5XSBhcyBzdHJpbmcsIHZhbHVlXVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHF1ZXJ5XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0ocGFyYW06IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmIChcbiAgICB0eXBlb2YgcGFyYW0gPT09ICdzdHJpbmcnIHx8XG4gICAgKHR5cGVvZiBwYXJhbSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHBhcmFtKSkgfHxcbiAgICB0eXBlb2YgcGFyYW0gPT09ICdib29sZWFuJ1xuICApIHtcbiAgICByZXR1cm4gU3RyaW5nKHBhcmFtKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAnJ1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cmxRdWVyeVRvU2VhcmNoUGFyYW1zKFxuICB1cmxRdWVyeTogUGFyc2VkVXJsUXVlcnlcbik6IFVSTFNlYXJjaFBhcmFtcyB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKVxuICBPYmplY3QuZW50cmllcyh1cmxRdWVyeSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtKSA9PiByZXN1bHQuYXBwZW5kKGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbShpdGVtKSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHZhbHVlKSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihcbiAgdGFyZ2V0OiBVUkxTZWFyY2hQYXJhbXMsXG4gIC4uLnNlYXJjaFBhcmFtc0xpc3Q6IFVSTFNlYXJjaFBhcmFtc1tdXG4pOiBVUkxTZWFyY2hQYXJhbXMge1xuICBzZWFyY2hQYXJhbXNMaXN0LmZvckVhY2goKHNlYXJjaFBhcmFtcykgPT4ge1xuICAgIEFycmF5LmZyb20oc2VhcmNoUGFyYW1zLmtleXMoKSkuZm9yRWFjaCgoa2V5KSA9PiB0YXJnZXQuZGVsZXRlKGtleSkpXG4gICAgc2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHRhcmdldC5hcHBlbmQoa2V5LCB2YWx1ZSkpXG4gIH0pXG4gIHJldHVybiB0YXJnZXRcbn1cbiIsImltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgcGF0aE1hdGNoIGZyb20gJy4vcGF0aC1tYXRjaCdcbmltcG9ydCBwcmVwYXJlRGVzdGluYXRpb24gZnJvbSAnLi9wcmVwYXJlLWRlc3RpbmF0aW9uJ1xuaW1wb3J0IHsgUmV3cml0ZSB9IGZyb20gJy4uLy4uLy4uLy4uL2xpYi9sb2FkLWN1c3RvbS1yb3V0ZXMnXG5pbXBvcnQgeyByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCB9IGZyb20gJy4uLy4uLy4uLy4uL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2gnXG5cbmNvbnN0IGN1c3RvbVJvdXRlTWF0Y2hlciA9IHBhdGhNYXRjaCh0cnVlKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXNvbHZlUmV3cml0ZXMoXG4gIGFzUGF0aDogc3RyaW5nLFxuICBwYWdlczogc3RyaW5nW10sXG4gIGJhc2VQYXRoOiBzdHJpbmcsXG4gIHJld3JpdGVzOiBSZXdyaXRlW10sXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgcmVzb2x2ZUhyZWY6IChwYXRoOiBzdHJpbmcpID0+IHN0cmluZ1xuKSB7XG4gIGlmICghcGFnZXMuaW5jbHVkZXMoYXNQYXRoKSkge1xuICAgIGZvciAoY29uc3QgcmV3cml0ZSBvZiByZXdyaXRlcykge1xuICAgICAgY29uc3QgbWF0Y2hlciA9IGN1c3RvbVJvdXRlTWF0Y2hlcihyZXdyaXRlLnNvdXJjZSlcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG1hdGNoZXIoYXNQYXRoKVxuXG4gICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgIGlmICghcmV3cml0ZS5kZXN0aW5hdGlvbikge1xuICAgICAgICAgIC8vIHRoaXMgaXMgYSBwcm94aWVkIHJld3JpdGUgd2hpY2ggaXNuJ3QgaGFuZGxlZCBvbiB0aGUgY2xpZW50XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXN0UmVzID0gcHJlcGFyZURlc3RpbmF0aW9uKFxuICAgICAgICAgIHJld3JpdGUuZGVzdGluYXRpb24sXG4gICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgcmV3cml0ZS5iYXNlUGF0aCA9PT0gZmFsc2UgPyAnJyA6IGJhc2VQYXRoXG4gICAgICAgIClcbiAgICAgICAgYXNQYXRoID0gZGVzdFJlcy5wYXJzZWREZXN0aW5hdGlvbi5wYXRobmFtZSFcbiAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgZGVzdFJlcy5wYXJzZWREZXN0aW5hdGlvbi5xdWVyeSlcblxuICAgICAgICBpZiAocGFnZXMuaW5jbHVkZXMocmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goYXNQYXRoKSkpIHtcbiAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBub3cgbWF0Y2ggYSBwYWdlIGFzIHRoaXMgbWVhbnMgd2UgYXJlIGRvbmVcbiAgICAgICAgICAvLyByZXNvbHZpbmcgdGhlIHJld3JpdGVzXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIG1hdGNoIGEgZHluYW1pYy1yb3V0ZSwgaWYgc28gd2UgYnJlYWsgdGhlIHJld3JpdGVzIGNoYWluXG4gICAgICAgIGNvbnN0IHJlc29sdmVkSHJlZiA9IHJlc29sdmVIcmVmKGFzUGF0aClcblxuICAgICAgICBpZiAocmVzb2x2ZWRIcmVmICE9PSBhc1BhdGggJiYgcGFnZXMuaW5jbHVkZXMocmVzb2x2ZWRIcmVmKSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFzUGF0aFxufVxuIiwiaW1wb3J0IHsgZ2V0Um91dGVSZWdleCB9IGZyb20gJy4vcm91dGUtcmVnZXgnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleDogUmV0dXJuVHlwZTx0eXBlb2YgZ2V0Um91dGVSZWdleD4pIHtcbiAgY29uc3QgeyByZSwgZ3JvdXBzIH0gPSByb3V0ZVJlZ2V4XG4gIHJldHVybiAocGF0aG5hbWU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcbiAgICBjb25zdCByb3V0ZU1hdGNoID0gcmUuZXhlYyhwYXRobmFtZSEpXG4gICAgaWYgKCFyb3V0ZU1hdGNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCBkZWNvZGUgPSAocGFyYW06IHN0cmluZykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChwYXJhbSlcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgY29uc3QgZXJyOiBFcnJvciAmIHsgY29kZT86IHN0cmluZyB9ID0gbmV3IEVycm9yKFxuICAgICAgICAgICdmYWlsZWQgdG8gZGVjb2RlIHBhcmFtJ1xuICAgICAgICApXG4gICAgICAgIGVyci5jb2RlID0gJ0RFQ09ERV9GQUlMRUQnXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwYXJhbXM6IHsgW3BhcmFtTmFtZTogc3RyaW5nXTogc3RyaW5nIHwgc3RyaW5nW10gfSA9IHt9XG5cbiAgICBPYmplY3Qua2V5cyhncm91cHMpLmZvckVhY2goKHNsdWdOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGcgPSBncm91cHNbc2x1Z05hbWVdXG4gICAgICBjb25zdCBtID0gcm91dGVNYXRjaFtnLnBvc11cbiAgICAgIGlmIChtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW1zW3NsdWdOYW1lXSA9IH5tLmluZGV4T2YoJy8nKVxuICAgICAgICAgID8gbS5zcGxpdCgnLycpLm1hcCgoZW50cnkpID0+IGRlY29kZShlbnRyeSkpXG4gICAgICAgICAgOiBnLnJlcGVhdFxuICAgICAgICAgID8gW2RlY29kZShtKV1cbiAgICAgICAgICA6IGRlY29kZShtKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG59XG4iLCJpbnRlcmZhY2UgR3JvdXAge1xuICBwb3M6IG51bWJlclxuICByZXBlYXQ6IGJvb2xlYW5cbiAgb3B0aW9uYWw6IGJvb2xlYW5cbn1cblxuLy8gdGhpcyBpc24ndCBpbXBvcnRpbmcgdGhlIGVzY2FwZS1zdHJpbmctcmVnZXggbW9kdWxlXG4vLyB0byByZWR1Y2UgYnl0ZXNcbmZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCsqPy4tXS9nLCAnXFxcXCQmJylcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXJhbWV0ZXIocGFyYW06IHN0cmluZykge1xuICBjb25zdCBvcHRpb25hbCA9IHBhcmFtLnN0YXJ0c1dpdGgoJ1snKSAmJiBwYXJhbS5lbmRzV2l0aCgnXScpXG4gIGlmIChvcHRpb25hbCkge1xuICAgIHBhcmFtID0gcGFyYW0uc2xpY2UoMSwgLTEpXG4gIH1cbiAgY29uc3QgcmVwZWF0ID0gcGFyYW0uc3RhcnRzV2l0aCgnLi4uJylcbiAgaWYgKHJlcGVhdCkge1xuICAgIHBhcmFtID0gcGFyYW0uc2xpY2UoMylcbiAgfVxuICByZXR1cm4geyBrZXk6IHBhcmFtLCByZXBlYXQsIG9wdGlvbmFsIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdXRlUmVnZXgoXG4gIG5vcm1hbGl6ZWRSb3V0ZTogc3RyaW5nXG4pOiB7XG4gIHJlOiBSZWdFeHBcbiAgbmFtZWRSZWdleD86IHN0cmluZ1xuICByb3V0ZUtleXM/OiB7IFtuYW1lZDogc3RyaW5nXTogc3RyaW5nIH1cbiAgZ3JvdXBzOiB7IFtncm91cE5hbWU6IHN0cmluZ106IEdyb3VwIH1cbn0ge1xuICBjb25zdCBzZWdtZW50cyA9IChub3JtYWxpemVkUm91dGUucmVwbGFjZSgvXFwvJC8sICcnKSB8fCAnLycpXG4gICAgLnNsaWNlKDEpXG4gICAgLnNwbGl0KCcvJylcblxuICBjb25zdCBncm91cHM6IHsgW2dyb3VwTmFtZTogc3RyaW5nXTogR3JvdXAgfSA9IHt9XG4gIGxldCBncm91cEluZGV4ID0gMVxuICBjb25zdCBwYXJhbWV0ZXJpemVkUm91dGUgPSBzZWdtZW50c1xuICAgIC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICAgIGlmIChzZWdtZW50LnN0YXJ0c1dpdGgoJ1snKSAmJiBzZWdtZW50LmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgY29uc3QgeyBrZXksIG9wdGlvbmFsLCByZXBlYXQgfSA9IHBhcnNlUGFyYW1ldGVyKHNlZ21lbnQuc2xpY2UoMSwgLTEpKVxuICAgICAgICBncm91cHNba2V5XSA9IHsgcG9zOiBncm91cEluZGV4KyssIHJlcGVhdCwgb3B0aW9uYWwgfVxuICAgICAgICByZXR1cm4gcmVwZWF0ID8gKG9wdGlvbmFsID8gJyg/Oi8oLis/KSk/JyA6ICcvKC4rPyknKSA6ICcvKFteL10rPyknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYC8ke2VzY2FwZVJlZ2V4KHNlZ21lbnQpfWBcbiAgICAgIH1cbiAgICB9KVxuICAgIC5qb2luKCcnKVxuXG4gIC8vIGRlYWQgY29kZSBlbGltaW5hdGUgZm9yIGJyb3dzZXIgc2luY2UgaXQncyBvbmx5IG5lZWRlZFxuICAvLyB3aGlsZSBnZW5lcmF0aW5nIHJvdXRlcy1tYW5pZmVzdFxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsZXQgcm91dGVLZXlDaGFyQ29kZSA9IDk3XG4gICAgbGV0IHJvdXRlS2V5Q2hhckxlbmd0aCA9IDFcblxuICAgIC8vIGJ1aWxkcyBhIG1pbmltYWwgcm91dGVLZXkgdXNpbmcgb25seSBhLXogYW5kIG1pbmltYWwgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbiAgICBjb25zdCBnZXRTYWZlUm91dGVLZXkgPSAoKSA9PiB7XG4gICAgICBsZXQgcm91dGVLZXkgPSAnJ1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlS2V5Q2hhckxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJvdXRlS2V5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocm91dGVLZXlDaGFyQ29kZSlcbiAgICAgICAgcm91dGVLZXlDaGFyQ29kZSsrXG5cbiAgICAgICAgaWYgKHJvdXRlS2V5Q2hhckNvZGUgPiAxMjIpIHtcbiAgICAgICAgICByb3V0ZUtleUNoYXJMZW5ndGgrK1xuICAgICAgICAgIHJvdXRlS2V5Q2hhckNvZGUgPSA5N1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcm91dGVLZXlcbiAgICB9XG5cbiAgICBjb25zdCByb3V0ZUtleXM6IHsgW25hbWVkOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9XG5cbiAgICBsZXQgbmFtZWRQYXJhbWV0ZXJpemVkUm91dGUgPSBzZWdtZW50c1xuICAgICAgLm1hcCgoc2VnbWVudCkgPT4ge1xuICAgICAgICBpZiAoc2VnbWVudC5zdGFydHNXaXRoKCdbJykgJiYgc2VnbWVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgY29uc3QgeyBrZXksIG9wdGlvbmFsLCByZXBlYXQgfSA9IHBhcnNlUGFyYW1ldGVyKHNlZ21lbnQuc2xpY2UoMSwgLTEpKVxuICAgICAgICAgIC8vIHJlcGxhY2UgYW55IG5vbi13b3JkIGNoYXJhY3RlcnMgc2luY2UgdGhleSBjYW4gYnJlYWtcbiAgICAgICAgICAvLyB0aGUgbmFtZWQgcmVnZXhcbiAgICAgICAgICBsZXQgY2xlYW5lZEtleSA9IGtleS5yZXBsYWNlKC9cXFcvZywgJycpXG4gICAgICAgICAgbGV0IGludmFsaWRLZXkgPSBmYWxzZVxuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGtleSBpcyBzdGlsbCBpbnZhbGlkIGFuZCBmYWxsYmFjayB0byB1c2luZyBhIGtub3duXG4gICAgICAgICAgLy8gc2FmZSBrZXlcbiAgICAgICAgICBpZiAoY2xlYW5lZEtleS5sZW5ndGggPT09IDAgfHwgY2xlYW5lZEtleS5sZW5ndGggPiAzMCkge1xuICAgICAgICAgICAgaW52YWxpZEtleSA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc05hTihwYXJzZUludChjbGVhbmVkS2V5LnN1YnN0cigwLCAxKSkpKSB7XG4gICAgICAgICAgICBpbnZhbGlkS2V5ID0gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbnZhbGlkS2V5KSB7XG4gICAgICAgICAgICBjbGVhbmVkS2V5ID0gZ2V0U2FmZVJvdXRlS2V5KClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3V0ZUtleXNbY2xlYW5lZEtleV0gPSBrZXlcbiAgICAgICAgICByZXR1cm4gcmVwZWF0XG4gICAgICAgICAgICA/IG9wdGlvbmFsXG4gICAgICAgICAgICAgID8gYCg/Oi8oPzwke2NsZWFuZWRLZXl9Pi4rPykpP2BcbiAgICAgICAgICAgICAgOiBgLyg/PCR7Y2xlYW5lZEtleX0+Lis/KWBcbiAgICAgICAgICAgIDogYC8oPzwke2NsZWFuZWRLZXl9PlteL10rPylgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGAvJHtlc2NhcGVSZWdleChzZWdtZW50KX1gXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuam9pbignJylcblxuICAgIHJldHVybiB7XG4gICAgICByZTogbmV3IFJlZ0V4cChgXiR7cGFyYW1ldGVyaXplZFJvdXRlfSg/Oi8pPyRgKSxcbiAgICAgIGdyb3VwcyxcbiAgICAgIHJvdXRlS2V5cyxcbiAgICAgIG5hbWVkUmVnZXg6IGBeJHtuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYCxcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlOiBuZXcgUmVnRXhwKGBeJHtwYXJhbWV0ZXJpemVkUm91dGV9KD86Lyk/JGApLFxuICAgIGdyb3VwcyxcbiAgfVxufVxuIiwiaW1wb3J0IHsgSW5jb21pbmdNZXNzYWdlLCBTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJ2h0dHAnXG5pbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHsgZm9ybWF0VXJsIH0gZnJvbSAnLi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybCdcbmltcG9ydCB7IE1hbmlmZXN0SXRlbSB9IGZyb20gJy4uL3NlcnZlci9sb2FkLWNvbXBvbmVudHMnXG5pbXBvcnQgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi9yb3V0ZXIvcm91dGVyJ1xuaW1wb3J0IHsgRW52IH0gZnJvbSAnQG5leHQvZW52J1xuaW1wb3J0IHsgQnVpbGRNYW5pZmVzdCB9IGZyb20gJy4uL3NlcnZlci9nZXQtcGFnZS1maWxlcydcblxuLyoqXG4gKiBUeXBlcyB1c2VkIGJ5IGJvdGggbmV4dCBhbmQgbmV4dC1zZXJ2ZXJcbiAqL1xuXG5leHBvcnQgdHlwZSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgQyBleHRlbmRzIEJhc2VDb250ZXh0ID0gTmV4dFBhZ2VDb250ZXh0LFxuICBJUCA9IHt9LFxuICBQID0ge31cbj4gPSBDb21wb25lbnRUeXBlPFA+ICYge1xuICAvKipcbiAgICogVXNlZCBmb3IgaW5pdGlhbCBwYWdlIGxvYWQgZGF0YSBwb3B1bGF0aW9uLiBEYXRhIHJldHVybmVkIGZyb20gYGdldEluaXRpYWxQcm9wc2AgaXMgc2VyaWFsaXplZCB3aGVuIHNlcnZlciByZW5kZXJlZC5cbiAgICogTWFrZSBzdXJlIHRvIHJldHVybiBwbGFpbiBgT2JqZWN0YCB3aXRob3V0IHVzaW5nIGBEYXRlYCwgYE1hcGAsIGBTZXRgLlxuICAgKiBAcGFyYW0gY3R4IENvbnRleHQgb2YgYHBhZ2VgXG4gICAqL1xuICBnZXRJbml0aWFsUHJvcHM/KGNvbnRleHQ6IEMpOiBJUCB8IFByb21pc2U8SVA+XG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50VHlwZSA9IE5leHRDb21wb25lbnRUeXBlPFxuICBEb2N1bWVudENvbnRleHQsXG4gIERvY3VtZW50SW5pdGlhbFByb3BzLFxuICBEb2N1bWVudFByb3BzXG4+ICYge1xuICByZW5kZXJEb2N1bWVudChcbiAgICBEb2N1bWVudDogRG9jdW1lbnRUeXBlLFxuICAgIHByb3BzOiBEb2N1bWVudFByb3BzXG4gICk6IFJlYWN0LlJlYWN0RWxlbWVudFxufVxuXG5leHBvcnQgdHlwZSBBcHBUeXBlID0gTmV4dENvbXBvbmVudFR5cGU8XG4gIEFwcENvbnRleHRUeXBlLFxuICBBcHBJbml0aWFsUHJvcHMsXG4gIEFwcFByb3BzVHlwZVxuPlxuXG5leHBvcnQgdHlwZSBBcHBUcmVlVHlwZSA9IENvbXBvbmVudFR5cGU8XG4gIEFwcEluaXRpYWxQcm9wcyAmIHsgW25hbWU6IHN0cmluZ106IGFueSB9XG4+XG5cbi8qKlxuICogV2ViIHZpdGFscyBwcm92aWRlZCB0byBfYXBwLnJlcG9ydFdlYlZpdGFscyBieSBDb3JlIFdlYiBWaXRhbHMgcGx1Z2luIGRldmVsb3BlZCBieSBHb29nbGUgQ2hyb21lIHRlYW0uXG4gKiBodHRwczovL25leHRqcy5vcmcvYmxvZy9uZXh0LTktNCNpbnRlZ3JhdGVkLXdlYi12aXRhbHMtcmVwb3J0aW5nXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRXZWJWaXRhbHNNZXRyaWMgPSB7XG4gIGlkOiBzdHJpbmdcbiAgbGFiZWw6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbiAgc3RhcnRUaW1lOiBudW1iZXJcbiAgdmFsdWU6IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBFbmhhbmNlcjxDPiA9IChDb21wb25lbnQ6IEMpID0+IENcblxuZXhwb3J0IHR5cGUgQ29tcG9uZW50c0VuaGFuY2VyID1cbiAgfCB7XG4gICAgICBlbmhhbmNlQXBwPzogRW5oYW5jZXI8QXBwVHlwZT5cbiAgICAgIGVuaGFuY2VDb21wb25lbnQ/OiBFbmhhbmNlcjxOZXh0Q29tcG9uZW50VHlwZT5cbiAgICB9XG4gIHwgRW5oYW5jZXI8TmV4dENvbXBvbmVudFR5cGU+XG5cbmV4cG9ydCB0eXBlIFJlbmRlclBhZ2VSZXN1bHQgPSB7XG4gIGh0bWw6IHN0cmluZ1xuICBoZWFkPzogQXJyYXk8SlNYLkVsZW1lbnQgfCBudWxsPlxufVxuXG5leHBvcnQgdHlwZSBSZW5kZXJQYWdlID0gKFxuICBvcHRpb25zPzogQ29tcG9uZW50c0VuaGFuY2VyXG4pID0+IFJlbmRlclBhZ2VSZXN1bHQgfCBQcm9taXNlPFJlbmRlclBhZ2VSZXN1bHQ+XG5cbmV4cG9ydCB0eXBlIEJhc2VDb250ZXh0ID0ge1xuICByZXM/OiBTZXJ2ZXJSZXNwb25zZVxuICBbazogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCB0eXBlIEhlYWRFbnRyeSA9IFtzdHJpbmcsIHsgW2tleTogc3RyaW5nXTogYW55IH1dXG5cbmV4cG9ydCB0eXBlIE5FWFRfREFUQSA9IHtcbiAgcHJvcHM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgcGFnZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBidWlsZElkOiBzdHJpbmdcbiAgYXNzZXRQcmVmaXg/OiBzdHJpbmdcbiAgcnVudGltZUNvbmZpZz86IHsgW2tleTogc3RyaW5nXTogYW55IH1cbiAgbmV4dEV4cG9ydD86IGJvb2xlYW5cbiAgYXV0b0V4cG9ydD86IGJvb2xlYW5cbiAgaXNGYWxsYmFjaz86IGJvb2xlYW5cbiAgZHluYW1pY0lkcz86IHN0cmluZ1tdXG4gIGVycj86IEVycm9yICYgeyBzdGF0dXNDb2RlPzogbnVtYmVyIH1cbiAgZ3NwPzogYm9vbGVhblxuICBnc3NwPzogYm9vbGVhblxuICBjdXN0b21TZXJ2ZXI/OiBib29sZWFuXG4gIGdpcD86IGJvb2xlYW5cbiAgYXBwR2lwPzogYm9vbGVhblxuICBoZWFkOiBIZWFkRW50cnlbXVxuICBsb2NhbGU/OiBzdHJpbmdcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbn1cblxuLyoqXG4gKiBgTmV4dGAgY29udGV4dFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5leHRQYWdlQ29udGV4dCB7XG4gIC8qKlxuICAgKiBFcnJvciBvYmplY3QgaWYgZW5jb3VudGVyZWQgZHVyaW5nIHJlbmRlcmluZ1xuICAgKi9cbiAgZXJyPzogKEVycm9yICYgeyBzdGF0dXNDb2RlPzogbnVtYmVyIH0pIHwgbnVsbFxuICAvKipcbiAgICogYEhUVFBgIHJlcXVlc3Qgb2JqZWN0LlxuICAgKi9cbiAgcmVxPzogSW5jb21pbmdNZXNzYWdlXG4gIC8qKlxuICAgKiBgSFRUUGAgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgcmVzPzogU2VydmVyUmVzcG9uc2VcbiAgLyoqXG4gICAqIFBhdGggc2VjdGlvbiBvZiBgVVJMYC5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgLyoqXG4gICAqIFF1ZXJ5IHN0cmluZyBzZWN0aW9uIG9mIGBVUkxgIHBhcnNlZCBhcyBhbiBvYmplY3QuXG4gICAqL1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgLyoqXG4gICAqIGBTdHJpbmdgIG9mIHRoZSBhY3R1YWwgcGF0aCBpbmNsdWRpbmcgcXVlcnkuXG4gICAqL1xuICBhc1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIGBDb21wb25lbnRgIHRoZSB0cmVlIG9mIHRoZSBBcHAgdG8gdXNlIGlmIG5lZWRpbmcgdG8gcmVuZGVyIHNlcGFyYXRlbHlcbiAgICovXG4gIEFwcFRyZWU6IEFwcFRyZWVUeXBlXG59XG5cbmV4cG9ydCB0eXBlIEFwcENvbnRleHRUeXBlPFIgZXh0ZW5kcyBOZXh0Um91dGVyID0gTmV4dFJvdXRlcj4gPSB7XG4gIENvbXBvbmVudDogTmV4dENvbXBvbmVudFR5cGU8TmV4dFBhZ2VDb250ZXh0PlxuICBBcHBUcmVlOiBBcHBUcmVlVHlwZVxuICBjdHg6IE5leHRQYWdlQ29udGV4dFxuICByb3V0ZXI6IFJcbn1cblxuZXhwb3J0IHR5cGUgQXBwSW5pdGlhbFByb3BzID0ge1xuICBwYWdlUHJvcHM6IGFueVxufVxuXG5leHBvcnQgdHlwZSBBcHBQcm9wc1R5cGU8XG4gIFIgZXh0ZW5kcyBOZXh0Um91dGVyID0gTmV4dFJvdXRlcixcbiAgUCA9IHt9XG4+ID0gQXBwSW5pdGlhbFByb3BzICYge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dCwgYW55LCBQPlxuICByb3V0ZXI6IFJcbiAgX19OX1NTRz86IGJvb2xlYW5cbiAgX19OX1NTUD86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRDb250ZXh0ID0gTmV4dFBhZ2VDb250ZXh0ICYge1xuICByZW5kZXJQYWdlOiBSZW5kZXJQYWdlXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50SW5pdGlhbFByb3BzID0gUmVuZGVyUGFnZVJlc3VsdCAmIHtcbiAgc3R5bGVzPzogUmVhY3QuUmVhY3RFbGVtZW50W10gfCBSZWFjdC5SZWFjdEZyYWdtZW50XG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50UHJvcHMgPSBEb2N1bWVudEluaXRpYWxQcm9wcyAmIHtcbiAgX19ORVhUX0RBVEFfXzogTkVYVF9EQVRBXG4gIGRhbmdlcm91c0FzUGF0aDogc3RyaW5nXG4gIGRvY0NvbXBvbmVudHNSZW5kZXJlZDoge1xuICAgIEh0bWw/OiBib29sZWFuXG4gICAgTWFpbj86IGJvb2xlYW5cbiAgICBIZWFkPzogYm9vbGVhblxuICAgIE5leHRTY3JpcHQ/OiBib29sZWFuXG4gIH1cbiAgYnVpbGRNYW5pZmVzdDogQnVpbGRNYW5pZmVzdFxuICBhbXBQYXRoOiBzdHJpbmdcbiAgaW5BbXBNb2RlOiBib29sZWFuXG4gIGh5YnJpZEFtcDogYm9vbGVhblxuICBpc0RldmVsb3BtZW50OiBib29sZWFuXG4gIGR5bmFtaWNJbXBvcnRzOiBNYW5pZmVzdEl0ZW1bXVxuICBhc3NldFByZWZpeD86IHN0cmluZ1xuICBjYW5vbmljYWxCYXNlOiBzdHJpbmdcbiAgaGVhZFRhZ3M6IGFueVtdXG4gIHVuc3RhYmxlX3J1bnRpbWVKUz86IGZhbHNlXG4gIGRldk9ubHlDYWNoZUJ1c3RlclF1ZXJ5U3RyaW5nOiBzdHJpbmdcbiAgbG9jYWxlPzogc3RyaW5nXG59XG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dEFwaVJlcXVlc3QgZXh0ZW5kcyBJbmNvbWluZ01lc3NhZ2Uge1xuICAvKipcbiAgICogT2JqZWN0IG9mIGBxdWVyeWAgdmFsdWVzIGZyb20gdXJsXG4gICAqL1xuICBxdWVyeToge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHN0cmluZ1tdXG4gIH1cbiAgLyoqXG4gICAqIE9iamVjdCBvZiBgY29va2llc2AgZnJvbSBoZWFkZXJcbiAgICovXG4gIGNvb2tpZXM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgfVxuXG4gIGJvZHk6IGFueVxuXG4gIGVudjogRW52XG5cbiAgcHJldmlldz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFByZXZpZXcgZGF0YSBzZXQgb24gdGhlIHJlcXVlc3QsIGlmIGFueVxuICAgKiAqL1xuICBwcmV2aWV3RGF0YT86IGFueVxufVxuXG4vKipcbiAqIFNlbmQgYm9keSBvZiByZXNwb25zZVxuICovXG50eXBlIFNlbmQ8VD4gPSAoYm9keTogVCkgPT4gdm9pZFxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgcmVzcG9uc2VcbiAqL1xuZXhwb3J0IHR5cGUgTmV4dEFwaVJlc3BvbnNlPFQgPSBhbnk+ID0gU2VydmVyUmVzcG9uc2UgJiB7XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgYGFueWAgZGF0YSBpbiByZXNwb25zZVxuICAgKi9cbiAgc2VuZDogU2VuZDxUPlxuICAvKipcbiAgICogU2VuZCBkYXRhIGBqc29uYCBkYXRhIGluIHJlc3BvbnNlXG4gICAqL1xuICBqc29uOiBTZW5kPFQ+XG4gIHN0YXR1czogKHN0YXR1c0NvZGU6IG51bWJlcikgPT4gTmV4dEFwaVJlc3BvbnNlPFQ+XG4gIHJlZGlyZWN0KHVybDogc3RyaW5nKTogTmV4dEFwaVJlc3BvbnNlPFQ+XG4gIHJlZGlyZWN0KHN0YXR1czogbnVtYmVyLCB1cmw6IHN0cmluZyk6IE5leHRBcGlSZXNwb25zZTxUPlxuXG4gIC8qKlxuICAgKiBTZXQgcHJldmlldyBkYXRhIGZvciBOZXh0LmpzJyBwcmVyZW5kZXIgbW9kZVxuICAgKi9cbiAgc2V0UHJldmlld0RhdGE6IChcbiAgICBkYXRhOiBvYmplY3QgfCBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHtcbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lmaWVzIHRoZSBudW1iZXIgKGluIHNlY29uZHMpIGZvciB0aGUgcHJldmlldyBzZXNzaW9uIHRvIGxhc3QgZm9yLlxuICAgICAgICogVGhlIGdpdmVuIG51bWJlciB3aWxsIGJlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyIGJ5IHJvdW5kaW5nIGRvd24uXG4gICAgICAgKiBCeSBkZWZhdWx0LCBubyBtYXhpbXVtIGFnZSBpcyBzZXQgYW5kIHRoZSBwcmV2aWV3IHNlc3Npb24gZmluaXNoZXNcbiAgICAgICAqIHdoZW4gdGhlIGNsaWVudCBzaHV0cyBkb3duIChicm93c2VyIGlzIGNsb3NlZCkuXG4gICAgICAgKi9cbiAgICAgIG1heEFnZT86IG51bWJlclxuICAgIH1cbiAgKSA9PiBOZXh0QXBpUmVzcG9uc2U8VD5cbiAgY2xlYXJQcmV2aWV3RGF0YTogKCkgPT4gTmV4dEFwaVJlc3BvbnNlPFQ+XG59XG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSBoYW5kbGVyXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRBcGlIYW5kbGVyPFQgPSBhbnk+ID0gKFxuICByZXE6IE5leHRBcGlSZXF1ZXN0LFxuICByZXM6IE5leHRBcGlSZXNwb25zZTxUPlxuKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPlxuXG4vKipcbiAqIFV0aWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjT25jZTxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBSZXR1cm5UeXBlPFQ+PihcbiAgZm46IFRcbik6IFQge1xuICBsZXQgdXNlZCA9IGZhbHNlXG4gIGxldCByZXN1bHQ6IFJldHVyblR5cGU8VD5cblxuICByZXR1cm4gKCguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgIGlmICghdXNlZCkge1xuICAgICAgdXNlZCA9IHRydWVcbiAgICAgIHJlc3VsdCA9IGZuKC4uLmFyZ3MpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSkgYXMgVFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9jYXRpb25PcmlnaW4oKSB7XG4gIGNvbnN0IHsgcHJvdG9jb2wsIGhvc3RuYW1lLCBwb3J0IH0gPSB3aW5kb3cubG9jYXRpb25cbiAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0bmFtZX0ke3BvcnQgPyAnOicgKyBwb3J0IDogJyd9YFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VVJMKCkge1xuICBjb25zdCB7IGhyZWYgfSA9IHdpbmRvdy5sb2NhdGlvblxuICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG4gIHJldHVybiBocmVmLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWU8UD4oQ29tcG9uZW50OiBDb21wb25lbnRUeXBlPFA+KSB7XG4gIHJldHVybiB0eXBlb2YgQ29tcG9uZW50ID09PSAnc3RyaW5nJ1xuICAgID8gQ29tcG9uZW50XG4gICAgOiBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Jlc1NlbnQocmVzOiBTZXJ2ZXJSZXNwb25zZSkge1xuICByZXR1cm4gcmVzLmZpbmlzaGVkIHx8IHJlcy5oZWFkZXJzU2VudFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZEdldEluaXRpYWxQcm9wczxcbiAgQyBleHRlbmRzIEJhc2VDb250ZXh0LFxuICBJUCA9IHt9LFxuICBQID0ge31cbj4oQXBwOiBOZXh0Q29tcG9uZW50VHlwZTxDLCBJUCwgUD4sIGN0eDogQyk6IFByb21pc2U8SVA+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoQXBwLnByb3RvdHlwZT8uZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShcbiAgICAgICAgQXBwXG4gICAgICApfS5nZXRJbml0aWFsUHJvcHMoKVwiIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIC0gdmlzaXQgaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvZ2V0LWluaXRpYWwtcHJvcHMtYXMtYW4taW5zdGFuY2UtbWV0aG9kIGZvciBtb3JlIGluZm9ybWF0aW9uLmBcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgIH1cbiAgfVxuICAvLyB3aGVuIGNhbGxlZCBmcm9tIF9hcHAgYGN0eGAgaXMgbmVzdGVkIGluIGBjdHhgXG4gIGNvbnN0IHJlcyA9IGN0eC5yZXMgfHwgKGN0eC5jdHggJiYgY3R4LmN0eC5yZXMpXG5cbiAgaWYgKCFBcHAuZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgaWYgKGN0eC5jdHggJiYgY3R4LkNvbXBvbmVudCkge1xuICAgICAgLy8gQHRzLWlnbm9yZSBwYWdlUHJvcHMgZGVmYXVsdFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZVByb3BzOiBhd2FpdCBsb2FkR2V0SW5pdGlhbFByb3BzKGN0eC5Db21wb25lbnQsIGN0eC5jdHgpLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge30gYXMgSVBcbiAgfVxuXG4gIGNvbnN0IHByb3BzID0gYXdhaXQgQXBwLmdldEluaXRpYWxQcm9wcyhjdHgpXG5cbiAgaWYgKHJlcyAmJiBpc1Jlc1NlbnQocmVzKSkge1xuICAgIHJldHVybiBwcm9wc1xuICB9XG5cbiAgaWYgKCFwcm9wcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgXCIke2dldERpc3BsYXlOYW1lKFxuICAgICAgQXBwXG4gICAgKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBzaG91bGQgcmVzb2x2ZSB0byBhbiBvYmplY3QuIEJ1dCBmb3VuZCBcIiR7cHJvcHN9XCIgaW5zdGVhZC5gXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoID09PSAwICYmICFjdHguY3R4KSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGAke2dldERpc3BsYXlOYW1lKFxuICAgICAgICAgIEFwcFxuICAgICAgICApfSByZXR1cm5lZCBhbiBlbXB0eSBvYmplY3QgZnJvbSBcXGBnZXRJbml0aWFsUHJvcHNcXGAuIFRoaXMgZGUtb3B0aW1pemVzIGFuZCBwcmV2ZW50cyBhdXRvbWF0aWMgc3RhdGljIG9wdGltaXphdGlvbi4gaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvZW1wdHktb2JqZWN0LWdldEluaXRpYWxQcm9wc2BcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvcHNcbn1cblxuZXhwb3J0IGNvbnN0IHVybE9iamVjdEtleXMgPSBbXG4gICdhdXRoJyxcbiAgJ2hhc2gnLFxuICAnaG9zdCcsXG4gICdob3N0bmFtZScsXG4gICdocmVmJyxcbiAgJ3BhdGgnLFxuICAncGF0aG5hbWUnLFxuICAncG9ydCcsXG4gICdwcm90b2NvbCcsXG4gICdxdWVyeScsXG4gICdzZWFyY2gnLFxuICAnc2xhc2hlcycsXG5dXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRXaXRoVmFsaWRhdGlvbih1cmw6IFVybE9iamVjdCk6IHN0cmluZyB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGlmICh1cmwgIT09IG51bGwgJiYgdHlwZW9mIHVybCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKHVybCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmICh1cmxPYmplY3RLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgVW5rbm93biBrZXkgcGFzc2VkIHZpYSB1cmxPYmplY3QgaW50byB1cmwuZm9ybWF0OiAke2tleX1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3JtYXRVcmwodXJsKVxufVxuXG5leHBvcnQgY29uc3QgU1AgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnXG5leHBvcnQgY29uc3QgU1QgPVxuICBTUCAmJlxuICB0eXBlb2YgcGVyZm9ybWFuY2UubWFyayA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSA9PT0gJ2Z1bmN0aW9uJ1xuIiwiXCJ1c2Ugc3RyaWN0XCI7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0cy5ub3JtYWxpemVQYXRoU2VwPW5vcm1hbGl6ZVBhdGhTZXA7ZXhwb3J0cy5kZW5vcm1hbGl6ZVBhZ2VQYXRoPWRlbm9ybWFsaXplUGFnZVBhdGg7ZnVuY3Rpb24gbm9ybWFsaXplUGF0aFNlcChwYXRoKXtyZXR1cm4gcGF0aC5yZXBsYWNlKC9cXFxcL2csJy8nKTt9ZnVuY3Rpb24gZGVub3JtYWxpemVQYWdlUGF0aChwYWdlKXtwYWdlPW5vcm1hbGl6ZVBhdGhTZXAocGFnZSk7aWYocGFnZS5zdGFydHNXaXRoKCcvaW5kZXgvJykpe3BhZ2U9cGFnZS5zbGljZSg2KTt9ZWxzZSBpZihwYWdlPT09Jy9pbmRleCcpe3BhZ2U9Jy8nO31yZXR1cm4gcGFnZTt9XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZW5vcm1hbGl6ZS1wYWdlLXBhdGguanMubWFwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L2xpbmsnKVxuIiwiZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5OyIsImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXM7IiwiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FzeW5jVG9HZW5lcmF0b3I7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY2xhc3NDYWxsQ2hlY2s7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbnZhciBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSByZXF1aXJlKFwiLi9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3RcIik7XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIHNldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3Q7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzczsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7IiwiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xuICBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7XG4gIHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xuICAgIHJldHVybiBjYWNoZTtcbiAgfTtcblxuICByZXR1cm4gY2FjaGU7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB7XG4gICAgICBcImRlZmF1bHRcIjogb2JqXG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpO1xuXG4gIGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkge1xuICAgIHJldHVybiBjYWNoZS5nZXQob2JqKTtcbiAgfVxuXG4gIHZhciBuZXdPYmogPSB7fTtcbiAgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7XG5cbiAgICAgIGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajtcblxuICBpZiAoY2FjaGUpIHtcbiAgICBjYWNoZS5zZXQob2JqLCBuZXdPYmopO1xuICB9XG5cbiAgcmV0dXJuIG5ld09iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZDsiLCJmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdDsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheUxpbWl0OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdDsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZjsiLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXRcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVSZXN0XCIpO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZjsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXlcIik7XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldHMgd2FybmluZyBjYWNoZSB3aGVuIHRlc3RpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgZWxlbWVudFR5cGU6IGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmYWxzeSB2YWx1ZSBjYW4ndCBiZSBhIFN5bWJvbFxuICAgIGlmICghcHJvcFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBjaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZTtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNldENvbmZpZ3VyYXRpb24gPSBleHBvcnRzLmdldENvbmZpZ3VyYXRpb24gPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgY29uZmlndXJhdGlvbiA9IHtcbiAgYnJlYWtwb2ludHM6IFs1NzYsIDc2OCwgOTkyLCAxMjAwLCAxNjAwXSxcbiAgY29udGFpbmVyV2lkdGhzOiBbNTQwLCA3NTAsIDk2MCwgMTE0MCwgMTU0MF0sXG4gIGd1dHRlcldpZHRoOiAzMCxcbiAgZ3JpZENvbHVtbnM6IDEyLFxuICBkZWZhdWx0U2NyZWVuQ2xhc3M6ICd4eGwnLFxuICBtYXhTY3JlZW5DbGFzczogJ3h4bCdcbn07XG5cbnZhciBnZXRDb25maWd1cmF0aW9uID0gZnVuY3Rpb24gZ2V0Q29uZmlndXJhdGlvbigpIHtcbiAgcmV0dXJuIGNvbmZpZ3VyYXRpb247XG59O1xuXG5leHBvcnRzLmdldENvbmZpZ3VyYXRpb24gPSBnZXRDb25maWd1cmF0aW9uO1xuXG52YXIgc2V0Q29uZmlndXJhdGlvbiA9IGZ1bmN0aW9uIHNldENvbmZpZ3VyYXRpb24obmV3Q29uZmlndXJhdGlvbikge1xuICBjb25maWd1cmF0aW9uID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjb25maWd1cmF0aW9uKSwgbmV3Q29uZmlndXJhdGlvbik7XG59O1xuXG5leHBvcnRzLnNldENvbmZpZ3VyYXRpb24gPSBzZXRDb25maWd1cmF0aW9uOyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLlNjcmVlbkNsYXNzQ29udGV4dCA9IGV4cG9ydHMuTk9fUFJPVklERVJfRkxBRyA9IHZvaWQgMDtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfcHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5cbnZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NvbmZpZ1wiKTtcblxudmFyIF9wcmltaXRpdmVzID0gcmVxdWlyZShcIi4uLy4uL3ByaW1pdGl2ZXNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbnZhciBOT19QUk9WSURFUl9GTEFHID0gJ05PX1BST1ZJREVSX0ZMQUcnO1xuZXhwb3J0cy5OT19QUk9WSURFUl9GTEFHID0gTk9fUFJPVklERVJfRkxBRztcblxudmFyIFNjcmVlbkNsYXNzQ29udGV4dCA9IC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVDb250ZXh0KE5PX1BST1ZJREVSX0ZMQUcpO1xuXG5leHBvcnRzLlNjcmVlbkNsYXNzQ29udGV4dCA9IFNjcmVlbkNsYXNzQ29udGV4dDtcblxudmFyIFNjcmVlbkNsYXNzUHJvdmlkZXIgPSBmdW5jdGlvbiBTY3JlZW5DbGFzc1Byb3ZpZGVyKF9yZWYpIHtcbiAgdmFyIHVzZU93bldpZHRoID0gX3JlZi51c2VPd25XaWR0aCxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGZhbGxiYWNrU2NyZWVuQ2xhc3MgPSBfcmVmLmZhbGxiYWNrU2NyZWVuQ2xhc3M7XG4gIHZhciBzY3JlZW5DbGFzc1JlZiA9ICgwLCBfcmVhY3QudXNlUmVmKSgpO1xuXG4gIHZhciBfdXNlU3RhdGUgPSAoMCwgX3JlYWN0LnVzZVN0YXRlKShmYWxzZSksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIG1vdW50ZWQgPSBfdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0TW91bnRlZCA9IF91c2VTdGF0ZTJbMV07XG5cbiAgdmFyIGRldGVjdGVkU2NyZWVuQ2xhc3MgPSAoMCwgX3V0aWxzLnVzZVNjcmVlbkNsYXNzKShzY3JlZW5DbGFzc1JlZiwgZmFsbGJhY2tTY3JlZW5DbGFzcyk7XG5cbiAgdmFyIF9nZXRDb25maWd1cmF0aW9uID0gKDAsIF9jb25maWcuZ2V0Q29uZmlndXJhdGlvbikoKSxcbiAgICAgIGRlZmF1bHRTY3JlZW5DbGFzcyA9IF9nZXRDb25maWd1cmF0aW9uLmRlZmF1bHRTY3JlZW5DbGFzcztcblxuICB2YXIgc2NyZWVuQ2xhc3MgPSBtb3VudGVkID8gZGV0ZWN0ZWRTY3JlZW5DbGFzcyA6IGZhbGxiYWNrU2NyZWVuQ2xhc3MgfHwgZGVmYXVsdFNjcmVlbkNsYXNzO1xuICAoMCwgX3JlYWN0LnVzZUVmZmVjdCkoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzZXRNb3VudGVkKHRydWUpO1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChTY3JlZW5DbGFzc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc2NyZWVuQ2xhc3NcbiAgfSwgdXNlT3duV2lkdGggPyAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcHJpbWl0aXZlcy5EaXYsIHtcbiAgICByZWY6IHVzZU93bldpZHRoID8gc2NyZWVuQ2xhc3NSZWYgOiBudWxsXG4gIH0sIGNoaWxkcmVuKSA6IC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbikpO1xufTtcblxuU2NyZWVuQ2xhc3NQcm92aWRlci5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBDaGlsZHJlbiBvZiB0aGUgU2NyZWVuQ2xhc3NQcm92aWRlci5cbiAgICogVGhpcyBzaG91bGQgYmUgYWxsIHlvdXIgY2hpbGQgUmVhY3Qgbm9kZXMgdGhhdCBhcmUgdXNpbmcgYHJlYWN0LWdyaWQtc3lzdGVtYC5cbiAgICovXG4gIGNoaWxkcmVuOiBfcHJvcFR5cGVzLmRlZmF1bHQubm9kZS5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBCb29sZWFuIHRvIGRldGVybWluZSB3aGV0aGVyIG93biB3aWR0aCBzaG91bGQgYmUgdXNlZCBhcyBzb3VyY2UuXG4gICAqIFdoZW4gcHJvdmlkZWQsIHRoZSBzY3JlZW4gY2xhc3MgaXMgZGVyaXZlZCBmcm9tIG93biBkaW1lbnNpb25zIGluc3RlYWQgb2YgdGhlIHdpbmRvdy5cbiAgICovXG4gIHVzZU93bldpZHRoOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcblxuICAvKipcbiAgICogU2NyZWVuIGNsYXNzIHRvIHVzZSB3aGVuIGl0IGNhbm5vdCBiZSBkZXRlcm1pbmVkIG90aGVyd2lzZS5cbiAgICogVXNlZnVsIGZvciBzZXJ2ZXIgc2lkZSByZW5kZXJpbmcuXG4gICAqL1xuICBmYWxsYmFja1NjcmVlbkNsYXNzOiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2YoW251bGwsICd4cycsICdzbScsICdtZCcsICdsZycsICd4bCcsICd4eGwnXSlcbn07XG5TY3JlZW5DbGFzc1Byb3ZpZGVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgdXNlT3duV2lkdGg6IGZhbHNlLFxuICBmYWxsYmFja1NjcmVlbkNsYXNzOiBudWxsXG59O1xudmFyIF9kZWZhdWx0ID0gU2NyZWVuQ2xhc3NQcm92aWRlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfcHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG5cbnZhciBfU2NyZWVuQ2xhc3NQcm92aWRlciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuLi9TY3JlZW5DbGFzc1Byb3ZpZGVyXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFNjcmVlbkNsYXNzUmVzb2x2ZXIgPSBmdW5jdGlvbiBTY3JlZW5DbGFzc1Jlc29sdmVyKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9TY3JlZW5DbGFzc1Byb3ZpZGVyLlNjcmVlbkNsYXNzQ29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKHNjcmVlbkNsYXNzQ2hlY2spIHtcbiAgICBpZiAoc2NyZWVuQ2xhc3NDaGVjayA9PT0gX1NjcmVlbkNsYXNzUHJvdmlkZXIuTk9fUFJPVklERVJfRkxBRykge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9TY3JlZW5DbGFzc1Byb3ZpZGVyLmRlZmF1bHQsIG51bGwsIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9TY3JlZW5DbGFzc1Byb3ZpZGVyLlNjcmVlbkNsYXNzQ29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKHNjcmVlbkNsYXNzUmVzb2x2ZWQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuKHNjcmVlbkNsYXNzUmVzb2x2ZWQpO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGlsZHJlbihzY3JlZW5DbGFzc0NoZWNrKTtcbiAgfSk7XG59O1xuXG5TY3JlZW5DbGFzc1Jlc29sdmVyLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLmlzUmVxdWlyZWRcbn07XG52YXIgX2RlZmF1bHQgPSBTY3JlZW5DbGFzc1Jlc29sdmVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfcHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG5cbnZhciBfc3R5bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0eWxlXCIpKTtcblxudmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vLi4vY29uZmlnXCIpO1xuXG52YXIgX1JvdyA9IHJlcXVpcmUoXCIuLi9Sb3dcIik7XG5cbnZhciBfU2NyZWVuQ2xhc3NSZXNvbHZlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL2NvbnRleHQvU2NyZWVuQ2xhc3NSZXNvbHZlclwiKSk7XG5cbnZhciBfcHJpbWl0aXZlcyA9IHJlcXVpcmUoXCIuLi8uLi9wcmltaXRpdmVzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIENvbCA9IGZ1bmN0aW9uIENvbChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICB4cyA9IF9yZWYueHMsXG4gICAgICBzbSA9IF9yZWYuc20sXG4gICAgICBtZCA9IF9yZWYubWQsXG4gICAgICBsZyA9IF9yZWYubGcsXG4gICAgICB4bCA9IF9yZWYueGwsXG4gICAgICB4eGwgPSBfcmVmLnh4bCxcbiAgICAgIG9mZnNldCA9IF9yZWYub2Zmc2V0LFxuICAgICAgcHVsbCA9IF9yZWYucHVsbCxcbiAgICAgIHB1c2ggPSBfcmVmLnB1c2gsXG4gICAgICBkZWJ1ZyA9IF9yZWYuZGVidWcsXG4gICAgICBzdHlsZSA9IF9yZWYuc3R5bGUsXG4gICAgICBjb21wb25lbnQgPSBfcmVmLmNvbXBvbmVudCxcbiAgICAgIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIG90aGVyUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJ4c1wiLCBcInNtXCIsIFwibWRcIiwgXCJsZ1wiLCBcInhsXCIsIFwieHhsXCIsIFwib2Zmc2V0XCIsIFwicHVsbFwiLCBcInB1c2hcIiwgXCJkZWJ1Z1wiLCBcInN0eWxlXCIsIFwiY29tcG9uZW50XCIsIFwid2lkdGhcIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfU2NyZWVuQ2xhc3NSZXNvbHZlci5kZWZhdWx0LCBudWxsLCBmdW5jdGlvbiAoc2NyZWVuQ2xhc3MpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX1Jvdy5HdXR0ZXJXaWR0aENvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChndXR0ZXJXaWR0aCkge1xuICAgICAgdmFyIHRoZVN0eWxlID0gKDAsIF9zdHlsZS5kZWZhdWx0KSh7XG4gICAgICAgIGZvcmNlV2lkdGg6IHdpZHRoLFxuICAgICAgICB3aWR0aDoge1xuICAgICAgICAgIHhzOiB4cyxcbiAgICAgICAgICBzbTogc20sXG4gICAgICAgICAgbWQ6IG1kLFxuICAgICAgICAgIGxnOiBsZyxcbiAgICAgICAgICB4bDogeGwsXG4gICAgICAgICAgeHhsOiB4eGxcbiAgICAgICAgfSxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIHB1bGw6IHB1bGwsXG4gICAgICAgIHB1c2g6IHB1c2gsXG4gICAgICAgIGRlYnVnOiBkZWJ1ZyxcbiAgICAgICAgc2NyZWVuQ2xhc3M6IHNjcmVlbkNsYXNzLFxuICAgICAgICBndXR0ZXJXaWR0aDogZ3V0dGVyV2lkdGgsXG4gICAgICAgIGdyaWRDb2x1bW5zOiAoMCwgX2NvbmZpZy5nZXRDb25maWd1cmF0aW9uKSgpLmdyaWRDb2x1bW5zLFxuICAgICAgICBtb3JlU3R5bGU6IHN0eWxlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovKDAsIF9yZWFjdC5jcmVhdGVFbGVtZW50KShjb21wb25lbnQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIHN0eWxlOiB0aGVTdHlsZVxuICAgICAgfSwgb3RoZXJQcm9wcyksIHt9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgfSkpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbkNvbC5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBDb250ZW50IG9mIHRoZSBjb2x1bW5cbiAgICovXG4gIGNoaWxkcmVuOiBfcHJvcFR5cGVzLmRlZmF1bHQubm9kZSxcblxuICAvKipcbiAgICogVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gZm9yIHNjcmVlbmNsYXNzIGB4c2AsIGVpdGhlciBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEyLCBvciBcImNvbnRlbnRcIlxuICAgKi9cbiAgeHM6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsIF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbJ2NvbnRlbnQnXSldKSxcblxuICAvKipcbiAgICogVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gZm9yIHNjcmVlbmNsYXNzIGBzbWAsIGVpdGhlciBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEyLCBvciBcImNvbnRlbnRcIlxuICAgKi9cbiAgc206IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsIF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbJ2NvbnRlbnQnXSldKSxcblxuICAvKipcbiAgICogVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gZm9yIHNjcmVlbmNsYXNzIGBtZGAsIGVpdGhlciBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEyLCBvciBcImNvbnRlbnRcIlxuICAgKi9cbiAgbWQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsIF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbJ2NvbnRlbnQnXSldKSxcblxuICAvKipcbiAgICogVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gZm9yIHNjcmVlbmNsYXNzIGBsZ2AsIGVpdGhlciBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEyLCBvciBcImNvbnRlbnRcIlxuICAgKi9cbiAgbGc6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsIF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbJ2NvbnRlbnQnXSldKSxcblxuICAvKipcbiAgICogVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gZm9yIHNjcmVlbmNsYXNzIGB4bGAsIGVpdGhlciBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEyLCBvciBcImNvbnRlbnRcIlxuICAgKi9cbiAgeGw6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsIF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbJ2NvbnRlbnQnXSldKSxcblxuICAvKipcbiAgICogVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gZm9yIHNjcmVlbmNsYXNzIGB4eGxgLCBlaXRoZXIgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxMiwgb3IgXCJjb250ZW50XCJcbiAgICovXG4gIHh4bDogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlciwgX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mKFsnY29udGVudCddKV0pLFxuXG4gIC8qKlxuICAgKiBBIGZpeGVkIHdpZHRoIG9mIHRoZSBjb2x1bW4gZm9yIGFsbCBzY3JlZW5jbGFzc2VzXCJcbiAgICovXG4gIHdpZHRoOiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLCBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nXSksXG5cbiAgLyoqXG4gICAqIFRoZSBvZmZzZXQgb2YgdGhpcyBjb2x1bW4gZm9yIGFsbCBzY3JlZW5jbGFzc2VzXG4gICAqL1xuICBvZmZzZXQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5zaGFwZSh7XG4gICAgeHM6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gICAgc206IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gICAgbWQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gICAgbGc6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gICAgeGw6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gICAgeHhsOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyXG4gIH0pLFxuXG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IHRoaXMgY29sdW1uIGlzIHB1c2hlZCB0byB0aGUgcmlnaHQgZm9yIGFsbCBzY3JlZW5jbGFzc2VzXG4gICAqL1xuICBwdXNoOiBfcHJvcFR5cGVzLmRlZmF1bHQuc2hhcGUoe1xuICAgIHhzOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHNtOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIG1kOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIGxnOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHhsOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHh4bDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlclxuICB9KSxcblxuICAvKipcbiAgICogVGhlIGFtb3VudCB0aGlzIGNvbHVtbiBpcyBwdWxsZWQgdG8gdGhlIGxlZnQgZm9yIGFsbCBzY3JlZW5jbGFzc2VzXG4gICAqL1xuICBwdWxsOiBfcHJvcFR5cGVzLmRlZmF1bHQuc2hhcGUoe1xuICAgIHhzOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHNtOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIG1kOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIGxnOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHhsOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHh4bDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlclxuICB9KSxcblxuICAvKipcbiAgICogT3B0aW9uYWwgc3R5bGluZ1xuICAgKi9cbiAgc3R5bGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5vYmplY3RPZihfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLCBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nXSkpLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gYXBwbHkgc29tZSBkZWJ1ZyBzdHlsaW5nXG4gICAqL1xuICBkZWJ1ZzogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIFVzZSB5b3VyIG93biBjb21wb25lbnRcbiAgICovXG4gIGNvbXBvbmVudDogX3Byb3BUeXBlcy5kZWZhdWx0LmVsZW1lbnRUeXBlXG59O1xuQ29sLmRlZmF1bHRQcm9wcyA9IHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIHhzOiBudWxsLFxuICBzbTogbnVsbCxcbiAgbWQ6IG51bGwsXG4gIGxnOiBudWxsLFxuICB4bDogbnVsbCxcbiAgeHhsOiBudWxsLFxuICB3aWR0aDogbnVsbCxcbiAgb2Zmc2V0OiB7fSxcbiAgcHVzaDoge30sXG4gIHB1bGw6IHt9LFxuICBzdHlsZToge30sXG4gIGRlYnVnOiBmYWxzZSxcbiAgY29tcG9uZW50OiBfcHJpbWl0aXZlcy5EaXZcbn07XG52YXIgX2RlZmF1bHQgPSBDb2w7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBoYXNXaWR0aCA9IGZ1bmN0aW9uIGhhc1dpZHRoKHdpZHRocykge1xuICByZXR1cm4gT2JqZWN0LmtleXMod2lkdGhzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3VyKSB7XG4gICAgcmV0dXJuIGFjYyB8fCB3aWR0aHNbY3VyXTtcbiAgfSwgZmFsc2UpO1xufTtcblxudmFyIGdldFdpZHRoID0gZnVuY3Rpb24gZ2V0V2lkdGgod2lkdGgsIGdyaWRDb2x1bW5zKSB7XG4gIGlmICh0eXBlb2Ygd2lkdGggIT09ICdudW1iZXInKSByZXR1cm4gdW5kZWZpbmVkO1xuICB2YXIgbm9ybWFsaXplZFdpZHRoID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZ3JpZENvbHVtbnMsIHdpZHRoKSk7XG4gIHJldHVybiBcIlwiLmNvbmNhdCgxMDAgLyBncmlkQ29sdW1ucyAqIG5vcm1hbGl6ZWRXaWR0aCwgXCIlXCIpO1xufTtcblxudmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQoX3JlZikge1xuICB2YXIgX3JlZiRmb3JjZVdpZHRoID0gX3JlZi5mb3JjZVdpZHRoLFxuICAgICAgZm9yY2VXaWR0aCA9IF9yZWYkZm9yY2VXaWR0aCA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkZm9yY2VXaWR0aCxcbiAgICAgIF9yZWYkd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgd2lkdGggPSBfcmVmJHdpZHRoID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkd2lkdGgsXG4gICAgICBfcmVmJG9mZnNldCA9IF9yZWYub2Zmc2V0LFxuICAgICAgb2Zmc2V0ID0gX3JlZiRvZmZzZXQgPT09IHZvaWQgMCA/IHt9IDogX3JlZiRvZmZzZXQsXG4gICAgICBfcmVmJHB1bGwgPSBfcmVmLnB1bGwsXG4gICAgICBwdWxsID0gX3JlZiRwdWxsID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkcHVsbCxcbiAgICAgIF9yZWYkcHVzaCA9IF9yZWYucHVzaCxcbiAgICAgIHB1c2ggPSBfcmVmJHB1c2ggPT09IHZvaWQgMCA/IHt9IDogX3JlZiRwdXNoLFxuICAgICAgZGVidWcgPSBfcmVmLmRlYnVnLFxuICAgICAgc2NyZWVuQ2xhc3MgPSBfcmVmLnNjcmVlbkNsYXNzLFxuICAgICAgZ3V0dGVyV2lkdGggPSBfcmVmLmd1dHRlcldpZHRoLFxuICAgICAgbW9yZVN0eWxlID0gX3JlZi5tb3JlU3R5bGUsXG4gICAgICBncmlkQ29sdW1ucyA9IF9yZWYuZ3JpZENvbHVtbnM7XG4gIHZhciBzdHlsZXMgPSB7XG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgbWluSGVpZ2h0OiAxLFxuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIHBhZGRpbmdMZWZ0OiBndXR0ZXJXaWR0aCAvIDIsXG4gICAgcGFkZGluZ1JpZ2h0OiBndXR0ZXJXaWR0aCAvIDIsXG4gICAgd2lkdGg6ICcxMDAlJ1xuICB9O1xuXG4gIGlmIChkZWJ1Zykge1xuICAgIHN0eWxlcy5vdXRsaW5lID0gJzFweCBzb2xpZCBzaWx2ZXInO1xuICAgIHN0eWxlcy5iYWNrZ3JvdW5kID0gJ3JnYmEoMCwwLDAsLjA1KSc7XG4gICAgc3R5bGVzLmxpbmVIZWlnaHQgPSAnMzJweCc7XG4gIH1cblxuICBzdHlsZXMuZmxleEJhc2lzID0gJzEwMCUnO1xuICBzdHlsZXMuZmxleEdyb3cgPSAwO1xuICBzdHlsZXMuZmxleFNocmluayA9IDA7XG4gIHN0eWxlcy5tYXhXaWR0aCA9ICcxMDAlJztcbiAgc3R5bGVzLm1hcmdpbkxlZnQgPSAnMCUnO1xuICBzdHlsZXMucmlnaHQgPSAnYXV0byc7XG4gIHN0eWxlcy5sZWZ0ID0gJ2F1dG8nO1xuXG4gIF91dGlscy5zY3JlZW5DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKHNpemUsIGluZGV4KSB7XG4gICAgaWYgKF91dGlscy5zY3JlZW5DbGFzc2VzLmluZGV4T2Yoc2NyZWVuQ2xhc3MpID49IGluZGV4KSB7XG4gICAgICB2YXIgY3VycmVudFdpZHRoID0gZ2V0V2lkdGgod2lkdGhbc2l6ZV0sIGdyaWRDb2x1bW5zKTtcbiAgICAgIHZhciBpc1NpemVkVG9Db250ZW50ID0gd2lkdGhbc2l6ZV0gPT09ICdjb250ZW50JztcbiAgICAgIHN0eWxlcy5mbGV4QmFzaXMgPSBpc1NpemVkVG9Db250ZW50ID8gJ2F1dG8nIDogY3VycmVudFdpZHRoIHx8IHN0eWxlcy5mbGV4QmFzaXM7XG4gICAgICBzdHlsZXMud2lkdGggPSBzdHlsZXMuZmxleEJhc2lzO1xuICAgICAgc3R5bGVzLm1heFdpZHRoID0gY3VycmVudFdpZHRoIHx8IHN0eWxlcy5tYXhXaWR0aDtcbiAgICAgIHN0eWxlcy5tYXJnaW5MZWZ0ID0gZ2V0V2lkdGgob2Zmc2V0W3NpemVdLCBncmlkQ29sdW1ucykgfHwgc3R5bGVzLm1hcmdpbkxlZnQ7XG4gICAgICBzdHlsZXMucmlnaHQgPSBnZXRXaWR0aChwdWxsW3NpemVdLCBncmlkQ29sdW1ucykgfHwgc3R5bGVzLnJpZ2h0O1xuICAgICAgc3R5bGVzLmxlZnQgPSBnZXRXaWR0aChwdXNoW3NpemVdLCBncmlkQ29sdW1ucykgfHwgc3R5bGVzLmxlZnQ7XG4gICAgfVxuICB9KTtcblxuICBpZiAoIWhhc1dpZHRoKHdpZHRoKSkge1xuICAgIHN0eWxlcy5mbGV4QmFzaXMgPSAwO1xuICAgIHN0eWxlcy5mbGV4R3JvdyA9IDE7XG4gIH1cblxuICBpZiAoZm9yY2VXaWR0aCkge1xuICAgIHN0eWxlcy5mbGV4QmFzaXMgPSAndW5zZXQnO1xuICAgIHN0eWxlcy5mbGV4R3JvdyA9ICd1bnNldCc7XG4gICAgc3R5bGVzLmZsZXhTaHJpbmsgPSAndW5zZXQnO1xuICAgIHN0eWxlcy53aWR0aCA9IGZvcmNlV2lkdGg7XG4gIH1cblxuICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdHlsZXMpLCBtb3JlU3R5bGUpO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfcHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG5cbnZhciBfc3R5bGUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9zdHlsZVwiKSk7XG5cbnZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NvbmZpZ1wiKTtcblxudmFyIF9TY3JlZW5DbGFzc1Jlc29sdmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vY29udGV4dC9TY3JlZW5DbGFzc1Jlc29sdmVyXCIpKTtcblxudmFyIF9wcmltaXRpdmVzID0gcmVxdWlyZShcIi4uLy4uL3ByaW1pdGl2ZXNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgQ29udGFpbmVyID0gZnVuY3Rpb24gQ29udGFpbmVyKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGZsdWlkID0gX3JlZi5mbHVpZCxcbiAgICAgIHhzID0gX3JlZi54cyxcbiAgICAgIHNtID0gX3JlZi5zbSxcbiAgICAgIG1kID0gX3JlZi5tZCxcbiAgICAgIGxnID0gX3JlZi5sZyxcbiAgICAgIHhsID0gX3JlZi54bCxcbiAgICAgIHh4bCA9IF9yZWYueHhsLFxuICAgICAgc3R5bGUgPSBfcmVmLnN0eWxlLFxuICAgICAgY29tcG9uZW50ID0gX3JlZi5jb21wb25lbnQsXG4gICAgICBvdGhlclByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiZmx1aWRcIiwgXCJ4c1wiLCBcInNtXCIsIFwibWRcIiwgXCJsZ1wiLCBcInhsXCIsIFwieHhsXCIsIFwic3R5bGVcIiwgXCJjb21wb25lbnRcIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfU2NyZWVuQ2xhc3NSZXNvbHZlci5kZWZhdWx0LCBudWxsLCBmdW5jdGlvbiAoc2NyZWVuQ2xhc3MpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLygwLCBfcmVhY3QuY3JlYXRlRWxlbWVudCkoY29tcG9uZW50LCBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIHN0eWxlOiAoMCwgX3N0eWxlLmRlZmF1bHQpKHtcbiAgICAgICAgZmx1aWQ6IGZsdWlkLFxuICAgICAgICB4czogeHMsXG4gICAgICAgIHNtOiBzbSxcbiAgICAgICAgbWQ6IG1kLFxuICAgICAgICBsZzogbGcsXG4gICAgICAgIHhsOiB4bCxcbiAgICAgICAgeHhsOiB4eGwsXG4gICAgICAgIHNjcmVlbkNsYXNzOiBzY3JlZW5DbGFzcyxcbiAgICAgICAgY29udGFpbmVyV2lkdGhzOiAoMCwgX2NvbmZpZy5nZXRDb25maWd1cmF0aW9uKSgpLmNvbnRhaW5lcldpZHRocyxcbiAgICAgICAgZ3V0dGVyV2lkdGg6ICgwLCBfY29uZmlnLmdldENvbmZpZ3VyYXRpb24pKCkuZ3V0dGVyV2lkdGgsXG4gICAgICAgIG1vcmVTdHlsZTogc3R5bGVcbiAgICAgIH0pXG4gICAgfSwgb3RoZXJQcm9wcyksIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbiwgLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3ByaW1pdGl2ZXMuU3Bhbiwge1xuICAgICAgc3R5bGU6ICgwLCBfc3R5bGUuZ2V0QWZ0ZXJTdHlsZSkoKVxuICAgIH0pKSk7XG4gIH0pO1xufTtcblxuQ29udGFpbmVyLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIENvbnRlbnQgb2YgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgY2hpbGRyZW46IF9wcm9wVHlwZXMuZGVmYXVsdC5ub2RlLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIFRydWUgbWFrZXMgdGhlIGNvbnRhaW5lciBmdWxsLXdpZHRoLCBmYWxzZSBmaXhlZC13aWR0aFxuICAgKi9cbiAgZmx1aWQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGluIGNvbWJpbmF0aW9uIHdpdGggZmx1aWQgZW5hYmxlZFxuICAgKiBUcnVlIG1ha2VzIGNvbnRhaW5lciBmbHVpZCBvbmx5IGluIHhzLCBub3QgcHJlc2VudCBtZWFucyBmbHVpZCBldmVyeXdoZXJlXG4gICAqL1xuICB4czogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgaW4gY29tYmluYXRpb24gd2l0aCBmbHVpZCBlbmFibGVkXG4gICAqIFRydWUgbWFrZXMgY29udGFpbmVyIGZsdWlkIG9ubHkgaW4gc20sIG5vdCBwcmVzZW50IG1lYW5zIGZsdWlkIGV2ZXJ5d2hlcmVcbiAgICovXG4gIHNtOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcblxuICAvKipcbiAgICogVGhpcyBpcyBpbiBjb21iaW5hdGlvbiB3aXRoIGZsdWlkIGVuYWJsZWRcbiAgICogVHJ1ZSBtYWtlcyBjb250YWluZXIgZmx1aWQgb25seSBpbiBtZCwgbm90IHByZXNlbnQgbWVhbnMgZmx1aWQgZXZlcnl3aGVyZVxuICAgKi9cbiAgbWQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGluIGNvbWJpbmF0aW9uIHdpdGggZmx1aWQgZW5hYmxlZFxuICAgKiBUcnVlIG1ha2VzIGNvbnRhaW5lciBmbHVpZCBvbmx5IGluIGxnLCBub3QgcHJlc2VudCBtZWFucyBmbHVpZCBldmVyeXdoZXJlXG4gICAqL1xuICBsZzogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgaW4gY29tYmluYXRpb24gd2l0aCBmbHVpZCBlbmFibGVkXG4gICAqIFRydWUgbWFrZXMgY29udGFpbmVyIGZsdWlkIG9ubHkgaW4geGwsIG5vdCBwcmVzZW50IG1lYW5zIGZsdWlkIGV2ZXJ5d2hlcmVcbiAgICovXG4gIHhsOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcblxuICAvKipcbiAgICogVGhpcyBpcyBpbiBjb21iaW5hdGlvbiB3aXRoIGZsdWlkIGVuYWJsZWRcbiAgICogVHJ1ZSBtYWtlcyBjb250YWluZXIgZmx1aWQgb25seSBpbiB4eGwsIG5vdCBwcmVzZW50IG1lYW5zIGZsdWlkIGV2ZXJ5d2hlcmVcbiAgICovXG4gIHh4bDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIHN0eWxpbmdcbiAgICovXG4gIHN0eWxlOiBfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0T2YoX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlciwgX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZ10pKSxcblxuICAvKipcbiAgICogVXNlIHlvdXIgb3duIGNvbXBvbmVudFxuICAgKi9cbiAgY29tcG9uZW50OiBfcHJvcFR5cGVzLmRlZmF1bHQuZWxlbWVudFR5cGVcbn07XG5Db250YWluZXIuZGVmYXVsdFByb3BzID0ge1xuICBmbHVpZDogZmFsc2UsXG4gIHhzOiBmYWxzZSxcbiAgc206IGZhbHNlLFxuICBtZDogZmFsc2UsXG4gIGxnOiBmYWxzZSxcbiAgeGw6IGZhbHNlLFxuICB4eGw6IGZhbHNlLFxuICBzdHlsZToge30sXG4gIGNvbXBvbmVudDogX3ByaW1pdGl2ZXMuRGl2XG59O1xudmFyIF9kZWZhdWx0ID0gQ29udGFpbmVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldEFmdGVyU3R5bGUgPSBleHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgX2RlZmF1bHQgPSBmdW5jdGlvbiBfZGVmYXVsdChfcmVmKSB7XG4gIHZhciBmbHVpZCA9IF9yZWYuZmx1aWQsXG4gICAgICB4cyA9IF9yZWYueHMsXG4gICAgICBzbSA9IF9yZWYuc20sXG4gICAgICBtZCA9IF9yZWYubWQsXG4gICAgICBsZyA9IF9yZWYubGcsXG4gICAgICB4bCA9IF9yZWYueGwsXG4gICAgICB4eGwgPSBfcmVmLnh4bCxcbiAgICAgIHNjcmVlbkNsYXNzID0gX3JlZi5zY3JlZW5DbGFzcyxcbiAgICAgIGNvbnRhaW5lcldpZHRocyA9IF9yZWYuY29udGFpbmVyV2lkdGhzLFxuICAgICAgZ3V0dGVyV2lkdGggPSBfcmVmLmd1dHRlcldpZHRoLFxuICAgICAgbW9yZVN0eWxlID0gX3JlZi5tb3JlU3R5bGU7XG4gIHZhciBzdHlsZXMgPSB7XG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgbWFyZ2luTGVmdDogJ2F1dG8nLFxuICAgIG1hcmdpblJpZ2h0OiAnYXV0bycsXG4gICAgcGFkZGluZ0xlZnQ6IGd1dHRlcldpZHRoIC8gMixcbiAgICBwYWRkaW5nUmlnaHQ6IGd1dHRlcldpZHRoIC8gMlxuICB9O1xuXG4gIGlmIChmbHVpZCAmJiAhc20gJiYgIW1kICYmICFsZyAmJiAheGwpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdHlsZXMpLCBtb3JlU3R5bGUpO1xuICB9XG5cbiAgaWYgKHNjcmVlbkNsYXNzID09PSAnc20nICYmIGNvbnRhaW5lcldpZHRoc1swXSAmJiAhc20gJiYgIXhzKSB7XG4gICAgc3R5bGVzLm1heFdpZHRoID0gY29udGFpbmVyV2lkdGhzWzBdO1xuICB9XG5cbiAgaWYgKHNjcmVlbkNsYXNzID09PSAnbWQnICYmIGNvbnRhaW5lcldpZHRoc1sxXSAmJiAhbWQpIHtcbiAgICBzdHlsZXMubWF4V2lkdGggPSBjb250YWluZXJXaWR0aHNbMV07XG4gIH1cblxuICBpZiAoc2NyZWVuQ2xhc3MgPT09ICdsZycgJiYgY29udGFpbmVyV2lkdGhzWzJdICYmICFsZykge1xuICAgIHN0eWxlcy5tYXhXaWR0aCA9IGNvbnRhaW5lcldpZHRoc1syXTtcbiAgfVxuXG4gIGlmIChzY3JlZW5DbGFzcyA9PT0gJ3hsJyAmJiBjb250YWluZXJXaWR0aHNbM10gJiYgIXhsKSB7XG4gICAgc3R5bGVzLm1heFdpZHRoID0gY29udGFpbmVyV2lkdGhzWzNdO1xuICB9XG5cbiAgaWYgKHNjcmVlbkNsYXNzID09PSAneHhsJyAmJiBjb250YWluZXJXaWR0aHNbNF0gJiYgIXh4bCkge1xuICAgIHN0eWxlcy5tYXhXaWR0aCA9IGNvbnRhaW5lcldpZHRoc1s0XTtcbiAgfVxuXG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0eWxlcyksIG1vcmVTdHlsZSk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcblxudmFyIGdldEFmdGVyU3R5bGUgPSBmdW5jdGlvbiBnZXRBZnRlclN0eWxlKCkge1xuICByZXR1cm4ge1xuICAgIGRpc3BsYXk6ICd0YWJsZScsXG4gICAgY2xlYXI6ICdib3RoJ1xuICB9O1xufTtcblxuZXhwb3J0cy5nZXRBZnRlclN0eWxlID0gZ2V0QWZ0ZXJTdHlsZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuR3V0dGVyV2lkdGhDb250ZXh0ID0gdm9pZCAwO1xuXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuXG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jb25maWdcIik7XG5cbnZhciBfc3R5bGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0eWxlXCIpKTtcblxudmFyIF9wcmltaXRpdmVzID0gcmVxdWlyZShcIi4uLy4uL3ByaW1pdGl2ZXNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgR3V0dGVyV2lkdGhDb250ZXh0ID0gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUNvbnRleHQoZmFsc2UpO1xuXG5leHBvcnRzLkd1dHRlcldpZHRoQ29udGV4dCA9IEd1dHRlcldpZHRoQ29udGV4dDtcblxudmFyIFJvdyA9IGZ1bmN0aW9uIFJvdyhfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBzdHlsZSA9IF9yZWYuc3R5bGUsXG4gICAgICBhbGlnbiA9IF9yZWYuYWxpZ24sXG4gICAgICBqdXN0aWZ5ID0gX3JlZi5qdXN0aWZ5LFxuICAgICAgZGVidWcgPSBfcmVmLmRlYnVnLFxuICAgICAgbm9ndXR0ZXIgPSBfcmVmLm5vZ3V0dGVyLFxuICAgICAgZ3V0dGVyV2lkdGggPSBfcmVmLmd1dHRlcldpZHRoLFxuICAgICAgY29tcG9uZW50ID0gX3JlZi5jb21wb25lbnQsXG4gICAgICBub3dyYXAgPSBfcmVmLm5vd3JhcCxcbiAgICAgIG90aGVyUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiY2hpbGRyZW5cIiwgXCJzdHlsZVwiLCBcImFsaWduXCIsIFwianVzdGlmeVwiLCBcImRlYnVnXCIsIFwibm9ndXR0ZXJcIiwgXCJndXR0ZXJXaWR0aFwiLCBcImNvbXBvbmVudFwiLCBcIm5vd3JhcFwiXSk7XG5cbiAgdmFyIHRoZUd1dHRlcldpZHRoID0gKDAsIF9jb25maWcuZ2V0Q29uZmlndXJhdGlvbikoKS5ndXR0ZXJXaWR0aDtcbiAgaWYgKG5vZ3V0dGVyKSB0aGVHdXR0ZXJXaWR0aCA9IDA7XG4gIGlmICh0eXBlb2YgZ3V0dGVyV2lkdGggPT09ICdudW1iZXInKSB0aGVHdXR0ZXJXaWR0aCA9IGd1dHRlcldpZHRoO1xuICB2YXIgdGhlU3R5bGUgPSAoMCwgX3N0eWxlLmRlZmF1bHQpKHtcbiAgICBndXR0ZXJXaWR0aDogdGhlR3V0dGVyV2lkdGgsXG4gICAgYWxpZ246IGFsaWduLFxuICAgIGp1c3RpZnk6IGp1c3RpZnksXG4gICAgZGVidWc6IGRlYnVnLFxuICAgIG1vcmVTdHlsZTogc3R5bGUsXG4gICAgbm93cmFwOiBub3dyYXBcbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChjb21wb25lbnQsIF9vYmplY3RTcHJlYWQoe1xuICAgIHN0eWxlOiB0aGVTdHlsZVxuICB9LCBvdGhlclByb3BzKSwgLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoR3V0dGVyV2lkdGhDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHRoZUd1dHRlcldpZHRoXG4gIH0sIGNoaWxkcmVuKSk7XG59O1xuXG5Sb3cucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogQ29udGVudCBvZiB0aGUgZWxlbWVudFxuICAgKi9cbiAgY2hpbGRyZW46IF9wcm9wVHlwZXMuZGVmYXVsdC5ub2RlLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIFZlcnRpY2FsIGNvbHVtbiBhbGlnbm1lbnRcbiAgICovXG4gIGFsaWduOiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2YoWydub3JtYWwnLCAnc3RhcnQnLCAnY2VudGVyJywgJ2VuZCcsICdzdHJldGNoJ10pLFxuXG4gIC8qKlxuICAgKiBIb3Jpem9udGFsIGNvbHVtbiBhbGlnbm1lbnRcbiAgICovXG4gIGp1c3RpZnk6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbJ3N0YXJ0JywgJ2NlbnRlcicsICdlbmQnLCAnYmV0d2VlbicsICdhcm91bmQnLCAnaW5pdGlhbCcsICdpbmhlcml0J10pLFxuXG4gIC8qKlxuICAgKiBObyBndXR0ZXIgZm9yIHRoaXMgcm93XG4gICAqL1xuICBub2d1dHRlcjogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIEN1c3RvbSBndXR0ZXIgd2lkdGggZm9yIHRoaXMgcm93XG4gICAqL1xuICBndXR0ZXJXaWR0aDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcblxuICAvKipcbiAgICogT3B0aW9uYWwgc3R5bGluZ1xuICAgKi9cbiAgc3R5bGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5vYmplY3RPZihfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLCBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nXSkpLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gYXBwbHkgc29tZSBkZWJ1ZyBzdHlsaW5nXG4gICAqL1xuICBkZWJ1ZzogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIFVzZSB5b3VyIG93biBjb21wb25lbnRcbiAgICovXG4gIGNvbXBvbmVudDogX3Byb3BUeXBlcy5kZWZhdWx0LmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBjb2xzIHNob3VsZCBub3Qgd3JhcFxuICAgKi9cbiAgbm93cmFwOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbFxufTtcblJvdy5kZWZhdWx0UHJvcHMgPSB7XG4gIGFsaWduOiAnbm9ybWFsJyxcbiAganVzdGlmeTogJ3N0YXJ0JyxcbiAgbm9ndXR0ZXI6IGZhbHNlLFxuICBndXR0ZXJXaWR0aDogbnVsbCxcbiAgc3R5bGU6IHt9LFxuICBkZWJ1ZzogZmFsc2UsXG4gIGNvbXBvbmVudDogX3ByaW1pdGl2ZXMuRGl2LFxuICBub3dyYXA6IGZhbHNlXG59O1xudmFyIF9kZWZhdWx0ID0gUm93O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgX2RlZmF1bHQgPSBmdW5jdGlvbiBfZGVmYXVsdChfcmVmKSB7XG4gIHZhciBndXR0ZXJXaWR0aCA9IF9yZWYuZ3V0dGVyV2lkdGgsXG4gICAgICBhbGlnbiA9IF9yZWYuYWxpZ24sXG4gICAgICBqdXN0aWZ5ID0gX3JlZi5qdXN0aWZ5LFxuICAgICAgZGVidWcgPSBfcmVmLmRlYnVnLFxuICAgICAgbW9yZVN0eWxlID0gX3JlZi5tb3JlU3R5bGUsXG4gICAgICBub3dyYXAgPSBfcmVmLm5vd3JhcDtcbiAgLy8gVmVydGljYWwgYWxpZ25tZW50XG4gIHZhciBhbGlnbkl0ZW1zID0gYWxpZ247XG4gIGlmIChhbGlnbiA9PT0gJ3N0YXJ0JykgYWxpZ25JdGVtcyA9ICdmbGV4LXN0YXJ0JztcbiAgaWYgKGFsaWduID09PSAnZW5kJykgYWxpZ25JdGVtcyA9ICdmbGV4LWVuZCc7IC8vIEhvcml6b250YWwgYWxpZ25tZW50XG5cbiAgdmFyIGp1c3RpZnlDb250ZW50ID0ganVzdGlmeTtcbiAgaWYgKGp1c3RpZnkgPT09ICdzdGFydCcpIGp1c3RpZnlDb250ZW50ID0gJ2ZsZXgtc3RhcnQnO1xuICBpZiAoanVzdGlmeSA9PT0gJ2VuZCcpIGp1c3RpZnlDb250ZW50ID0gJ2ZsZXgtZW5kJztcbiAgaWYgKGp1c3RpZnkgPT09ICdiZXR3ZWVuJykganVzdGlmeUNvbnRlbnQgPSAnc3BhY2UtYmV0d2Vlbic7XG4gIGlmIChqdXN0aWZ5ID09PSAnYXJvdW5kJykganVzdGlmeUNvbnRlbnQgPSAnc3BhY2UtYXJvdW5kJztcbiAgaWYgKGp1c3RpZnkgPT09ICdjZW50ZXInKSBqdXN0aWZ5Q29udGVudCA9ICdjZW50ZXInO1xuICBpZiAoanVzdGlmeSA9PT0gJ2luaXRpYWwnKSBqdXN0aWZ5Q29udGVudCA9ICdpbml0aWFsJztcbiAgaWYgKGp1c3RpZnkgPT09ICdpbmhlcml0JykganVzdGlmeUNvbnRlbnQgPSAnaW5oZXJpdCc7XG4gIHZhciBzdHlsZXMgPSB7XG4gICAgbWFyZ2luTGVmdDogLWd1dHRlcldpZHRoIC8gMixcbiAgICBtYXJnaW5SaWdodDogLWd1dHRlcldpZHRoIC8gMixcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgZmxleFdyYXA6IG5vd3JhcCA/ICdub3dyYXAnIDogJ3dyYXAnLFxuICAgIGZsZXhHcm93OiAwLFxuICAgIGZsZXhTaHJpbms6IDAsXG4gICAgYWxpZ25JdGVtczogYWxpZ25JdGVtcyxcbiAgICBqdXN0aWZ5Q29udGVudDoganVzdGlmeUNvbnRlbnRcbiAgfTtcblxuICBpZiAoZGVidWcpIHtcbiAgICBzdHlsZXMuYmFja2dyb3VuZCA9ICdyZ2JhKDEyOCwxMjgsMTI4LC4wNSknO1xuICB9XG5cbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3R5bGVzKSwgbW9yZVN0eWxlKTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2xcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0NvbC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRhaW5lclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfQ29udGFpbmVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUm93XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Sb3cuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIaWRkZW5cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0hpZGRlbi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZpc2libGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1Zpc2libGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTY3JlZW5DbGFzc1JlbmRlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfU2NyZWVuQ2xhc3NSZW5kZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTY3JlZW5DbGFzc1Byb3ZpZGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9TY3JlZW5DbGFzc1Byb3ZpZGVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2NyZWVuQ2xhc3NDb250ZXh0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9TY3JlZW5DbGFzc1Byb3ZpZGVyLlNjcmVlbkNsYXNzQ29udGV4dDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZXRDb25maWd1cmF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jb25maWcuc2V0Q29uZmlndXJhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1c2VTY3JlZW5DbGFzc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdXRpbHMudXNlU2NyZWVuQ2xhc3M7XG4gIH1cbn0pO1xuXG52YXIgX0NvbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZ3JpZC9Db2xcIikpO1xuXG52YXIgX0NvbnRhaW5lciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZ3JpZC9Db250YWluZXJcIikpO1xuXG52YXIgX1JvdyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZ3JpZC9Sb3dcIikpO1xuXG52YXIgX0hpZGRlbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbGl0aWVzL0hpZGRlblwiKSk7XG5cbnZhciBfVmlzaWJsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbGl0aWVzL1Zpc2libGVcIikpO1xuXG52YXIgX1NjcmVlbkNsYXNzUmVuZGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlsaXRpZXMvU2NyZWVuQ2xhc3NSZW5kZXJcIikpO1xuXG52YXIgX1NjcmVlbkNsYXNzUHJvdmlkZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9jb250ZXh0L1NjcmVlbkNsYXNzUHJvdmlkZXJcIikpO1xuXG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9kZWZhdWx0ID0gJ2Rpdic7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZGVmYXVsdCA9ICdzcGFuJztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG4vKiBnbG9iYWwgd2luZG93ICovXG52YXIgX2RlZmF1bHQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaXZcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0Rpdi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNwYW5cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1NwYW4uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXaW5kb3dcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1dpbmRvdy5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9EaXYgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0RpdlwiKSk7XG5cbnZhciBfU3BhbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vU3BhblwiKSk7XG5cbnZhciBfV2luZG93ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9XaW5kb3dcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfSIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfcHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG5cbnZhciBzdHlsZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3N0eWxlXCIpKTtcblxudmFyIF9TY3JlZW5DbGFzc1Jlc29sdmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vY29udGV4dC9TY3JlZW5DbGFzc1Jlc29sdmVyXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIEhpZGRlbiA9IGZ1bmN0aW9uIEhpZGRlbihfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICB4cyA9IF9yZWYueHMsXG4gICAgICBzbSA9IF9yZWYuc20sXG4gICAgICBtZCA9IF9yZWYubWQsXG4gICAgICBsZyA9IF9yZWYubGcsXG4gICAgICB4bCA9IF9yZWYueGwsXG4gICAgICB4eGwgPSBfcmVmLnh4bDtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9TY3JlZW5DbGFzc1Jlc29sdmVyLmRlZmF1bHQsIG51bGwsIGZ1bmN0aW9uIChzY3JlZW5DbGFzcykge1xuICAgIHJldHVybiBzdHlsZS5oaWRkZW4oe1xuICAgICAgc2NyZWVuQ2xhc3M6IHNjcmVlbkNsYXNzLFxuICAgICAgeHM6IHhzLFxuICAgICAgc206IHNtLFxuICAgICAgbWQ6IG1kLFxuICAgICAgbGc6IGxnLFxuICAgICAgeGw6IHhsLFxuICAgICAgeHhsOiB4eGxcbiAgICB9KSA/IG51bGwgOiBjaGlsZHJlbjtcbiAgfSk7XG59O1xuXG5IaWRkZW4ucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogQ29udGVudCBvZiB0aGUgY29tcG9uZW50XG4gICAqL1xuICBjaGlsZHJlbjogX3Byb3BUeXBlcy5kZWZhdWx0Lm5vZGUuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogSGlkZSBvbiBleHRyYSBzbWFsbCBkZXZpY2VzXG4gICAqL1xuICB4czogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIEhpZGUgb24gc21hbGwgZGV2aWNlc1xuICAgKi9cbiAgc206IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBIaWRlIG9uIG1lZGl1bSBkZXZpY2VzXG4gICAqL1xuICBtZDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIEhpZGUgb24gbGFyZ2UgZGV2aWNlc1xuICAgKi9cbiAgbGc6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBIaWRlIG9uIHhsYXJnZSBkZXZpY2VzXG4gICAqL1xuICB4bDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIEhpZGUgb24geHhsYXJnZSBkZXZpY2VzXG4gICAqL1xuICB4eGw6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sXG59O1xuSGlkZGVuLmRlZmF1bHRQcm9wcyA9IHtcbiAgeHM6IGZhbHNlLFxuICBzbTogZmFsc2UsXG4gIG1kOiBmYWxzZSxcbiAgbGc6IGZhbHNlLFxuICB4bDogZmFsc2UsXG4gIHh4bDogZmFsc2Vcbn07XG52YXIgX2RlZmF1bHQgPSBIaWRkZW47XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuaGlkZGVuID0gdm9pZCAwO1xuXG52YXIgaGlkZGVuID0gZnVuY3Rpb24gaGlkZGVuKF9yZWYpIHtcbiAgdmFyIHNjcmVlbkNsYXNzID0gX3JlZi5zY3JlZW5DbGFzcyxcbiAgICAgIHhzID0gX3JlZi54cyxcbiAgICAgIHNtID0gX3JlZi5zbSxcbiAgICAgIG1kID0gX3JlZi5tZCxcbiAgICAgIGxnID0gX3JlZi5sZyxcbiAgICAgIHhsID0gX3JlZi54bCxcbiAgICAgIHh4bCA9IF9yZWYueHhsO1xuICBpZiAoc2NyZWVuQ2xhc3MgPT09ICd4eGwnKSByZXR1cm4geHhsO1xuICBpZiAoc2NyZWVuQ2xhc3MgPT09ICd4bCcpIHJldHVybiB4bDtcbiAgaWYgKHNjcmVlbkNsYXNzID09PSAnbGcnKSByZXR1cm4gbGc7XG4gIGlmIChzY3JlZW5DbGFzcyA9PT0gJ21kJykgcmV0dXJuIG1kO1xuICBpZiAoc2NyZWVuQ2xhc3MgPT09ICdzbScpIHJldHVybiBzbTtcbiAgcmV0dXJuIHhzO1xufTtcblxuZXhwb3J0cy5oaWRkZW4gPSBoaWRkZW47XG52YXIgX2RlZmF1bHQgPSBoaWRkZW47XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcblxudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcblxudmFyIF9TY3JlZW5DbGFzc1Jlc29sdmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vY29udGV4dC9TY3JlZW5DbGFzc1Jlc29sdmVyXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFNjcmVlbkNsYXNzUmVuZGVyID0gZnVuY3Rpb24gU2NyZWVuQ2xhc3NSZW5kZXIoX3JlZikge1xuICB2YXIgcmVuZGVyID0gX3JlZi5yZW5kZXI7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfU2NyZWVuQ2xhc3NSZXNvbHZlci5kZWZhdWx0LCBudWxsLCBmdW5jdGlvbiAoc2NyZWVuQ2xhc3MpIHtcbiAgICByZXR1cm4gcmVuZGVyKHNjcmVlbkNsYXNzKTtcbiAgfSk7XG59O1xuXG5TY3JlZW5DbGFzc1JlbmRlci5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gd2hpY2ggcmV0dXJuIHZhbHVlIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAqIFdpbGwgYmUgY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50OiB0aGUgc2NyZWVuIGNsYXNzLlxuICAgKi9cbiAgcmVuZGVyOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYy5pc1JlcXVpcmVkXG59O1xudmFyIF9kZWZhdWx0ID0gU2NyZWVuQ2xhc3NSZW5kZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuXG52YXIgc3R5bGUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9zdHlsZVwiKSk7XG5cbnZhciBfU2NyZWVuQ2xhc3NSZXNvbHZlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL2NvbnRleHQvU2NyZWVuQ2xhc3NSZXNvbHZlclwiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBWaXNpYmxlID0gZnVuY3Rpb24gVmlzaWJsZShfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICB4cyA9IF9yZWYueHMsXG4gICAgICBzbSA9IF9yZWYuc20sXG4gICAgICBtZCA9IF9yZWYubWQsXG4gICAgICBsZyA9IF9yZWYubGcsXG4gICAgICB4bCA9IF9yZWYueGwsXG4gICAgICB4eGwgPSBfcmVmLnh4bDtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9TY3JlZW5DbGFzc1Jlc29sdmVyLmRlZmF1bHQsIG51bGwsIGZ1bmN0aW9uIChzY3JlZW5DbGFzcykge1xuICAgIHJldHVybiAhc3R5bGUudmlzaWJsZSh7XG4gICAgICBzY3JlZW5DbGFzczogc2NyZWVuQ2xhc3MsXG4gICAgICB4czogeHMsXG4gICAgICBzbTogc20sXG4gICAgICBtZDogbWQsXG4gICAgICBsZzogbGcsXG4gICAgICB4bDogeGwsXG4gICAgICB4eGw6IHh4bFxuICAgIH0pID8gbnVsbCA6IGNoaWxkcmVuO1xuICB9KTtcbn07XG5cblZpc2libGUucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogQ29udGVudCBvZiB0aGUgY29tcG9uZW50XG4gICAqL1xuICBjaGlsZHJlbjogX3Byb3BUeXBlcy5kZWZhdWx0Lm5vZGUuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogU2hvdyBvbiBleHRyYSBzbWFsbCBkZXZpY2VzXG4gICAqL1xuICB4czogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIFNob3cgb24gc21hbGwgZGV2aWNlc1xuICAgKi9cbiAgc206IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBTaG93IG9uIG1lZGl1bSBkZXZpY2VzXG4gICAqL1xuICBtZDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIFNob3cgb24gbGFyZ2UgZGV2aWNlc1xuICAgKi9cbiAgbGc6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBTaG93IG9uIHhsYXJnZSBkZXZpY2VzXG4gICAqL1xuICB4bDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG5cbiAgLyoqXG4gICAqIFNob3cgb24geHhsYXJnZSBkZXZpY2VzXG4gICAqL1xuICB4eGw6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sXG59O1xuVmlzaWJsZS5kZWZhdWx0UHJvcHMgPSB7XG4gIHhzOiBmYWxzZSxcbiAgc206IGZhbHNlLFxuICBtZDogZmFsc2UsXG4gIGxnOiBmYWxzZSxcbiAgeGw6IGZhbHNlLFxuICB4eGw6IGZhbHNlXG59O1xudmFyIF9kZWZhdWx0ID0gVmlzaWJsZTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy52aXNpYmxlID0gdm9pZCAwO1xuXG52YXIgdmlzaWJsZSA9IGZ1bmN0aW9uIHZpc2libGUoX3JlZikge1xuICB2YXIgc2NyZWVuQ2xhc3MgPSBfcmVmLnNjcmVlbkNsYXNzLFxuICAgICAgeHMgPSBfcmVmLnhzLFxuICAgICAgc20gPSBfcmVmLnNtLFxuICAgICAgbWQgPSBfcmVmLm1kLFxuICAgICAgbGcgPSBfcmVmLmxnLFxuICAgICAgeGwgPSBfcmVmLnhsLFxuICAgICAgeHhsID0gX3JlZi54eGw7XG4gIGlmIChzY3JlZW5DbGFzcyA9PT0gJ3h4bCcpIHJldHVybiB4eGw7XG4gIGlmIChzY3JlZW5DbGFzcyA9PT0gJ3hsJykgcmV0dXJuIHhsO1xuICBpZiAoc2NyZWVuQ2xhc3MgPT09ICdsZycpIHJldHVybiBsZztcbiAgaWYgKHNjcmVlbkNsYXNzID09PSAnbWQnKSByZXR1cm4gbWQ7XG4gIGlmIChzY3JlZW5DbGFzcyA9PT0gJ3NtJykgcmV0dXJuIHNtO1xuICByZXR1cm4geHM7XG59O1xuXG5leHBvcnRzLnZpc2libGUgPSB2aXNpYmxlO1xudmFyIF9kZWZhdWx0ID0gdmlzaWJsZTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy51c2VTY3JlZW5DbGFzcyA9IGV4cG9ydHMuc2NyZWVuQ2xhc3NlcyA9IHZvaWQgMDtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxudmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi9jb25maWdcIik7XG5cbnZhciBfcHJpbWl0aXZlcyA9IHJlcXVpcmUoXCIuL3ByaW1pdGl2ZXNcIik7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbnZhciBnZXRWaWV3UG9ydCA9IGZ1bmN0aW9uIGdldFZpZXdQb3J0KHNvdXJjZSkge1xuICBpZiAoc291cmNlICYmIHNvdXJjZS5jdXJyZW50ICYmIHNvdXJjZS5jdXJyZW50LmNsaWVudFdpZHRoKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5jdXJyZW50LmNsaWVudFdpZHRoO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBfcHJpbWl0aXZlcy5XaW5kb3cgIT09ICd1bmRlZmluZWQnICYmIF9wcmltaXRpdmVzLldpbmRvdy5pbm5lcldpZHRoKSB7XG4gICAgcmV0dXJuIF9wcmltaXRpdmVzLldpbmRvdy5pbm5lcldpZHRoO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG52YXIgc2NyZWVuQ2xhc3NlcyA9IFsneHMnLCAnc20nLCAnbWQnLCAnbGcnLCAneGwnLCAneHhsJ107XG5leHBvcnRzLnNjcmVlbkNsYXNzZXMgPSBzY3JlZW5DbGFzc2VzO1xuXG52YXIgdXNlU2NyZWVuQ2xhc3MgPSBmdW5jdGlvbiB1c2VTY3JlZW5DbGFzcyhzb3VyY2UsIGZhbGxiYWNrU2NyZWVuQ2xhc3MpIHtcbiAgdmFyIGdldFNjcmVlbkNsYXNzID0gZnVuY3Rpb24gZ2V0U2NyZWVuQ2xhc3MoKSB7XG4gICAgdmFyIF9nZXRDb25maWd1cmF0aW9uID0gKDAsIF9jb25maWcuZ2V0Q29uZmlndXJhdGlvbikoKSxcbiAgICAgICAgYnJlYWtwb2ludHMgPSBfZ2V0Q29uZmlndXJhdGlvbi5icmVha3BvaW50cyxcbiAgICAgICAgZGVmYXVsdFNjcmVlbkNsYXNzID0gX2dldENvbmZpZ3VyYXRpb24uZGVmYXVsdFNjcmVlbkNsYXNzLFxuICAgICAgICBtYXhTY3JlZW5DbGFzcyA9IF9nZXRDb25maWd1cmF0aW9uLm1heFNjcmVlbkNsYXNzO1xuXG4gICAgdmFyIG5ld1NjcmVlbkNsYXNzID0gZGVmYXVsdFNjcmVlbkNsYXNzO1xuICAgIHZhciB2aWV3cG9ydCA9IGdldFZpZXdQb3J0KHNvdXJjZSk7XG5cbiAgICBpZiAodmlld3BvcnQpIHtcbiAgICAgIG5ld1NjcmVlbkNsYXNzID0gJ3hzJztcbiAgICAgIGlmIChicmVha3BvaW50c1swXSAmJiB2aWV3cG9ydCA+PSBicmVha3BvaW50c1swXSkgbmV3U2NyZWVuQ2xhc3MgPSAnc20nO1xuICAgICAgaWYgKGJyZWFrcG9pbnRzWzFdICYmIHZpZXdwb3J0ID49IGJyZWFrcG9pbnRzWzFdKSBuZXdTY3JlZW5DbGFzcyA9ICdtZCc7XG4gICAgICBpZiAoYnJlYWtwb2ludHNbMl0gJiYgdmlld3BvcnQgPj0gYnJlYWtwb2ludHNbMl0pIG5ld1NjcmVlbkNsYXNzID0gJ2xnJztcbiAgICAgIGlmIChicmVha3BvaW50c1szXSAmJiB2aWV3cG9ydCA+PSBicmVha3BvaW50c1szXSkgbmV3U2NyZWVuQ2xhc3MgPSAneGwnO1xuICAgICAgaWYgKGJyZWFrcG9pbnRzWzRdICYmIHZpZXdwb3J0ID49IGJyZWFrcG9pbnRzWzRdKSBuZXdTY3JlZW5DbGFzcyA9ICd4eGwnO1xuICAgIH0gZWxzZSBpZiAoZmFsbGJhY2tTY3JlZW5DbGFzcykge1xuICAgICAgbmV3U2NyZWVuQ2xhc3MgPSBmYWxsYmFja1NjcmVlbkNsYXNzO1xuICAgIH1cblxuICAgIHZhciBuZXdTY3JlZW5DbGFzc0luZGV4ID0gc2NyZWVuQ2xhc3Nlcy5pbmRleE9mKG5ld1NjcmVlbkNsYXNzKTtcbiAgICB2YXIgbWF4U2NyZWVuQ2xhc3NJbmRleCA9IHNjcmVlbkNsYXNzZXMuaW5kZXhPZihtYXhTY3JlZW5DbGFzcyk7XG5cbiAgICBpZiAobWF4U2NyZWVuQ2xhc3NJbmRleCA+PSAwICYmIG5ld1NjcmVlbkNsYXNzSW5kZXggPiBtYXhTY3JlZW5DbGFzc0luZGV4KSB7XG4gICAgICBuZXdTY3JlZW5DbGFzcyA9IHNjcmVlbkNsYXNzZXNbbWF4U2NyZWVuQ2xhc3NJbmRleF07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1NjcmVlbkNsYXNzO1xuICB9O1xuXG4gIHZhciBfdXNlU3RhdGUgPSAoMCwgX3JlYWN0LnVzZVN0YXRlKShnZXRTY3JlZW5DbGFzcygpKSxcbiAgICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgICAgc2NyZWVuQ2xhc3MgPSBfdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0U2NyZWVuQ2xhc3MgPSBfdXNlU3RhdGUyWzFdO1xuXG4gICgwLCBfcmVhY3QudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZVdpbmRvd1Jlc2l6ZWQgPSBmdW5jdGlvbiBoYW5kbGVXaW5kb3dSZXNpemVkKCkge1xuICAgICAgcmV0dXJuIHNldFNjcmVlbkNsYXNzKGdldFNjcmVlbkNsYXNzKCkpO1xuICAgIH07XG5cbiAgICBfcHJpbWl0aXZlcy5XaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlV2luZG93UmVzaXplZCwgZmFsc2UpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIF9wcmltaXRpdmVzLldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVXaW5kb3dSZXNpemVkLCBmYWxzZSk7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gc2NyZWVuQ2xhc3M7XG59O1xuXG5leHBvcnRzLnVzZVNjcmVlbkNsYXNzID0gdXNlU2NyZWVuQ2xhc3M7IiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7IC8vIFRPRE86IFdlIGRvbid0IHVzZSBBc3luY01vZGUgb3IgQ29uY3VycmVudE1vZGUgYW55bW9yZS4gVGhleSB3ZXJlIHRlbXBvcmFyeVxuLy8gKHVuc3RhYmxlKSBBUElzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuIENhbiB3ZSByZW1vdmUgdGhlIHN5bWJvbHM/XG5cbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0JykgOiAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYmxvY2snKSA6IDB4ZWFkOTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcbnZhciBSRUFDVF9SRVNQT05ERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnJlc3BvbmRlcicpIDogMHhlYWQ2O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpIDogMHhlYWQ3O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9SRVNQT05ERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9TQ09QRV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUpO1xufVxuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG5cbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0gLy8gQXN5bmNNb2RlIGlzIGRlcHJlY2F0ZWQgYWxvbmcgd2l0aCBpc0FzeW5jTW9kZVxuXG52YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTsgLy8gQXN5bmNNb2RlIHNob3VsZCBiZSBkZXByZWNhdGVkXG5cbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkgfHwgdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9WSURFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTEFaWV9UWVBFO1xufVxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX01FTU9fVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BPUlRBTF9UWVBFO1xufVxuZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG59XG5cbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsImZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGN4IGZyb20gJ2Nsc3gnO1xudmFyIERFRkFVTFRfQ0xBU1MgPSAncmVhY3QtdGFic19fdGFiJztcblxudmFyIFRhYiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShUYWIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRhYigpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVGFiLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLmNoZWNrRm9jdXMoKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHRoaXMuY2hlY2tGb2N1cygpO1xuICB9O1xuXG4gIF9wcm90by5jaGVja0ZvY3VzID0gZnVuY3Rpb24gY2hlY2tGb2N1cygpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBzZWxlY3RlZCA9IF90aGlzJHByb3BzLnNlbGVjdGVkLFxuICAgICAgICBmb2N1cyA9IF90aGlzJHByb3BzLmZvY3VzO1xuXG4gICAgaWYgKHNlbGVjdGVkICYmIGZvY3VzKSB7XG4gICAgICB0aGlzLm5vZGUuZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX2N4LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczIuY2hpbGRyZW4sXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzMi5jbGFzc05hbWUsXG4gICAgICAgIGRpc2FibGVkID0gX3RoaXMkcHJvcHMyLmRpc2FibGVkLFxuICAgICAgICBkaXNhYmxlZENsYXNzTmFtZSA9IF90aGlzJHByb3BzMi5kaXNhYmxlZENsYXNzTmFtZSxcbiAgICAgICAgZm9jdXMgPSBfdGhpcyRwcm9wczIuZm9jdXMsXG4gICAgICAgIGlkID0gX3RoaXMkcHJvcHMyLmlkLFxuICAgICAgICBwYW5lbElkID0gX3RoaXMkcHJvcHMyLnBhbmVsSWQsXG4gICAgICAgIHNlbGVjdGVkID0gX3RoaXMkcHJvcHMyLnNlbGVjdGVkLFxuICAgICAgICBzZWxlY3RlZENsYXNzTmFtZSA9IF90aGlzJHByb3BzMi5zZWxlY3RlZENsYXNzTmFtZSxcbiAgICAgICAgdGFiSW5kZXggPSBfdGhpcyRwcm9wczIudGFiSW5kZXgsXG4gICAgICAgIHRhYlJlZiA9IF90aGlzJHByb3BzMi50YWJSZWYsXG4gICAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wczIsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZENsYXNzTmFtZVwiLCBcImZvY3VzXCIsIFwiaWRcIiwgXCJwYW5lbElkXCIsIFwic2VsZWN0ZWRcIiwgXCJzZWxlY3RlZENsYXNzTmFtZVwiLCBcInRhYkluZGV4XCIsIFwidGFiUmVmXCJdKTtcblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpXCIsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgICBjbGFzc05hbWU6IGN4KGNsYXNzTmFtZSwgKF9jeCA9IHt9LCBfY3hbc2VsZWN0ZWRDbGFzc05hbWVdID0gc2VsZWN0ZWQsIF9jeFtkaXNhYmxlZENsYXNzTmFtZV0gPSBkaXNhYmxlZCwgX2N4KSksXG4gICAgICByZWY6IGZ1bmN0aW9uIHJlZihub2RlKSB7XG4gICAgICAgIF90aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICBpZiAodGFiUmVmKSB0YWJSZWYobm9kZSk7XG4gICAgICB9LFxuICAgICAgcm9sZTogXCJ0YWJcIixcbiAgICAgIGlkOiBpZCxcbiAgICAgIFwiYXJpYS1zZWxlY3RlZFwiOiBzZWxlY3RlZCA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICAgICBcImFyaWEtZGlzYWJsZWRcIjogZGlzYWJsZWQgPyAndHJ1ZScgOiAnZmFsc2UnLFxuICAgICAgXCJhcmlhLWNvbnRyb2xzXCI6IHBhbmVsSWQsXG4gICAgICB0YWJJbmRleDogdGFiSW5kZXggfHwgKHNlbGVjdGVkID8gJzAnIDogbnVsbClcbiAgICB9KSwgY2hpbGRyZW4pO1xuICB9O1xuXG4gIHJldHVybiBUYWI7XG59KENvbXBvbmVudCk7XG5cblRhYi5kZWZhdWx0UHJvcHMgPSB7XG4gIGNsYXNzTmFtZTogREVGQVVMVF9DTEFTUyxcbiAgZGlzYWJsZWRDbGFzc05hbWU6IERFRkFVTFRfQ0xBU1MgKyBcIi0tZGlzYWJsZWRcIixcbiAgZm9jdXM6IGZhbHNlLFxuICBpZDogbnVsbCxcbiAgcGFuZWxJZDogbnVsbCxcbiAgc2VsZWN0ZWQ6IGZhbHNlLFxuICBzZWxlY3RlZENsYXNzTmFtZTogREVGQVVMVF9DTEFTUyArIFwiLS1zZWxlY3RlZFwiXG59O1xuZXhwb3J0IHsgVGFiIGFzIGRlZmF1bHQgfTtcblRhYi5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYXJyYXksIFByb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYXJyYXksIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICB0YWJJbmRleDogUHJvcFR5cGVzLnN0cmluZyxcbiAgZGlzYWJsZWRDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8gcHJpdmF0ZVxuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgLy8gcHJpdmF0ZVxuICBwYW5lbElkOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvLyBwcml2YXRlXG4gIHNlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8gcHJpdmF0ZVxuICBzZWxlY3RlZENsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGFiUmVmOiBQcm9wVHlwZXMuZnVuYyAvLyBwcml2YXRlXG5cbn0gOiB7fTtcblRhYi50YWJzUm9sZSA9ICdUYWInOyIsImZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGN4IGZyb20gJ2Nsc3gnO1xuXG52YXIgVGFiTGlzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShUYWJMaXN0LCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUYWJMaXN0KCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUYWJMaXN0LnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzLmNsYXNzTmFtZSxcbiAgICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiXSk7XG5cbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgICAgY2xhc3NOYW1lOiBjeChjbGFzc05hbWUpLFxuICAgICAgcm9sZTogXCJ0YWJsaXN0XCJcbiAgICB9KSwgY2hpbGRyZW4pO1xuICB9O1xuXG4gIHJldHVybiBUYWJMaXN0O1xufShDb21wb25lbnQpO1xuXG5UYWJMaXN0LmRlZmF1bHRQcm9wcyA9IHtcbiAgY2xhc3NOYW1lOiAncmVhY3QtdGFic19fdGFiLWxpc3QnXG59O1xuZXhwb3J0IHsgVGFiTGlzdCBhcyBkZWZhdWx0IH07XG5UYWJMaXN0LnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5hcnJheV0pLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5hcnJheSwgUHJvcFR5cGVzLm9iamVjdF0pXG59IDoge307XG5UYWJMaXN0LnRhYnNSb2xlID0gJ1RhYkxpc3QnOyIsImZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGN4IGZyb20gJ2Nsc3gnO1xudmFyIERFRkFVTFRfQ0xBU1MgPSAncmVhY3QtdGFic19fdGFiLXBhbmVsJztcblxudmFyIFRhYlBhbmVsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRhYlBhbmVsLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUYWJQYW5lbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVGFiUGFuZWwucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9jeDtcblxuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzLmNsYXNzTmFtZSxcbiAgICAgICAgZm9yY2VSZW5kZXIgPSBfdGhpcyRwcm9wcy5mb3JjZVJlbmRlcixcbiAgICAgICAgaWQgPSBfdGhpcyRwcm9wcy5pZCxcbiAgICAgICAgc2VsZWN0ZWQgPSBfdGhpcyRwcm9wcy5zZWxlY3RlZCxcbiAgICAgICAgc2VsZWN0ZWRDbGFzc05hbWUgPSBfdGhpcyRwcm9wcy5zZWxlY3RlZENsYXNzTmFtZSxcbiAgICAgICAgdGFiSWQgPSBfdGhpcyRwcm9wcy50YWJJZCxcbiAgICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiLCBcImZvcmNlUmVuZGVyXCIsIFwiaWRcIiwgXCJzZWxlY3RlZFwiLCBcInNlbGVjdGVkQ2xhc3NOYW1lXCIsIFwidGFiSWRcIl0pO1xuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgICBjbGFzc05hbWU6IGN4KGNsYXNzTmFtZSwgKF9jeCA9IHt9LCBfY3hbc2VsZWN0ZWRDbGFzc05hbWVdID0gc2VsZWN0ZWQsIF9jeCkpLFxuICAgICAgcm9sZTogXCJ0YWJwYW5lbFwiLFxuICAgICAgaWQ6IGlkLFxuICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogdGFiSWRcbiAgICB9KSwgZm9yY2VSZW5kZXIgfHwgc2VsZWN0ZWQgPyBjaGlsZHJlbiA6IG51bGwpO1xuICB9O1xuXG4gIHJldHVybiBUYWJQYW5lbDtcbn0oQ29tcG9uZW50KTtcblxuVGFiUGFuZWwuZGVmYXVsdFByb3BzID0ge1xuICBjbGFzc05hbWU6IERFRkFVTFRfQ0xBU1MsXG4gIGZvcmNlUmVuZGVyOiBmYWxzZSxcbiAgc2VsZWN0ZWRDbGFzc05hbWU6IERFRkFVTFRfQ0xBU1MgKyBcIi0tc2VsZWN0ZWRcIlxufTtcbmV4cG9ydCB7IFRhYlBhbmVsIGFzIGRlZmF1bHQgfTtcblRhYlBhbmVsLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5hcnJheSwgUHJvcFR5cGVzLm9iamVjdF0pLFxuICBmb3JjZVJlbmRlcjogUHJvcFR5cGVzLmJvb2wsXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvLyBwcml2YXRlXG4gIHNlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8gcHJpdmF0ZVxuICBzZWxlY3RlZENsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGFiSWQ6IFByb3BUeXBlcy5zdHJpbmcgLy8gcHJpdmF0ZVxuXG59IDoge307XG5UYWJQYW5lbC50YWJzUm9sZSA9ICdUYWJQYW5lbCc7IiwiZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjaGlsZHJlblByb3BUeXBlLCBvblNlbGVjdFByb3BUeXBlLCBzZWxlY3RlZEluZGV4UHJvcFR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL3Byb3BUeXBlcyc7XG5pbXBvcnQgVW5jb250cm9sbGVkVGFicyBmcm9tICcuL1VuY29udHJvbGxlZFRhYnMnO1xuaW1wb3J0IHsgZ2V0VGFic0NvdW50IH0gZnJvbSAnLi4vaGVscGVycy9jb3VudCc7XG52YXIgTU9ERV9DT05UUk9MTEVEID0gMDtcbnZhciBNT0RFX1VOQ09OVFJPTExFRCA9IDE7XG5cbnZhciBUYWJzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRhYnMsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRhYnMocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcblxuICAgIF90aGlzLmhhbmRsZVNlbGVjdGVkID0gZnVuY3Rpb24gKGluZGV4LCBsYXN0LCBldmVudCkge1xuICAgICAgdmFyIG9uU2VsZWN0ID0gX3RoaXMucHJvcHMub25TZWxlY3Q7XG4gICAgICB2YXIgbW9kZSA9IF90aGlzLnN0YXRlLm1vZGU7IC8vIENhbGwgY2hhbmdlIGV2ZW50IGhhbmRsZXJcblxuICAgICAgaWYgKHR5cGVvZiBvblNlbGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY2hhbmdlIGV2ZW50IGhhbmRsZXIgY2FuY2VscyB0aGUgdGFiIGNoYW5nZVxuICAgICAgICBpZiAob25TZWxlY3QoaW5kZXgsIGxhc3QsIGV2ZW50KSA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAvLyBTZXQgZm9jdXMgaWYgdGhlIGNoYW5nZSB3YXMgdHJpZ2dlcmVkIGZyb20gdGhlIGtleWJvYXJkXG4gICAgICAgIGZvY3VzOiBldmVudC50eXBlID09PSAna2V5ZG93bidcbiAgICAgIH07XG5cbiAgICAgIGlmIChtb2RlID09PSBNT0RFX1VOQ09OVFJPTExFRCkge1xuICAgICAgICAvLyBVcGRhdGUgc2VsZWN0ZWQgaW5kZXhcbiAgICAgICAgc3RhdGUuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgfTtcblxuICAgIF90aGlzLnN0YXRlID0gVGFicy5jb3B5UHJvcHNUb1N0YXRlKF90aGlzLnByb3BzLCB7fSwgcHJvcHMuZGVmYXVsdEZvY3VzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBUYWJzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICByZXR1cm4gVGFicy5jb3B5UHJvcHNUb1N0YXRlKHByb3BzLCBzdGF0ZSk7XG4gIH07XG5cbiAgVGFicy5nZXRNb2RlRnJvbVByb3BzID0gZnVuY3Rpb24gZ2V0TW9kZUZyb21Qcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5zZWxlY3RlZEluZGV4ID09PSBudWxsID8gTU9ERV9VTkNPTlRST0xMRUQgOiBNT0RFX0NPTlRST0xMRUQ7XG4gIH07XG5cbiAgLy8gcHJlc2VydmUgdGhlIGV4aXN0aW5nIHNlbGVjdGVkSW5kZXggZnJvbSBzdGF0ZS5cbiAgLy8gSWYgdGhlIHN0YXRlIGhhcyBub3Qgc2VsZWN0ZWRJbmRleCwgZGVmYXVsdCB0byB0aGUgZGVmYXVsdEluZGV4IG9yIDBcbiAgVGFicy5jb3B5UHJvcHNUb1N0YXRlID0gZnVuY3Rpb24gY29weVByb3BzVG9TdGF0ZShwcm9wcywgc3RhdGUsIGZvY3VzKSB7XG4gICAgaWYgKGZvY3VzID09PSB2b2lkIDApIHtcbiAgICAgIGZvY3VzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGUubW9kZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlLm1vZGUgIT09IFRhYnMuZ2V0TW9kZUZyb21Qcm9wcyhwcm9wcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN3aXRjaGluZyBiZXR3ZWVuIGNvbnRyb2xsZWQgbW9kZSAoYnkgdXNpbmcgYHNlbGVjdGVkSW5kZXhgKSBhbmQgdW5jb250cm9sbGVkIG1vZGUgaXMgbm90IHN1cHBvcnRlZCBpbiBgVGFic2AuXFxuRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgY29udHJvbGxlZCBhbmQgdW5jb250cm9sbGVkIG1vZGUgb2YgcmVhY3QtdGFicyBzZWUgdGhlIFJFQURNRS5cIik7XG4gICAgfVxuXG4gICAgdmFyIG5ld1N0YXRlID0ge1xuICAgICAgZm9jdXM6IGZvY3VzLFxuICAgICAgbW9kZTogVGFicy5nZXRNb2RlRnJvbVByb3BzKHByb3BzKVxuICAgIH07XG5cbiAgICBpZiAobmV3U3RhdGUubW9kZSA9PT0gTU9ERV9VTkNPTlRST0xMRUQpIHtcbiAgICAgIHZhciBtYXhUYWJJbmRleCA9IGdldFRhYnNDb3VudChwcm9wcy5jaGlsZHJlbikgLSAxO1xuICAgICAgdmFyIHNlbGVjdGVkSW5kZXggPSBudWxsO1xuXG4gICAgICBpZiAoc3RhdGUuc2VsZWN0ZWRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHNlbGVjdGVkSW5kZXggPSBNYXRoLm1pbihzdGF0ZS5zZWxlY3RlZEluZGV4LCBtYXhUYWJJbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZEluZGV4ID0gcHJvcHMuZGVmYXVsdEluZGV4IHx8IDA7XG4gICAgICB9XG5cbiAgICAgIG5ld1N0YXRlLnNlbGVjdGVkSW5kZXggPSBzZWxlY3RlZEluZGV4O1xuICAgIH1cblxuICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgfTtcblxuICB2YXIgX3Byb3RvID0gVGFicy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBkZWZhdWx0SW5kZXggPSBfdGhpcyRwcm9wcy5kZWZhdWx0SW5kZXgsXG4gICAgICAgIGRlZmF1bHRGb2N1cyA9IF90aGlzJHByb3BzLmRlZmF1bHRGb2N1cyxcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJkZWZhdWx0SW5kZXhcIiwgXCJkZWZhdWx0Rm9jdXNcIl0pO1xuXG4gICAgdmFyIF90aGlzJHN0YXRlID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgZm9jdXMgPSBfdGhpcyRzdGF0ZS5mb2N1cyxcbiAgICAgICAgc2VsZWN0ZWRJbmRleCA9IF90aGlzJHN0YXRlLnNlbGVjdGVkSW5kZXg7XG4gICAgcHJvcHMuZm9jdXMgPSBmb2N1cztcbiAgICBwcm9wcy5vblNlbGVjdCA9IHRoaXMuaGFuZGxlU2VsZWN0ZWQ7XG5cbiAgICBpZiAoc2VsZWN0ZWRJbmRleCAhPSBudWxsKSB7XG4gICAgICBwcm9wcy5zZWxlY3RlZEluZGV4ID0gc2VsZWN0ZWRJbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVW5jb250cm9sbGVkVGFicywgcHJvcHMsIGNoaWxkcmVuKTtcbiAgfTtcblxuICByZXR1cm4gVGFicztcbn0oQ29tcG9uZW50KTtcblxuVGFicy5kZWZhdWx0UHJvcHMgPSB7XG4gIGRlZmF1bHRGb2N1czogZmFsc2UsXG4gIGZvcmNlUmVuZGVyVGFiUGFuZWw6IGZhbHNlLFxuICBzZWxlY3RlZEluZGV4OiBudWxsLFxuICBkZWZhdWx0SW5kZXg6IG51bGxcbn07XG5leHBvcnQgeyBUYWJzIGFzIGRlZmF1bHQgfTtcblRhYnMucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICBjaGlsZHJlbjogY2hpbGRyZW5Qcm9wVHlwZSxcbiAgZGlyZWN0aW9uOiBQcm9wVHlwZXMub25lT2YoWydydGwnLCAnbHRyJ10pLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5hcnJheSwgUHJvcFR5cGVzLm9iamVjdF0pLFxuICBkZWZhdWx0Rm9jdXM6IFByb3BUeXBlcy5ib29sLFxuICBkZWZhdWx0SW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGRpc2FibGVkVGFiQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBkb21SZWY6IFByb3BUeXBlcy5mdW5jLFxuICBmb3JjZVJlbmRlclRhYlBhbmVsOiBQcm9wVHlwZXMuYm9vbCxcbiAgb25TZWxlY3Q6IG9uU2VsZWN0UHJvcFR5cGUsXG4gIHNlbGVjdGVkSW5kZXg6IHNlbGVjdGVkSW5kZXhQcm9wVHlwZSxcbiAgc2VsZWN0ZWRUYWJDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHNlbGVjdGVkVGFiUGFuZWxDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmdcbn0gOiB7fTtcblRhYnMudGFic1JvbGUgPSAnVGFicyc7IiwiZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCwgeyBjbG9uZUVsZW1lbnQsIENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjeCBmcm9tICdjbHN4JztcbmltcG9ydCB1dWlkIGZyb20gJy4uL2hlbHBlcnMvdXVpZCc7XG5pbXBvcnQgeyBjaGlsZHJlblByb3BUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9wcm9wVHlwZXMnO1xuaW1wb3J0IHsgZ2V0UGFuZWxzQ291bnQgYXMgX2dldFBhbmVsc0NvdW50LCBnZXRUYWJzQ291bnQgYXMgX2dldFRhYnNDb3VudCB9IGZyb20gJy4uL2hlbHBlcnMvY291bnQnO1xuaW1wb3J0IHsgZGVlcE1hcCB9IGZyb20gJy4uL2hlbHBlcnMvY2hpbGRyZW5EZWVwTWFwJztcbmltcG9ydCB7IGlzVGFiTGlzdCwgaXNUYWJQYW5lbCwgaXNUYWIgfSBmcm9tICcuLi9oZWxwZXJzL2VsZW1lbnRUeXBlcyc7XG5cbmZ1bmN0aW9uIGlzTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlICYmICdnZXRBdHRyaWJ1dGUnIGluIG5vZGU7XG59IC8vIERldGVybWluZSBpZiBhIG5vZGUgZnJvbSBldmVudC50YXJnZXQgaXMgYSBUYWIgZWxlbWVudFxuXG5cbmZ1bmN0aW9uIGlzVGFiTm9kZShub2RlKSB7XG4gIHJldHVybiBpc05vZGUobm9kZSkgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ3RhYic7XG59IC8vIERldGVybWluZSBpZiBhIHRhYiBub2RlIGlzIGRpc2FibGVkXG5cblxuZnVuY3Rpb24gaXNUYWJEaXNhYmxlZChub2RlKSB7XG4gIHJldHVybiBpc05vZGUobm9kZSkgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnKSA9PT0gJ3RydWUnO1xufVxuXG52YXIgY2FuVXNlQWN0aXZlRWxlbWVudDtcblxudHJ5IHtcbiAgY2FuVXNlQWN0aXZlRWxlbWVudCA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG59IGNhdGNoIChlKSB7XG4gIC8vIFdvcmsgYXJvdW5kIGZvciBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcbiAgLy8gUmVmZXIgdG8gdGhlIGZvbGxvd2luZyByZXNvdXJjZXM6XG4gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEwOTgyOTYwLzM2OTY4N1xuICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMjczMzU5OVxuICBjYW5Vc2VBY3RpdmVFbGVtZW50ID0gZmFsc2U7XG59XG5cbnZhciBVbmNvbnRyb2xsZWRUYWJzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFVuY29udHJvbGxlZFRhYnMsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFVuY29udHJvbGxlZFRhYnMoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX0NvbXBvbmVudC5jYWxsLmFwcGx5KF9Db21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMudGFiTm9kZXMgPSBbXTtcblxuICAgIF90aGlzLmhhbmRsZUtleURvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IF90aGlzLnByb3BzLmRpcmVjdGlvbjtcblxuICAgICAgaWYgKF90aGlzLmlzVGFiRnJvbUNvbnRhaW5lcihlLnRhcmdldCkpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMucHJvcHMuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgdmFyIHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIHZhciB1c2VTZWxlY3RlZEluZGV4ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMzIgfHwgZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICB1c2VTZWxlY3RlZEluZGV4ID0gZmFsc2U7XG5cbiAgICAgICAgICBfdGhpcy5oYW5kbGVDbGljayhlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDM3IHx8IGUua2V5Q29kZSA9PT0gMzgpIHtcbiAgICAgICAgICAvLyBTZWxlY3QgbmV4dCB0YWIgdG8gdGhlIGxlZnRcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgICAgICAgaW5kZXggPSBfdGhpcy5nZXROZXh0VGFiKGluZGV4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXggPSBfdGhpcy5nZXRQcmV2VGFiKGluZGV4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgdXNlU2VsZWN0ZWRJbmRleCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09PSAzOSB8fCBlLmtleUNvZGUgPT09IDQwKSB7XG4gICAgICAgICAgLy8gU2VsZWN0IG5leHQgdGFiIHRvIHRoZSByaWdodFxuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICAgICAgICBpbmRleCA9IF90aGlzLmdldFByZXZUYWIoaW5kZXgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleCA9IF90aGlzLmdldE5leHRUYWIoaW5kZXgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICB1c2VTZWxlY3RlZEluZGV4ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT09IDM1KSB7XG4gICAgICAgICAgLy8gU2VsZWN0IGxhc3QgdGFiIChFbmQga2V5KVxuICAgICAgICAgIGluZGV4ID0gX3RoaXMuZ2V0TGFzdFRhYigpO1xuICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICB1c2VTZWxlY3RlZEluZGV4ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT09IDM2KSB7XG4gICAgICAgICAgLy8gU2VsZWN0IGZpcnN0IHRhYiAoSG9tZSBrZXkpXG4gICAgICAgICAgaW5kZXggPSBfdGhpcy5nZXRGaXJzdFRhYigpO1xuICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICB1c2VTZWxlY3RlZEluZGV4ID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBUaGlzIHByZXZlbnRzIHNjcm9sbGJhcnMgZnJvbSBtb3ZpbmcgYXJvdW5kXG5cblxuICAgICAgICBpZiAocHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gLy8gT25seSB1c2UgdGhlIHNlbGVjdGVkIGluZGV4IGluIHRoZSBzdGF0ZSBpZiB3ZSdyZSBub3QgdXNpbmcgdGhlIHRhYmJlZCBpbmRleFxuXG5cbiAgICAgICAgaWYgKHVzZVNlbGVjdGVkSW5kZXgpIHtcbiAgICAgICAgICBfdGhpcy5zZXRTZWxlY3RlZChpbmRleCwgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIG5vZGUgPSBlLnRhcmdldDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAoX3RoaXMuaXNUYWJGcm9tQ29udGFpbmVyKG5vZGUpKSB7XG4gICAgICAgICAgaWYgKGlzVGFiRGlzYWJsZWQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW5kZXggPSBbXS5zbGljZS5jYWxsKG5vZGUucGFyZW50Tm9kZS5jaGlsZHJlbikuZmlsdGVyKGlzVGFiTm9kZSkuaW5kZXhPZihub2RlKTtcblxuICAgICAgICAgIF90aGlzLnNldFNlbGVjdGVkKGluZGV4LCBlKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cblxuICAgICAgfSB3aGlsZSAoKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpICE9IG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVW5jb250cm9sbGVkVGFicy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNldFNlbGVjdGVkID0gZnVuY3Rpb24gc2V0U2VsZWN0ZWQoaW5kZXgsIGV2ZW50KSB7XG4gICAgLy8gQ2hlY2sgaW5kZXggYm91bmRhcnlcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuZ2V0VGFic0NvdW50KCkpIHJldHVybjtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBvblNlbGVjdCA9IF90aGlzJHByb3BzLm9uU2VsZWN0LFxuICAgICAgICBzZWxlY3RlZEluZGV4ID0gX3RoaXMkcHJvcHMuc2VsZWN0ZWRJbmRleDsgLy8gQ2FsbCBjaGFuZ2UgZXZlbnQgaGFuZGxlclxuXG4gICAgb25TZWxlY3QoaW5kZXgsIHNlbGVjdGVkSW5kZXgsIGV2ZW50KTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TmV4dFRhYiA9IGZ1bmN0aW9uIGdldE5leHRUYWIoaW5kZXgpIHtcbiAgICB2YXIgY291bnQgPSB0aGlzLmdldFRhYnNDb3VudCgpOyAvLyBMb29rIGZvciBub24tZGlzYWJsZWQgdGFiIGZyb20gaW5kZXggdG8gdGhlIGxhc3QgdGFiIG9uIHRoZSByaWdodFxuXG4gICAgZm9yICh2YXIgaSA9IGluZGV4ICsgMTsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGlmICghaXNUYWJEaXNhYmxlZCh0aGlzLmdldFRhYihpKSkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfSAvLyBJZiBubyB0YWIgZm91bmQsIGNvbnRpbnVlIHNlYXJjaGluZyBmcm9tIGZpcnN0IG9uIGxlZnQgdG8gaW5kZXhcblxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGluZGV4OyBfaSsrKSB7XG4gICAgICBpZiAoIWlzVGFiRGlzYWJsZWQodGhpcy5nZXRUYWIoX2kpKSkge1xuICAgICAgICByZXR1cm4gX2k7XG4gICAgICB9XG4gICAgfSAvLyBObyB0YWJzIGFyZSBkaXNhYmxlZCwgcmV0dXJuIGluZGV4XG5cblxuICAgIHJldHVybiBpbmRleDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0UHJldlRhYiA9IGZ1bmN0aW9uIGdldFByZXZUYWIoaW5kZXgpIHtcbiAgICB2YXIgaSA9IGluZGV4OyAvLyBMb29rIGZvciBub24tZGlzYWJsZWQgdGFiIGZyb20gaW5kZXggdG8gZmlyc3QgdGFiIG9uIHRoZSBsZWZ0XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoIWlzVGFiRGlzYWJsZWQodGhpcy5nZXRUYWIoaSkpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH0gLy8gSWYgbm8gdGFiIGZvdW5kLCBjb250aW51ZSBzZWFyY2hpbmcgZnJvbSBsYXN0IHRhYiBvbiByaWdodCB0byBpbmRleFxuXG5cbiAgICBpID0gdGhpcy5nZXRUYWJzQ291bnQoKTtcblxuICAgIHdoaWxlIChpLS0gPiBpbmRleCkge1xuICAgICAgaWYgKCFpc1RhYkRpc2FibGVkKHRoaXMuZ2V0VGFiKGkpKSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9IC8vIE5vIHRhYnMgYXJlIGRpc2FibGVkLCByZXR1cm4gaW5kZXhcblxuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9O1xuXG4gIF9wcm90by5nZXRGaXJzdFRhYiA9IGZ1bmN0aW9uIGdldEZpcnN0VGFiKCkge1xuICAgIHZhciBjb3VudCA9IHRoaXMuZ2V0VGFic0NvdW50KCk7IC8vIExvb2sgZm9yIG5vbiBkaXNhYmxlZCB0YWIgZnJvbSB0aGUgZmlyc3QgdGFiXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGlmICghaXNUYWJEaXNhYmxlZCh0aGlzLmdldFRhYihpKSkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLmdldExhc3RUYWIgPSBmdW5jdGlvbiBnZXRMYXN0VGFiKCkge1xuICAgIHZhciBpID0gdGhpcy5nZXRUYWJzQ291bnQoKTsgLy8gTG9vayBmb3Igbm9uIGRpc2FibGVkIHRhYiBmcm9tIHRoZSBsYXN0IHRhYlxuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKCFpc1RhYkRpc2FibGVkKHRoaXMuZ2V0VGFiKGkpKSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VGFic0NvdW50ID0gZnVuY3Rpb24gZ2V0VGFic0NvdW50KCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgcmV0dXJuIF9nZXRUYWJzQ291bnQoY2hpbGRyZW4pO1xuICB9O1xuXG4gIF9wcm90by5nZXRQYW5lbHNDb3VudCA9IGZ1bmN0aW9uIGdldFBhbmVsc0NvdW50KCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgcmV0dXJuIF9nZXRQYW5lbHNDb3VudChjaGlsZHJlbik7XG4gIH07XG5cbiAgX3Byb3RvLmdldFRhYiA9IGZ1bmN0aW9uIGdldFRhYihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLnRhYk5vZGVzW1widGFicy1cIiArIGluZGV4XTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRDaGlsZHJlbigpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMyLmNoaWxkcmVuLFxuICAgICAgICBkaXNhYmxlZFRhYkNsYXNzTmFtZSA9IF90aGlzJHByb3BzMi5kaXNhYmxlZFRhYkNsYXNzTmFtZSxcbiAgICAgICAgZm9jdXMgPSBfdGhpcyRwcm9wczIuZm9jdXMsXG4gICAgICAgIGZvcmNlUmVuZGVyVGFiUGFuZWwgPSBfdGhpcyRwcm9wczIuZm9yY2VSZW5kZXJUYWJQYW5lbCxcbiAgICAgICAgc2VsZWN0ZWRJbmRleCA9IF90aGlzJHByb3BzMi5zZWxlY3RlZEluZGV4LFxuICAgICAgICBzZWxlY3RlZFRhYkNsYXNzTmFtZSA9IF90aGlzJHByb3BzMi5zZWxlY3RlZFRhYkNsYXNzTmFtZSxcbiAgICAgICAgc2VsZWN0ZWRUYWJQYW5lbENsYXNzTmFtZSA9IF90aGlzJHByb3BzMi5zZWxlY3RlZFRhYlBhbmVsQ2xhc3NOYW1lO1xuICAgIHRoaXMudGFiSWRzID0gdGhpcy50YWJJZHMgfHwgW107XG4gICAgdGhpcy5wYW5lbElkcyA9IHRoaXMucGFuZWxJZHMgfHwgW107XG4gICAgdmFyIGRpZmYgPSB0aGlzLnRhYklkcy5sZW5ndGggLSB0aGlzLmdldFRhYnNDb3VudCgpOyAvLyBBZGQgaWRzIGlmIG5ldyB0YWJzIGhhdmUgYmVlbiBhZGRlZFxuICAgIC8vIERvbid0IGJvdGhlciByZW1vdmluZyBpZHMsIGp1c3Qga2VlcCB0aGVtIGluIGNhc2UgdGhleSBhcmUgYWRkZWQgYWdhaW5cbiAgICAvLyBUaGlzIGlzIG1vcmUgZWZmaWNpZW50LCBhbmQga2VlcHMgdGhlIHV1aWQgY291bnRlciB1bmRlciBjb250cm9sXG5cbiAgICB3aGlsZSAoZGlmZisrIDwgMCkge1xuICAgICAgdGhpcy50YWJJZHMucHVzaCh1dWlkKCkpO1xuICAgICAgdGhpcy5wYW5lbElkcy5wdXNoKHV1aWQoKSk7XG4gICAgfSAvLyBNYXAgY2hpbGRyZW4gdG8gZHluYW1pY2FsbHkgc2V0dXAgcmVmc1xuXG5cbiAgICByZXR1cm4gZGVlcE1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY2hpbGQ7IC8vIENsb25lIFRhYkxpc3QgYW5kIFRhYiBjb21wb25lbnRzIHRvIGhhdmUgcmVmc1xuXG4gICAgICBpZiAoaXNUYWJMaXN0KGNoaWxkKSkge1xuICAgICAgICB2YXIgbGlzdEluZGV4ID0gMDsgLy8gRmlndXJlIG91dCBpZiB0aGUgY3VycmVudCBmb2N1cyBpbiB0aGUgRE9NIGlzIHNldCBvbiBhIFRhYlxuICAgICAgICAvLyBJZiBpdCBpcyB3ZSBzaG91bGQga2VlcCB0aGUgZm9jdXMgb24gdGhlIG5leHQgc2VsZWN0ZWQgdGFiXG5cbiAgICAgICAgdmFyIHdhc1RhYkZvY3VzZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoY2FuVXNlQWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgIHdhc1RhYkZvY3VzZWQgPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkLnByb3BzLmNoaWxkcmVuKS5maWx0ZXIoaXNUYWIpLnNvbWUoZnVuY3Rpb24gKHRhYiwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IF90aGlzMi5nZXRUYWIoaSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBjbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgICBjaGlsZHJlbjogZGVlcE1hcChjaGlsZC5wcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKHRhYikge1xuICAgICAgICAgICAgdmFyIGtleSA9IFwidGFicy1cIiArIGxpc3RJbmRleDtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkSW5kZXggPT09IGxpc3RJbmRleDtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICAgICAgdGFiUmVmOiBmdW5jdGlvbiB0YWJSZWYobm9kZSkge1xuICAgICAgICAgICAgICAgIF90aGlzMi50YWJOb2Rlc1trZXldID0gbm9kZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgaWQ6IF90aGlzMi50YWJJZHNbbGlzdEluZGV4XSxcbiAgICAgICAgICAgICAgcGFuZWxJZDogX3RoaXMyLnBhbmVsSWRzW2xpc3RJbmRleF0sXG4gICAgICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgICAgICAgICAgZm9jdXM6IHNlbGVjdGVkICYmIChmb2N1cyB8fCB3YXNUYWJGb2N1c2VkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFRhYkNsYXNzTmFtZSkgcHJvcHMuc2VsZWN0ZWRDbGFzc05hbWUgPSBzZWxlY3RlZFRhYkNsYXNzTmFtZTtcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZFRhYkNsYXNzTmFtZSkgcHJvcHMuZGlzYWJsZWRDbGFzc05hbWUgPSBkaXNhYmxlZFRhYkNsYXNzTmFtZTtcbiAgICAgICAgICAgIGxpc3RJbmRleCsrO1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lRWxlbWVudCh0YWIsIHByb3BzKTtcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNUYWJQYW5lbChjaGlsZCkpIHtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGlkOiBfdGhpczIucGFuZWxJZHNbaW5kZXhdLFxuICAgICAgICAgIHRhYklkOiBfdGhpczIudGFiSWRzW2luZGV4XSxcbiAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWRJbmRleCA9PT0gaW5kZXhcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZvcmNlUmVuZGVyVGFiUGFuZWwpIHByb3BzLmZvcmNlUmVuZGVyID0gZm9yY2VSZW5kZXJUYWJQYW5lbDtcbiAgICAgICAgaWYgKHNlbGVjdGVkVGFiUGFuZWxDbGFzc05hbWUpIHByb3BzLnNlbGVjdGVkQ2xhc3NOYW1lID0gc2VsZWN0ZWRUYWJQYW5lbENsYXNzTmFtZTtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgcmVzdWx0ID0gY2xvbmVFbGVtZW50KGNoaWxkLCBwcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhIG5vZGUgZnJvbSBldmVudC50YXJnZXQgaXMgYSBUYWIgZWxlbWVudCBmb3IgdGhlIGN1cnJlbnQgVGFicyBjb250YWluZXIuXG4gICAqIElmIHRoZSBjbGlja2VkIGVsZW1lbnQgaXMgbm90IGEgVGFiLCBpdCByZXR1cm5zIGZhbHNlLlxuICAgKiBJZiBpdCBmaW5kcyBhbm90aGVyIFRhYnMgY29udGFpbmVyIGJldHdlZW4gdGhlIFRhYiBhbmQgYHRoaXNgLCBpdCByZXR1cm5zIGZhbHNlLlxuICAgKi9cbiAgX3Byb3RvLmlzVGFiRnJvbUNvbnRhaW5lciA9IGZ1bmN0aW9uIGlzVGFiRnJvbUNvbnRhaW5lcihub2RlKSB7XG4gICAgLy8gcmV0dXJuIGltbWVkaWF0ZWx5IGlmIHRoZSBjbGlja2VkIGVsZW1lbnQgaXMgbm90IGEgVGFiLlxuICAgIGlmICghaXNUYWJOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBDaGVjayBpZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhIFRhYnMgY29udGFpbmVyIGlzIGB0aGlzYCBvbmUuXG5cblxuICAgIHZhciBub2RlQW5jZXN0b3IgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG5cbiAgICBkbyB7XG4gICAgICBpZiAobm9kZUFuY2VzdG9yID09PSB0aGlzLm5vZGUpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKG5vZGVBbmNlc3Rvci5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFicycpKSBicmVhaztcbiAgICAgIG5vZGVBbmNlc3RvciA9IG5vZGVBbmNlc3Rvci5wYXJlbnRFbGVtZW50O1xuICAgIH0gd2hpbGUgKG5vZGVBbmNlc3Rvcik7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIC8vIERlbGV0ZSBhbGwga25vd24gcHJvcHMsIHNvIHRoZXkgZG9uJ3QgZ2V0IGFkZGVkIHRvIERPTVxuICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzMy5jaGlsZHJlbixcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHMzLmNsYXNzTmFtZSxcbiAgICAgICAgZGlzYWJsZWRUYWJDbGFzc05hbWUgPSBfdGhpcyRwcm9wczMuZGlzYWJsZWRUYWJDbGFzc05hbWUsXG4gICAgICAgIGRvbVJlZiA9IF90aGlzJHByb3BzMy5kb21SZWYsXG4gICAgICAgIGZvY3VzID0gX3RoaXMkcHJvcHMzLmZvY3VzLFxuICAgICAgICBmb3JjZVJlbmRlclRhYlBhbmVsID0gX3RoaXMkcHJvcHMzLmZvcmNlUmVuZGVyVGFiUGFuZWwsXG4gICAgICAgIG9uU2VsZWN0ID0gX3RoaXMkcHJvcHMzLm9uU2VsZWN0LFxuICAgICAgICBzZWxlY3RlZEluZGV4ID0gX3RoaXMkcHJvcHMzLnNlbGVjdGVkSW5kZXgsXG4gICAgICAgIHNlbGVjdGVkVGFiQ2xhc3NOYW1lID0gX3RoaXMkcHJvcHMzLnNlbGVjdGVkVGFiQ2xhc3NOYW1lLFxuICAgICAgICBzZWxlY3RlZFRhYlBhbmVsQ2xhc3NOYW1lID0gX3RoaXMkcHJvcHMzLnNlbGVjdGVkVGFiUGFuZWxDbGFzc05hbWUsXG4gICAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wczMsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwiZGlzYWJsZWRUYWJDbGFzc05hbWVcIiwgXCJkb21SZWZcIiwgXCJmb2N1c1wiLCBcImZvcmNlUmVuZGVyVGFiUGFuZWxcIiwgXCJvblNlbGVjdFwiLCBcInNlbGVjdGVkSW5kZXhcIiwgXCJzZWxlY3RlZFRhYkNsYXNzTmFtZVwiLCBcInNlbGVjdGVkVGFiUGFuZWxDbGFzc05hbWVcIl0pO1xuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgICBjbGFzc05hbWU6IGN4KGNsYXNzTmFtZSksXG4gICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrLFxuICAgICAgb25LZXlEb3duOiB0aGlzLmhhbmRsZUtleURvd24sXG4gICAgICByZWY6IGZ1bmN0aW9uIHJlZihub2RlKSB7XG4gICAgICAgIF90aGlzMy5ub2RlID0gbm9kZTtcbiAgICAgICAgaWYgKGRvbVJlZikgZG9tUmVmKG5vZGUpO1xuICAgICAgfSxcbiAgICAgIFwiZGF0YS10YWJzXCI6IHRydWVcbiAgICB9KSwgdGhpcy5nZXRDaGlsZHJlbigpKTtcbiAgfTtcblxuICByZXR1cm4gVW5jb250cm9sbGVkVGFicztcbn0oQ29tcG9uZW50KTtcblxuVW5jb250cm9sbGVkVGFicy5kZWZhdWx0UHJvcHMgPSB7XG4gIGNsYXNzTmFtZTogJ3JlYWN0LXRhYnMnLFxuICBmb2N1czogZmFsc2Vcbn07XG5leHBvcnQgeyBVbmNvbnRyb2xsZWRUYWJzIGFzIGRlZmF1bHQgfTtcblVuY29udHJvbGxlZFRhYnMucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICBjaGlsZHJlbjogY2hpbGRyZW5Qcm9wVHlwZSxcbiAgZGlyZWN0aW9uOiBQcm9wVHlwZXMub25lT2YoWydydGwnLCAnbHRyJ10pLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5hcnJheSwgUHJvcFR5cGVzLm9iamVjdF0pLFxuICBkaXNhYmxlZFRhYkNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZG9tUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgZm9jdXM6IFByb3BUeXBlcy5ib29sLFxuICBmb3JjZVJlbmRlclRhYlBhbmVsOiBQcm9wVHlwZXMuYm9vbCxcbiAgb25TZWxlY3Q6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHNlbGVjdGVkSW5kZXg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgc2VsZWN0ZWRUYWJDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHNlbGVjdGVkVGFiUGFuZWxDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmdcbn0gOiB7fTsiLCJmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuaW1wb3J0IHsgQ2hpbGRyZW4sIGNsb25lRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzVGFiUGFuZWwsIGlzVGFiLCBpc1RhYkxpc3QgfSBmcm9tICcuL2VsZW1lbnRUeXBlcyc7XG5cbmZ1bmN0aW9uIGlzVGFiQ2hpbGQoY2hpbGQpIHtcbiAgcmV0dXJuIGlzVGFiKGNoaWxkKSB8fCBpc1RhYkxpc3QoY2hpbGQpIHx8IGlzVGFiUGFuZWwoY2hpbGQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVlcE1hcChjaGlsZHJlbiwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIENoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgLy8gbnVsbCBoYXBwZW5zIHdoZW4gY29uZGl0aW9uYWxseSByZW5kZXJpbmcgVGFiUGFuZWwvVGFiXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXRhYnMvaXNzdWVzLzM3XG4gICAgaWYgKGNoaWxkID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgIGlmIChpc1RhYkNoaWxkKGNoaWxkKSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGQucHJvcHMgJiYgY2hpbGQucHJvcHMuY2hpbGRyZW4gJiYgdHlwZW9mIGNoaWxkLnByb3BzLmNoaWxkcmVuID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gQ2xvbmUgdGhlIGNoaWxkIHRoYXQgaGFzIGNoaWxkcmVuIGFuZCBtYXAgdGhlbSB0b29cbiAgICAgIHJldHVybiBjbG9uZUVsZW1lbnQoY2hpbGQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY2hpbGQucHJvcHMpLCB7fSwge1xuICAgICAgICBjaGlsZHJlbjogZGVlcE1hcChjaGlsZC5wcm9wcy5jaGlsZHJlbiwgY2FsbGJhY2spXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWVwRm9yRWFjaChjaGlsZHJlbiwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIENoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIC8vIG51bGwgaGFwcGVucyB3aGVuIGNvbmRpdGlvbmFsbHkgcmVuZGVyaW5nIFRhYlBhbmVsL1RhYlxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC10YWJzL2lzc3Vlcy8zN1xuICAgIGlmIChjaGlsZCA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgaWYgKGlzVGFiKGNoaWxkKSB8fCBpc1RhYlBhbmVsKGNoaWxkKSkge1xuICAgICAgY2FsbGJhY2soY2hpbGQpO1xuICAgIH0gZWxzZSBpZiAoY2hpbGQucHJvcHMgJiYgY2hpbGQucHJvcHMuY2hpbGRyZW4gJiYgdHlwZW9mIGNoaWxkLnByb3BzLmNoaWxkcmVuID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGlzVGFiTGlzdChjaGlsZCkpIGNhbGxiYWNrKGNoaWxkKTtcbiAgICAgIGRlZXBGb3JFYWNoKGNoaWxkLnByb3BzLmNoaWxkcmVuLCBjYWxsYmFjayk7XG4gICAgfVxuICB9KTtcbn0iLCJpbXBvcnQgeyBkZWVwRm9yRWFjaCB9IGZyb20gJy4vY2hpbGRyZW5EZWVwTWFwJztcbmltcG9ydCB7IGlzVGFiLCBpc1RhYlBhbmVsIH0gZnJvbSAnLi9lbGVtZW50VHlwZXMnO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRhYnNDb3VudChjaGlsZHJlbikge1xuICB2YXIgdGFiQ291bnQgPSAwO1xuICBkZWVwRm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGlzVGFiKGNoaWxkKSkgdGFiQ291bnQrKztcbiAgfSk7XG4gIHJldHVybiB0YWJDb3VudDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYW5lbHNDb3VudChjaGlsZHJlbikge1xuICB2YXIgcGFuZWxDb3VudCA9IDA7XG4gIGRlZXBGb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoaXNUYWJQYW5lbChjaGlsZCkpIHBhbmVsQ291bnQrKztcbiAgfSk7XG4gIHJldHVybiBwYW5lbENvdW50O1xufSIsImZ1bmN0aW9uIG1ha2VUeXBlQ2hlY2tlcih0YWJzUm9sZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gISFlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLnRhYnNSb2xlID09PSB0YWJzUm9sZTtcbiAgfTtcbn1cblxuZXhwb3J0IHZhciBpc1RhYiA9IG1ha2VUeXBlQ2hlY2tlcignVGFiJyk7XG5leHBvcnQgdmFyIGlzVGFiTGlzdCA9IG1ha2VUeXBlQ2hlY2tlcignVGFiTGlzdCcpO1xuZXhwb3J0IHZhciBpc1RhYlBhbmVsID0gbWFrZVR5cGVDaGVja2VyKCdUYWJQYW5lbCcpOyIsImltcG9ydCB7IGRlZXBGb3JFYWNoIH0gZnJvbSAnLi9jaGlsZHJlbkRlZXBNYXAnO1xuaW1wb3J0IHsgaXNUYWIsIGlzVGFiTGlzdCwgaXNUYWJQYW5lbCB9IGZyb20gJy4vZWxlbWVudFR5cGVzJztcbmV4cG9ydCBmdW5jdGlvbiBjaGlsZHJlblByb3BUeXBlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICB2YXIgZXJyb3I7XG4gIHZhciB0YWJzQ291bnQgPSAwO1xuICB2YXIgcGFuZWxzQ291bnQgPSAwO1xuICB2YXIgdGFiTGlzdEZvdW5kID0gZmFsc2U7XG4gIHZhciBsaXN0VGFicyA9IFtdO1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wc1twcm9wTmFtZV07XG4gIGRlZXBGb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoaXNUYWJMaXN0KGNoaWxkKSkge1xuICAgICAgaWYgKGNoaWxkLnByb3BzICYmIGNoaWxkLnByb3BzLmNoaWxkcmVuICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5jaGlsZHJlbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZGVlcEZvckVhY2goY2hpbGQucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChsaXN0Q2hpbGQpIHtcbiAgICAgICAgICByZXR1cm4gbGlzdFRhYnMucHVzaChsaXN0Q2hpbGQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhYkxpc3RGb3VuZCkge1xuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkZvdW5kIG11bHRpcGxlICdUYWJMaXN0JyBjb21wb25lbnRzIGluc2lkZSAnVGFicycuIE9ubHkgb25lIGlzIGFsbG93ZWQuXCIpO1xuICAgICAgfVxuXG4gICAgICB0YWJMaXN0Rm91bmQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc1RhYihjaGlsZCkpIHtcbiAgICAgIGlmICghdGFiTGlzdEZvdW5kIHx8IGxpc3RUYWJzLmluZGV4T2YoY2hpbGQpID09PSAtMSkge1xuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkZvdW5kIGEgJ1RhYicgY29tcG9uZW50IG91dHNpZGUgb2YgdGhlICdUYWJMaXN0JyBjb21wb25lbnQuICdUYWInIGNvbXBvbmVudHMgXCIgKyBcImhhdmUgdG8gYmUgaW5zaWRlIHRoZSAnVGFiTGlzdCcgY29tcG9uZW50LlwiKTtcbiAgICAgIH1cblxuICAgICAgdGFic0NvdW50Kys7XG4gICAgfSBlbHNlIGlmIChpc1RhYlBhbmVsKGNoaWxkKSkge1xuICAgICAgcGFuZWxzQ291bnQrKztcbiAgICB9XG4gIH0pO1xuXG4gIGlmICghZXJyb3IgJiYgdGFic0NvdW50ICE9PSBwYW5lbHNDb3VudCkge1xuICAgIGVycm9yID0gbmV3IEVycm9yKFwiVGhlcmUgc2hvdWxkIGJlIGFuIGVxdWFsIG51bWJlciBvZiAnVGFiJyBhbmQgJ1RhYlBhbmVsJyBpbiBgXCIgKyBjb21wb25lbnROYW1lICsgXCJgLiBcIiArIChcIlJlY2VpdmVkIFwiICsgdGFic0NvdW50ICsgXCIgJ1RhYicgYW5kIFwiICsgcGFuZWxzQ291bnQgKyBcIiAnVGFiUGFuZWwnLlwiKSk7XG4gIH1cblxuICByZXR1cm4gZXJyb3I7XG59XG5leHBvcnQgZnVuY3Rpb24gb25TZWxlY3RQcm9wVHlwZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgdmFyIHByb3AgPSBwcm9wc1twcm9wTmFtZV07XG4gIHZhciBuYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuICB2YXIgZXJyb3IgPSBudWxsO1xuXG4gIGlmIChwcm9wICYmIHR5cGVvZiBwcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJJbnZhbGlkIFwiICsgbG9jYXRpb24gKyBcIiBgXCIgKyBuYW1lICsgXCJgIG9mIHR5cGUgYFwiICsgdHlwZW9mIHByb3AgKyBcImAgc3VwcGxpZWQgXCIgKyAoXCJ0byBgXCIgKyBjb21wb25lbnROYW1lICsgXCJgLCBleHBlY3RlZCBgZnVuY3Rpb25gLlwiKSk7XG4gIH0gZWxzZSBpZiAocHJvcHMuc2VsZWN0ZWRJbmRleCAhPSBudWxsICYmIHByb3AgPT0gbnVsbCkge1xuICAgIGVycm9yID0gbmV3IEVycm9yKFwiVGhlIFwiICsgbG9jYXRpb24gKyBcIiBgXCIgKyBuYW1lICsgXCJgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiBgXCIgKyBjb21wb25lbnROYW1lICsgXCJgLCBidXQgXCIgKyBcIml0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYCBvciBgbnVsbGAuXFxuXCIgKyBcImBvblNlbGVjdGAgaXMgcmVxdWlyZWQgd2hlbiBgc2VsZWN0ZWRJbmRleGAgaXMgYWxzbyBzZXQuIE5vdCBkb2luZyBzbyB3aWxsIFwiICsgXCJtYWtlIHRoZSB0YWJzIG5vdCBkbyBhbnl0aGluZywgYXMgYHNlbGVjdGVkSW5kZXhgIGluZGljYXRlcyB0aGF0IHlvdSB3YW50IHRvIFwiICsgXCJoYW5kbGUgdGhlIHNlbGVjdGVkIHRhYiB5b3Vyc2VsZi5cXG5cIiArIFwiSWYgeW91IG9ubHkgd2FudCB0byBzZXQgdGhlIGluaXRhbCB0YWIgcmVwbGFjZSBgc2VsZWN0ZWRJbmRleGAgd2l0aCBgZGVmYXVsdEluZGV4YC5cIik7XG4gIH1cblxuICByZXR1cm4gZXJyb3I7XG59XG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0ZWRJbmRleFByb3BUeXBlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICB2YXIgcHJvcCA9IHByb3BzW3Byb3BOYW1lXTtcbiAgdmFyIG5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG4gIHZhciBlcnJvciA9IG51bGw7XG5cbiAgaWYgKHByb3AgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcCAhPT0gJ251bWJlcicpIHtcbiAgICBlcnJvciA9IG5ldyBFcnJvcihcIkludmFsaWQgXCIgKyBsb2NhdGlvbiArIFwiIGBcIiArIG5hbWUgKyBcImAgb2YgdHlwZSBgXCIgKyB0eXBlb2YgcHJvcCArIFwiYCBzdXBwbGllZCB0byBcIiArIChcImBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGBudW1iZXJgLlwiKSk7XG4gIH0gZWxzZSBpZiAocHJvcHMuZGVmYXVsdEluZGV4ICE9IG51bGwgJiYgcHJvcCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIlRoZSBcIiArIGxvY2F0aW9uICsgXCIgYFwiICsgbmFtZSArIFwiYCBjYW5ub3QgYmUgdXNlZCB0b2dldGhlciB3aXRoIGBkZWZhdWx0SW5kZXhgIFwiICsgKFwiaW4gYFwiICsgY29tcG9uZW50TmFtZSArIFwiYC5cXG5cIikgKyAoXCJFaXRoZXIgcmVtb3ZlIGBcIiArIG5hbWUgKyBcImAgdG8gbGV0IGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAgaGFuZGxlIHRoZSBzZWxlY3RlZCBcIikgKyBcInRhYiBpbnRlcm5hbGx5IG9yIHJlbW92ZSBgZGVmYXVsdEluZGV4YCB0byBoYW5kbGUgaXQgeW91cnNlbGYuXCIpO1xuICB9XG5cbiAgcmV0dXJuIGVycm9yO1xufSIsIi8vIEdldCBhIHVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyXG52YXIgY291bnQgPSAwO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXVpZCgpIHtcbiAgcmV0dXJuIFwicmVhY3QtdGFicy1cIiArIGNvdW50Kys7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVzZXQoKSB7XG4gIGNvdW50ID0gMDtcbn0iLCJleHBvcnQgeyBkZWZhdWx0IGFzIFRhYnMgfSBmcm9tICcuL2NvbXBvbmVudHMvVGFicyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRhYkxpc3QgfSBmcm9tICcuL2NvbXBvbmVudHMvVGFiTGlzdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFRhYiB9IGZyb20gJy4vY29tcG9uZW50cy9UYWInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJQYW5lbCB9IGZyb20gJy4vY29tcG9uZW50cy9UYWJQYW5lbCc7XG5leHBvcnQgeyByZXNldCBhcyByZXNldElkQ291bnRlciB9IGZyb20gJy4vaGVscGVycy91dWlkJzsiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMVxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xuZXhwb3J0cy5GcmFnbWVudCA9IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgZXhwb3J0cy5GcmFnbWVudCA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUgfHwgdHlwZVswXSA9PT0gUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5GcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG5cbnZhciBqc3hERVYkMSA9ICBqc3hXaXRoVmFsaWRhdGlvbiA7XG5cbmV4cG9ydHMuanN4REVWID0ganN4REVWJDE7XG4gIH0pKCk7XG59XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMVxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE3LjAuMSc7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XG5leHBvcnRzLkZyYWdtZW50ID0gMHhlYWNiO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gMHhlYWNjO1xuZXhwb3J0cy5Qcm9maWxlciA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xuZXhwb3J0cy5TdXNwZW5zZSA9IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gMHhlYWQ5O1xudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIGV4cG9ydHMuRnJhZ21lbnQgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIGV4cG9ydHMuU3RyaWN0TW9kZSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgZXhwb3J0cy5Qcm9maWxlciA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIGV4cG9ydHMuU3VzcGVuc2UgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBkaXNwYXRjaGVyLlxuICovXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGJhdGNoJ3MgY29uZmlndXJhdGlvbiBzdWNoIGFzIGhvdyBsb25nIGFuIHVwZGF0ZVxuICogc2hvdWxkIHN1c3BlbmQgZm9yIGlmIGl0IG5lZWRzIHRvLlxuICovXG52YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSB7XG4gIHRyYW5zaXRpb246IDBcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcbnZhciBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gbnVsbDtcbmZ1bmN0aW9uIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjaykge1xuICB7XG4gICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICB9XG59XG5cbntcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUgPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgICB7XG4gICAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gICAgfVxuICB9OyAvLyBTdGFjayBpbXBsZW1lbnRhdGlvbiBpbmplY3RlZCBieSB0aGUgY3VycmVudCByZW5kZXJlci5cblxuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7IC8vIEFkZCBhbiBleHRyYSB0b3AgZnJhbWUgd2hpbGUgYW4gZWxlbWVudCBpcyBiZWluZyB2YWxpZGF0ZWRcblxuICAgIGlmIChjdXJyZW50RXh0cmFTdGFja0ZyYW1lKSB7XG4gICAgICBzdGFjayArPSBjdXJyZW50RXh0cmFTdGFja0ZyYW1lO1xuICAgIH0gLy8gRGVsZWdhdGUgdG8gdGhlIGluamVjdGVkIHJlbmRlcmVyLXNwZWNpZmljIGltcGxlbWVudGF0aW9uXG5cblxuICAgIHZhciBpbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG5cbiAgICBpZiAoaW1wbCkge1xuICAgICAgc3RhY2sgKz0gaW1wbCgpIHx8ICcnO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGFjdCgpIHRvIHRyYWNrIHdoZXRoZXIgeW91J3JlIGluc2lkZSBhbiBhY3QoKSBzY29wZS5cbiAqL1xudmFyIElzU29tZVJlbmRlcmVyQWN0aW5nID0ge1xuICBjdXJyZW50OiBmYWxzZVxufTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0ge1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsXG4gIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgSXNTb21lUmVuZGVyZXJBY3Rpbmc6IElzU29tZVJlbmRlcmVyQWN0aW5nLFxuICAvLyBVc2VkIGJ5IHJlbmRlcmVycyB0byBhdm9pZCBidW5kbGluZyBvYmplY3QtYXNzaWduIHR3aWNlIGluIFVNRCBidW5kbGVzOlxuICBhc3NpZ246IF9hc3NpZ25cbn07XG5cbntcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG59XG5cbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnd2FybicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgKF9jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBfY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlcnJvcihcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFwiICsgJ1RoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uICcgKyAnSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgICcgKyAnY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xuXG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxue1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDsgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgaWYgKCEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5cblxue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG5cbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4vKipcbiAqIENvbnZlbmllbmNlIGNvbXBvbmVudCB3aXRoIGRlZmF1bHQgc2hhbGxvdyBlcXVhbGl0eSBjaGVjayBmb3Igc0NVLlxuICovXG5cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7IC8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuXG5fYXNzaWduKHB1cmVDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xuXG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuLy8gYW4gaW1tdXRhYmxlIG9iamVjdCB3aXRoIGEgc2luZ2xlIG11dGFibGUgdmFsdWVcbmZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcbiAgdmFyIHJlZk9iamVjdCA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG5cbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cblxuICByZXR1cm4gcmVmT2JqZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLkZyYWdtZW50OlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBleHBvcnRzLlByb2ZpbGVyOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIGV4cG9ydHMuU3RyaWN0TW9kZTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIGV4cG9ydHMuU3VzcGVuc2U6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duLCBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBjb25maWcuX19zZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBjb25maWcuX19zZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGNvbXBvbmVudE5hbWUsIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG5cbiAgICAgIHtcbiAgICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlOyAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgaWYgKCEhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkIFwiICsgZWxlbWVudCArIFwiLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3BOYW1lOyAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG5cbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmOyAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjsgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTsgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG5cblxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG5cbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6Jztcbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSBrZXkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuXG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBlbGVtZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGVsZW1lbnQgQSBlbGVtZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRFbGVtZW50S2V5KGVsZW1lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnICYmIGVsZW1lbnQgIT09IG51bGwgJiYgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoJycgKyBlbGVtZW50LmtleSk7XG4gIH0gLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcblxuXG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIG1hcEludG9BcnJheShjaGlsZHJlbiwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5hbWVTb0ZhciwgY2FsbGJhY2spIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpbnZva2VDYWxsYmFjayA9IGZhbHNlO1xuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgdmFyIF9jaGlsZCA9IGNoaWxkcmVuO1xuICAgIHZhciBtYXBwZWRDaGlsZCA9IGNhbGxiYWNrKF9jaGlsZCk7IC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93czpcblxuICAgIHZhciBjaGlsZEtleSA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRFbGVtZW50S2V5KF9jaGlsZCwgMCkgOiBuYW1lU29GYXI7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICAgIHZhciBlc2NhcGVkQ2hpbGRLZXkgPSAnJztcblxuICAgICAgaWYgKGNoaWxkS2V5ICE9IG51bGwpIHtcbiAgICAgICAgZXNjYXBlZENoaWxkS2V5ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KGNoaWxkS2V5KSArICcvJztcbiAgICAgIH1cblxuICAgICAgbWFwSW50b0FycmF5KG1hcHBlZENoaWxkLCBhcnJheSwgZXNjYXBlZENoaWxkS2V5LCAnJywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAgICBlc2NhcGVkUHJlZml4ICsgKCAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFJlYWN0LlBvcnRhbCBkb2Vzbid0IGhhdmUgYSBrZXlcbiAgICAgICAgbWFwcGVkQ2hpbGQua2V5ICYmICghX2NoaWxkIHx8IF9jaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIGV4aXN0aW5nIGVsZW1lbnQncyBrZXkgY2FuIGJlIGEgbnVtYmVyXG4gICAgICAgIGVzY2FwZVVzZXJQcm92aWRlZEtleSgnJyArIG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgICB9XG5cbiAgICAgIGFycmF5LnB1c2gobWFwcGVkQ2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgaXRlcmFibGVDaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gaXRlcmFibGVDaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgICAgICB3YXJuKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGVDaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpaSA9IDA7XG5cbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAoY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nKSArIFwiKS4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSBpbnN0ZWFkLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGNvdW50ID0gMDtcbiAgbWFwSW50b0FycmF5KGNoaWxkcmVuLCByZXN1bHQsICcnLCAnJywgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgY291bnQrKyk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIG4gPSAwO1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIG4rKzsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nXG4gIH0pO1xuICByZXR1cm4gbjtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIGZvckVhY2hGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIERvbid0IHJldHVybiBhbnl0aGluZy5cbiAgfSwgZm9yRWFjaENvbnRleHQpO1xufVxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW50b2FycmF5XG4gKi9cblxuXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHJldHVybiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9KSB8fCBbXTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cblxuXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSB7XG4gIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyAhPT0gbnVsbCAmJiB0eXBlb2YgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJ2NyZWF0ZUNvbnRleHQ6IEV4cGVjdGVkIHRoZSBvcHRpb25hbCBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY2FsY3VsYXRlQ2hhbmdlZEJpdHMsXG4gICAgLy8gQXMgYSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgbXVsdGlwbGUgY29uY3VycmVudCByZW5kZXJlcnMsIHdlIGNhdGVnb3JpemVcbiAgICAvLyBzb21lIHJlbmRlcmVycyBhcyBwcmltYXJ5IGFuZCBvdGhlcnMgYXMgc2Vjb25kYXJ5LiBXZSBvbmx5IGV4cGVjdFxuICAgIC8vIHRoZXJlIHRvIGJlIHR3byBjb25jdXJyZW50IHJlbmRlcmVycyBhdCBtb3N0OiBSZWFjdCBOYXRpdmUgKHByaW1hcnkpIGFuZFxuICAgIC8vIEZhYnJpYyAoc2Vjb25kYXJ5KTsgUmVhY3QgRE9NIChwcmltYXJ5KSBhbmQgUmVhY3QgQVJUIChzZWNvbmRhcnkpLlxuICAgIC8vIFNlY29uZGFyeSByZW5kZXJlcnMgc3RvcmUgdGhlaXIgY29udGV4dCB2YWx1ZXMgb24gc2VwYXJhdGUgZmllbGRzLlxuICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgIC8vIFVzZWQgdG8gdHJhY2sgaG93IG1hbnkgY29uY3VycmVudCByZW5kZXJlcnMgdGhpcyBjb250ZXh0IGN1cnJlbnRseVxuICAgIC8vIHN1cHBvcnRzIHdpdGhpbiBpbiBhIHNpbmdsZSByZW5kZXJlci4gU3VjaCBhcyBwYXJhbGxlbCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbFxuICB9O1xuICBjb250ZXh0LlByb3ZpZGVyID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9QUk9WSURFUl9UWVBFLFxuICAgIF9jb250ZXh0OiBjb250ZXh0XG4gIH07XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gZmFsc2U7XG5cbiAge1xuICAgIC8vIEEgc2VwYXJhdGUgb2JqZWN0LCBidXQgcHJveGllcyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBjb250ZXh0IG9iamVjdCBmb3JcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gSXQgaGFzIGEgZGlmZmVyZW50ICQkdHlwZW9mLCBzbyB3ZSBjYW4gcHJvcGVybHlcbiAgICAvLyB3YXJuIGZvciB0aGUgaW5jb3JyZWN0IHVzYWdlIG9mIENvbnRleHQgYXMgYSBDb25zdW1lci5cbiAgICB2YXIgQ29uc3VtZXIgPSB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNvbnRleHQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzXG4gICAgfTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbm90IHNldHRpbmcgYSB2YWx1ZSwgd2hpY2ggaXMgaW50ZW50aW9uYWwgaGVyZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29uc3VtZXIsIHtcbiAgICAgIFByb3ZpZGVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Qcm92aWRlcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Qcm92aWRlcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Qcm92aWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX1Byb3ZpZGVyKSB7XG4gICAgICAgICAgY29udGV4dC5Qcm92aWRlciA9IF9Qcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IF9jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlMjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZTIpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfdGhyZWFkQ291bnQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX3RocmVhZENvdW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfdGhyZWFkQ291bnQpIHtcbiAgICAgICAgICBjb250ZXh0Ll90aHJlYWRDb3VudCA9IF90aHJlYWRDb3VudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIENvbnN1bWVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Db25zdW1lcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Db25zdW1lcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc3BsYXlOYW1lOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpc3BsYXlOYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkaXNwbGF5TmFtZSkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIpIHtcbiAgICAgICAgICAgIHdhcm4oJ1NldHRpbmcgYGRpc3BsYXlOYW1lYCBvbiBDb250ZXh0LkNvbnN1bWVyIGhhcyBubyBlZmZlY3QuICcgKyBcIllvdSBzaG91bGQgc2V0IGl0IGRpcmVjdGx5IG9uIHRoZSBjb250ZXh0IHdpdGggQ29udGV4dC5kaXNwbGF5TmFtZSA9ICclcycuXCIsIGRpc3BsYXlOYW1lKTtcblxuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pOyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBtaXNzaW5nIHByb3BlcnRpZXMgYmVjYXVzZSBpdCBkb2Vzbid0IHVuZGVyc3RhbmQgZGVmaW5lUHJvcGVydHlcblxuICAgIGNvbnRleHQuQ29uc3VtZXIgPSBDb25zdW1lcjtcbiAgfVxuXG4gIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbnZhciBVbmluaXRpYWxpemVkID0gLTE7XG52YXIgUGVuZGluZyA9IDA7XG52YXIgUmVzb2x2ZWQgPSAxO1xudmFyIFJlamVjdGVkID0gMjtcblxuZnVuY3Rpb24gbGF6eUluaXRpYWxpemVyKHBheWxvYWQpIHtcbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgIHZhciBjdG9yID0gcGF5bG9hZC5fcmVzdWx0O1xuICAgIHZhciB0aGVuYWJsZSA9IGN0b3IoKTsgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cblxuICAgIHZhciBwZW5kaW5nID0gcGF5bG9hZDtcbiAgICBwZW5kaW5nLl9zdGF0dXMgPSBQZW5kaW5nO1xuICAgIHBlbmRpbmcuX3Jlc3VsdCA9IHRoZW5hYmxlO1xuICAgIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKG1vZHVsZU9iamVjdCkge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICB2YXIgZGVmYXVsdEV4cG9ydCA9IG1vZHVsZU9iamVjdC5kZWZhdWx0O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdEV4cG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvcignbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wb3J0KCkgY2FsbC4gJyArICdJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gICcgKyAvLyBCcmVhayB1cCBpbXBvcnRzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgJ2NvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXAnICsgXCJvcnQoJy4vTXlDb21wb25lbnQnKSlcIiwgbW9kdWxlT2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cblxuXG4gICAgICAgIHZhciByZXNvbHZlZCA9IHBheWxvYWQ7XG4gICAgICAgIHJlc29sdmVkLl9zdGF0dXMgPSBSZXNvbHZlZDtcbiAgICAgICAgcmVzb2x2ZWQuX3Jlc3VsdCA9IGRlZmF1bHRFeHBvcnQ7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nKSB7XG4gICAgICAgIC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgICAgIHZhciByZWplY3RlZCA9IHBheWxvYWQ7XG4gICAgICAgIHJlamVjdGVkLl9zdGF0dXMgPSBSZWplY3RlZDtcbiAgICAgICAgcmVqZWN0ZWQuX3Jlc3VsdCA9IGVycm9yO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUmVzb2x2ZWQpIHtcbiAgICByZXR1cm4gcGF5bG9hZC5fcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHRocm93IHBheWxvYWQuX3Jlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBsYXp5KGN0b3IpIHtcbiAgdmFyIHBheWxvYWQgPSB7XG4gICAgLy8gV2UgdXNlIHRoZXNlIGZpZWxkcyB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICAgIF9zdGF0dXM6IC0xLFxuICAgIF9yZXN1bHQ6IGN0b3JcbiAgfTtcbiAgdmFyIGxhenlUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgX3BheWxvYWQ6IHBheWxvYWQsXG4gICAgX2luaXQ6IGxhenlJbml0aWFsaXplclxuICB9O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGp1c3Qgc2V0IGl0IG9uIHRoZSBvYmplY3QuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICB2YXIgcHJvcFR5cGVzOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsYXp5VHlwZSwge1xuICAgICAgZGVmYXVsdFByb3BzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRQcm9wcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3RGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYGRlZmF1bHRQcm9wc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIGRlZmF1bHRQcm9wcyA9IG5ld0RlZmF1bHRQcm9wczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAnZGVmYXVsdFByb3BzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BUeXBlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3UHJvcFR5cGVzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYHByb3BUeXBlc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIHByb3BUeXBlcyA9IG5ld1Byb3BUeXBlczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAncHJvcFR5cGVzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGF6eVR5cGU7XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSZWYocmVuZGVyKSB7XG4gIHtcbiAgICBpZiAocmVuZGVyICE9IG51bGwgJiYgcmVuZGVyLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCByZWNlaXZlZCBhIGBtZW1vYCAnICsgJ2NvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSAnICsgJ21lbW8oZm9yd2FyZFJlZiguLi4pKS4nKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuJywgcmVuZGVyID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJlbmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZW5kZXIubGVuZ3RoICE9PSAwICYmIHJlbmRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgZXhhY3RseSB0d28gcGFyYW1ldGVyczogcHJvcHMgYW5kIHJlZi4gJXMnLCByZW5kZXIubGVuZ3RoID09PSAxID8gJ0RpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj8nIDogJ0FueSBhZGRpdGlvbmFsIHBhcmFtZXRlciB3aWxsIGJlIHVuZGVmaW5lZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVuZGVyICE9IG51bGwpIHtcbiAgICAgIGlmIChyZW5kZXIuZGVmYXVsdFByb3BzICE9IG51bGwgfHwgcmVuZGVyLnByb3BUeXBlcyAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgcHJvcFR5cGVzIG9yIGRlZmF1bHRQcm9wcy4gJyArICdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50PycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICByZW5kZXI6IHJlbmRlclxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7XG5cbiAgICAgICAgaWYgKHJlbmRlci5kaXNwbGF5TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmVuZGVyLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCB8fCB0eXBlID09PSBleHBvcnRzLlByb2ZpbGVyIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IGV4cG9ydHMuU3RyaWN0TW9kZSB8fCB0eXBlID09PSBleHBvcnRzLlN1c3BlbnNlIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSB8fCB0eXBlWzBdID09PSBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtZW1vKHR5cGUsIGNvbXBhcmUpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICBlcnJvcignbWVtbzogVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjb21wb25lbnQuIEluc3RlYWQgJyArICdyZWNlaXZlZDogJXMnLCB0eXBlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29tcGFyZTogY29tcGFyZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbXBhcmVcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGlmICh0eXBlLmRpc3BsYXlOYW1lID09IG51bGwpIHtcbiAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGlzcGF0Y2hlcigpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG5cbiAgaWYgKCEoZGlzcGF0Y2hlciAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyO1xufVxuXG5mdW5jdGlvbiB1c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cbiAge1xuICAgIGlmICh1bnN0YWJsZV9vYnNlcnZlZEJpdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IoJ3VzZUNvbnRleHQoKSBzZWNvbmQgYXJndW1lbnQgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSAnICsgJ3VzZSBpbiBSZWFjdC4gUGFzc2luZyBpdCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1lvdSBwYXNzZWQ6ICVzLiVzJywgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzLCB0eXBlb2YgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzID09PSAnbnVtYmVyJyAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1syXSkgPyAnXFxuXFxuRGlkIHlvdSBjYWxsIGFycmF5Lm1hcCh1c2VDb250ZXh0KT8gJyArICdDYWxsaW5nIEhvb2tzIGluc2lkZSBhIGxvb3AgaXMgbm90IHN1cHBvcnRlZC4gJyArICdMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rcycgOiAnJyk7XG4gICAgfSAvLyBUT0RPOiBhZGQgYSBtb3JlIGdlbmVyaWMgd2FybmluZyBmb3IgaW52YWxpZCB2YWx1ZXMuXG5cblxuICAgIGlmIChDb250ZXh0Ll9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZWFsQ29udGV4dCA9IENvbnRleHQuX2NvbnRleHQ7IC8vIERvbid0IGRlZHVwbGljYXRlIGJlY2F1c2UgdGhpcyBsZWdpdGltYXRlbHkgY2F1c2VzIGJ1Z3NcbiAgICAgIC8vIGFuZCBub2JvZHkgc2hvdWxkIGJlIHVzaW5nIHRoaXMgaW4gZXhpc3RpbmcgY29kZS5cblxuICAgICAgaWYgKHJlYWxDb250ZXh0LkNvbnN1bWVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Db25zdW1lcikgaXMgbm90IHN1cHBvcnRlZCwgbWF5IGNhdXNlIGJ1Z3MsIGFuZCB3aWxsIGJlICcgKyAncmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9IGVsc2UgaWYgKHJlYWxDb250ZXh0LlByb3ZpZGVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Qcm92aWRlcikgaXMgbm90IHN1cHBvcnRlZC4gJyArICdEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpO1xufVxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG59XG5mdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVmKGluaXRpYWxWYWx1ZSk7XG59XG5mdW5jdGlvbiB1c2VFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZU1lbW8oY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTWVtbyhjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAge1xuICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG4gIH1cbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLlN1c3BlbnNlOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMoZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzLl9fc291cmNlKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZm87XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gIH1cblxuICB7XG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKHByb3BzKTtcblxuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSkge1xuICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSB0cnVlO1xuXG4gICAgICB3YXJuKCdSZWFjdC5jcmVhdGVGYWN0b3J5KCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gQ29uc2lkZXIgdXNpbmcgSlNYICcgKyAnb3IgdXNlIFJlYWN0LmNyZWF0ZUVsZW1lbnQoKSBkaXJlY3RseSBpbnN0ZWFkLicpO1xuICAgIH0gLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cblxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbntcblxuICB0cnkge1xuICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cblxuICAgIG5ldyBNYXAoW1tmcm96ZW5PYmplY3QsIG51bGxdXSk7XG4gICAgbmV3IFNldChbZnJvemVuT2JqZWN0XSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5cbnZhciBjcmVhdGVFbGVtZW50JDEgPSAgY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjbG9uZUVsZW1lbnQkMSA9ICBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY3JlYXRlRmFjdG9yeSA9ICBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24gO1xudmFyIENoaWxkcmVuID0ge1xuICBtYXA6IG1hcENoaWxkcmVuLFxuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5LFxuICBvbmx5OiBvbmx5Q2hpbGRcbn07XG5cbmV4cG9ydHMuQ2hpbGRyZW4gPSBDaGlsZHJlbjtcbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuZXhwb3J0cy5QdXJlQ29tcG9uZW50ID0gUHVyZUNvbXBvbmVudDtcbmV4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBSZWFjdFNoYXJlZEludGVybmFscztcbmV4cG9ydHMuY2xvbmVFbGVtZW50ID0gY2xvbmVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0O1xuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVGYWN0b3J5ID0gY3JlYXRlRmFjdG9yeTtcbmV4cG9ydHMuY3JlYXRlUmVmID0gY3JlYXRlUmVmO1xuZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBpc1ZhbGlkRWxlbWVudDtcbmV4cG9ydHMubGF6eSA9IGxhenk7XG5leHBvcnRzLm1lbW8gPSBtZW1vO1xuZXhwb3J0cy51c2VDYWxsYmFjayA9IHVzZUNhbGxiYWNrO1xuZXhwb3J0cy51c2VDb250ZXh0ID0gdXNlQ29udGV4dDtcbmV4cG9ydHMudXNlRGVidWdWYWx1ZSA9IHVzZURlYnVnVmFsdWU7XG5leHBvcnRzLnVzZUVmZmVjdCA9IHVzZUVmZmVjdDtcbmV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IHVzZUltcGVyYXRpdmVIYW5kbGU7XG5leHBvcnRzLnVzZUxheW91dEVmZmVjdCA9IHVzZUxheW91dEVmZmVjdDtcbmV4cG9ydHMudXNlTWVtbyA9IHVzZU1lbW87XG5leHBvcnRzLnVzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyO1xuZXhwb3J0cy51c2VSZWYgPSB1c2VSZWY7XG5leHBvcnRzLnVzZVN0YXRlID0gdXNlU3RhdGU7XG5leHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWxNb2R1bGUpIHtcblx0aWYgKCFvcmlnaW5hbE1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHR2YXIgbW9kdWxlID0gT2JqZWN0LmNyZWF0ZShvcmlnaW5hbE1vZHVsZSk7XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiZXhwb3J0c1wiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCJpbXBvcnQgUGFydGVuZXJpIGZyb20gIFwiLi4vY29tcG9uZW50cy9wYWdlX2NvbXBvbmVudHMvcGFydGVuZXJpXCJcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERlc3ByZSgpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIDw+PFBhcnRlbmVyaSAvPjwvPlxyXG4gICAgKVxyXG4gIH0iXSwic291cmNlUm9vdCI6IiJ9